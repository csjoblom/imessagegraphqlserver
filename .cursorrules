# iMessage GraphQL Server Migration Plan: JavaScript to TypeScript with Bun using TDD

## Test-Driven Development Approach

### TDD Principles (REQUIRED FOR ALL DEVELOPMENT):
1. **TESTS FIRST**: Write a failing test before writing any implementation code
2. **RED-GREEN-REFACTOR**: Follow the TDD cycle strictly:
   - Write a failing test (RED)
   - Implement minimal code to make the test pass (GREEN)
   - Refactor the code while keeping tests passing
3. **NEVER SKIP TESTS**: No implementation code should be written without corresponding tests
4. **FEATURE COMPLETENESS**: A feature is only considered complete when all tests pass
5. **INCREMENTAL PROGRESS**: Add functionality in small, testable increments

### TDD Implementation Rules:
- Begin each task by creating test files in the appropriate test directory
- Ensure tests fail initially (RED) to confirm they're actually testing something
- Document each test case with clear descriptions of expected behavior
- Implement the minimal code necessary to make tests pass
- Only proceed to the next feature after all current tests are passing (GREEN)
- Refactor only after tests are passing, and ensure tests remain green after refactoring

## Codebase Analysis

### Core Files and Their Purposes:
- **index.js** (475 lines): Main entry point that creates the Apollo GraphQL server and terminal UI using Blessed
- **imessage.js** (653 lines): Core functionality for interacting with iMessage database and sending messages
- **test.js** (20 lines): Limited testing file
- **package.json**: Dependencies and configuration

### Key Dependencies:
- apollo-server/graphql: GraphQL server implementation
- sqlite3: Database access to iMessage chat.db
- blessed: Terminal UI rendering
- osa2: macOS automation/scripting
- emoji related packages: Text emoji parsing
- glob: File path pattern matching

### Core Functionality:
1. Database access to local iMessage SQLite database
2. Contact resolution from Address Book
3. GraphQL query/mutation implementation
4. Terminal UI for monitoring and status
5. iMessage sending via macOS automation

### Current Code Structure Analysis:

#### index.js:
- Contains GraphQL type definitions (Lines 14-38)
- Terminal UI setup using blessed (Lines 43-167)
- Apollo server configuration (Lines 169-230)
- GraphQL resolvers (Lines 232-300)
- Server start logic and runtime monitoring (Lines 302-475)

The file mixes concerns including UI, GraphQL schema, resolver logic, and server configuration. This makes it hard to test and maintain.

#### imessage.js:
- SQLite database initialization (Lines 1-9)
- User chat handle retrieval (Lines 11-45)
- Chat name resolution (Lines 47-85)
- Contact lookup by phone number (Lines 87-180)
- Chat message retrieval (Lines 182-320)
- Message sending functionality (Lines 322-420)
- Various utility functions for data formatting (Lines 422-653)

This file contains several complex async functions with nested promises and SQL queries, making it difficult to type properly without refactoring.

### Pain Points for Migration:

1. **Promise-heavy code without async/await**: Most database operations use nested Promises instead of async/await, making TypeScript typing more challenging.

2. **Direct SQL queries**: Raw SQL is embedded throughout the codebase without parameterization in many places, making it harder to type and test.

3. **macOS specificity**: The code relies heavily on macOS-specific paths and functionality, which complicates testing.

4. **Lack of error handling**: Many functions have minimal error handling, which needs improvement during migration.

5. **Large monolithic files**: Both main files have hundreds of lines with intertwined responsibilities.

6. **Limited testing**: Current test file is minimal and doesn't provide proper coverage.

7. **CommonJS to ESM migration**: The codebase uses CommonJS module system, but Bun works best with ESM modules.

## TDD-First Migration Strategy to TypeScript with Bun

### 1. Test-Driven Project Structure
```
imessagegraphqlserver/
├── .git/
├── .gitignore
├── README.md
├── package.json
├── bun.lockb
├── tsconfig.json
├── jest.config.ts
├── tests/
│   ├── unit/
│   │   ├── database/
│   │   │   ├── connection.test.ts
│   │   │   └── queries.test.ts
│   │   ├── graphql/
│   │   │   ├── schema.test.ts
│   │   │   └── resolvers.test.ts 
│   │   ├── ui/
│   │   │   └── components.test.ts
│   │   └── utils/
│   │       ├── emoji.test.ts
│   │       └── contacts.test.ts
│   ├── integration/
│   │   ├── api.test.ts
│   │   └── database-queries.test.ts
│   └── mocks/
│       ├── database.ts
│       └── messages.ts
├── src/
│   ├── index.ts
│   ├── imessage.ts
│   ├── types/
│   │   ├── index.ts
│   │   ├── chat.ts
│   │   ├── message.ts
│   │   └── database.ts
│   ├── graphql/
│   │   ├── schema.ts
│   │   ├── resolvers.ts
│   │   └── typeDefs.ts
│   ├── ui/
│   │   ├── terminal.ts
│   │   └── components.ts
│   └── utils/
│       ├── database.ts
│       ├── emoji.ts
│       └── contacts.ts
└── dist/
```

### 2. TypeScript and Test Configuration
Create a `tsconfig.json` with the following config:
```json
{
  "compilerOptions": {
    "target": "ESNext",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "types": ["bun-types", "jest"],
    "esModuleInterop": true,
    "strict": true,
    "outDir": "dist",
    "sourceMap": true,
    "declaration": true,
    "resolveJsonModule": true,
    "rootDir": "src"
  },
  "include": ["src/**/*", "tests/**/*"],
  "exclude": ["node_modules", "dist"]
}
```

Set up Jest or Bun test configuration:
```typescript
// jest.config.ts
export default {
  preset: 'ts-jest',
  testEnvironment: 'node',
  testMatch: ['**/tests/**/*.test.ts'],
  collectCoverage: true,
  coverageDirectory: 'coverage',
  coverageReporters: ['text', 'lcov'],
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80
    }
  }
};
```

### 3. TDD-First Migration Steps

#### Phase 1: Setup and Testing Infrastructure
1. Initialize Bun project
   ```bash
   bun init -y
   ```
2. Install TypeScript and testing dependencies FIRST
   ```bash
   bun add -d typescript @types/node bun-types
   bun add -d @types/sqlite3 @types/blessed
   bun add -d bun-test jest @types/jest ts-jest
   ```
3. Create mock data and test helpers
   ```bash
   mkdir -p tests/mocks
   touch tests/mocks/database.ts
   touch tests/mocks/messages.ts
   ```
4. Install runtime dependencies
   ```bash
   bun add apollo-server graphql sqlite3 blessed osa2 @devsnowflake/text-emoji-parser emoji-short-name glob running-at
   ```

#### Phase 2: Type Definition and Test First
1. Write tests for types first:
   ```typescript
   // tests/unit/types/chat.test.ts
   import { Chat, ChatMessage, ChatCount } from '../../../src/types/chat';
   
   describe('Chat Types', () => {
     describe('ChatMessage interface', () => {
       it('should accept valid ChatMessage object', () => {
         const message: ChatMessage = {
           chatter: 'test@example.com',
           text: 'Hello world'
         };
         
         expect(message.chatter).toBe('test@example.com');
         expect(message.text).toBe('Hello world');
       });
       
       // More type tests...
     });
     
     // Tests for other interfaces...
   });
   ```

2. AFTER tests are written, create interface definitions:
   ```typescript
   // src/types/chat.ts
   export interface ChatMessage {
     ROWID?: number;
     chatter: string;
     text: string;
     date?: number;
     is_from_me?: number;
     handle_id?: number;
   }

   export interface Chat {
     name: string;
     friendlyName: string | null;
     chat_identifier?: string;
     display_name?: string | null;
   }

   export interface ChatCount {
     friendlyName: string;
     count: number;
   }
   ```

#### Phase 3: Database Layer - Tests First

1. Write database connection tests:
   ```typescript
   // tests/unit/database/connection.test.ts
   import { Database } from '../../../src/utils/database';
   
   // Mock SQLite3
   jest.mock('sqlite3', () => ({
     verbose: () => ({
       Database: class MockDB {
         constructor(path: string) {}
         all(sql: string, params: any[], callback: Function) {
           callback(null, []);
         }
         close(callback: Function) {
           callback(null);
         }
       }
     })
   }));
   
   describe('Database Connection', () => {
     let db: Database;
     
     beforeEach(() => {
       db = new Database(':memory:');
     });
     
     afterEach(async () => {
       await db.close();
     });
     
     it('should construct without errors', () => {
       expect(db).toBeInstanceOf(Database);
     });
     
     it('should perform query operations', async () => {
       const spy = jest.spyOn(db['db'], 'all');
       await db.query('SELECT 1');
       expect(spy).toHaveBeenCalledWith('SELECT 1', [], expect.any(Function));
     });
     
     // More connection tests...
   });
   ```

2. AFTER tests, implement the database class:
   ```typescript
   // src/utils/database.ts
   import sqlite3 from 'sqlite3';
   import { DatabaseRow } from '../types/database';
   
   export class Database {
     private db: sqlite3.Database;
     
     constructor(filePath: string) {
       this.db = new sqlite3.Database(filePath);
     }
     
     async query<T>(sql: string, params: any[] = []): Promise<T[]> {
       return new Promise((resolve, reject) => {
         this.db.all(sql, params, (err, rows) => {
           if (err) return reject(err);
           resolve(rows as T[]);
         });
       });
     }
     
     // Implement remaining methods ONLY after corresponding tests...
   }
   ```

#### Phase 4: Migrate Core Functions - Tests First

1. Write tests for each core function before implementing:
   ```typescript
   // tests/unit/imessage/handle.test.ts
   import { getLoggedInUseriMessageHandle } from '../../../src/imessage';
   import { Database } from '../../../src/utils/database';
   
   // Mock database implementation
   jest.mock('../../../src/utils/database');
   
   describe('iMessage Handle Functions', () => {
     let mockDb: jest.Mocked<Database>;
     
     beforeEach(() => {
       mockDb = new Database(':memory:') as jest.Mocked<Database>;
       mockDb.query.mockImplementation(async (sql, params) => {
         if (sql.includes('account_login')) {
           return [{ account_login: 'E:test@example.com' }];
         }
         return [];
       });
     });
     
     it('should return the correct handle when found', async () => {
       const result = await getLoggedInUseriMessageHandle(mockDb);
       expect(result).toBe('test@example.com');
       expect(mockDb.query).toHaveBeenCalledWith(
         expect.stringContaining('account_login'),
         ['iMessage']
       );
     });
     
     it('should return error message when no rows', async () => {
       mockDb.query.mockResolvedValueOnce([]);
       const result = await getLoggedInUseriMessageHandle(mockDb);
       expect(result).toBe('no chat handle! [1]');
     });
     
     // More tests for error conditions and edge cases...
   });
   ```

2. AFTER tests, implement the function:
   ```typescript
   // src/imessage.ts
   import { Database } from './utils/database';
   import { ChatRow } from './types/database';
   
   export async function getLoggedInUseriMessageHandle(
     database: Database
   ): Promise<string> {
     try {
       const sql = 'SELECT DISTINCT account_login FROM chat WHERE service_name = ?';
       const rows = await database.query<ChatRow>(sql, ['iMessage']);
       
       if (!rows || rows.length === 0) {
         return 'no chat handle! [1]';
       }
       
       if (!rows[0].account_login) {
         return 'no chat handle! [2]';
       }
       
       return rows[0].account_login.split('E:')[1];
     } catch (error) {
       throw new Error(`Failed to get iMessage handle: ${error.message}`);
     }
   }
   ```

#### Phase 5: GraphQL Components - Tests First

1. Write tests for GraphQL schema and resolvers:
   ```typescript
   // tests/unit/graphql/schema.test.ts
   import { gql } from 'apollo-server';
   import { typeDefs } from '../../../src/graphql/typeDefs';
   import { makeExecutableSchema } from '@graphql-tools/schema';
   
   describe('GraphQL Schema', () => {
     it('should compile without errors', () => {
       expect(() => {
         makeExecutableSchema({ typeDefs });
       }).not.toThrow();
     });
     
     it('should define Chat type with required fields', () => {
       const schema = makeExecutableSchema({ typeDefs });
       // Test schema structure...
     });
     
     // More schema tests...
   });
   ```

2. AFTER schema tests, implement GraphQL types:
   ```typescript
   // src/graphql/typeDefs.ts
   import { gql } from 'apollo-server';
   
   export const typeDefs = gql`
     type ChatMessage {
       chatter: String!
       text: String!
     }
     
     # Rest of schema...
   `;
   ```

### 4. TDD-Driven Implementation Strategy

1. **Work in Vertical Slices**: Implement complete features with tests first, rather than horizontal layers
2. **Test Coverage Requirements**: Maintain at least 80% test coverage for all code
3. **Incremental Test-First Development**:
   - Write failing tests for a small piece of functionality
   - Implement minimal code to make tests pass
   - Run tests to verify passing state
   - Refactor if needed, keeping tests passing
   - Move to next small piece of functionality

4. **Testing Priority Order**:
   - Start with units that have fewest dependencies (utilities, types)
   - Then database access layer
   - Then core business logic (imessage functions)
   - Then GraphQL schema and resolvers
   - Finally UI components and integration tests

### 5. Testing Execution with Bun

Set up package.json scripts for TDD workflow:
```json
"scripts": {
  "test": "bun test",
  "test:watch": "bun test --watch",
  "test:coverage": "bun test --coverage",
  "start": "bun src/index.ts",
  "typecheck": "tsc --noEmit",
  "build": "bun build ./src/index.ts --outdir ./dist"
}
```

## Example TDD Workflow for a Feature

### 1. Write the test first
```typescript
// tests/unit/imessage/chats.test.ts
import { getChats } from '../../../src/imessage';
import { Database } from '../../../src/utils/database';
import { Chat } from '../../../src/types/chat';

jest.mock('../../../src/utils/database');

describe('Chat Functions', () => {
  let mockDb: jest.Mocked<Database>;
  
  beforeEach(() => {
    mockDb = new Database(':memory:') as jest.Mocked<Database>;
    // Set up mock responses
    mockDb.query.mockImplementation(async (sql) => {
      if (sql.includes('chat.chat_identifier')) {
        return [
          {
            id: '+11234567890',
            chat_identifier: '+11234567890',
            display_name: 'John Doe'
          },
          {
            id: '+10987654321',
            chat_identifier: '+10987654321',
            display_name: null
          }
        ];
      }
      return [];
    });
  });
  
  it('should return list of chats with proper structure', async () => {
    const result = await getChats(mockDb);
    
    expect(result).toBeInstanceOf(Array);
    expect(result.length).toBe(2);
    expect(result[0]).toHaveProperty('name');
    expect(result[0]).toHaveProperty('friendlyName');
    expect(result[0].name).toBe('+11234567890');
    expect(result[0].friendlyName).toBe('John Doe');
  });
  
  it('should handle errors properly', async () => {
    mockDb.query.mockRejectedValueOnce(new Error('Database error'));
    
    await expect(getChats(mockDb)).rejects.toThrow('Failed to get chats');
  });
  
  // More tests...
});
```

### 2. Run the test and watch it fail (RED)
```bash
bun test tests/unit/imessage/chats.test.ts
```

### 3. Implement minimal code to make the test pass
```typescript
// src/imessage.ts
import { Database } from './utils/database';
import { Chat, ChatRow, HandleRow } from './types/database';

export async function getChats(database: Database): Promise<Chat[]> {
  try {
    const sql = `
      SELECT DISTINCT 
        handle.id,
        chat.chat_identifier,
        chat.display_name
      FROM
        chat
      LEFT OUTER JOIN chat_handle_join ON chat_handle_join.chat_id = chat.ROWID
      LEFT OUTER JOIN handle ON handle.ROWID = chat_handle_join.handle_id
      WHERE
        chat.service_name = ?
    `;
    
    const rows = await database.query<ChatRow & HandleRow>(sql, ['iMessage']);
    const result: Chat[] = [];
    const seenNames: string[] = [];
    
    for (const row of rows) {
      const name = row.chat_identifier;
      
      if (seenNames.includes(name)) {
        continue;
      }
      
      seenNames.push(name);
      
      result.push({
        name,
        friendlyName: row.display_name || await getChatFriendlyName(database, name);
      });
    }
    
    return result;
  } catch (error) {
    throw new Error(`Failed to get chats: ${error.message}`);
  }
}
```

### 4. Run the test again to verify it passes (GREEN)
```bash
bun test tests/unit/imessage/chats.test.ts
```

### 5. Refactor if needed, keeping tests green
```typescript
// Improved implementation with better error handling
export async function getChats(database: Database): Promise<Chat[]> {
  try {
    const sql = `
      SELECT DISTINCT 
        handle.id,
        chat.chat_identifier,
        chat.display_name
      FROM
        chat
      LEFT OUTER JOIN chat_handle_join ON chat_handle_join.chat_id = chat.ROWID
      LEFT OUTER JOIN handle ON handle.ROWID = chat_handle_join.handle_id
      WHERE
        chat.service_name = ?
    `;
    
    const rows = await database.query<ChatRow & HandleRow>(sql, ['iMessage']);
    
    // Use Set for better performance
    const seenNames = new Set<string>();
    const result: Chat[] = [];
    
    for (const row of rows) {
      const name = row.chat_identifier;
      
      if (!name || seenNames.has(name)) {
        continue;
      }
      
      seenNames.add(name);
      
      result.push({
        name,
        friendlyName: row.display_name || null
      });
    }
    
    return result;
  } catch (error) {
    throw new Error(`Failed to get chats: ${error.message}`);
  }
}
```

### 6. Run tests to ensure refactoring didn't break anything
```bash
bun test tests/unit/imessage/chats.test.ts
```

## Implementation Challenges and Solutions

### Challenge 1: Testing macOS-specific Code
**Solution:**
- Create platform abstraction layers with interfaces
- Implement mock versions for testing
- Use dependency injection to swap implementations
- Write tests that validate the behavior without requiring macOS

```typescript
// src/platform/interfaces.ts
export interface FileSystem {
  readFile(path: string): Promise<string>;
  exists(path: string): Promise<boolean>;
  glob(pattern: string): Promise<string[]>;
}

// src/platform/macos.ts
export class MacOSFileSystem implements FileSystem {
  // Real implementation
}

// src/platform/mock.ts
export class MockFileSystem implements FileSystem {
  // Mock implementation for testing
}
```

### Challenge 2: Database Testing
**Solution:**
- Use in-memory SQLite for tests
- Create database fixtures with predictable test data
- Mock database layer for unit tests
- Use actual database with transactions for integration tests

```typescript
// tests/integration/database-setup.ts
export async function setupTestDatabase(): Promise<Database> {
  const db = new Database(':memory:');
  await db.exec(`
    CREATE TABLE chat (
      ROWID INTEGER PRIMARY KEY,
      chat_identifier TEXT,
      display_name TEXT,
      service_name TEXT
    );
    -- More schema...
  `);
  
  // Insert test data
  await db.exec(`
    INSERT INTO chat (chat_identifier, display_name, service_name)
    VALUES ('+11234567890', 'Test User', 'iMessage');
  `);
  
  return db;
}
```

### Challenge 3: UI Testing
**Solution:**
- Create testable UI components that don't require actual rendering
- Use snapshot testing for component structure
- Implement event simulation for interactive components
- Separate UI logic from rendering for better testability

```typescript
// tests/unit/ui/components.test.ts
import { createIPBox, createStatusBox } from '../../../src/ui/components';

describe('UI Components', () => {
  it('should create IP box with correct properties', () => {
    const box = createIPBox();
    expect(box).toMatchObject({
      top: '0%',
      left: '0%',
      width: '50%',
      height: '25%',
      tags: true,
      label: 'IP Address',
      border: {
        type: 'line'
      }
    });
  });
  
  // More component tests...
});
```

## Refactoring Opportunities with TDD

1. **Apply TDD to GraphQL Schema Modularization**
   - Write tests for schema validation before splitting
   - Ensure schema tests pass after modularization
   - Use schema stitching with proper test coverage

2. **Apply TDD to Database Abstraction**
   - Create test fixtures for each database entity
   - Test database operations in isolation
   - Ensure query builders produce correct SQL

3. **Apply TDD to Error Handling**
   - Test each error case specifically
   - Ensure errors are properly propagated
   - Validate error messages and types

## TDD-Focused Migration Timeline

1. **Week 1:** 
   - Set up testing infrastructure
   - Write tests for core types and utilities
   - Implement and verify basic utilities

2. **Week 2:**
   - Write tests for database layer
   - Implement database abstraction
   - Write tests for core iMessage functions

3. **Week 3:**
   - Write GraphQL schema and resolver tests
   - Implement GraphQL components
   - Write UI component tests

4. **Week 4:**
   - Write integration tests
   - Fix any remaining failing tests
   - Documentation and final clean-up

## Documenting the TDD Process

1. Create Test Coverage Report Commands:
   ```json
   "scripts": {
     "test:report": "bun test --coverage && open coverage/lcov-report/index.html"
   }
   ```

2. Document each test pattern for future development:
   ```markdown
   # Testing Patterns

   ## Database Mocking
   When testing database operations, use the following pattern:
   
   ```typescript
   // Import database mock
   jest.mock('../../../src/utils/database');
   
   // Configure mock responses
   mockDb.query.mockResolvedValueOnce([{ /* test data */ }]);
   ```

## TDD Requirements Checklist

- [ ] All new code has corresponding tests
- [ ] Tests are written BEFORE implementation
- [ ] Code coverage is at least 80%
- [ ] All tests pass before merging changes
- [ ] Integration tests confirm system behavior
- [ ] Mocks and fixtures are properly maintained 