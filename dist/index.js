import { createRequire } from "node:module";
var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod2, isNodeMode, target) => {
  target = mod2 != null ? __create(__getProtoOf(mod2)) : {};
  const to = isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod2))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod2[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod2) => () => (mod2 || cb((mod2 = { exports: {} }).exports, mod2), mod2.exports);
var __require = /* @__PURE__ */ createRequire(import.meta.url);

// node_modules/depd/lib/compat/callsite-tostring.js
var require_callsite_tostring = __commonJS((exports, module) => {
  /*!
   * depd
   * Copyright(c) 2014 Douglas Christopher Wilson
   * MIT Licensed
   */
  module.exports = callSiteToString;
  function callSiteFileLocation(callSite) {
    var fileName;
    var fileLocation = "";
    if (callSite.isNative()) {
      fileLocation = "native";
    } else if (callSite.isEval()) {
      fileName = callSite.getScriptNameOrSourceURL();
      if (!fileName) {
        fileLocation = callSite.getEvalOrigin();
      }
    } else {
      fileName = callSite.getFileName();
    }
    if (fileName) {
      fileLocation += fileName;
      var lineNumber = callSite.getLineNumber();
      if (lineNumber != null) {
        fileLocation += ":" + lineNumber;
        var columnNumber = callSite.getColumnNumber();
        if (columnNumber) {
          fileLocation += ":" + columnNumber;
        }
      }
    }
    return fileLocation || "unknown source";
  }
  function callSiteToString(callSite) {
    var addSuffix = true;
    var fileLocation = callSiteFileLocation(callSite);
    var functionName = callSite.getFunctionName();
    var isConstructor = callSite.isConstructor();
    var isMethodCall = !(callSite.isToplevel() || isConstructor);
    var line = "";
    if (isMethodCall) {
      var methodName = callSite.getMethodName();
      var typeName = getConstructorName(callSite);
      if (functionName) {
        if (typeName && functionName.indexOf(typeName) !== 0) {
          line += typeName + ".";
        }
        line += functionName;
        if (methodName && functionName.lastIndexOf("." + methodName) !== functionName.length - methodName.length - 1) {
          line += " [as " + methodName + "]";
        }
      } else {
        line += typeName + "." + (methodName || "<anonymous>");
      }
    } else if (isConstructor) {
      line += "new " + (functionName || "<anonymous>");
    } else if (functionName) {
      line += functionName;
    } else {
      addSuffix = false;
      line += fileLocation;
    }
    if (addSuffix) {
      line += " (" + fileLocation + ")";
    }
    return line;
  }
  function getConstructorName(obj) {
    var receiver = obj.receiver;
    return receiver.constructor && receiver.constructor.name || null;
  }
});

// node_modules/depd/lib/compat/event-listener-count.js
var require_event_listener_count = __commonJS((exports, module) => {
  /*!
   * depd
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  module.exports = eventListenerCount;
  function eventListenerCount(emitter, type) {
    return emitter.listeners(type).length;
  }
});

// node_modules/depd/lib/compat/index.js
var require_compat = __commonJS((exports, module) => {
  /*!
   * depd
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  var EventEmitter = __require("events").EventEmitter;
  lazyProperty(exports, "callSiteToString", function callSiteToString() {
    var limit = Error.stackTraceLimit;
    var obj = {};
    var prep = Error.prepareStackTrace;
    function prepareObjectStackTrace(obj2, stack3) {
      return stack3;
    }
    Error.prepareStackTrace = prepareObjectStackTrace;
    Error.stackTraceLimit = 2;
    Error.captureStackTrace(obj);
    var stack2 = obj.stack.slice();
    Error.prepareStackTrace = prep;
    Error.stackTraceLimit = limit;
    return stack2[0].toString ? toString : require_callsite_tostring();
  });
  lazyProperty(exports, "eventListenerCount", function eventListenerCount() {
    return EventEmitter.listenerCount || require_event_listener_count();
  });
  function lazyProperty(obj, prop, getter) {
    function get() {
      var val = getter();
      Object.defineProperty(obj, prop, {
        configurable: true,
        enumerable: true,
        value: val
      });
      return val;
    }
    Object.defineProperty(obj, prop, {
      configurable: true,
      enumerable: true,
      get
    });
  }
  function toString(obj) {
    return obj.toString();
  }
});

// node_modules/depd/index.js
var require_depd = __commonJS((exports, module) => {
  /*!
   * depd
   * Copyright(c) 2014-2017 Douglas Christopher Wilson
   * MIT Licensed
   */
  var callSiteToString = require_compat().callSiteToString;
  var eventListenerCount = require_compat().eventListenerCount;
  var relative = __require("path").relative;
  module.exports = depd;
  var basePath = process.cwd();
  function containsNamespace(str, namespace) {
    var vals = str.split(/[ ,]+/);
    var ns = String(namespace).toLowerCase();
    for (var i = 0;i < vals.length; i++) {
      var val = vals[i];
      if (val && (val === "*" || val.toLowerCase() === ns)) {
        return true;
      }
    }
    return false;
  }
  function convertDataDescriptorToAccessor(obj, prop, message2) {
    var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
    var value = descriptor.value;
    descriptor.get = function getter() {
      return value;
    };
    if (descriptor.writable) {
      descriptor.set = function setter(val) {
        return value = val;
      };
    }
    delete descriptor.value;
    delete descriptor.writable;
    Object.defineProperty(obj, prop, descriptor);
    return descriptor;
  }
  function createArgumentsString(arity) {
    var str = "";
    for (var i = 0;i < arity; i++) {
      str += ", arg" + i;
    }
    return str.substr(2);
  }
  function createStackString(stack2) {
    var str = this.name + ": " + this.namespace;
    if (this.message) {
      str += " deprecated " + this.message;
    }
    for (var i = 0;i < stack2.length; i++) {
      str += `
    at ` + callSiteToString(stack2[i]);
    }
    return str;
  }
  function depd(namespace) {
    if (!namespace) {
      throw new TypeError("argument namespace is required");
    }
    var stack2 = getStack();
    var site2 = callSiteLocation(stack2[1]);
    var file = site2[0];
    function deprecate2(message2) {
      log.call(deprecate2, message2);
    }
    deprecate2._file = file;
    deprecate2._ignored = isignored(namespace);
    deprecate2._namespace = namespace;
    deprecate2._traced = istraced(namespace);
    deprecate2._warned = Object.create(null);
    deprecate2.function = wrapfunction;
    deprecate2.property = wrapproperty;
    return deprecate2;
  }
  function isignored(namespace) {
    if (process.noDeprecation) {
      return true;
    }
    var str = process.env.NO_DEPRECATION || "";
    return containsNamespace(str, namespace);
  }
  function istraced(namespace) {
    if (process.traceDeprecation) {
      return true;
    }
    var str = process.env.TRACE_DEPRECATION || "";
    return containsNamespace(str, namespace);
  }
  function log(message2, site2) {
    var haslisteners = eventListenerCount(process, "deprecation") !== 0;
    if (!haslisteners && this._ignored) {
      return;
    }
    var caller;
    var callFile;
    var callSite;
    var depSite;
    var i = 0;
    var seen = false;
    var stack2 = getStack();
    var file = this._file;
    if (site2) {
      depSite = site2;
      callSite = callSiteLocation(stack2[1]);
      callSite.name = depSite.name;
      file = callSite[0];
    } else {
      i = 2;
      depSite = callSiteLocation(stack2[i]);
      callSite = depSite;
    }
    for (;i < stack2.length; i++) {
      caller = callSiteLocation(stack2[i]);
      callFile = caller[0];
      if (callFile === file) {
        seen = true;
      } else if (callFile === this._file) {
        file = this._file;
      } else if (seen) {
        break;
      }
    }
    var key = caller ? depSite.join(":") + "__" + caller.join(":") : undefined;
    if (key !== undefined && key in this._warned) {
      return;
    }
    this._warned[key] = true;
    var msg = message2;
    if (!msg) {
      msg = callSite === depSite || !callSite.name ? defaultMessage(depSite) : defaultMessage(callSite);
    }
    if (haslisteners) {
      var err = DeprecationError(this._namespace, msg, stack2.slice(i));
      process.emit("deprecation", err);
      return;
    }
    var format = process.stderr.isTTY ? formatColor : formatPlain;
    var output = format.call(this, msg, caller, stack2.slice(i));
    process.stderr.write(output + `
`, "utf8");
  }
  function callSiteLocation(callSite) {
    var file = callSite.getFileName() || "<anonymous>";
    var line = callSite.getLineNumber();
    var colm = callSite.getColumnNumber();
    if (callSite.isEval()) {
      file = callSite.getEvalOrigin() + ", " + file;
    }
    var site2 = [file, line, colm];
    site2.callSite = callSite;
    site2.name = callSite.getFunctionName();
    return site2;
  }
  function defaultMessage(site2) {
    var callSite = site2.callSite;
    var funcName = site2.name;
    if (!funcName) {
      funcName = "<anonymous@" + formatLocation(site2) + ">";
    }
    var context = callSite.getThis();
    var typeName = context && callSite.getTypeName();
    if (typeName === "Object") {
      typeName = undefined;
    }
    if (typeName === "Function") {
      typeName = context.name || typeName;
    }
    return typeName && callSite.getMethodName() ? typeName + "." + funcName : funcName;
  }
  function formatPlain(msg, caller, stack2) {
    var timestamp = new Date().toUTCString();
    var formatted = timestamp + " " + this._namespace + " deprecated " + msg;
    if (this._traced) {
      for (var i = 0;i < stack2.length; i++) {
        formatted += `
    at ` + callSiteToString(stack2[i]);
      }
      return formatted;
    }
    if (caller) {
      formatted += " at " + formatLocation(caller);
    }
    return formatted;
  }
  function formatColor(msg, caller, stack2) {
    var formatted = "\x1B[36;1m" + this._namespace + "\x1B[22;39m" + " \x1B[33;1mdeprecated\x1B[22;39m" + " \x1B[0m" + msg + "\x1B[39m";
    if (this._traced) {
      for (var i = 0;i < stack2.length; i++) {
        formatted += `
    \x1B[36mat ` + callSiteToString(stack2[i]) + "\x1B[39m";
      }
      return formatted;
    }
    if (caller) {
      formatted += " \x1B[36m" + formatLocation(caller) + "\x1B[39m";
    }
    return formatted;
  }
  function formatLocation(callSite) {
    return relative(basePath, callSite[0]) + ":" + callSite[1] + ":" + callSite[2];
  }
  function getStack() {
    var limit = Error.stackTraceLimit;
    var obj = {};
    var prep = Error.prepareStackTrace;
    Error.prepareStackTrace = prepareObjectStackTrace;
    Error.stackTraceLimit = Math.max(10, limit);
    Error.captureStackTrace(obj);
    var stack2 = obj.stack.slice(1);
    Error.prepareStackTrace = prep;
    Error.stackTraceLimit = limit;
    return stack2;
  }
  function prepareObjectStackTrace(obj, stack2) {
    return stack2;
  }
  function wrapfunction(fn, message) {
    if (typeof fn !== "function") {
      throw new TypeError("argument fn must be a function");
    }
    var args = createArgumentsString(fn.length);
    var deprecate = this;
    var stack = getStack();
    var site = callSiteLocation(stack[1]);
    site.name = fn.name;
    var deprecatedfn = eval("(function (" + args + `) {
` + `"use strict"
` + `log.call(deprecate, message, site)
` + `return fn.apply(this, arguments)
` + "})");
    return deprecatedfn;
  }
  function wrapproperty(obj, prop, message2) {
    if (!obj || typeof obj !== "object" && typeof obj !== "function") {
      throw new TypeError("argument obj must be object");
    }
    var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
    if (!descriptor) {
      throw new TypeError("must call property on owner object");
    }
    if (!descriptor.configurable) {
      throw new TypeError("property must be configurable");
    }
    var deprecate2 = this;
    var stack2 = getStack();
    var site2 = callSiteLocation(stack2[1]);
    site2.name = prop;
    if ("value" in descriptor) {
      descriptor = convertDataDescriptorToAccessor(obj, prop, message2);
    }
    var get = descriptor.get;
    var set = descriptor.set;
    if (typeof get === "function") {
      descriptor.get = function getter() {
        log.call(deprecate2, message2, site2);
        return get.apply(this, arguments);
      };
    }
    if (typeof set === "function") {
      descriptor.set = function setter() {
        log.call(deprecate2, message2, site2);
        return set.apply(this, arguments);
      };
    }
    Object.defineProperty(obj, prop, descriptor);
  }
  function DeprecationError(namespace, message2, stack2) {
    var error = new Error;
    var stackString;
    Object.defineProperty(error, "constructor", {
      value: DeprecationError
    });
    Object.defineProperty(error, "message", {
      configurable: true,
      enumerable: false,
      value: message2,
      writable: true
    });
    Object.defineProperty(error, "name", {
      enumerable: false,
      configurable: true,
      value: "DeprecationError",
      writable: true
    });
    Object.defineProperty(error, "namespace", {
      configurable: true,
      enumerable: false,
      value: namespace,
      writable: true
    });
    Object.defineProperty(error, "stack", {
      configurable: true,
      enumerable: false,
      get: function() {
        if (stackString !== undefined) {
          return stackString;
        }
        return stackString = createStackString.call(this, stack2);
      },
      set: function setter(val) {
        stackString = val;
      }
    });
    return error;
  }
});

// node_modules/bytes/index.js
var require_bytes = __commonJS((exports, module) => {
  /*!
   * bytes
   * Copyright(c) 2012-2014 TJ Holowaychuk
   * Copyright(c) 2015 Jed Watson
   * MIT Licensed
   */
  module.exports = bytes;
  module.exports.format = format;
  module.exports.parse = parse;
  var formatThousandsRegExp = /\B(?=(\d{3})+(?!\d))/g;
  var formatDecimalsRegExp = /(?:\.0*|(\.[^0]+)0+)$/;
  var map = {
    b: 1,
    kb: 1 << 10,
    mb: 1 << 20,
    gb: 1 << 30,
    tb: Math.pow(1024, 4),
    pb: Math.pow(1024, 5)
  };
  var parseRegExp = /^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb|pb)$/i;
  function bytes(value, options) {
    if (typeof value === "string") {
      return parse(value);
    }
    if (typeof value === "number") {
      return format(value, options);
    }
    return null;
  }
  function format(value, options) {
    if (!Number.isFinite(value)) {
      return null;
    }
    var mag = Math.abs(value);
    var thousandsSeparator = options && options.thousandsSeparator || "";
    var unitSeparator = options && options.unitSeparator || "";
    var decimalPlaces = options && options.decimalPlaces !== undefined ? options.decimalPlaces : 2;
    var fixedDecimals = Boolean(options && options.fixedDecimals);
    var unit = options && options.unit || "";
    if (!unit || !map[unit.toLowerCase()]) {
      if (mag >= map.pb) {
        unit = "PB";
      } else if (mag >= map.tb) {
        unit = "TB";
      } else if (mag >= map.gb) {
        unit = "GB";
      } else if (mag >= map.mb) {
        unit = "MB";
      } else if (mag >= map.kb) {
        unit = "KB";
      } else {
        unit = "B";
      }
    }
    var val = value / map[unit.toLowerCase()];
    var str = val.toFixed(decimalPlaces);
    if (!fixedDecimals) {
      str = str.replace(formatDecimalsRegExp, "$1");
    }
    if (thousandsSeparator) {
      str = str.replace(formatThousandsRegExp, thousandsSeparator);
    }
    return str + unitSeparator + unit;
  }
  function parse(val) {
    if (typeof val === "number" && !isNaN(val)) {
      return val;
    }
    if (typeof val !== "string") {
      return null;
    }
    var results = parseRegExp.exec(val);
    var floatValue;
    var unit = "b";
    if (!results) {
      floatValue = parseInt(val, 10);
      unit = "b";
    } else {
      floatValue = parseFloat(results[1]);
      unit = results[4].toLowerCase();
    }
    return Math.floor(map[unit] * floatValue);
  }
});

// node_modules/content-type/index.js
var require_content_type = __commonJS((exports) => {
  /*!
   * content-type
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  var PARAM_REGEXP = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g;
  var TEXT_REGEXP = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/;
  var TOKEN_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
  var QESC_REGEXP = /\\([\u000b\u0020-\u00ff])/g;
  var QUOTE_REGEXP = /([\\"])/g;
  var TYPE_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
  exports.format = format;
  exports.parse = parse;
  function format(obj) {
    if (!obj || typeof obj !== "object") {
      throw new TypeError("argument obj is required");
    }
    var parameters = obj.parameters;
    var type = obj.type;
    if (!type || !TYPE_REGEXP.test(type)) {
      throw new TypeError("invalid type");
    }
    var string = type;
    if (parameters && typeof parameters === "object") {
      var param;
      var params = Object.keys(parameters).sort();
      for (var i = 0;i < params.length; i++) {
        param = params[i];
        if (!TOKEN_REGEXP.test(param)) {
          throw new TypeError("invalid parameter name");
        }
        string += "; " + param + "=" + qstring(parameters[param]);
      }
    }
    return string;
  }
  function parse(string) {
    if (!string) {
      throw new TypeError("argument string is required");
    }
    var header = typeof string === "object" ? getcontenttype(string) : string;
    if (typeof header !== "string") {
      throw new TypeError("argument string is required to be a string");
    }
    var index = header.indexOf(";");
    var type = index !== -1 ? header.substr(0, index).trim() : header.trim();
    if (!TYPE_REGEXP.test(type)) {
      throw new TypeError("invalid media type");
    }
    var obj = new ContentType(type.toLowerCase());
    if (index !== -1) {
      var key;
      var match;
      var value;
      PARAM_REGEXP.lastIndex = index;
      while (match = PARAM_REGEXP.exec(header)) {
        if (match.index !== index) {
          throw new TypeError("invalid parameter format");
        }
        index += match[0].length;
        key = match[1].toLowerCase();
        value = match[2];
        if (value[0] === '"') {
          value = value.substr(1, value.length - 2).replace(QESC_REGEXP, "$1");
        }
        obj.parameters[key] = value;
      }
      if (index !== header.length) {
        throw new TypeError("invalid parameter format");
      }
    }
    return obj;
  }
  function getcontenttype(obj) {
    var header;
    if (typeof obj.getHeader === "function") {
      header = obj.getHeader("content-type");
    } else if (typeof obj.headers === "object") {
      header = obj.headers && obj.headers["content-type"];
    }
    if (typeof header !== "string") {
      throw new TypeError("content-type header is missing from object");
    }
    return header;
  }
  function qstring(val) {
    var str = String(val);
    if (TOKEN_REGEXP.test(str)) {
      return str;
    }
    if (str.length > 0 && !TEXT_REGEXP.test(str)) {
      throw new TypeError("invalid parameter value");
    }
    return '"' + str.replace(QUOTE_REGEXP, "\\$1") + '"';
  }
  function ContentType(type) {
    this.parameters = Object.create(null);
    this.type = type;
  }
});

// node_modules/setprototypeof/index.js
var require_setprototypeof = __commonJS((exports, module) => {
  module.exports = Object.setPrototypeOf || ({ __proto__: [] } instanceof Array ? setProtoOf : mixinProperties);
  function setProtoOf(obj, proto) {
    obj.__proto__ = proto;
    return obj;
  }
  function mixinProperties(obj, proto) {
    for (var prop in proto) {
      if (!obj.hasOwnProperty(prop)) {
        obj[prop] = proto[prop];
      }
    }
    return obj;
  }
});

// node_modules/statuses/codes.json
var require_codes = __commonJS((exports, module) => {
  module.exports = {
    "100": "Continue",
    "101": "Switching Protocols",
    "102": "Processing",
    "103": "Early Hints",
    "200": "OK",
    "201": "Created",
    "202": "Accepted",
    "203": "Non-Authoritative Information",
    "204": "No Content",
    "205": "Reset Content",
    "206": "Partial Content",
    "207": "Multi-Status",
    "208": "Already Reported",
    "226": "IM Used",
    "300": "Multiple Choices",
    "301": "Moved Permanently",
    "302": "Found",
    "303": "See Other",
    "304": "Not Modified",
    "305": "Use Proxy",
    "306": "(Unused)",
    "307": "Temporary Redirect",
    "308": "Permanent Redirect",
    "400": "Bad Request",
    "401": "Unauthorized",
    "402": "Payment Required",
    "403": "Forbidden",
    "404": "Not Found",
    "405": "Method Not Allowed",
    "406": "Not Acceptable",
    "407": "Proxy Authentication Required",
    "408": "Request Timeout",
    "409": "Conflict",
    "410": "Gone",
    "411": "Length Required",
    "412": "Precondition Failed",
    "413": "Payload Too Large",
    "414": "URI Too Long",
    "415": "Unsupported Media Type",
    "416": "Range Not Satisfiable",
    "417": "Expectation Failed",
    "418": "I'm a teapot",
    "421": "Misdirected Request",
    "422": "Unprocessable Entity",
    "423": "Locked",
    "424": "Failed Dependency",
    "425": "Unordered Collection",
    "426": "Upgrade Required",
    "428": "Precondition Required",
    "429": "Too Many Requests",
    "431": "Request Header Fields Too Large",
    "451": "Unavailable For Legal Reasons",
    "500": "Internal Server Error",
    "501": "Not Implemented",
    "502": "Bad Gateway",
    "503": "Service Unavailable",
    "504": "Gateway Timeout",
    "505": "HTTP Version Not Supported",
    "506": "Variant Also Negotiates",
    "507": "Insufficient Storage",
    "508": "Loop Detected",
    "509": "Bandwidth Limit Exceeded",
    "510": "Not Extended",
    "511": "Network Authentication Required"
  };
});

// node_modules/statuses/index.js
var require_statuses = __commonJS((exports, module) => {
  /*!
   * statuses
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2016 Douglas Christopher Wilson
   * MIT Licensed
   */
  var codes = require_codes();
  module.exports = status;
  status.STATUS_CODES = codes;
  status.codes = populateStatusesMap(status, codes);
  status.redirect = {
    300: true,
    301: true,
    302: true,
    303: true,
    305: true,
    307: true,
    308: true
  };
  status.empty = {
    204: true,
    205: true,
    304: true
  };
  status.retry = {
    502: true,
    503: true,
    504: true
  };
  function populateStatusesMap(statuses, codes2) {
    var arr = [];
    Object.keys(codes2).forEach(function forEachCode(code) {
      var message2 = codes2[code];
      var status2 = Number(code);
      statuses[status2] = message2;
      statuses[message2] = status2;
      statuses[message2.toLowerCase()] = status2;
      arr.push(status2);
    });
    return arr;
  }
  function status(code) {
    if (typeof code === "number") {
      if (!status[code])
        throw new Error("invalid status code: " + code);
      return code;
    }
    if (typeof code !== "string") {
      throw new TypeError("code must be a number or string");
    }
    var n = parseInt(code, 10);
    if (!isNaN(n)) {
      if (!status[n])
        throw new Error("invalid status code: " + n);
      return n;
    }
    n = status[code.toLowerCase()];
    if (!n)
      throw new Error('invalid status message: "' + code + '"');
    return n;
  }
});

// node_modules/http-errors/node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS((exports, module) => {
  if (typeof Object.create === "function") {
    module.exports = function inherits(ctor, superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    };
  } else {
    module.exports = function inherits(ctor, superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function() {};
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor;
      ctor.prototype.constructor = ctor;
    };
  }
});

// node_modules/http-errors/node_modules/inherits/inherits.js
var require_inherits = __commonJS((exports, module) => {
  try {
    util = __require("util");
    if (typeof util.inherits !== "function")
      throw "";
    module.exports = util.inherits;
  } catch (e) {
    module.exports = require_inherits_browser();
  }
  var util;
});

// node_modules/toidentifier/index.js
var require_toidentifier = __commonJS((exports, module) => {
  /*!
   * toidentifier
   * Copyright(c) 2016 Douglas Christopher Wilson
   * MIT Licensed
   */
  module.exports = toIdentifier;
  function toIdentifier(str) {
    return str.split(" ").map(function(token) {
      return token.slice(0, 1).toUpperCase() + token.slice(1);
    }).join("").replace(/[^ _0-9a-z]/gi, "");
  }
});

// node_modules/http-errors/index.js
var require_http_errors = __commonJS((exports, module) => {
  /*!
   * http-errors
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2016 Douglas Christopher Wilson
   * MIT Licensed
   */
  var deprecate2 = require_depd()("http-errors");
  var setPrototypeOf = require_setprototypeof();
  var statuses = require_statuses();
  var inherits = require_inherits();
  var toIdentifier = require_toidentifier();
  module.exports = createError;
  module.exports.HttpError = createHttpErrorConstructor();
  populateConstructorExports(module.exports, statuses.codes, module.exports.HttpError);
  function codeClass(status) {
    return Number(String(status).charAt(0) + "00");
  }
  function createError() {
    var err;
    var msg;
    var status = 500;
    var props = {};
    for (var i = 0;i < arguments.length; i++) {
      var arg = arguments[i];
      if (arg instanceof Error) {
        err = arg;
        status = err.status || err.statusCode || status;
        continue;
      }
      switch (typeof arg) {
        case "string":
          msg = arg;
          break;
        case "number":
          status = arg;
          if (i !== 0) {
            deprecate2("non-first-argument status code; replace with createError(" + arg + ", ...)");
          }
          break;
        case "object":
          props = arg;
          break;
      }
    }
    if (typeof status === "number" && (status < 400 || status >= 600)) {
      deprecate2("non-error status code; use only 4xx or 5xx status codes");
    }
    if (typeof status !== "number" || !statuses[status] && (status < 400 || status >= 600)) {
      status = 500;
    }
    var HttpError = createError[status] || createError[codeClass(status)];
    if (!err) {
      err = HttpError ? new HttpError(msg) : new Error(msg || statuses[status]);
      Error.captureStackTrace(err, createError);
    }
    if (!HttpError || !(err instanceof HttpError) || err.status !== status) {
      err.expose = status < 500;
      err.status = err.statusCode = status;
    }
    for (var key in props) {
      if (key !== "status" && key !== "statusCode") {
        err[key] = props[key];
      }
    }
    return err;
  }
  function createHttpErrorConstructor() {
    function HttpError() {
      throw new TypeError("cannot construct abstract class");
    }
    inherits(HttpError, Error);
    return HttpError;
  }
  function createClientErrorConstructor(HttpError, name, code) {
    var className = name.match(/Error$/) ? name : name + "Error";
    function ClientError(message2) {
      var msg = message2 != null ? message2 : statuses[code];
      var err = new Error(msg);
      Error.captureStackTrace(err, ClientError);
      setPrototypeOf(err, ClientError.prototype);
      Object.defineProperty(err, "message", {
        enumerable: true,
        configurable: true,
        value: msg,
        writable: true
      });
      Object.defineProperty(err, "name", {
        enumerable: false,
        configurable: true,
        value: className,
        writable: true
      });
      return err;
    }
    inherits(ClientError, HttpError);
    nameFunc(ClientError, className);
    ClientError.prototype.status = code;
    ClientError.prototype.statusCode = code;
    ClientError.prototype.expose = true;
    return ClientError;
  }
  function createServerErrorConstructor(HttpError, name, code) {
    var className = name.match(/Error$/) ? name : name + "Error";
    function ServerError(message2) {
      var msg = message2 != null ? message2 : statuses[code];
      var err = new Error(msg);
      Error.captureStackTrace(err, ServerError);
      setPrototypeOf(err, ServerError.prototype);
      Object.defineProperty(err, "message", {
        enumerable: true,
        configurable: true,
        value: msg,
        writable: true
      });
      Object.defineProperty(err, "name", {
        enumerable: false,
        configurable: true,
        value: className,
        writable: true
      });
      return err;
    }
    inherits(ServerError, HttpError);
    nameFunc(ServerError, className);
    ServerError.prototype.status = code;
    ServerError.prototype.statusCode = code;
    ServerError.prototype.expose = false;
    return ServerError;
  }
  function nameFunc(func, name) {
    var desc = Object.getOwnPropertyDescriptor(func, "name");
    if (desc && desc.configurable) {
      desc.value = name;
      Object.defineProperty(func, "name", desc);
    }
  }
  function populateConstructorExports(exports2, codes, HttpError) {
    codes.forEach(function forEachCode(code) {
      var CodeError;
      var name = toIdentifier(statuses[code]);
      switch (codeClass(code)) {
        case 400:
          CodeError = createClientErrorConstructor(HttpError, name, code);
          break;
        case 500:
          CodeError = createServerErrorConstructor(HttpError, name, code);
          break;
      }
      if (CodeError) {
        exports2[code] = CodeError;
        exports2[name] = CodeError;
      }
    });
    exports2["I'mateapot"] = deprecate2.function(exports2.ImATeapot, `"I'mateapot"; use "ImATeapot" instead`);
  }
});

// node_modules/body-parser/node_modules/debug/node_modules/ms/index.js
var require_ms = __commonJS((exports, module) => {
  var s = 1000;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var y = d * 365.25;
  module.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse(val);
    } else if (type === "number" && isNaN(val) === false) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
  function parse(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return;
    }
  }
  function fmtShort(ms) {
    if (ms >= d) {
      return Math.round(ms / d) + "d";
    }
    if (ms >= h) {
      return Math.round(ms / h) + "h";
    }
    if (ms >= m) {
      return Math.round(ms / m) + "m";
    }
    if (ms >= s) {
      return Math.round(ms / s) + "s";
    }
    return ms + "ms";
  }
  function fmtLong(ms) {
    return plural(ms, d, "day") || plural(ms, h, "hour") || plural(ms, m, "minute") || plural(ms, s, "second") || ms + " ms";
  }
  function plural(ms, n, name) {
    if (ms < n) {
      return;
    }
    if (ms < n * 1.5) {
      return Math.floor(ms / n) + " " + name;
    }
    return Math.ceil(ms / n) + " " + name + "s";
  }
});

// node_modules/body-parser/node_modules/debug/src/debug.js
var require_debug = __commonJS((exports, module) => {
  exports = module.exports = createDebug.debug = createDebug["default"] = createDebug;
  exports.coerce = coerce;
  exports.disable = disable;
  exports.enable = enable;
  exports.enabled = enabled;
  exports.humanize = require_ms();
  exports.names = [];
  exports.skips = [];
  exports.formatters = {};
  var prevTime;
  function selectColor(namespace) {
    var hash = 0, i;
    for (i in namespace) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i);
      hash |= 0;
    }
    return exports.colors[Math.abs(hash) % exports.colors.length];
  }
  function createDebug(namespace) {
    function debug() {
      if (!debug.enabled)
        return;
      var self2 = debug;
      var curr = +new Date;
      var ms = curr - (prevTime || curr);
      self2.diff = ms;
      self2.prev = prevTime;
      self2.curr = curr;
      prevTime = curr;
      var args2 = new Array(arguments.length);
      for (var i = 0;i < args2.length; i++) {
        args2[i] = arguments[i];
      }
      args2[0] = exports.coerce(args2[0]);
      if (typeof args2[0] !== "string") {
        args2.unshift("%O");
      }
      var index = 0;
      args2[0] = args2[0].replace(/%([a-zA-Z%])/g, function(match, format) {
        if (match === "%%")
          return match;
        index++;
        var formatter = exports.formatters[format];
        if (typeof formatter === "function") {
          var val = args2[index];
          match = formatter.call(self2, val);
          args2.splice(index, 1);
          index--;
        }
        return match;
      });
      exports.formatArgs.call(self2, args2);
      var logFn = debug.log || exports.log || console.log.bind(console);
      logFn.apply(self2, args2);
    }
    debug.namespace = namespace;
    debug.enabled = exports.enabled(namespace);
    debug.useColors = exports.useColors();
    debug.color = selectColor(namespace);
    if (typeof exports.init === "function") {
      exports.init(debug);
    }
    return debug;
  }
  function enable(namespaces) {
    exports.save(namespaces);
    exports.names = [];
    exports.skips = [];
    var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
    var len = split.length;
    for (var i = 0;i < len; i++) {
      if (!split[i])
        continue;
      namespaces = split[i].replace(/\*/g, ".*?");
      if (namespaces[0] === "-") {
        exports.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
      } else {
        exports.names.push(new RegExp("^" + namespaces + "$"));
      }
    }
  }
  function disable() {
    exports.enable("");
  }
  function enabled(name) {
    var i, len;
    for (i = 0, len = exports.skips.length;i < len; i++) {
      if (exports.skips[i].test(name)) {
        return false;
      }
    }
    for (i = 0, len = exports.names.length;i < len; i++) {
      if (exports.names[i].test(name)) {
        return true;
      }
    }
    return false;
  }
  function coerce(val) {
    if (val instanceof Error)
      return val.stack || val.message;
    return val;
  }
});

// node_modules/body-parser/node_modules/debug/src/browser.js
var require_browser = __commonJS((exports, module) => {
  exports = module.exports = require_debug();
  exports.log = log;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = typeof chrome != "undefined" && typeof chrome.storage != "undefined" ? chrome.storage.local : localstorage();
  exports.colors = [
    "lightseagreen",
    "forestgreen",
    "goldenrod",
    "dodgerblue",
    "darkorchid",
    "crimson"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
      return true;
    }
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  exports.formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (err) {
      return "[UnexpectedJSONParseError]: " + err.message;
    }
  };
  function formatArgs(args2) {
    var useColors2 = this.useColors;
    args2[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args2[0] + (useColors2 ? "%c " : " ") + "+" + exports.humanize(this.diff);
    if (!useColors2)
      return;
    var c = "color: " + this.color;
    args2.splice(1, 0, c, "color: inherit");
    var index = 0;
    var lastC = 0;
    args2[0].replace(/%[a-zA-Z%]/g, function(match) {
      if (match === "%%")
        return;
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args2.splice(lastC, 0, c);
  }
  function log() {
    return typeof console === "object" && console.log && Function.prototype.apply.call(console.log, console, arguments);
  }
  function save(namespaces) {
    try {
      if (namespaces == null) {
        exports.storage.removeItem("debug");
      } else {
        exports.storage.debug = namespaces;
      }
    } catch (e) {}
  }
  function load() {
    var r;
    try {
      r = exports.storage.debug;
    } catch (e) {}
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = process.env.DEBUG;
    }
    return r;
  }
  exports.enable(load());
  function localstorage() {
    try {
      return window.localStorage;
    } catch (e) {}
  }
});

// node_modules/body-parser/node_modules/debug/src/node.js
var require_node = __commonJS((exports, module) => {
  var tty = __require("tty");
  var util = __require("util");
  exports = module.exports = require_debug();
  exports.init = init;
  exports.log = log;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.colors = [6, 2, 3, 4, 5, 1];
  exports.inspectOpts = Object.keys(process.env).filter(function(key) {
    return /^debug_/i.test(key);
  }).reduce(function(obj, key) {
    var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function(_, k) {
      return k.toUpperCase();
    });
    var val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val))
      val = true;
    else if (/^(no|off|false|disabled)$/i.test(val))
      val = false;
    else if (val === "null")
      val = null;
    else
      val = Number(val);
    obj[prop] = val;
    return obj;
  }, {});
  var fd = parseInt(process.env.DEBUG_FD, 10) || 2;
  if (fd !== 1 && fd !== 2) {
    util.deprecate(function() {}, "except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)")();
  }
  var stream = fd === 1 ? process.stdout : fd === 2 ? process.stderr : createWritableStdioStream(fd);
  function useColors() {
    return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(fd);
  }
  exports.formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts).split(`
`).map(function(str) {
      return str.trim();
    }).join(" ");
  };
  exports.formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts);
  };
  function formatArgs(args2) {
    var name = this.namespace;
    var useColors2 = this.useColors;
    if (useColors2) {
      var c = this.color;
      var prefix = "  \x1B[3" + c + ";1m" + name + " " + "\x1B[0m";
      args2[0] = prefix + args2[0].split(`
`).join(`
` + prefix);
      args2.push("\x1B[3" + c + "m+" + exports.humanize(this.diff) + "\x1B[0m");
    } else {
      args2[0] = new Date().toUTCString() + " " + name + " " + args2[0];
    }
  }
  function log() {
    return stream.write(util.format.apply(util, arguments) + `
`);
  }
  function save(namespaces) {
    if (namespaces == null) {
      delete process.env.DEBUG;
    } else {
      process.env.DEBUG = namespaces;
    }
  }
  function load() {
    return process.env.DEBUG;
  }
  function createWritableStdioStream(fd2) {
    var stream2;
    var tty_wrap = process.binding("tty_wrap");
    switch (tty_wrap.guessHandleType(fd2)) {
      case "TTY":
        stream2 = new tty.WriteStream(fd2);
        stream2._type = "tty";
        if (stream2._handle && stream2._handle.unref) {
          stream2._handle.unref();
        }
        break;
      case "FILE":
        var fs = __require("fs");
        stream2 = new fs.SyncWriteStream(fd2, { autoClose: false });
        stream2._type = "fs";
        break;
      case "PIPE":
      case "TCP":
        var net = __require("net");
        stream2 = new net.Socket({
          fd: fd2,
          readable: false,
          writable: true
        });
        stream2.readable = false;
        stream2.read = null;
        stream2._type = "pipe";
        if (stream2._handle && stream2._handle.unref) {
          stream2._handle.unref();
        }
        break;
      default:
        throw new Error("Implement me. Unknown stream file type!");
    }
    stream2.fd = fd2;
    stream2._isStdio = true;
    return stream2;
  }
  function init(debug) {
    debug.inspectOpts = {};
    var keys = Object.keys(exports.inspectOpts);
    for (var i = 0;i < keys.length; i++) {
      debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
    }
  }
  exports.enable(load());
});

// node_modules/body-parser/node_modules/debug/src/index.js
var require_src = __commonJS((exports, module) => {
  if (typeof process !== "undefined" && process.type === "renderer") {
    module.exports = require_browser();
  } else {
    module.exports = require_node();
  }
});

// node_modules/safer-buffer/safer.js
var require_safer = __commonJS((exports, module) => {
  var buffer = __require("buffer");
  var Buffer2 = buffer.Buffer;
  var safer = {};
  var key;
  for (key in buffer) {
    if (!buffer.hasOwnProperty(key))
      continue;
    if (key === "SlowBuffer" || key === "Buffer")
      continue;
    safer[key] = buffer[key];
  }
  var Safer = safer.Buffer = {};
  for (key in Buffer2) {
    if (!Buffer2.hasOwnProperty(key))
      continue;
    if (key === "allocUnsafe" || key === "allocUnsafeSlow")
      continue;
    Safer[key] = Buffer2[key];
  }
  safer.Buffer.prototype = Buffer2.prototype;
  if (!Safer.from || Safer.from === Uint8Array.from) {
    Safer.from = function(value, encodingOrOffset, length) {
      if (typeof value === "number") {
        throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value);
      }
      if (value && typeof value.length === "undefined") {
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
      }
      return Buffer2(value, encodingOrOffset, length);
    };
  }
  if (!Safer.alloc) {
    Safer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size);
      }
      if (size < 0 || size >= 2 * (1 << 30)) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
      var buf = Buffer2(size);
      if (!fill || fill.length === 0) {
        buf.fill(0);
      } else if (typeof encoding === "string") {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
      return buf;
    };
  }
  if (!safer.kStringMaxLength) {
    try {
      safer.kStringMaxLength = process.binding("buffer").kStringMaxLength;
    } catch (e) {}
  }
  if (!safer.constants) {
    safer.constants = {
      MAX_LENGTH: safer.kMaxLength
    };
    if (safer.kStringMaxLength) {
      safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
    }
  }
  module.exports = safer;
});

// node_modules/iconv-lite/lib/bom-handling.js
var require_bom_handling = __commonJS((exports) => {
  var BOMChar = "\uFEFF";
  exports.PrependBOM = PrependBOMWrapper;
  function PrependBOMWrapper(encoder, options) {
    this.encoder = encoder;
    this.addBOM = true;
  }
  PrependBOMWrapper.prototype.write = function(str) {
    if (this.addBOM) {
      str = BOMChar + str;
      this.addBOM = false;
    }
    return this.encoder.write(str);
  };
  PrependBOMWrapper.prototype.end = function() {
    return this.encoder.end();
  };
  exports.StripBOM = StripBOMWrapper;
  function StripBOMWrapper(decoder, options) {
    this.decoder = decoder;
    this.pass = false;
    this.options = options || {};
  }
  StripBOMWrapper.prototype.write = function(buf) {
    var res = this.decoder.write(buf);
    if (this.pass || !res)
      return res;
    if (res[0] === BOMChar) {
      res = res.slice(1);
      if (typeof this.options.stripBOM === "function")
        this.options.stripBOM();
    }
    this.pass = true;
    return res;
  };
  StripBOMWrapper.prototype.end = function() {
    return this.decoder.end();
  };
});

// node_modules/iconv-lite/encodings/internal.js
var require_internal = __commonJS((exports, module) => {
  var Buffer2 = require_safer().Buffer;
  module.exports = {
    utf8: { type: "_internal", bomAware: true },
    cesu8: { type: "_internal", bomAware: true },
    unicode11utf8: "utf8",
    ucs2: { type: "_internal", bomAware: true },
    utf16le: "ucs2",
    binary: { type: "_internal" },
    base64: { type: "_internal" },
    hex: { type: "_internal" },
    _internal: InternalCodec
  };
  function InternalCodec(codecOptions, iconv) {
    this.enc = codecOptions.encodingName;
    this.bomAware = codecOptions.bomAware;
    if (this.enc === "base64")
      this.encoder = InternalEncoderBase64;
    else if (this.enc === "cesu8") {
      this.enc = "utf8";
      this.encoder = InternalEncoderCesu8;
      if (Buffer2.from("eda0bdedb2a9", "hex").toString() !== "\uD83D\uDCA9") {
        this.decoder = InternalDecoderCesu8;
        this.defaultCharUnicode = iconv.defaultCharUnicode;
      }
    }
  }
  InternalCodec.prototype.encoder = InternalEncoder;
  InternalCodec.prototype.decoder = InternalDecoder;
  var StringDecoder = __require("string_decoder").StringDecoder;
  if (!StringDecoder.prototype.end)
    StringDecoder.prototype.end = function() {};
  function InternalDecoder(options, codec) {
    StringDecoder.call(this, codec.enc);
  }
  InternalDecoder.prototype = StringDecoder.prototype;
  function InternalEncoder(options, codec) {
    this.enc = codec.enc;
  }
  InternalEncoder.prototype.write = function(str) {
    return Buffer2.from(str, this.enc);
  };
  InternalEncoder.prototype.end = function() {};
  function InternalEncoderBase64(options, codec) {
    this.prevStr = "";
  }
  InternalEncoderBase64.prototype.write = function(str) {
    str = this.prevStr + str;
    var completeQuads = str.length - str.length % 4;
    this.prevStr = str.slice(completeQuads);
    str = str.slice(0, completeQuads);
    return Buffer2.from(str, "base64");
  };
  InternalEncoderBase64.prototype.end = function() {
    return Buffer2.from(this.prevStr, "base64");
  };
  function InternalEncoderCesu8(options, codec) {}
  InternalEncoderCesu8.prototype.write = function(str) {
    var buf = Buffer2.alloc(str.length * 3), bufIdx = 0;
    for (var i = 0;i < str.length; i++) {
      var charCode = str.charCodeAt(i);
      if (charCode < 128)
        buf[bufIdx++] = charCode;
      else if (charCode < 2048) {
        buf[bufIdx++] = 192 + (charCode >>> 6);
        buf[bufIdx++] = 128 + (charCode & 63);
      } else {
        buf[bufIdx++] = 224 + (charCode >>> 12);
        buf[bufIdx++] = 128 + (charCode >>> 6 & 63);
        buf[bufIdx++] = 128 + (charCode & 63);
      }
    }
    return buf.slice(0, bufIdx);
  };
  InternalEncoderCesu8.prototype.end = function() {};
  function InternalDecoderCesu8(options, codec) {
    this.acc = 0;
    this.contBytes = 0;
    this.accBytes = 0;
    this.defaultCharUnicode = codec.defaultCharUnicode;
  }
  InternalDecoderCesu8.prototype.write = function(buf) {
    var acc = this.acc, contBytes = this.contBytes, accBytes = this.accBytes, res = "";
    for (var i = 0;i < buf.length; i++) {
      var curByte = buf[i];
      if ((curByte & 192) !== 128) {
        if (contBytes > 0) {
          res += this.defaultCharUnicode;
          contBytes = 0;
        }
        if (curByte < 128) {
          res += String.fromCharCode(curByte);
        } else if (curByte < 224) {
          acc = curByte & 31;
          contBytes = 1;
          accBytes = 1;
        } else if (curByte < 240) {
          acc = curByte & 15;
          contBytes = 2;
          accBytes = 1;
        } else {
          res += this.defaultCharUnicode;
        }
      } else {
        if (contBytes > 0) {
          acc = acc << 6 | curByte & 63;
          contBytes--;
          accBytes++;
          if (contBytes === 0) {
            if (accBytes === 2 && acc < 128 && acc > 0)
              res += this.defaultCharUnicode;
            else if (accBytes === 3 && acc < 2048)
              res += this.defaultCharUnicode;
            else
              res += String.fromCharCode(acc);
          }
        } else {
          res += this.defaultCharUnicode;
        }
      }
    }
    this.acc = acc;
    this.contBytes = contBytes;
    this.accBytes = accBytes;
    return res;
  };
  InternalDecoderCesu8.prototype.end = function() {
    var res = 0;
    if (this.contBytes > 0)
      res += this.defaultCharUnicode;
    return res;
  };
});

// node_modules/iconv-lite/encodings/utf16.js
var require_utf16 = __commonJS((exports) => {
  var Buffer2 = require_safer().Buffer;
  exports.utf16be = Utf16BECodec;
  function Utf16BECodec() {}
  Utf16BECodec.prototype.encoder = Utf16BEEncoder;
  Utf16BECodec.prototype.decoder = Utf16BEDecoder;
  Utf16BECodec.prototype.bomAware = true;
  function Utf16BEEncoder() {}
  Utf16BEEncoder.prototype.write = function(str) {
    var buf = Buffer2.from(str, "ucs2");
    for (var i = 0;i < buf.length; i += 2) {
      var tmp = buf[i];
      buf[i] = buf[i + 1];
      buf[i + 1] = tmp;
    }
    return buf;
  };
  Utf16BEEncoder.prototype.end = function() {};
  function Utf16BEDecoder() {
    this.overflowByte = -1;
  }
  Utf16BEDecoder.prototype.write = function(buf) {
    if (buf.length == 0)
      return "";
    var buf2 = Buffer2.alloc(buf.length + 1), i = 0, j = 0;
    if (this.overflowByte !== -1) {
      buf2[0] = buf[0];
      buf2[1] = this.overflowByte;
      i = 1;
      j = 2;
    }
    for (;i < buf.length - 1; i += 2, j += 2) {
      buf2[j] = buf[i + 1];
      buf2[j + 1] = buf[i];
    }
    this.overflowByte = i == buf.length - 1 ? buf[buf.length - 1] : -1;
    return buf2.slice(0, j).toString("ucs2");
  };
  Utf16BEDecoder.prototype.end = function() {};
  exports.utf16 = Utf16Codec;
  function Utf16Codec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf16Codec.prototype.encoder = Utf16Encoder;
  Utf16Codec.prototype.decoder = Utf16Decoder;
  function Utf16Encoder(options, codec) {
    options = options || {};
    if (options.addBOM === undefined)
      options.addBOM = true;
    this.encoder = codec.iconv.getEncoder("utf-16le", options);
  }
  Utf16Encoder.prototype.write = function(str) {
    return this.encoder.write(str);
  };
  Utf16Encoder.prototype.end = function() {
    return this.encoder.end();
  };
  function Utf16Decoder(options, codec) {
    this.decoder = null;
    this.initialBytes = [];
    this.initialBytesLen = 0;
    this.options = options || {};
    this.iconv = codec.iconv;
  }
  Utf16Decoder.prototype.write = function(buf) {
    if (!this.decoder) {
      this.initialBytes.push(buf);
      this.initialBytesLen += buf.length;
      if (this.initialBytesLen < 16)
        return "";
      var buf = Buffer2.concat(this.initialBytes), encoding = detectEncoding(buf, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding, this.options);
      this.initialBytes.length = this.initialBytesLen = 0;
    }
    return this.decoder.write(buf);
  };
  Utf16Decoder.prototype.end = function() {
    if (!this.decoder) {
      var buf = Buffer2.concat(this.initialBytes), encoding = detectEncoding(buf, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding, this.options);
      var res = this.decoder.write(buf), trail = this.decoder.end();
      return trail ? res + trail : res;
    }
    return this.decoder.end();
  };
  function detectEncoding(buf, defaultEncoding) {
    var enc = defaultEncoding || "utf-16le";
    if (buf.length >= 2) {
      if (buf[0] == 254 && buf[1] == 255)
        enc = "utf-16be";
      else if (buf[0] == 255 && buf[1] == 254)
        enc = "utf-16le";
      else {
        var asciiCharsLE = 0, asciiCharsBE = 0, _len = Math.min(buf.length - buf.length % 2, 64);
        for (var i = 0;i < _len; i += 2) {
          if (buf[i] === 0 && buf[i + 1] !== 0)
            asciiCharsBE++;
          if (buf[i] !== 0 && buf[i + 1] === 0)
            asciiCharsLE++;
        }
        if (asciiCharsBE > asciiCharsLE)
          enc = "utf-16be";
        else if (asciiCharsBE < asciiCharsLE)
          enc = "utf-16le";
      }
    }
    return enc;
  }
});

// node_modules/iconv-lite/encodings/utf7.js
var require_utf7 = __commonJS((exports) => {
  var Buffer2 = require_safer().Buffer;
  exports.utf7 = Utf7Codec;
  exports.unicode11utf7 = "utf7";
  function Utf7Codec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf7Codec.prototype.encoder = Utf7Encoder;
  Utf7Codec.prototype.decoder = Utf7Decoder;
  Utf7Codec.prototype.bomAware = true;
  var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;
  function Utf7Encoder(options, codec) {
    this.iconv = codec.iconv;
  }
  Utf7Encoder.prototype.write = function(str) {
    return Buffer2.from(str.replace(nonDirectChars, function(chunk) {
      return "+" + (chunk === "+" ? "" : this.iconv.encode(chunk, "utf16-be").toString("base64").replace(/=+$/, "")) + "-";
    }.bind(this)));
  };
  Utf7Encoder.prototype.end = function() {};
  function Utf7Decoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = "";
  }
  var base64Regex = /[A-Za-z0-9\/+]/;
  var base64Chars = [];
  for (i = 0;i < 256; i++)
    base64Chars[i] = base64Regex.test(String.fromCharCode(i));
  var i;
  var plusChar = 43;
  var minusChar = 45;
  var andChar = 38;
  Utf7Decoder.prototype.write = function(buf) {
    var res = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
    for (var i2 = 0;i2 < buf.length; i2++) {
      if (!inBase64) {
        if (buf[i2] == plusChar) {
          res += this.iconv.decode(buf.slice(lastI, i2), "ascii");
          lastI = i2 + 1;
          inBase64 = true;
        }
      } else {
        if (!base64Chars[buf[i2]]) {
          if (i2 == lastI && buf[i2] == minusChar) {
            res += "+";
          } else {
            var b64str = base64Accum + buf.slice(lastI, i2).toString();
            res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
          }
          if (buf[i2] != minusChar)
            i2--;
          lastI = i2 + 1;
          inBase64 = false;
          base64Accum = "";
        }
      }
    }
    if (!inBase64) {
      res += this.iconv.decode(buf.slice(lastI), "ascii");
    } else {
      var b64str = base64Accum + buf.slice(lastI).toString();
      var canBeDecoded = b64str.length - b64str.length % 8;
      base64Accum = b64str.slice(canBeDecoded);
      b64str = b64str.slice(0, canBeDecoded);
      res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
    }
    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;
    return res;
  };
  Utf7Decoder.prototype.end = function() {
    var res = "";
    if (this.inBase64 && this.base64Accum.length > 0)
      res = this.iconv.decode(Buffer2.from(this.base64Accum, "base64"), "utf16-be");
    this.inBase64 = false;
    this.base64Accum = "";
    return res;
  };
  exports.utf7imap = Utf7IMAPCodec;
  function Utf7IMAPCodec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
  Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
  Utf7IMAPCodec.prototype.bomAware = true;
  function Utf7IMAPEncoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = Buffer2.alloc(6);
    this.base64AccumIdx = 0;
  }
  Utf7IMAPEncoder.prototype.write = function(str) {
    var inBase64 = this.inBase64, base64Accum = this.base64Accum, base64AccumIdx = this.base64AccumIdx, buf = Buffer2.alloc(str.length * 5 + 10), bufIdx = 0;
    for (var i2 = 0;i2 < str.length; i2++) {
      var uChar = str.charCodeAt(i2);
      if (32 <= uChar && uChar <= 126) {
        if (inBase64) {
          if (base64AccumIdx > 0) {
            bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
            base64AccumIdx = 0;
          }
          buf[bufIdx++] = minusChar;
          inBase64 = false;
        }
        if (!inBase64) {
          buf[bufIdx++] = uChar;
          if (uChar === andChar)
            buf[bufIdx++] = minusChar;
        }
      } else {
        if (!inBase64) {
          buf[bufIdx++] = andChar;
          inBase64 = true;
        }
        if (inBase64) {
          base64Accum[base64AccumIdx++] = uChar >> 8;
          base64Accum[base64AccumIdx++] = uChar & 255;
          if (base64AccumIdx == base64Accum.length) {
            bufIdx += buf.write(base64Accum.toString("base64").replace(/\//g, ","), bufIdx);
            base64AccumIdx = 0;
          }
        }
      }
    }
    this.inBase64 = inBase64;
    this.base64AccumIdx = base64AccumIdx;
    return buf.slice(0, bufIdx);
  };
  Utf7IMAPEncoder.prototype.end = function() {
    var buf = Buffer2.alloc(10), bufIdx = 0;
    if (this.inBase64) {
      if (this.base64AccumIdx > 0) {
        bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
        this.base64AccumIdx = 0;
      }
      buf[bufIdx++] = minusChar;
      this.inBase64 = false;
    }
    return buf.slice(0, bufIdx);
  };
  function Utf7IMAPDecoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = "";
  }
  var base64IMAPChars = base64Chars.slice();
  base64IMAPChars[44] = true;
  Utf7IMAPDecoder.prototype.write = function(buf) {
    var res = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
    for (var i2 = 0;i2 < buf.length; i2++) {
      if (!inBase64) {
        if (buf[i2] == andChar) {
          res += this.iconv.decode(buf.slice(lastI, i2), "ascii");
          lastI = i2 + 1;
          inBase64 = true;
        }
      } else {
        if (!base64IMAPChars[buf[i2]]) {
          if (i2 == lastI && buf[i2] == minusChar) {
            res += "&";
          } else {
            var b64str = base64Accum + buf.slice(lastI, i2).toString().replace(/,/g, "/");
            res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
          }
          if (buf[i2] != minusChar)
            i2--;
          lastI = i2 + 1;
          inBase64 = false;
          base64Accum = "";
        }
      }
    }
    if (!inBase64) {
      res += this.iconv.decode(buf.slice(lastI), "ascii");
    } else {
      var b64str = base64Accum + buf.slice(lastI).toString().replace(/,/g, "/");
      var canBeDecoded = b64str.length - b64str.length % 8;
      base64Accum = b64str.slice(canBeDecoded);
      b64str = b64str.slice(0, canBeDecoded);
      res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
    }
    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;
    return res;
  };
  Utf7IMAPDecoder.prototype.end = function() {
    var res = "";
    if (this.inBase64 && this.base64Accum.length > 0)
      res = this.iconv.decode(Buffer2.from(this.base64Accum, "base64"), "utf16-be");
    this.inBase64 = false;
    this.base64Accum = "";
    return res;
  };
});

// node_modules/iconv-lite/encodings/sbcs-codec.js
var require_sbcs_codec = __commonJS((exports) => {
  var Buffer2 = require_safer().Buffer;
  exports._sbcs = SBCSCodec;
  function SBCSCodec(codecOptions, iconv) {
    if (!codecOptions)
      throw new Error("SBCS codec is called without the data.");
    if (!codecOptions.chars || codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256)
      throw new Error("Encoding '" + codecOptions.type + "' has incorrect 'chars' (must be of len 128 or 256)");
    if (codecOptions.chars.length === 128) {
      var asciiString = "";
      for (var i = 0;i < 128; i++)
        asciiString += String.fromCharCode(i);
      codecOptions.chars = asciiString + codecOptions.chars;
    }
    this.decodeBuf = Buffer2.from(codecOptions.chars, "ucs2");
    var encodeBuf = Buffer2.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0));
    for (var i = 0;i < codecOptions.chars.length; i++)
      encodeBuf[codecOptions.chars.charCodeAt(i)] = i;
    this.encodeBuf = encodeBuf;
  }
  SBCSCodec.prototype.encoder = SBCSEncoder;
  SBCSCodec.prototype.decoder = SBCSDecoder;
  function SBCSEncoder(options, codec) {
    this.encodeBuf = codec.encodeBuf;
  }
  SBCSEncoder.prototype.write = function(str) {
    var buf = Buffer2.alloc(str.length);
    for (var i = 0;i < str.length; i++)
      buf[i] = this.encodeBuf[str.charCodeAt(i)];
    return buf;
  };
  SBCSEncoder.prototype.end = function() {};
  function SBCSDecoder(options, codec) {
    this.decodeBuf = codec.decodeBuf;
  }
  SBCSDecoder.prototype.write = function(buf) {
    var decodeBuf = this.decodeBuf;
    var newBuf = Buffer2.alloc(buf.length * 2);
    var idx1 = 0, idx2 = 0;
    for (var i = 0;i < buf.length; i++) {
      idx1 = buf[i] * 2;
      idx2 = i * 2;
      newBuf[idx2] = decodeBuf[idx1];
      newBuf[idx2 + 1] = decodeBuf[idx1 + 1];
    }
    return newBuf.toString("ucs2");
  };
  SBCSDecoder.prototype.end = function() {};
});

// node_modules/iconv-lite/encodings/sbcs-data.js
var require_sbcs_data = __commonJS((exports, module) => {
  module.exports = {
    "10029": "maccenteuro",
    maccenteuro: {
      type: "_sbcs",
      chars: ""
    },
    "808": "cp808",
    ibm808: "cp808",
    cp808: {
      type: "_sbcs",
      chars: ""
    },
    mik: {
      type: "_sbcs",
      chars: ""
    },
    ascii8bit: "ascii",
    usascii: "ascii",
    ansix34: "ascii",
    ansix341968: "ascii",
    ansix341986: "ascii",
    csascii: "ascii",
    cp367: "ascii",
    ibm367: "ascii",
    isoir6: "ascii",
    iso646us: "ascii",
    iso646irv: "ascii",
    us: "ascii",
    latin1: "iso88591",
    latin2: "iso88592",
    latin3: "iso88593",
    latin4: "iso88594",
    latin5: "iso88599",
    latin6: "iso885910",
    latin7: "iso885913",
    latin8: "iso885914",
    latin9: "iso885915",
    latin10: "iso885916",
    csisolatin1: "iso88591",
    csisolatin2: "iso88592",
    csisolatin3: "iso88593",
    csisolatin4: "iso88594",
    csisolatincyrillic: "iso88595",
    csisolatinarabic: "iso88596",
    csisolatingreek: "iso88597",
    csisolatinhebrew: "iso88598",
    csisolatin5: "iso88599",
    csisolatin6: "iso885910",
    l1: "iso88591",
    l2: "iso88592",
    l3: "iso88593",
    l4: "iso88594",
    l5: "iso88599",
    l6: "iso885910",
    l7: "iso885913",
    l8: "iso885914",
    l9: "iso885915",
    l10: "iso885916",
    isoir14: "iso646jp",
    isoir57: "iso646cn",
    isoir100: "iso88591",
    isoir101: "iso88592",
    isoir109: "iso88593",
    isoir110: "iso88594",
    isoir144: "iso88595",
    isoir127: "iso88596",
    isoir126: "iso88597",
    isoir138: "iso88598",
    isoir148: "iso88599",
    isoir157: "iso885910",
    isoir166: "tis620",
    isoir179: "iso885913",
    isoir199: "iso885914",
    isoir203: "iso885915",
    isoir226: "iso885916",
    cp819: "iso88591",
    ibm819: "iso88591",
    cyrillic: "iso88595",
    arabic: "iso88596",
    arabic8: "iso88596",
    ecma114: "iso88596",
    asmo708: "iso88596",
    greek: "iso88597",
    greek8: "iso88597",
    ecma118: "iso88597",
    elot928: "iso88597",
    hebrew: "iso88598",
    hebrew8: "iso88598",
    turkish: "iso88599",
    turkish8: "iso88599",
    thai: "iso885911",
    thai8: "iso885911",
    celtic: "iso885914",
    celtic8: "iso885914",
    isoceltic: "iso885914",
    tis6200: "tis620",
    tis62025291: "tis620",
    tis62025330: "tis620",
    "10000": "macroman",
    "10006": "macgreek",
    "10007": "maccyrillic",
    "10079": "maciceland",
    "10081": "macturkish",
    cspc8codepage437: "cp437",
    cspc775baltic: "cp775",
    cspc850multilingual: "cp850",
    cspcp852: "cp852",
    cspc862latinhebrew: "cp862",
    cpgr: "cp869",
    msee: "cp1250",
    mscyrl: "cp1251",
    msansi: "cp1252",
    msgreek: "cp1253",
    msturk: "cp1254",
    mshebr: "cp1255",
    msarab: "cp1256",
    winbaltrim: "cp1257",
    cp20866: "koi8r",
    "20866": "koi8r",
    ibm878: "koi8r",
    cskoi8r: "koi8r",
    cp21866: "koi8u",
    "21866": "koi8u",
    ibm1168: "koi8u",
    strk10482002: "rk1048",
    tcvn5712: "tcvn",
    tcvn57121: "tcvn",
    gb198880: "iso646cn",
    cn: "iso646cn",
    csiso14jisc6220ro: "iso646jp",
    jisc62201969ro: "iso646jp",
    jp: "iso646jp",
    cshproman8: "hproman8",
    r8: "hproman8",
    roman8: "hproman8",
    xroman8: "hproman8",
    ibm1051: "hproman8",
    mac: "macintosh",
    csmacintosh: "macintosh"
  };
});

// node_modules/iconv-lite/encodings/sbcs-data-generated.js
var require_sbcs_data_generated = __commonJS((exports, module) => {
  module.exports = {
    "437": "cp437",
    "737": "cp737",
    "775": "cp775",
    "850": "cp850",
    "852": "cp852",
    "855": "cp855",
    "856": "cp856",
    "857": "cp857",
    "858": "cp858",
    "860": "cp860",
    "861": "cp861",
    "862": "cp862",
    "863": "cp863",
    "864": "cp864",
    "865": "cp865",
    "866": "cp866",
    "869": "cp869",
    "874": "windows874",
    "922": "cp922",
    "1046": "cp1046",
    "1124": "cp1124",
    "1125": "cp1125",
    "1129": "cp1129",
    "1133": "cp1133",
    "1161": "cp1161",
    "1162": "cp1162",
    "1163": "cp1163",
    "1250": "windows1250",
    "1251": "windows1251",
    "1252": "windows1252",
    "1253": "windows1253",
    "1254": "windows1254",
    "1255": "windows1255",
    "1256": "windows1256",
    "1257": "windows1257",
    "1258": "windows1258",
    "28591": "iso88591",
    "28592": "iso88592",
    "28593": "iso88593",
    "28594": "iso88594",
    "28595": "iso88595",
    "28596": "iso88596",
    "28597": "iso88597",
    "28598": "iso88598",
    "28599": "iso88599",
    "28600": "iso885910",
    "28601": "iso885911",
    "28603": "iso885913",
    "28604": "iso885914",
    "28605": "iso885915",
    "28606": "iso885916",
    windows874: {
      type: "_sbcs",
      chars: ""
    },
    win874: "windows874",
    cp874: "windows874",
    windows1250: {
      type: "_sbcs",
      chars: ""
    },
    win1250: "windows1250",
    cp1250: "windows1250",
    windows1251: {
      type: "_sbcs",
      chars: ""
    },
    win1251: "windows1251",
    cp1251: "windows1251",
    windows1252: {
      type: "_sbcs",
      chars: ""
    },
    win1252: "windows1252",
    cp1252: "windows1252",
    windows1253: {
      type: "_sbcs",
      chars: ""
    },
    win1253: "windows1253",
    cp1253: "windows1253",
    windows1254: {
      type: "_sbcs",
      chars: ""
    },
    win1254: "windows1254",
    cp1254: "windows1254",
    windows1255: {
      type: "_sbcs",
      chars: ""
    },
    win1255: "windows1255",
    cp1255: "windows1255",
    windows1256: {
      type: "_sbcs",
      chars: ""
    },
    win1256: "windows1256",
    cp1256: "windows1256",
    windows1257: {
      type: "_sbcs",
      chars: ""
    },
    win1257: "windows1257",
    cp1257: "windows1257",
    windows1258: {
      type: "_sbcs",
      chars: ""
    },
    win1258: "windows1258",
    cp1258: "windows1258",
    iso88591: {
      type: "_sbcs",
      chars: ""
    },
    cp28591: "iso88591",
    iso88592: {
      type: "_sbcs",
      chars: ""
    },
    cp28592: "iso88592",
    iso88593: {
      type: "_sbcs",
      chars: ""
    },
    cp28593: "iso88593",
    iso88594: {
      type: "_sbcs",
      chars: ""
    },
    cp28594: "iso88594",
    iso88595: {
      type: "_sbcs",
      chars: ""
    },
    cp28595: "iso88595",
    iso88596: {
      type: "_sbcs",
      chars: ""
    },
    cp28596: "iso88596",
    iso88597: {
      type: "_sbcs",
      chars: ""
    },
    cp28597: "iso88597",
    iso88598: {
      type: "_sbcs",
      chars: ""
    },
    cp28598: "iso88598",
    iso88599: {
      type: "_sbcs",
      chars: ""
    },
    cp28599: "iso88599",
    iso885910: {
      type: "_sbcs",
      chars: ""
    },
    cp28600: "iso885910",
    iso885911: {
      type: "_sbcs",
      chars: ""
    },
    cp28601: "iso885911",
    iso885913: {
      type: "_sbcs",
      chars: ""
    },
    cp28603: "iso885913",
    iso885914: {
      type: "_sbcs",
      chars: ""
    },
    cp28604: "iso885914",
    iso885915: {
      type: "_sbcs",
      chars: ""
    },
    cp28605: "iso885915",
    iso885916: {
      type: "_sbcs",
      chars: ""
    },
    cp28606: "iso885916",
    cp437: {
      type: "_sbcs",
      chars: ""
    },
    ibm437: "cp437",
    csibm437: "cp437",
    cp737: {
      type: "_sbcs",
      chars: ""
    },
    ibm737: "cp737",
    csibm737: "cp737",
    cp775: {
      type: "_sbcs",
      chars: ""
    },
    ibm775: "cp775",
    csibm775: "cp775",
    cp850: {
      type: "_sbcs",
      chars: ""
    },
    ibm850: "cp850",
    csibm850: "cp850",
    cp852: {
      type: "_sbcs",
      chars: ""
    },
    ibm852: "cp852",
    csibm852: "cp852",
    cp855: {
      type: "_sbcs",
      chars: ""
    },
    ibm855: "cp855",
    csibm855: "cp855",
    cp856: {
      type: "_sbcs",
      chars: ""
    },
    ibm856: "cp856",
    csibm856: "cp856",
    cp857: {
      type: "_sbcs",
      chars: ""
    },
    ibm857: "cp857",
    csibm857: "cp857",
    cp858: {
      type: "_sbcs",
      chars: ""
    },
    ibm858: "cp858",
    csibm858: "cp858",
    cp860: {
      type: "_sbcs",
      chars: ""
    },
    ibm860: "cp860",
    csibm860: "cp860",
    cp861: {
      type: "_sbcs",
      chars: ""
    },
    ibm861: "cp861",
    csibm861: "cp861",
    cp862: {
      type: "_sbcs",
      chars: ""
    },
    ibm862: "cp862",
    csibm862: "cp862",
    cp863: {
      type: "_sbcs",
      chars: ""
    },
    ibm863: "cp863",
    csibm863: "cp863",
    cp864: {
      type: "_sbcs",
      chars: `\x00\x01\x02\x03\x04\x05\x06\x07\b	
\v\f\r\x0E\x0F\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1A\x1B\x1C\x1D\x1E\x1F !"#$&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_\`abcdefghijklmnopqrstuvwxyz{|}~`
    },
    ibm864: "cp864",
    csibm864: "cp864",
    cp865: {
      type: "_sbcs",
      chars: ""
    },
    ibm865: "cp865",
    csibm865: "cp865",
    cp866: {
      type: "_sbcs",
      chars: ""
    },
    ibm866: "cp866",
    csibm866: "cp866",
    cp869: {
      type: "_sbcs",
      chars: ""
    },
    ibm869: "cp869",
    csibm869: "cp869",
    cp922: {
      type: "_sbcs",
      chars: ""
    },
    ibm922: "cp922",
    csibm922: "cp922",
    cp1046: {
      type: "_sbcs",
      chars: ""
    },
    ibm1046: "cp1046",
    csibm1046: "cp1046",
    cp1124: {
      type: "_sbcs",
      chars: ""
    },
    ibm1124: "cp1124",
    csibm1124: "cp1124",
    cp1125: {
      type: "_sbcs",
      chars: ""
    },
    ibm1125: "cp1125",
    csibm1125: "cp1125",
    cp1129: {
      type: "_sbcs",
      chars: ""
    },
    ibm1129: "cp1129",
    csibm1129: "cp1129",
    cp1133: {
      type: "_sbcs",
      chars: ""
    },
    ibm1133: "cp1133",
    csibm1133: "cp1133",
    cp1161: {
      type: "_sbcs",
      chars: ""
    },
    ibm1161: "cp1161",
    csibm1161: "cp1161",
    cp1162: {
      type: "_sbcs",
      chars: ""
    },
    ibm1162: "cp1162",
    csibm1162: "cp1162",
    cp1163: {
      type: "_sbcs",
      chars: ""
    },
    ibm1163: "cp1163",
    csibm1163: "cp1163",
    maccroatian: {
      type: "_sbcs",
      chars: ""
    },
    maccyrillic: {
      type: "_sbcs",
      chars: ""
    },
    macgreek: {
      type: "_sbcs",
      chars: ""
    },
    maciceland: {
      type: "_sbcs",
      chars: ""
    },
    macroman: {
      type: "_sbcs",
      chars: ""
    },
    macromania: {
      type: "_sbcs",
      chars: ""
    },
    macthai: {
      type: "_sbcs",
      chars: "\uFEFF"
    },
    macturkish: {
      type: "_sbcs",
      chars: ""
    },
    macukraine: {
      type: "_sbcs",
      chars: ""
    },
    koi8r: {
      type: "_sbcs",
      chars: ""
    },
    koi8u: {
      type: "_sbcs",
      chars: ""
    },
    koi8ru: {
      type: "_sbcs",
      chars: ""
    },
    koi8t: {
      type: "_sbcs",
      chars: ""
    },
    armscii8: {
      type: "_sbcs",
      chars: ")(.,-"
    },
    rk1048: {
      type: "_sbcs",
      chars: ""
    },
    tcvn: {
      type: "_sbcs",
      chars: `\x00\x03\x07\b	
\v\f\r\x0E\x0F\x10\x18\x19\x1A\x1B\x1C\x1D\x1E\x1F !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_\`abcdefghijklmnopqrstuvwxyz{|}~`
    },
    georgianacademy: {
      type: "_sbcs",
      chars: ""
    },
    georgianps: {
      type: "_sbcs",
      chars: ""
    },
    pt154: {
      type: "_sbcs",
      chars: ""
    },
    viscii: {
      type: "_sbcs",
      chars: `\x00\x01\x03\x04\x07\b	
\v\f\r\x0E\x0F\x10\x11\x12\x13\x15\x16\x17\x18\x1A\x1B\x1C\x1D\x1F !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_\`abcdefghijklmnopqrstuvwxyz{|}~`
    },
    iso646cn: {
      type: "_sbcs",
      chars: `\x00\x01\x02\x03\x04\x05\x06\x07\b	
\v\f\r\x0E\x0F\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1A\x1B\x1C\x1D\x1E\x1F !"#%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_\`abcdefghijklmnopqrstuvwxyz{|}`
    },
    iso646jp: {
      type: "_sbcs",
      chars: `\x00\x01\x02\x03\x04\x05\x06\x07\b	
\v\f\r\x0E\x0F\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1A\x1B\x1C\x1D\x1E\x1F !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_\`abcdefghijklmnopqrstuvwxyz{|}`
    },
    hproman8: {
      type: "_sbcs",
      chars: ""
    },
    macintosh: {
      type: "_sbcs",
      chars: ""
    },
    ascii: {
      type: "_sbcs",
      chars: ""
    },
    tis620: {
      type: "_sbcs",
      chars: ""
    }
  };
});

// node_modules/iconv-lite/encodings/dbcs-codec.js
var require_dbcs_codec = __commonJS((exports) => {
  var Buffer2 = require_safer().Buffer;
  exports._dbcs = DBCSCodec;
  var UNASSIGNED = -1;
  var GB18030_CODE = -2;
  var SEQ_START = -10;
  var NODE_START = -1000;
  var UNASSIGNED_NODE = new Array(256);
  var DEF_CHAR = -1;
  for (i = 0;i < 256; i++)
    UNASSIGNED_NODE[i] = UNASSIGNED;
  var i;
  function DBCSCodec(codecOptions, iconv) {
    this.encodingName = codecOptions.encodingName;
    if (!codecOptions)
      throw new Error("DBCS codec is called without the data.");
    if (!codecOptions.table)
      throw new Error("Encoding '" + this.encodingName + "' has no data.");
    var mappingTable = codecOptions.table();
    this.decodeTables = [];
    this.decodeTables[0] = UNASSIGNED_NODE.slice(0);
    this.decodeTableSeq = [];
    for (var i2 = 0;i2 < mappingTable.length; i2++)
      this._addDecodeChunk(mappingTable[i2]);
    this.defaultCharUnicode = iconv.defaultCharUnicode;
    this.encodeTable = [];
    this.encodeTableSeq = [];
    var skipEncodeChars = {};
    if (codecOptions.encodeSkipVals)
      for (var i2 = 0;i2 < codecOptions.encodeSkipVals.length; i2++) {
        var val = codecOptions.encodeSkipVals[i2];
        if (typeof val === "number")
          skipEncodeChars[val] = true;
        else
          for (var j = val.from;j <= val.to; j++)
            skipEncodeChars[j] = true;
      }
    this._fillEncodeTable(0, 0, skipEncodeChars);
    if (codecOptions.encodeAdd) {
      for (var uChar in codecOptions.encodeAdd)
        if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar))
          this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
    }
    this.defCharSB = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];
    if (this.defCharSB === UNASSIGNED)
      this.defCharSB = this.encodeTable[0]["?"];
    if (this.defCharSB === UNASSIGNED)
      this.defCharSB = 63;
    if (typeof codecOptions.gb18030 === "function") {
      this.gb18030 = codecOptions.gb18030();
      var thirdByteNodeIdx = this.decodeTables.length;
      var thirdByteNode = this.decodeTables[thirdByteNodeIdx] = UNASSIGNED_NODE.slice(0);
      var fourthByteNodeIdx = this.decodeTables.length;
      var fourthByteNode = this.decodeTables[fourthByteNodeIdx] = UNASSIGNED_NODE.slice(0);
      for (var i2 = 129;i2 <= 254; i2++) {
        var secondByteNodeIdx = NODE_START - this.decodeTables[0][i2];
        var secondByteNode = this.decodeTables[secondByteNodeIdx];
        for (var j = 48;j <= 57; j++)
          secondByteNode[j] = NODE_START - thirdByteNodeIdx;
      }
      for (var i2 = 129;i2 <= 254; i2++)
        thirdByteNode[i2] = NODE_START - fourthByteNodeIdx;
      for (var i2 = 48;i2 <= 57; i2++)
        fourthByteNode[i2] = GB18030_CODE;
    }
  }
  DBCSCodec.prototype.encoder = DBCSEncoder;
  DBCSCodec.prototype.decoder = DBCSDecoder;
  DBCSCodec.prototype._getDecodeTrieNode = function(addr) {
    var bytes = [];
    for (;addr > 0; addr >>= 8)
      bytes.push(addr & 255);
    if (bytes.length == 0)
      bytes.push(0);
    var node = this.decodeTables[0];
    for (var i2 = bytes.length - 1;i2 > 0; i2--) {
      var val = node[bytes[i2]];
      if (val == UNASSIGNED) {
        node[bytes[i2]] = NODE_START - this.decodeTables.length;
        this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));
      } else if (val <= NODE_START) {
        node = this.decodeTables[NODE_START - val];
      } else
        throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
    }
    return node;
  };
  DBCSCodec.prototype._addDecodeChunk = function(chunk) {
    var curAddr = parseInt(chunk[0], 16);
    var writeTable = this._getDecodeTrieNode(curAddr);
    curAddr = curAddr & 255;
    for (var k = 1;k < chunk.length; k++) {
      var part = chunk[k];
      if (typeof part === "string") {
        for (var l = 0;l < part.length; ) {
          var code = part.charCodeAt(l++);
          if (55296 <= code && code < 56320) {
            var codeTrail = part.charCodeAt(l++);
            if (56320 <= codeTrail && codeTrail < 57344)
              writeTable[curAddr++] = 65536 + (code - 55296) * 1024 + (codeTrail - 56320);
            else
              throw new Error("Incorrect surrogate pair in " + this.encodingName + " at chunk " + chunk[0]);
          } else if (4080 < code && code <= 4095) {
            var len = 4095 - code + 2;
            var seq = [];
            for (var m = 0;m < len; m++)
              seq.push(part.charCodeAt(l++));
            writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
            this.decodeTableSeq.push(seq);
          } else
            writeTable[curAddr++] = code;
        }
      } else if (typeof part === "number") {
        var charCode = writeTable[curAddr - 1] + 1;
        for (var l = 0;l < part; l++)
          writeTable[curAddr++] = charCode++;
      } else
        throw new Error("Incorrect type '" + typeof part + "' given in " + this.encodingName + " at chunk " + chunk[0]);
    }
    if (curAddr > 255)
      throw new Error("Incorrect chunk in " + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
  };
  DBCSCodec.prototype._getEncodeBucket = function(uCode) {
    var high = uCode >> 8;
    if (this.encodeTable[high] === undefined)
      this.encodeTable[high] = UNASSIGNED_NODE.slice(0);
    return this.encodeTable[high];
  };
  DBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 255;
    if (bucket[low] <= SEQ_START)
      this.encodeTableSeq[SEQ_START - bucket[low]][DEF_CHAR] = dbcsCode;
    else if (bucket[low] == UNASSIGNED)
      bucket[low] = dbcsCode;
  };
  DBCSCodec.prototype._setEncodeSequence = function(seq, dbcsCode) {
    var uCode = seq[0];
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 255;
    var node;
    if (bucket[low] <= SEQ_START) {
      node = this.encodeTableSeq[SEQ_START - bucket[low]];
    } else {
      node = {};
      if (bucket[low] !== UNASSIGNED)
        node[DEF_CHAR] = bucket[low];
      bucket[low] = SEQ_START - this.encodeTableSeq.length;
      this.encodeTableSeq.push(node);
    }
    for (var j = 1;j < seq.length - 1; j++) {
      var oldVal = node[uCode];
      if (typeof oldVal === "object")
        node = oldVal;
      else {
        node = node[uCode] = {};
        if (oldVal !== undefined)
          node[DEF_CHAR] = oldVal;
      }
    }
    uCode = seq[seq.length - 1];
    node[uCode] = dbcsCode;
  };
  DBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {
    var node = this.decodeTables[nodeIdx];
    for (var i2 = 0;i2 < 256; i2++) {
      var uCode = node[i2];
      var mbCode = prefix + i2;
      if (skipEncodeChars[mbCode])
        continue;
      if (uCode >= 0)
        this._setEncodeChar(uCode, mbCode);
      else if (uCode <= NODE_START)
        this._fillEncodeTable(NODE_START - uCode, mbCode << 8, skipEncodeChars);
      else if (uCode <= SEQ_START)
        this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
    }
  };
  function DBCSEncoder(options, codec) {
    this.leadSurrogate = -1;
    this.seqObj = undefined;
    this.encodeTable = codec.encodeTable;
    this.encodeTableSeq = codec.encodeTableSeq;
    this.defaultCharSingleByte = codec.defCharSB;
    this.gb18030 = codec.gb18030;
  }
  DBCSEncoder.prototype.write = function(str) {
    var newBuf = Buffer2.alloc(str.length * (this.gb18030 ? 4 : 3)), leadSurrogate = this.leadSurrogate, seqObj = this.seqObj, nextChar = -1, i2 = 0, j = 0;
    while (true) {
      if (nextChar === -1) {
        if (i2 == str.length)
          break;
        var uCode = str.charCodeAt(i2++);
      } else {
        var uCode = nextChar;
        nextChar = -1;
      }
      if (55296 <= uCode && uCode < 57344) {
        if (uCode < 56320) {
          if (leadSurrogate === -1) {
            leadSurrogate = uCode;
            continue;
          } else {
            leadSurrogate = uCode;
            uCode = UNASSIGNED;
          }
        } else {
          if (leadSurrogate !== -1) {
            uCode = 65536 + (leadSurrogate - 55296) * 1024 + (uCode - 56320);
            leadSurrogate = -1;
          } else {
            uCode = UNASSIGNED;
          }
        }
      } else if (leadSurrogate !== -1) {
        nextChar = uCode;
        uCode = UNASSIGNED;
        leadSurrogate = -1;
      }
      var dbcsCode = UNASSIGNED;
      if (seqObj !== undefined && uCode != UNASSIGNED) {
        var resCode = seqObj[uCode];
        if (typeof resCode === "object") {
          seqObj = resCode;
          continue;
        } else if (typeof resCode == "number") {
          dbcsCode = resCode;
        } else if (resCode == undefined) {
          resCode = seqObj[DEF_CHAR];
          if (resCode !== undefined) {
            dbcsCode = resCode;
            nextChar = uCode;
          } else {}
        }
        seqObj = undefined;
      } else if (uCode >= 0) {
        var subtable = this.encodeTable[uCode >> 8];
        if (subtable !== undefined)
          dbcsCode = subtable[uCode & 255];
        if (dbcsCode <= SEQ_START) {
          seqObj = this.encodeTableSeq[SEQ_START - dbcsCode];
          continue;
        }
        if (dbcsCode == UNASSIGNED && this.gb18030) {
          var idx = findIdx(this.gb18030.uChars, uCode);
          if (idx != -1) {
            var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
            newBuf[j++] = 129 + Math.floor(dbcsCode / 12600);
            dbcsCode = dbcsCode % 12600;
            newBuf[j++] = 48 + Math.floor(dbcsCode / 1260);
            dbcsCode = dbcsCode % 1260;
            newBuf[j++] = 129 + Math.floor(dbcsCode / 10);
            dbcsCode = dbcsCode % 10;
            newBuf[j++] = 48 + dbcsCode;
            continue;
          }
        }
      }
      if (dbcsCode === UNASSIGNED)
        dbcsCode = this.defaultCharSingleByte;
      if (dbcsCode < 256) {
        newBuf[j++] = dbcsCode;
      } else if (dbcsCode < 65536) {
        newBuf[j++] = dbcsCode >> 8;
        newBuf[j++] = dbcsCode & 255;
      } else {
        newBuf[j++] = dbcsCode >> 16;
        newBuf[j++] = dbcsCode >> 8 & 255;
        newBuf[j++] = dbcsCode & 255;
      }
    }
    this.seqObj = seqObj;
    this.leadSurrogate = leadSurrogate;
    return newBuf.slice(0, j);
  };
  DBCSEncoder.prototype.end = function() {
    if (this.leadSurrogate === -1 && this.seqObj === undefined)
      return;
    var newBuf = Buffer2.alloc(10), j = 0;
    if (this.seqObj) {
      var dbcsCode = this.seqObj[DEF_CHAR];
      if (dbcsCode !== undefined) {
        if (dbcsCode < 256) {
          newBuf[j++] = dbcsCode;
        } else {
          newBuf[j++] = dbcsCode >> 8;
          newBuf[j++] = dbcsCode & 255;
        }
      } else {}
      this.seqObj = undefined;
    }
    if (this.leadSurrogate !== -1) {
      newBuf[j++] = this.defaultCharSingleByte;
      this.leadSurrogate = -1;
    }
    return newBuf.slice(0, j);
  };
  DBCSEncoder.prototype.findIdx = findIdx;
  function DBCSDecoder(options, codec) {
    this.nodeIdx = 0;
    this.prevBuf = Buffer2.alloc(0);
    this.decodeTables = codec.decodeTables;
    this.decodeTableSeq = codec.decodeTableSeq;
    this.defaultCharUnicode = codec.defaultCharUnicode;
    this.gb18030 = codec.gb18030;
  }
  DBCSDecoder.prototype.write = function(buf) {
    var newBuf = Buffer2.alloc(buf.length * 2), nodeIdx = this.nodeIdx, prevBuf = this.prevBuf, prevBufOffset = this.prevBuf.length, seqStart = -this.prevBuf.length, uCode;
    if (prevBufOffset > 0)
      prevBuf = Buffer2.concat([prevBuf, buf.slice(0, 10)]);
    for (var i2 = 0, j = 0;i2 < buf.length; i2++) {
      var curByte = i2 >= 0 ? buf[i2] : prevBuf[i2 + prevBufOffset];
      var uCode = this.decodeTables[nodeIdx][curByte];
      if (uCode >= 0) {} else if (uCode === UNASSIGNED) {
        i2 = seqStart;
        uCode = this.defaultCharUnicode.charCodeAt(0);
      } else if (uCode === GB18030_CODE) {
        var curSeq = seqStart >= 0 ? buf.slice(seqStart, i2 + 1) : prevBuf.slice(seqStart + prevBufOffset, i2 + 1 + prevBufOffset);
        var ptr = (curSeq[0] - 129) * 12600 + (curSeq[1] - 48) * 1260 + (curSeq[2] - 129) * 10 + (curSeq[3] - 48);
        var idx = findIdx(this.gb18030.gbChars, ptr);
        uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
      } else if (uCode <= NODE_START) {
        nodeIdx = NODE_START - uCode;
        continue;
      } else if (uCode <= SEQ_START) {
        var seq = this.decodeTableSeq[SEQ_START - uCode];
        for (var k = 0;k < seq.length - 1; k++) {
          uCode = seq[k];
          newBuf[j++] = uCode & 255;
          newBuf[j++] = uCode >> 8;
        }
        uCode = seq[seq.length - 1];
      } else
        throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);
      if (uCode > 65535) {
        uCode -= 65536;
        var uCodeLead = 55296 + Math.floor(uCode / 1024);
        newBuf[j++] = uCodeLead & 255;
        newBuf[j++] = uCodeLead >> 8;
        uCode = 56320 + uCode % 1024;
      }
      newBuf[j++] = uCode & 255;
      newBuf[j++] = uCode >> 8;
      nodeIdx = 0;
      seqStart = i2 + 1;
    }
    this.nodeIdx = nodeIdx;
    this.prevBuf = seqStart >= 0 ? buf.slice(seqStart) : prevBuf.slice(seqStart + prevBufOffset);
    return newBuf.slice(0, j).toString("ucs2");
  };
  DBCSDecoder.prototype.end = function() {
    var ret = "";
    while (this.prevBuf.length > 0) {
      ret += this.defaultCharUnicode;
      var buf = this.prevBuf.slice(1);
      this.prevBuf = Buffer2.alloc(0);
      this.nodeIdx = 0;
      if (buf.length > 0)
        ret += this.write(buf);
    }
    this.nodeIdx = 0;
    return ret;
  };
  function findIdx(table, val) {
    if (table[0] > val)
      return -1;
    var l = 0, r = table.length;
    while (l < r - 1) {
      var mid = l + Math.floor((r - l + 1) / 2);
      if (table[mid] <= val)
        l = mid;
      else
        r = mid;
    }
    return l;
  }
});

// node_modules/iconv-lite/encodings/tables/shiftjis.json
var require_shiftjis = __commonJS((exports, module) => {
  module.exports = [
    ["0", "\x00", 128],
    ["a1", "", 62],
    ["8140", "", 9, ""],
    ["8180", ""],
    ["81b8", ""],
    ["81c8", ""],
    ["81da", ""],
    ["81f0", ""],
    ["81fc", ""],
    ["824f", "", 9],
    ["8260", "", 25],
    ["8281", "", 25],
    ["829f", "", 82],
    ["8340", "", 62],
    ["8380", "", 22],
    ["839f", "", 16, "", 6],
    ["83bf", "", 16, "", 6],
    ["8440", "", 5, "", 25],
    ["8470", "", 5, "", 7],
    ["8480", "", 17],
    ["849f", ""],
    ["8740", "", 19, "", 9],
    ["875f", ""],
    ["877e", ""],
    ["8780", "", 4, ""],
    ["889f", ""],
    ["8940", ""],
    ["8980", ""],
    ["8a40", ""],
    ["8a80", ""],
    ["8b40", ""],
    ["8b80", ""],
    ["8c40", ""],
    ["8c80", ""],
    ["8d40", ""],
    ["8d80", ""],
    ["8e40", ""],
    ["8e80", ""],
    ["8f40", ""],
    ["8f80", ""],
    ["9040", ""],
    ["9080", ""],
    ["9140", ""],
    ["9180", ""],
    ["9240", ""],
    ["9280", ""],
    ["9340", ""],
    ["9380", ""],
    ["9440", ""],
    ["9480", ""],
    ["9540", ""],
    ["9580", ""],
    ["9640", ""],
    ["9680", ""],
    ["9740", ""],
    ["9780", ""],
    ["9840", ""],
    ["989f", ""],
    ["9940", ""],
    ["9980", ""],
    ["9a40", ""],
    ["9a80", ""],
    ["9b40", ""],
    ["9b80", ""],
    ["9c40", ""],
    ["9c80", ""],
    ["9d40", ""],
    ["9d80", ""],
    ["9e40", ""],
    ["9e80", ""],
    ["9f40", ""],
    ["9f80", ""],
    ["e040", ""],
    ["e080", ""],
    ["e140", ""],
    ["e180", ""],
    ["e240", ""],
    ["e280", ""],
    ["e340", ""],
    ["e380", ""],
    ["e440", ""],
    ["e480", ""],
    ["e540", ""],
    ["e580", ""],
    ["e640", ""],
    ["e680", ""],
    ["e740", ""],
    ["e780", ""],
    ["e840", ""],
    ["e880", ""],
    ["e940", ""],
    ["e980", ""],
    ["ea40", ""],
    ["ea80", ""],
    ["ed40", ""],
    ["ed80", ""],
    ["ee40", ""],
    ["ee80", ""],
    ["eeef", "", 9, ""],
    ["f040", "", 62],
    ["f080", "", 124],
    ["f140", "", 62],
    ["f180", "", 124],
    ["f240", "", 62],
    ["f280", "", 124],
    ["f340", "", 62],
    ["f380", "", 124],
    ["f440", "", 62],
    ["f480", "", 124],
    ["f540", "", 62],
    ["f580", "", 124],
    ["f640", "", 62],
    ["f680", "", 124],
    ["f740", "", 62],
    ["f780", "", 124],
    ["f840", "", 62],
    ["f880", "", 124],
    ["f940", ""],
    ["fa40", "", 9, "", 9, ""],
    ["fa80", ""],
    ["fb40", ""],
    ["fb80", ""],
    ["fc40", ""]
  ];
});

// node_modules/iconv-lite/encodings/tables/eucjp.json
var require_eucjp = __commonJS((exports, module) => {
  module.exports = [
    ["0", "\x00", 127],
    ["8ea1", "", 62],
    ["a1a1", "", 9, ""],
    ["a2a1", ""],
    ["a2ba", ""],
    ["a2ca", ""],
    ["a2dc", ""],
    ["a2f2", ""],
    ["a2fe", ""],
    ["a3b0", "", 9],
    ["a3c1", "", 25],
    ["a3e1", "", 25],
    ["a4a1", "", 82],
    ["a5a1", "", 85],
    ["a6a1", "", 16, "", 6],
    ["a6c1", "", 16, "", 6],
    ["a7a1", "", 5, "", 25],
    ["a7d1", "", 5, "", 25],
    ["a8a1", ""],
    ["ada1", "", 19, "", 9],
    ["adc0", ""],
    ["addf", "", 4, ""],
    ["b0a1", ""],
    ["b1a1", ""],
    ["b2a1", ""],
    ["b3a1", ""],
    ["b4a1", ""],
    ["b5a1", ""],
    ["b6a1", ""],
    ["b7a1", ""],
    ["b8a1", ""],
    ["b9a1", ""],
    ["baa1", ""],
    ["bba1", ""],
    ["bca1", ""],
    ["bda1", ""],
    ["bea1", ""],
    ["bfa1", ""],
    ["c0a1", ""],
    ["c1a1", ""],
    ["c2a1", ""],
    ["c3a1", ""],
    ["c4a1", ""],
    ["c5a1", ""],
    ["c6a1", ""],
    ["c7a1", ""],
    ["c8a1", ""],
    ["c9a1", ""],
    ["caa1", ""],
    ["cba1", ""],
    ["cca1", ""],
    ["cda1", ""],
    ["cea1", ""],
    ["cfa1", ""],
    ["d0a1", ""],
    ["d1a1", ""],
    ["d2a1", ""],
    ["d3a1", ""],
    ["d4a1", ""],
    ["d5a1", ""],
    ["d6a1", ""],
    ["d7a1", ""],
    ["d8a1", ""],
    ["d9a1", ""],
    ["daa1", ""],
    ["dba1", ""],
    ["dca1", ""],
    ["dda1", ""],
    ["dea1", ""],
    ["dfa1", ""],
    ["e0a1", ""],
    ["e1a1", ""],
    ["e2a1", ""],
    ["e3a1", ""],
    ["e4a1", ""],
    ["e5a1", ""],
    ["e6a1", ""],
    ["e7a1", ""],
    ["e8a1", ""],
    ["e9a1", ""],
    ["eaa1", ""],
    ["eba1", ""],
    ["eca1", ""],
    ["eda1", ""],
    ["eea1", ""],
    ["efa1", ""],
    ["f0a1", ""],
    ["f1a1", ""],
    ["f2a1", ""],
    ["f3a1", ""],
    ["f4a1", ""],
    ["f9a1", ""],
    ["faa1", ""],
    ["fba1", ""],
    ["fca1", ""],
    ["fcf1", "", 9, ""],
    ["8fa2af", ""],
    ["8fa2c2", ""],
    ["8fa2eb", ""],
    ["8fa6e1", ""],
    ["8fa6e7", ""],
    ["8fa6e9", ""],
    ["8fa6ec", ""],
    ["8fa6f1", ""],
    ["8fa7c2", "", 10, ""],
    ["8fa7f2", "", 10, ""],
    ["8fa9a1", ""],
    ["8fa9a4", ""],
    ["8fa9a6", ""],
    ["8fa9a8", ""],
    ["8fa9ab", ""],
    ["8fa9af", ""],
    ["8fa9c1", ""],
    ["8faaa1", ""],
    ["8faaba", ""],
    ["8faba1", ""],
    ["8fabbd", ""],
    ["8fabc5", ""],
    ["8fb0a1", ""],
    ["8fb1a1", ""],
    ["8fb2a1", "", 4, ""],
    ["8fb3a1", ""],
    ["8fb4a1", ""],
    ["8fb5a1", ""],
    ["8fb6a1", "", 5, "", 4, ""],
    ["8fb7a1", "", 4, ""],
    ["8fb8a1", ""],
    ["8fb9a1", ""],
    ["8fbaa1", "", 4, ""],
    ["8fbba1", ""],
    ["8fbca1", "", 4, ""],
    ["8fbda1", "", 4, ""],
    ["8fbea1", "", 4, ""],
    ["8fbfa1", ""],
    ["8fc0a1", ""],
    ["8fc1a1", ""],
    ["8fc2a1", ""],
    ["8fc3a1", "", 4, ""],
    ["8fc4a1", ""],
    ["8fc5a1", ""],
    ["8fc6a1", ""],
    ["8fc7a1", ""],
    ["8fc8a1", ""],
    ["8fc9a1", "", 4, "", 4, ""],
    ["8fcaa1", ""],
    ["8fcba1", ""],
    ["8fcca1", "", 9, ""],
    ["8fcda1", "", 5, ""],
    ["8fcea1", "", 6, ""],
    ["8fcfa1", ""],
    ["8fd0a1", ""],
    ["8fd1a1", ""],
    ["8fd2a1", "", 5],
    ["8fd3a1", ""],
    ["8fd4a1", "", 4, ""],
    ["8fd5a1", ""],
    ["8fd6a1", ""],
    ["8fd7a1", ""],
    ["8fd8a1", ""],
    ["8fd9a1", "", 4, "", 6, ""],
    ["8fdaa1", "", 4, ""],
    ["8fdba1", "", 6, ""],
    ["8fdca1", "", 4, ""],
    ["8fdda1", "", 4, ""],
    ["8fdea1", "", 4, ""],
    ["8fdfa1", ""],
    ["8fe0a1", ""],
    ["8fe1a1", "", 4, ""],
    ["8fe2a1", ""],
    ["8fe3a1", "", 5, "", 4, ""],
    ["8fe4a1", "", 4, ""],
    ["8fe5a1", "", 4, ""],
    ["8fe6a1", ""],
    ["8fe7a1", ""],
    ["8fe8a1", "", 4, ""],
    ["8fe9a1", "", 4],
    ["8feaa1", "", 4, ""],
    ["8feba1", "", 4, ""],
    ["8feca1", ""],
    ["8feda1", "", 4, "", 4, ""]
  ];
});

// node_modules/iconv-lite/encodings/tables/cp936.json
var require_cp936 = __commonJS((exports, module) => {
  module.exports = [
    ["0", "\x00", 127, ""],
    ["8140", "", 5, "", 9, "", 6, ""],
    ["8180", "", 6, "", 4, "", 4, "", 5, ""],
    ["8240", "", 4, "", 8, "", 4, "", 11],
    ["8280", "", 10, "", 4, "", 7, "", 5, "", 8, "", 20, "", 4, "", 6, ""],
    ["8340", "", 17, "", 5, "", 10, "", 4, "", 9, ""],
    ["8380", "", 5, "", 13, "", 28, "", 4, "", 4, "", 5],
    ["8440", "", 5, "", 5, ""],
    ["8480", "", 9, "", 4, "", 6, "", 6, "", 9, "", 5, "", 10, "", 7, ""],
    ["8540", "", 9, ""],
    ["8580", "", 4, "", 6, "", 4, "", 4, "", 7, ""],
    ["8640", "", 4, "", 5, "", 4, "", 5, ""],
    ["8680", "", 4, "", 4, "", 5, "", 6, "", 8, "", 4, "", 4, "", 4, ""],
    ["8740", "", 7, "", 11, "", 4, "", 4],
    ["8780", "", 7, "", 6, "", 14, "", 10, "", 6, "", 12, "", 8, "", 5, "", 6],
    ["8840", "", 9, "", 4, "", 4, ""],
    ["8880", "", 4, "", 6, "", 8, "", 6, "", 7, "", 4, "", 4, "", 7],
    ["8940", "", 5, "", 6, "", 4, "", 5, "", 4, "", 16, ""],
    ["8980", "", 4, "", 4, "", 7, "", 17, "", 10, "", 13, "", 5, "", 7, "", 4, ""],
    ["8a40", "", 4, "", 12, ""],
    ["8a80", "", 5, "", 6, "", 4, "", 11, "", 6, "", 4, "", 4, "", 9, "", 5],
    ["8b40", "", 8, "", 17, "", 6, "", 13, ""],
    ["8b80", "", 4, "", 4, "", 5, "", 4, "", 4, "", 22, "", 11, "", 25, "", 7, "", 6],
    ["8c40", "", 7, ""],
    ["8c80", "", 8, "", 4, "", 6, "", 6, "", 6, "", 4, "", 4, "", 4],
    ["8d40", "", 5, "", 5, "", 5, "", 6, "", 9, "", 4],
    ["8d80", "", 5, "", 4, "", 4, "", 4, "", 7, "", 7, "", 10, "", 10, "", 12, "", 21, ""],
    ["8e40", "", 21, "", 12, "", 6, "", 12, ""],
    ["8e80", "", 4, "", 7, "", 4, "", 4, "", 5, "", 6, "", 4, "", 14, "", 4, "", 4, "", 6],
    ["8f40", "", 5, "", 11, "", 8, ""],
    ["8f80", "", 6, "", 14, "", 5, "", 5, "", 4, ""],
    ["9040", "", 4, "", 4, "", 6, ""],
    ["9080", "", 7, "", 4, "", 4, "", 4, "", 4, "", 18, "", 6],
    ["9140", "", 6, "", 6, "", 18, "", 4, ""],
    ["9180", "", 6, "", 8, "", 9, "", 5, "", 4, "", 4, "", 16, "", 13, "", 8, "", 5, "", 4, ""],
    ["9240", "", 6, "", 5, ""],
    ["9280", "", 5, "", 7, "", 6, ""],
    ["9340", "", 6, "", 4, "", 4, "", 5, ""],
    ["9380", "", 5, "", 4, "", 6, "", 4, "", 7, "", 9, "", 6, "", 8, "", 4, "", 6, ""],
    ["9440", "", 24, "", 7, "", 7, "", 4, "", 8],
    ["9480", "", 4, "", 4, "", 14, "", 7, "", 7, ""],
    ["9540", "", 4, "", 4, "", 6, ""],
    ["9580", "", 4, "", 4, "", 8, "", 4, "", 4, "", 25, "", 7, "", 5, ""],
    ["9640", "", 5, "", 4, ""],
    ["9680", "", 7, "", 9, "", 7, "", 4, "", 6, "", 6, "", 5],
    ["9740", "", 7, "", 8, "", 7, "", 9, ""],
    ["9780", "", 6, "", 5, "", 4, "", 9, "", 4, "", 11, "", 7, "", 16, ""],
    ["9840", "", 4, "", 5, "", 9, ""],
    ["9880", "", 7, "", 5, "", 11, "", 9, "", 9, "", 11, "", 5, "", 5, "", 6, "", 4, "", 7, "", 6, ""],
    ["9940", "", 4, "", 10, "", 6, "", 8, "", 4, "", 7, "", 5],
    ["9980", "", 114, "", 6],
    ["9a40", "", 11, "", 7, "", 13, ""],
    ["9a80", "", 4, "", 7, "", 7, "", 6, "", 4, "", 4, "", 7, "", 6, "", 4, "", 4, ""],
    ["9b40", "", 4, ""],
    ["9b80", "", 5, "", 4, "", 4, "", 5, ""],
    ["9c40", "", 7, ""],
    ["9c80", "", 7, "", 7, "", 10, "", 14, "", 4, "", 6, "", 5],
    ["9d40", "", 7, "", 4, "", 9, "", 6, ""],
    ["9d80", "", 9, "", 5, "", 6, "", 12, "", 4, "", 10, "", 5, "", 5, "", 6, "", 10, ""],
    ["9e40", "", 7, "", 32, "", 7, "", 6, "", 6],
    ["9e80", "", 9, "", 17, "", 13, "", 11, "", 12, "", 12, ""],
    ["9f40", "", 6, "", 10, "", 4, "", 10, "", 7, ""],
    ["9f80", "", 13, "", 12, "", 4, "", 4, "", 5, "", 4, "", 4, "", 6, "", 5, "", 8, "", 9, "", 4],
    ["a040", "", 9, "", 5, "", 9, "", 11, "", 19],
    ["a080", "", 9, "", 6, "", 4, "", 11, "", 11, "", 6, ""],
    ["a1a1", "", 7, ""],
    ["a2a1", "", 9],
    ["a2b1", "", 19, "", 19, "", 9],
    ["a2e5", "", 9],
    ["a2f1", "", 11],
    ["a3a1", "", 88, ""],
    ["a4a1", "", 82],
    ["a5a1", "", 85],
    ["a6a1", "", 16, "", 6],
    ["a6c1", "", 16, "", 6],
    ["a6e0", ""],
    ["a6ee", ""],
    ["a6f4", ""],
    ["a7a1", "", 5, "", 25],
    ["a7d1", "", 5, "", 25],
    ["a840", "", 35, "", 6],
    ["a880", "", 7, ""],
    ["a8a1", ""],
    ["a8bd", ""],
    ["a8c0", ""],
    ["a8c5", "", 36],
    ["a940", "", 8, ""],
    ["a959", ""],
    ["a95c", ""],
    ["a960", "", 9, "", 8],
    ["a980", "", 4, ""],
    ["a996", ""],
    ["a9a4", "", 75],
    ["aa40", "", 5, "", 5, "", 8],
    ["aa80", "", 7, "", 10, ""],
    ["ab40", "", 11, "", 4, "", 5, "", 4],
    ["ab80", "", 6, "", 4],
    ["ac40", "", 10, "", 8, "", 5, "", 4, "", 11],
    ["ac80", "", 6, "", 12, "", 4, ""],
    ["ad40", "", 10, "", 7, "", 15, "", 12],
    ["ad80", "", 9, "", 8, "", 6, ""],
    ["ae40", "", 6, "", 7, "", 4, ""],
    ["ae80", "", 7, "", 6, "", 4, ""],
    ["af40", "", 4, ""],
    ["af80", ""],
    ["b040", "", 6, "", 5, "", 4, "", 6, "", 7, ""],
    ["b080", "", 7, "", 8, "", 9, ""],
    ["b140", "", 4, "", 7, "", 10, ""],
    ["b180", "", 4, "", 7, "", 7, ""],
    ["b240", "", 11, "", 5, "", 11, "", 4],
    ["b280", "", 12, "", 8, "", 4, ""],
    ["b340", "", 5, ""],
    ["b380", "", 11, "", 7, "", 6, ""],
    ["b440", "", 7, "", 9],
    ["b480", "", 4, "", 5, "", 6, ""],
    ["b540", "", 5, "", 9, "", 4, "", 14, "", 4, "", 8, ""],
    ["b580", "", 6, "", 4, ""],
    ["b640", "", 6, "", 11, "", 10, "", 4, "", 5, ""],
    ["b680", "", 6, "", 4, ""],
    ["b740", "", 14, "", 5, "", 9, "", 4, "", 16],
    ["b780", "", 6, ""],
    ["b840", "", 4, "", 10, "", 10, "", 9, "", 5, ""],
    ["b880", "", 4, ""],
    ["b940", "", 5, "", 10, "", 6, ""],
    ["b980", "", 7, ""],
    ["ba40", "", 4, "", 4, "", 7, "", 5, ""],
    ["ba80", "", 4, "", 5, "", 12, "", 5, ""],
    ["bb40", "", 9, "", 36, "", 5, "", 9],
    ["bb80", "", 6, "", 4, ""],
    ["bc40", "", 6, "", 6, "", 5, "", 7, "", 13, "", 5],
    ["bc80", "", 14, "", 6, ""],
    ["bd40", "", 54, "", 7],
    ["bd80", "", 32, ""],
    ["be40", "", 12, "", 6, "", 42],
    ["be80", "", 32, ""],
    ["bf40", "", 62],
    ["bf80", "", 4, "", 4, "", 21, ""],
    ["c040", "", 35, "", 23, ""],
    ["c080", "", 6, "", 9, ""],
    ["c140", "", 4, "", 7, "", 4, "", 4, "", 6, ""],
    ["c180", "", 4, "", 4, "", 5, ""],
    ["c240", "", 6, "", 5, ""],
    ["c280", "", 13, "", 5, "", 11, ""],
    ["c340", "", 5, "", 4, "", 6, ""],
    ["c380", "", 12, "", 4, ""],
    ["c440", "", 5, "", 4, "", 4, "", 5, "", 4, ""],
    ["c480", "", 7, "", 5, "", 6, ""],
    ["c540", "", 14, "", 4, "", 5, "", 4, "", 5, ""],
    ["c580", "", 7, "", 7, ""],
    ["c640", ""],
    ["c680", "", 4, "", 9, ""],
    ["c740", "", 4, "", 4, "", 6, "", 6, "", 6, ""],
    ["c780", ""],
    ["c840", "", 4, "", 5, "", 5, "", 7, "", 5, "", 7, ""],
    ["c880", "", 6, "", 4, "", 4, ""],
    ["c940", "", 4, "", 7, "", 12, ""],
    ["c980", "", 4, "", 4, "", 10, ""],
    ["ca40", "", 8, "", 8, "", 9, "", 4, "", 10],
    ["ca80", "", 4, "", 8, ""],
    ["cb40", "", 6, "", 10, "", 6, "", 5, "", 6, "", 6, "", 4, ""],
    ["cb80", "", 5, "", 6, "", 14, ""],
    ["cc40", "", 4, "", 10, "", 15, "", 13, ""],
    ["cc80", "", 11, "", 4, "", 7, ""],
    ["cd40", "", 6, "", 6, "", 4, "", 5, "", 4, "", 4, ""],
    ["cd80", ""],
    ["ce40", "", 6, "", 5, "", 7, ""],
    ["ce80", "", 4, "", 6, "", 4, ""],
    ["cf40", "", 4, "", 4, "", 6, "", 9],
    ["cf80", "", 5, "", 7, "", 4, ""],
    ["d040", "", 13, "", 5, "", 5, "", 5, "", 6, ""],
    ["d080", "", 4, "", 4, "", 5, ""],
    ["d140", "", 4, "", 4, "", 6, "", 5],
    ["d180", "", 4, "", 4, "", 4, ""],
    ["d240", "", 8, "", 24, "", 5, "", 19, ""],
    ["d280", "", 26, ""],
    ["d340", "", 30, "", 6],
    ["d380", "", 4, "", 5, "", 21, ""],
    ["d440", "", 31, "", 8, "", 21],
    ["d480", "", 25, "", 6, ""],
    ["d540", "", 7, "", 7, "", 46],
    ["d580", "", 32, ""],
    ["d640", "", 34, "", 27],
    ["d680", "", 30, ""],
    ["d740", "", 31, "", 4, "", 25],
    ["d780", "", 24, ""],
    ["d840", "", 8, "", 7, "", 5, "", 6, "", 6, "", 6, ""],
    ["d880", "", 6, "", 20, ""],
    ["d940", "", 62],
    ["d980", "", 32, ""],
    ["da40", "", 14, "", 8, "", 4, "", 9, ""],
    ["da80", "", 12, ""],
    ["db40", "", 6, "", 7, "", 4, ""],
    ["db80", "", 4, "", 5, "", 11, ""],
    ["dc40", "", 4, "", 6, "", 6, "", 11, "", 6, "", 7],
    ["dc80", "", 10, "", 21, ""],
    ["dd40", "", 62],
    ["dd80", "", 32, ""],
    ["de40", "", 32, ""],
    ["de80", "", 4, ""],
    ["df40", "", 5, "", 4, "", 4, "", 5, "", 4, "", 6, ""],
    ["df80", "", 4, ""],
    ["e040", "", 19, ""],
    ["e080", "", 10, "", 6, "", 8, ""],
    ["e140", "", 4, "", 6, "", 5, "", 5, ""],
    ["e180", "", 10, "", 9, "", 8, ""],
    ["e240", "", 62],
    ["e280", "", 32, "", 5, ""],
    ["e340", "", 45, "", 16],
    ["e380", "", 7, "", 24, ""],
    ["e440", "", 5, "", 24, "", 31],
    ["e480", "", 32, ""],
    ["e540", "", 51, "", 10],
    ["e580", "", 31, ""],
    ["e640", "", 34, "", 27],
    ["e680", "", 29, ""],
    ["e740", "", 7, "", 54],
    ["e780", "", 32, "", 6, "", 4, ""],
    ["e840", "", 14, "", 43, ""],
    ["e880", "", 20, ""],
    ["e940", "", 7, "", 42],
    ["e980", "", 32, ""],
    ["ea40", "", 27, "", 6, ""],
    ["ea80", "", 4, "", 12, ""],
    ["eb40", "", 9, "", 7, "", 9, "", 6, ""],
    ["eb80", "", 4, ""],
    ["ec40", "", 8, "", 4, "", 18, "", 7],
    ["ec80", "", 4, "", 7, "", 4, "", 4, ""],
    ["ed40", "", 6, "", 46],
    ["ed80", "", 4, "", 23, ""],
    ["ee40", "", 62],
    ["ee80", "", 32, "", 4, "", 6, ""],
    ["ef40", "", 5, "", 37, "", 4],
    ["ef80", "", 30, "", 4, "", 8, ""],
    ["f040", "", 4, "", 28, "", 26],
    ["f080", "", 9, "", 12, "", 4, "", 6, ""],
    ["f140", "", 10, "", 47],
    ["f180", "", 32, ""],
    ["f240", "", 62],
    ["f280", "", 32, ""],
    ["f340", "", 17, "", 6, "", 4, ""],
    ["f380", "", 8, "", 6, ""],
    ["f440", "", 5, "", 10, "", 10, "", 7, "", 5],
    ["f480", "", 32, ""],
    ["f540", "", 62],
    ["f580", "", 32, ""],
    ["f640", "", 62],
    ["f680", "", 32, "", 5, "", 5, "", 4, "", 7, ""],
    ["f740", "", 62],
    ["f780", "", 4, "", 4, ""],
    ["f840", "", 62],
    ["f880", "", 32],
    ["f940", "", 62],
    ["f980", "", 32],
    ["fa40", "", 62],
    ["fa80", "", 32],
    ["fb40", "", 27, "", 9, ""],
    ["fb80", "", 5, "", 8, "", 5, ""],
    ["fc40", "", 8, "", 4, "", 8, "", 6],
    ["fc80", "", 4, "", 5, "", 8, ""],
    ["fd40", "", 4, "", 4, "", 10, "", 38],
    ["fd80", "", 5, "", 11, "", 4, ""],
    ["fe40", ""]
  ];
});

// node_modules/iconv-lite/encodings/tables/gbk-added.json
var require_gbk_added = __commonJS((exports, module) => {
  module.exports = [
    ["a140", "", 62],
    ["a180", "", 32],
    ["a240", "", 62],
    ["a280", "", 32],
    ["a2ab", "", 5],
    ["a2e3", ""],
    ["a2ef", ""],
    ["a2fd", ""],
    ["a340", "", 62],
    ["a380", "", 31, ""],
    ["a440", "", 62],
    ["a480", "", 32],
    ["a4f4", "", 10],
    ["a540", "", 62],
    ["a580", "", 32],
    ["a5f7", "", 7],
    ["a640", "", 62],
    ["a680", "", 32],
    ["a6b9", "", 7],
    ["a6d9", "", 6],
    ["a6ec", ""],
    ["a6f3", ""],
    ["a6f6", "", 8],
    ["a740", "", 62],
    ["a780", "", 32],
    ["a7c2", "", 14],
    ["a7f2", "", 12],
    ["a896", "", 10],
    ["a8bc", ""],
    ["a8bf", ""],
    ["a8c1", ""],
    ["a8ea", "", 20],
    ["a958", ""],
    ["a95b", ""],
    ["a95d", ""],
    ["a989", "", 11],
    ["a997", "", 12],
    ["a9f0", "", 14],
    ["aaa1", "", 93],
    ["aba1", "", 93],
    ["aca1", "", 93],
    ["ada1", "", 93],
    ["aea1", "", 93],
    ["afa1", "", 93],
    ["d7fa", "", 4],
    ["f8a1", "", 93],
    ["f9a1", "", 93],
    ["faa1", "", 93],
    ["fba1", "", 93],
    ["fca1", "", 93],
    ["fda1", "", 93],
    ["fe50", ""],
    ["fe80", "", 6, "", 93]
  ];
});

// node_modules/iconv-lite/encodings/tables/gb18030-ranges.json
var require_gb18030_ranges = __commonJS((exports, module) => {
  module.exports = { uChars: [128, 165, 169, 178, 184, 216, 226, 235, 238, 244, 248, 251, 253, 258, 276, 284, 300, 325, 329, 334, 364, 463, 465, 467, 469, 471, 473, 475, 477, 506, 594, 610, 712, 716, 730, 930, 938, 962, 970, 1026, 1104, 1106, 8209, 8215, 8218, 8222, 8231, 8241, 8244, 8246, 8252, 8365, 8452, 8454, 8458, 8471, 8482, 8556, 8570, 8596, 8602, 8713, 8720, 8722, 8726, 8731, 8737, 8740, 8742, 8748, 8751, 8760, 8766, 8777, 8781, 8787, 8802, 8808, 8816, 8854, 8858, 8870, 8896, 8979, 9322, 9372, 9548, 9588, 9616, 9622, 9634, 9652, 9662, 9672, 9676, 9680, 9702, 9735, 9738, 9793, 9795, 11906, 11909, 11913, 11917, 11928, 11944, 11947, 11951, 11956, 11960, 11964, 11979, 12284, 12292, 12312, 12319, 12330, 12351, 12436, 12447, 12535, 12543, 12586, 12842, 12850, 12964, 13200, 13215, 13218, 13253, 13263, 13267, 13270, 13384, 13428, 13727, 13839, 13851, 14617, 14703, 14801, 14816, 14964, 15183, 15471, 15585, 16471, 16736, 17208, 17325, 17330, 17374, 17623, 17997, 18018, 18212, 18218, 18301, 18318, 18760, 18811, 18814, 18820, 18823, 18844, 18848, 18872, 19576, 19620, 19738, 19887, 40870, 59244, 59336, 59367, 59413, 59417, 59423, 59431, 59437, 59443, 59452, 59460, 59478, 59493, 63789, 63866, 63894, 63976, 63986, 64016, 64018, 64021, 64025, 64034, 64037, 64042, 65074, 65093, 65107, 65112, 65127, 65132, 65375, 65510, 65536], gbChars: [0, 36, 38, 45, 50, 81, 89, 95, 96, 100, 103, 104, 105, 109, 126, 133, 148, 172, 175, 179, 208, 306, 307, 308, 309, 310, 311, 312, 313, 341, 428, 443, 544, 545, 558, 741, 742, 749, 750, 805, 819, 820, 7922, 7924, 7925, 7927, 7934, 7943, 7944, 7945, 7950, 8062, 8148, 8149, 8152, 8164, 8174, 8236, 8240, 8262, 8264, 8374, 8380, 8381, 8384, 8388, 8390, 8392, 8393, 8394, 8396, 8401, 8406, 8416, 8419, 8424, 8437, 8439, 8445, 8482, 8485, 8496, 8521, 8603, 8936, 8946, 9046, 9050, 9063, 9066, 9076, 9092, 9100, 9108, 9111, 9113, 9131, 9162, 9164, 9218, 9219, 11329, 11331, 11334, 11336, 11346, 11361, 11363, 11366, 11370, 11372, 11375, 11389, 11682, 11686, 11687, 11692, 11694, 11714, 11716, 11723, 11725, 11730, 11736, 11982, 11989, 12102, 12336, 12348, 12350, 12384, 12393, 12395, 12397, 12510, 12553, 12851, 12962, 12973, 13738, 13823, 13919, 13933, 14080, 14298, 14585, 14698, 15583, 15847, 16318, 16434, 16438, 16481, 16729, 17102, 17122, 17315, 17320, 17402, 17418, 17859, 17909, 17911, 17915, 17916, 17936, 17939, 17961, 18664, 18703, 18814, 18962, 19043, 33469, 33470, 33471, 33484, 33485, 33490, 33497, 33501, 33505, 33513, 33520, 33536, 33550, 37845, 37921, 37948, 38029, 38038, 38064, 38065, 38066, 38069, 38075, 38076, 38078, 39108, 39109, 39113, 39114, 39115, 39116, 39265, 39394, 189000] };
});

// node_modules/iconv-lite/encodings/tables/cp949.json
var require_cp949 = __commonJS((exports, module) => {
  module.exports = [
    ["0", "\x00", 127],
    ["8141", "", 4, "", 6, ""],
    ["8161", "", 9, "", 5, ""],
    ["8181", "", 18, "", 4, "", 6, "", 5, "", 6, "", 7, "", 7, "", 4, "", 4, ""],
    ["8241", "", 7, "", 5],
    ["8261", "", 6, "", 5, ""],
    ["8281", "", 7, "", 7, "", 4, "", 10, "", 5, "", 17, "", 7, "", 6, "", 7, "", 18],
    ["8341", "", 5, "", 5, "", 7],
    ["8361", "", 18, ""],
    ["8381", "", 4, "", 6, "", 5, "", 5, "", 46, "", 6, "", 5, "", 8],
    ["8441", "", 5, "", 8],
    ["8461", "", 18],
    ["8481", "", 7, "", 6, "", 5, "", 10, "", 5, "", 18, "", 5, "", 6, "", 5, "", 26, ""],
    ["8541", "", 5, "", 4, "", 6, "", 4],
    ["8561", "", 5, "", 5, "", 6, ""],
    ["8581", "", 6, "", 6, "", 9, "", 26, "", 29, "", 6, "", 5, ""],
    ["8641", "", 6, "", 5, ""],
    ["8661", "", 6, "", 10],
    ["8681", "", 22, "", 4, "", 6, "", 5, "", 6, "", 22, "", 4, ""],
    ["8741", "", 9, "", 15],
    ["8761", "", 18, ""],
    ["8781", "", 5, "", 7, "", 7, "", 5, "", 6, "", 5, "", 18, "", 6, "", 26, "", 6, "", 4],
    ["8841", "", 4, "", 5, "", 6, "", 4],
    ["8861", "", 4, ""],
    ["8881", "", 15, "", 4, "", 6, "", 5, "", 54, ""],
    ["8941", "", 6, "", 5, ""],
    ["8961", "", 10, "", 5, ""],
    ["8981", "", 21, "", 18, "", 18, "", 6, "", 6, "", 7, "", 15],
    ["8a41", "", 10, "", 6, ""],
    ["8a61", "", 4, "", 18, ""],
    ["8a81", "", 4, "", 19, "", 5, "", 7, "", 5, "", 6, "", 5, "", 4, "", 5, "", 26, ""],
    ["8b41", "", 5, "", 4, "", 6, ""],
    ["8b61", "", 6, "", 8],
    ["8b81", "", 52, "", 4, "", 6, "", 5, "", 18, "", 18],
    ["8c41", "", 15, "", 4],
    ["8c61", "", 6, "", 5, "", 6, "", 5],
    ["8c81", "", 12, "", 26, "", 50, "", 5, "", 16],
    ["8d41", "", 16, "", 8],
    ["8d61", "", 17, ""],
    ["8d81", "", 4, "", 33, "", 6, "", 7, "", 6, "", 9, "", 6, "", 5, "", 6, ""],
    ["8e41", "", 6, "", 5, "", 8],
    ["8e61", "", 4, "", 19],
    ["8e81", "", 13, "", 6, "", 4, "", 6, "", 5, "", 6, "", 5, "", 11, "", 7, "", 6, "", 5, "", 7],
    ["8f41", "", 7, "", 17],
    ["8f61", "", 7, "", 6, "", 4],
    ["8f81", "", 5, "", 7, "", 5, "", 6, "", 5, "", 18, "", 6, "", 26, "", 6, "", 5],
    ["9041", "", 6, "", 5, ""],
    ["9061", "", 5, "", 15],
    ["9081", "", 12, "", 6, "", 5, "", 4, "", 6, "", 4, "", 5, "", 11, "", 33, ""],
    ["9141", "", 6, "", 5],
    ["9161", "", 9, "", 5],
    ["9181", "", 20, "", 4, "", 5, "", 14, "", 33, "", 7, "", 5, "", 6],
    ["9241", "", 7, "", 4, ""],
    ["9261", "", 7, "", 7, "", 4],
    ["9281", "", 21, "", 18, "", 6, "", 7, "", 6, "", 35, ""],
    ["9341", "", 4, ""],
    ["9361", "", 6, "", 8],
    ["9381", "", 37, "", 4, "", 4, "", 6, "", 5, "", 7, "", 22, ""],
    ["9441", "", 5, "", 5, "", 8],
    ["9461", "", 5, "", 6, "", 12],
    ["9481", "", 5, "", 6, "", 6, "", 9, "", 22, "", 4, "", 6, "", 10, "", 6, "", 24],
    ["9541", "", 11, "", 5, ""],
    ["9561", "", 6, "", 5, ""],
    ["9581", "", 6, "", 35, "", 4, "", 4, "", 4, "", 6, "", 5, "", 13, "", 14],
    ["9641", "", 23, ""],
    ["9661", "", 6, "", 5, "", 8],
    ["9681", "", 10, "", 5, "", 13, "", 33, "", 6, "", 44],
    ["9741", "", 16, "", 8],
    ["9761", "", 17, "", 7],
    ["9781", "", 11, "", 5, "", 6, "", 89, ""],
    ["9841", "", 16, "", 5, ""],
    ["9861", "", 6, "", 15],
    ["9881", "", 21, "", 6, "", 5, "", 4, "", 6, "", 5, "", 6, "", 5, "", 6, "", 5, ""],
    ["9941", "", 6, "", 5, ""],
    ["9961", "", 6, "", 5, ""],
    ["9981", "", 8, "", 5, "", 4, "", 11, "", 5, "", 6, "", 6, "", 6, "", 7, "", 6, "", 5, ""],
    ["9a41", "", 16],
    ["9a61", "", 6, "", 6, ""],
    ["9a81", "", 4, "", 6, "", 5, "", 5, "", 6, "", 5, "", 5, "", 33, "", 5, "", 6, ""],
    ["9b41", "", 6, "", 8],
    ["9b61", "", 17, "", 7],
    ["9b81", "", 25, "", 4, "", 5, "", 50, "", 22, ""],
    ["9c41", "", 4, "", 5, "", 5],
    ["9c61", "", 8, "", 6, "", 9],
    ["9c81", "", 8, "", 6, "", 6, "", 9, "", 26, "", 6, "", 5, "", 18, "", 6, "", 12],
    ["9d41", "", 13, "", 8],
    ["9d61", "", 25],
    ["9d81", "", 8, "", 5, "", 9, "", 6, "", 10, "", 6, "", 5, "", 6, "", 5, ""],
    ["9e41", "", 7, "", 9, ""],
    ["9e61", "", 4, "", 6, ""],
    ["9e81", "", 6, "", 6, "", 6, "", 5, "", 10, "", 5, "", 6, "", 5, "", 6, ""],
    ["9f41", "", 5, "", 4, "", 5, ""],
    ["9f61", "", 6, "", 5, ""],
    ["9f81", "", 4, "", 5, "", 6, "", 5, "", 6, "", 4, "", 6, "", 7, "", 4, "", 4, ""],
    ["a041", "", 5, "", 6, ""],
    ["a061", "", 5, "", 13],
    ["a081", "", 4, "", 4, "", 4, "", 6, "", 5, "", 6, "", 5, "", 26, "", 4, "", 5, "", 7, ""],
    ["a141", "", 18, ""],
    ["a161", "", 6, "", 5, ""],
    ["a181", "", 14, "", 5, "", 4, "", 9, ""],
    ["a241", "", 5, "", 18],
    ["a261", "", 6, "", 18],
    ["a281", "", 7, "", 6, "", 7, ""],
    ["a341", "", 6, "", 10, ""],
    ["a361", "", 6, "", 16],
    ["a381", "", 16, "", 4, "", 58, "", 32, ""],
    ["a441", "", 5, ""],
    ["a461", "", 5, "", 12],
    ["a481", "", 28, "", 93],
    ["a541", "", 4, "", 6, "", 5, ""],
    ["a561", "", 17, "", 5, ""],
    ["a581", "", 16, "", 14, "", 9],
    ["a5b0", "", 9],
    ["a5c1", "", 16, "", 6],
    ["a5e1", "", 16, "", 6],
    ["a641", "", 19, ""],
    ["a661", "", 5, "", 5, "", 6],
    ["a681", "", 6, "", 18, "", 7],
    ["a741", "", 4, "", 6, "", 7],
    ["a761", "", 22, ""],
    ["a781", "", 6, "", 5, "", 7, "", 9, "", 9, "", 4, "", 5, "", 4, ""],
    ["a841", "", 10, "", 14],
    ["a861", "", 18, "", 6],
    ["a881", "", 19, "", 11, ""],
    ["a8a6", ""],
    ["a8a8", ""],
    ["a8b1", "", 27, "", 25, "", 14, ""],
    ["a941", "", 14, "", 10],
    ["a961", "", 18],
    ["a981", "", 14, "", 6, "", 27, "", 25, "", 14, ""],
    ["aa41", "", 6, "", 4, ""],
    ["aa61", "", 4, "", 5, "", 6, ""],
    ["aa81", "", 29, "", 82],
    ["ab41", "", 6, "", 5, ""],
    ["ab61", "", 6, "", 5, "", 5],
    ["ab81", "", 8, "", 6, "", 12, "", 85],
    ["ac41", "", 5, "", 6, ""],
    ["ac61", "", 11, "", 4],
    ["ac81", "", 28, "", 5, "", 25],
    ["acd1", "", 5, "", 25],
    ["ad41", "", 6, "", 5, "", 7],
    ["ad61", "", 6, "", 10, ""],
    ["ad81", "", 5, "", 18, ""],
    ["ae41", "", 5, "", 16],
    ["ae61", "", 5, "", 6, "", 4],
    ["ae81", "", 6, "", 5, ""],
    ["af41", "", 19],
    ["af61", "", 13, "", 5, ""],
    ["af81", "", 5, "", 6, "", 5, ""],
    ["b041", "", 5, "", 5, "", 12],
    ["b061", "", 5, "", 19],
    ["b081", "", 13, "", 6, "", 5, "", 7, "", 4, ""],
    ["b141", "", 6, "", 5, ""],
    ["b161", "", 6, "", 5, "", 11],
    ["b181", "", 14, "", 6, ""],
    ["b241", "", 6, "", 5, ""],
    ["b261", "", 18, "", 5, ""],
    ["b281", "", 5, "", 18, "", 6, ""],
    ["b341", "", 19, ""],
    ["b361", "", 5, "", 5, "", 5],
    ["b381", "", 5, "", 5, "", 19, "", 4, ""],
    ["b441", "", 5, "", 6, "", 5],
    ["b461", "", 6, "", 10, ""],
    ["b481", "", 6, "", 18, "", 4, "", 4, ""],
    ["b541", "", 14, "", 5],
    ["b561", "", 5, "", 5, "", 4],
    ["b581", "", 6, "", 5, "", 11, ""],
    ["b641", "", 7, "", 17],
    ["b661", "", 15, ""],
    ["b681", "", 5, "", 6, "", 5, ""],
    ["b741", "", 13, "", 6, ""],
    ["b761", "", 20, ""],
    ["b781", "", 6, "", 14, ""],
    ["b841", "", 7, "", 17],
    ["b861", "", 8, "", 13],
    ["b881", "", 5, "", 24, "", 4, ""],
    ["b941", "", 6, "", 5, ""],
    ["b961", "", 14, "", 6, ""],
    ["b981", "", 22, "", 4, "", 4, ""],
    ["ba41", "", 5, "", 6, ""],
    ["ba61", "", 5, "", 4, "", 5],
    ["ba81", "", 6, "", 9, ""],
    ["bb41", "", 4, "", 5, "", 4, ""],
    ["bb61", "", 6, "", 5, ""],
    ["bb81", "", 31, ""],
    ["bc41", "", 17, ""],
    ["bc61", "", 5, "", 6, ""],
    ["bc81", "", 4, "", 6, "", 5, "", 5, "", 4, ""],
    ["bd41", "", 7, "", 7, ""],
    ["bd61", "", 5, "", 13],
    ["bd81", "", 5, "", 25, ""],
    ["be41", "", 7, "", 14],
    ["be61", "", 7, "", 7, ""],
    ["be81", "", 4, "", 4, "", 5, "", 8, "", 6, ""],
    ["bf41", "", 10, "", 14],
    ["bf61", "", 18, ""],
    ["bf81", "", 5, "", 7, "", 6, "", 5, ""],
    ["c041", "", 5, "", 6, "", 5],
    ["c061", "", 25],
    ["c081", "", 6, "", 5, "", 7, ""],
    ["c141", "", 5, "", 6, ""],
    ["c161", "", 19, ""],
    ["c181", "", 31, ""],
    ["c241", "", 4, "", 5, ""],
    ["c261", "", 4, "", 5, "", 6, ""],
    ["c281", "", 5, "", 7, "", 9, ""],
    ["c341", "", 4],
    ["c361", "", 4, "", 5, "", 11],
    ["c381", "", 5, "", 7, "", 5, ""],
    ["c441", "", 7, "", 7, ""],
    ["c461", "", 5, "", 4],
    ["c481", "", 5, "", 11, ""],
    ["c541", "", 6, "", 5, ""],
    ["c561", "", 6, "", 5, "", 4],
    ["c581", "", 6, "", 5, ""],
    ["c641", "", 6, "", 5],
    ["c6a1", ""],
    ["c7a1", ""],
    ["c8a1", ""],
    ["caa1", ""],
    ["cba1", ""],
    ["cca1", ""],
    ["cda1", ""],
    ["cea1", ""],
    ["cfa1", ""],
    ["d0a1", ""],
    ["d1a1", "", 5, "", 4, ""],
    ["d2a1", "", 4, "", 5, "", 10, "", 7, "", 5, ""],
    ["d3a1", ""],
    ["d4a1", ""],
    ["d5a1", ""],
    ["d6a1", ""],
    ["d7a1", ""],
    ["d8a1", ""],
    ["d9a1", ""],
    ["daa1", ""],
    ["dba1", ""],
    ["dca1", ""],
    ["dda1", ""],
    ["dea1", ""],
    ["dfa1", ""],
    ["e0a1", ""],
    ["e1a1", ""],
    ["e2a1", ""],
    ["e3a1", ""],
    ["e4a1", ""],
    ["e5a1", ""],
    ["e6a1", ""],
    ["e7a1", ""],
    ["e8a1", ""],
    ["e9a1", ""],
    ["eaa1", ""],
    ["eba1", ""],
    ["eca1", ""],
    ["eda1", ""],
    ["eea1", ""],
    ["efa1", ""],
    ["f0a1", ""],
    ["f1a1", ""],
    ["f2a1", ""],
    ["f3a1", ""],
    ["f4a1", ""],
    ["f5a1", ""],
    ["f6a1", ""],
    ["f7a1", ""],
    ["f8a1", ""],
    ["f9a1", ""],
    ["faa1", ""],
    ["fba1", ""],
    ["fca1", ""],
    ["fda1", ""]
  ];
});

// node_modules/iconv-lite/encodings/tables/cp950.json
var require_cp950 = __commonJS((exports, module) => {
  module.exports = [
    ["0", "\x00", 127],
    ["a140", ""],
    ["a1a1", "", 4, ""],
    ["a240", "", 7, ""],
    ["a2a1", "", 9, "", 9, "", 8, "", 25, "", 21],
    ["a340", "", 16, "", 6, "", 16, "", 6, "", 10],
    ["a3a1", "", 25, ""],
    ["a3e1", ""],
    ["a440", ""],
    ["a4a1", ""],
    ["a540", ""],
    ["a5a1", ""],
    ["a640", ""],
    ["a6a1", ""],
    ["a740", ""],
    ["a7a1", ""],
    ["a840", ""],
    ["a8a1", ""],
    ["a940", ""],
    ["a9a1", ""],
    ["aa40", ""],
    ["aaa1", ""],
    ["ab40", ""],
    ["aba1", ""],
    ["ac40", ""],
    ["aca1", ""],
    ["ad40", ""],
    ["ada1", ""],
    ["ae40", ""],
    ["aea1", ""],
    ["af40", ""],
    ["afa1", ""],
    ["b040", ""],
    ["b0a1", ""],
    ["b140", ""],
    ["b1a1", ""],
    ["b240", ""],
    ["b2a1", ""],
    ["b340", ""],
    ["b3a1", ""],
    ["b440", ""],
    ["b4a1", ""],
    ["b540", ""],
    ["b5a1", ""],
    ["b640", ""],
    ["b6a1", ""],
    ["b740", ""],
    ["b7a1", ""],
    ["b840", ""],
    ["b8a1", ""],
    ["b940", ""],
    ["b9a1", ""],
    ["ba40", ""],
    ["baa1", ""],
    ["bb40", ""],
    ["bba1", ""],
    ["bc40", ""],
    ["bca1", ""],
    ["bd40", ""],
    ["bda1", ""],
    ["be40", ""],
    ["bea1", ""],
    ["bf40", ""],
    ["bfa1", ""],
    ["c040", ""],
    ["c0a1", ""],
    ["c140", ""],
    ["c1a1", ""],
    ["c240", ""],
    ["c2a1", ""],
    ["c340", ""],
    ["c3a1", ""],
    ["c440", ""],
    ["c4a1", ""],
    ["c540", ""],
    ["c5a1", ""],
    ["c640", ""],
    ["c940", ""],
    ["c9a1", ""],
    ["ca40", ""],
    ["caa1", ""],
    ["cb40", ""],
    ["cba1", ""],
    ["cc40", ""],
    ["cca1", ""],
    ["cd40", ""],
    ["cda1", ""],
    ["ce40", ""],
    ["cea1", ""],
    ["cf40", ""],
    ["cfa1", ""],
    ["d040", ""],
    ["d0a1", ""],
    ["d140", ""],
    ["d1a1", ""],
    ["d240", ""],
    ["d2a1", ""],
    ["d340", ""],
    ["d3a1", ""],
    ["d440", ""],
    ["d4a1", ""],
    ["d540", ""],
    ["d5a1", ""],
    ["d640", ""],
    ["d6a1", ""],
    ["d740", ""],
    ["d7a1", ""],
    ["d840", ""],
    ["d8a1", ""],
    ["d940", ""],
    ["d9a1", ""],
    ["da40", ""],
    ["daa1", ""],
    ["db40", ""],
    ["dba1", ""],
    ["dc40", ""],
    ["dca1", ""],
    ["dd40", ""],
    ["dda1", ""],
    ["de40", ""],
    ["dea1", ""],
    ["df40", ""],
    ["dfa1", ""],
    ["e040", ""],
    ["e0a1", ""],
    ["e140", ""],
    ["e1a1", ""],
    ["e240", ""],
    ["e2a1", ""],
    ["e340", ""],
    ["e3a1", ""],
    ["e440", ""],
    ["e4a1", ""],
    ["e540", ""],
    ["e5a1", ""],
    ["e640", ""],
    ["e6a1", ""],
    ["e740", ""],
    ["e7a1", ""],
    ["e840", ""],
    ["e8a1", ""],
    ["e940", ""],
    ["e9a1", ""],
    ["ea40", ""],
    ["eaa1", ""],
    ["eb40", ""],
    ["eba1", ""],
    ["ec40", ""],
    ["eca1", ""],
    ["ed40", ""],
    ["eda1", ""],
    ["ee40", ""],
    ["eea1", ""],
    ["ef40", ""],
    ["efa1", ""],
    ["f040", ""],
    ["f0a1", ""],
    ["f140", ""],
    ["f1a1", ""],
    ["f240", ""],
    ["f2a1", ""],
    ["f340", ""],
    ["f3a1", ""],
    ["f440", ""],
    ["f4a1", ""],
    ["f540", ""],
    ["f5a1", ""],
    ["f640", ""],
    ["f6a1", ""],
    ["f740", ""],
    ["f7a1", ""],
    ["f840", ""],
    ["f8a1", ""],
    ["f940", ""],
    ["f9a1", ""]
  ];
});

// node_modules/iconv-lite/encodings/tables/big5-added.json
var require_big5_added = __commonJS((exports, module) => {
  module.exports = [
    ["8740", ""],
    ["8767", ""],
    ["87a1", ""],
    ["8840", "", 4, ""],
    ["88a1", ""],
    ["8940", ""],
    ["8943", ""],
    ["8946", ""],
    ["894c", ""],
    ["89a1", ""],
    ["89ab", ""],
    ["89b0", ""],
    ["89b5", ""],
    ["89c1", ""],
    ["89c5", ""],
    ["8a40", ""],
    ["8a43", ""],
    ["8a64", ""],
    ["8a76", ""],
    ["8aa1", ""],
    ["8aac", ""],
    ["8ab2", ""],
    ["8abb", ""],
    ["8ac9", ""],
    ["8ace", ""],
    ["8adf", ""],
    ["8af6", ""],
    ["8b40", ""],
    ["8b55", ""],
    ["8ba1", ""],
    ["8bde", ""],
    ["8c40", ""],
    ["8ca1", ""],
    ["8ca7", ""],
    ["8cc9", ""],
    ["8cce", ""],
    ["8ce6", ""],
    ["8d40", ""],
    ["8d42", ""],
    ["8da1", ""],
    ["8e40", ""],
    ["8ea1", ""],
    ["8f40", ""],
    ["8fa1", ""],
    ["9040", ""],
    ["90a1", ""],
    ["9140", ""],
    ["91a1", ""],
    ["9240", ""],
    ["92a1", ""],
    ["9340", ""],
    ["93a1", ""],
    ["9440", ""],
    ["94a1", ""],
    ["9540", ""],
    ["95a1", ""],
    ["9640", ""],
    ["96a1", ""],
    ["9740", ""],
    ["97a1", ""],
    ["9840", ""],
    ["98a1", ""],
    ["9940", ""],
    ["99a1", ""],
    ["9a40", ""],
    ["9aa1", ""],
    ["9b40", ""],
    ["9b62", ""],
    ["9ba1", ""],
    ["9c40", ""],
    ["9ca1", ""],
    ["9d40", ""],
    ["9da1", ""],
    ["9e40", ""],
    ["9ea1", ""],
    ["9ead", ""],
    ["9ec5", ""],
    ["9ef5", ""],
    ["9f40", ""],
    ["9f4f", ""],
    ["9fa1", ""],
    ["9fae", ""],
    ["9fb2", ""],
    ["9fc1", ""],
    ["9fc9", ""],
    ["9fdb", ""],
    ["9fe7", ""],
    ["9feb", ""],
    ["9ff0", ""],
    ["a040", ""],
    ["a055", ""],
    ["a058", ""],
    ["a05b", ""],
    ["a063", ""],
    ["a073", ""],
    ["a0a1", ""],
    ["a0a6", ""],
    ["a0ae", ""],
    ["a0b0", ""],
    ["a0d4", ""],
    ["a0e2", ""],
    ["a3c0", "", 31, ""],
    ["c6a1", "", 9, "", 9, "", 9, "", 23],
    ["c740", "", 58, ""],
    ["c7a1", "", 81, "", 5, "", 4],
    ["c840", "", 26, "", 25, ""],
    ["c8a1", ""],
    ["c8cd", ""],
    ["c8f5", ""],
    ["f9fe", ""],
    ["fa40", ""],
    ["faa1", ""],
    ["fb40", ""],
    ["fba1", ""],
    ["fc40", ""],
    ["fca1", ""],
    ["fd40", ""],
    ["fda1", ""],
    ["fe40", ""],
    ["fea1", ""]
  ];
});

// node_modules/iconv-lite/encodings/dbcs-data.js
var require_dbcs_data = __commonJS((exports, module) => {
  module.exports = {
    shiftjis: {
      type: "_dbcs",
      table: function() {
        return require_shiftjis();
      },
      encodeAdd: { "": 92, "": 126 },
      encodeSkipVals: [{ from: 60736, to: 63808 }]
    },
    csshiftjis: "shiftjis",
    mskanji: "shiftjis",
    sjis: "shiftjis",
    windows31j: "shiftjis",
    ms31j: "shiftjis",
    xsjis: "shiftjis",
    windows932: "shiftjis",
    ms932: "shiftjis",
    "932": "shiftjis",
    cp932: "shiftjis",
    eucjp: {
      type: "_dbcs",
      table: function() {
        return require_eucjp();
      },
      encodeAdd: { "": 92, "": 126 }
    },
    gb2312: "cp936",
    gb231280: "cp936",
    gb23121980: "cp936",
    csgb2312: "cp936",
    csiso58gb231280: "cp936",
    euccn: "cp936",
    windows936: "cp936",
    ms936: "cp936",
    "936": "cp936",
    cp936: {
      type: "_dbcs",
      table: function() {
        return require_cp936();
      }
    },
    gbk: {
      type: "_dbcs",
      table: function() {
        return require_cp936().concat(require_gbk_added());
      }
    },
    xgbk: "gbk",
    isoir58: "gbk",
    gb18030: {
      type: "_dbcs",
      table: function() {
        return require_cp936().concat(require_gbk_added());
      },
      gb18030: function() {
        return require_gb18030_ranges();
      },
      encodeSkipVals: [128],
      encodeAdd: { "": 41699 }
    },
    chinese: "gb18030",
    windows949: "cp949",
    ms949: "cp949",
    "949": "cp949",
    cp949: {
      type: "_dbcs",
      table: function() {
        return require_cp949();
      }
    },
    cseuckr: "cp949",
    csksc56011987: "cp949",
    euckr: "cp949",
    isoir149: "cp949",
    korean: "cp949",
    ksc56011987: "cp949",
    ksc56011989: "cp949",
    ksc5601: "cp949",
    windows950: "cp950",
    ms950: "cp950",
    "950": "cp950",
    cp950: {
      type: "_dbcs",
      table: function() {
        return require_cp950();
      }
    },
    big5: "big5hkscs",
    big5hkscs: {
      type: "_dbcs",
      table: function() {
        return require_cp950().concat(require_big5_added());
      },
      encodeSkipVals: [41676]
    },
    cnbig5: "big5hkscs",
    csbig5: "big5hkscs",
    xxbig5: "big5hkscs"
  };
});

// node_modules/iconv-lite/encodings/index.js
var require_encodings = __commonJS((exports, module) => {
  var modules = [
    require_internal(),
    require_utf16(),
    require_utf7(),
    require_sbcs_codec(),
    require_sbcs_data(),
    require_sbcs_data_generated(),
    require_dbcs_codec(),
    require_dbcs_data()
  ];
  for (i = 0;i < modules.length; i++) {
    module = modules[i];
    for (enc in module)
      if (Object.prototype.hasOwnProperty.call(module, enc))
        exports[enc] = module[enc];
  }
  var module;
  var enc;
  var i;
});

// node_modules/iconv-lite/lib/streams.js
var require_streams = __commonJS((exports, module) => {
  var Buffer2 = __require("buffer").Buffer;
  var Transform = __require("stream").Transform;
  module.exports = function(iconv) {
    iconv.encodeStream = function encodeStream(encoding, options) {
      return new IconvLiteEncoderStream(iconv.getEncoder(encoding, options), options);
    };
    iconv.decodeStream = function decodeStream(encoding, options) {
      return new IconvLiteDecoderStream(iconv.getDecoder(encoding, options), options);
    };
    iconv.supportsStreams = true;
    iconv.IconvLiteEncoderStream = IconvLiteEncoderStream;
    iconv.IconvLiteDecoderStream = IconvLiteDecoderStream;
    iconv._collect = IconvLiteDecoderStream.prototype.collect;
  };
  function IconvLiteEncoderStream(conv, options) {
    this.conv = conv;
    options = options || {};
    options.decodeStrings = false;
    Transform.call(this, options);
  }
  IconvLiteEncoderStream.prototype = Object.create(Transform.prototype, {
    constructor: { value: IconvLiteEncoderStream }
  });
  IconvLiteEncoderStream.prototype._transform = function(chunk, encoding, done) {
    if (typeof chunk != "string")
      return done(new Error("Iconv encoding stream needs strings as its input."));
    try {
      var res = this.conv.write(chunk);
      if (res && res.length)
        this.push(res);
      done();
    } catch (e) {
      done(e);
    }
  };
  IconvLiteEncoderStream.prototype._flush = function(done) {
    try {
      var res = this.conv.end();
      if (res && res.length)
        this.push(res);
      done();
    } catch (e) {
      done(e);
    }
  };
  IconvLiteEncoderStream.prototype.collect = function(cb) {
    var chunks = [];
    this.on("error", cb);
    this.on("data", function(chunk) {
      chunks.push(chunk);
    });
    this.on("end", function() {
      cb(null, Buffer2.concat(chunks));
    });
    return this;
  };
  function IconvLiteDecoderStream(conv, options) {
    this.conv = conv;
    options = options || {};
    options.encoding = this.encoding = "utf8";
    Transform.call(this, options);
  }
  IconvLiteDecoderStream.prototype = Object.create(Transform.prototype, {
    constructor: { value: IconvLiteDecoderStream }
  });
  IconvLiteDecoderStream.prototype._transform = function(chunk, encoding, done) {
    if (!Buffer2.isBuffer(chunk))
      return done(new Error("Iconv decoding stream needs buffers as its input."));
    try {
      var res = this.conv.write(chunk);
      if (res && res.length)
        this.push(res, this.encoding);
      done();
    } catch (e) {
      done(e);
    }
  };
  IconvLiteDecoderStream.prototype._flush = function(done) {
    try {
      var res = this.conv.end();
      if (res && res.length)
        this.push(res, this.encoding);
      done();
    } catch (e) {
      done(e);
    }
  };
  IconvLiteDecoderStream.prototype.collect = function(cb) {
    var res = "";
    this.on("error", cb);
    this.on("data", function(chunk) {
      res += chunk;
    });
    this.on("end", function() {
      cb(null, res);
    });
    return this;
  };
});

// node_modules/iconv-lite/lib/extend-node.js
var require_extend_node = __commonJS((exports, module) => {
  var Buffer2 = __require("buffer").Buffer;
  module.exports = function(iconv) {
    var original = undefined;
    iconv.supportsNodeEncodingsExtension = !(Buffer2.from || new Buffer2(0) instanceof Uint8Array);
    iconv.extendNodeEncodings = function extendNodeEncodings() {
      if (original)
        return;
      original = {};
      if (!iconv.supportsNodeEncodingsExtension) {
        console.error("ACTION NEEDED: require('iconv-lite').extendNodeEncodings() is not supported in your version of Node");
        console.error("See more info at https://github.com/ashtuchkin/iconv-lite/wiki/Node-v4-compatibility");
        return;
      }
      var nodeNativeEncodings = {
        hex: true,
        utf8: true,
        "utf-8": true,
        ascii: true,
        binary: true,
        base64: true,
        ucs2: true,
        "ucs-2": true,
        utf16le: true,
        "utf-16le": true
      };
      Buffer2.isNativeEncoding = function(enc) {
        return enc && nodeNativeEncodings[enc.toLowerCase()];
      };
      var SlowBuffer = __require("buffer").SlowBuffer;
      original.SlowBufferToString = SlowBuffer.prototype.toString;
      SlowBuffer.prototype.toString = function(encoding, start, end) {
        encoding = String(encoding || "utf8").toLowerCase();
        if (Buffer2.isNativeEncoding(encoding))
          return original.SlowBufferToString.call(this, encoding, start, end);
        if (typeof start == "undefined")
          start = 0;
        if (typeof end == "undefined")
          end = this.length;
        return iconv.decode(this.slice(start, end), encoding);
      };
      original.SlowBufferWrite = SlowBuffer.prototype.write;
      SlowBuffer.prototype.write = function(string, offset, length, encoding) {
        if (isFinite(offset)) {
          if (!isFinite(length)) {
            encoding = length;
            length = undefined;
          }
        } else {
          var swap = encoding;
          encoding = offset;
          offset = length;
          length = swap;
        }
        offset = +offset || 0;
        var remaining = this.length - offset;
        if (!length) {
          length = remaining;
        } else {
          length = +length;
          if (length > remaining) {
            length = remaining;
          }
        }
        encoding = String(encoding || "utf8").toLowerCase();
        if (Buffer2.isNativeEncoding(encoding))
          return original.SlowBufferWrite.call(this, string, offset, length, encoding);
        if (string.length > 0 && (length < 0 || offset < 0))
          throw new RangeError("attempt to write beyond buffer bounds");
        var buf = iconv.encode(string, encoding);
        if (buf.length < length)
          length = buf.length;
        buf.copy(this, offset, 0, length);
        return length;
      };
      original.BufferIsEncoding = Buffer2.isEncoding;
      Buffer2.isEncoding = function(encoding) {
        return Buffer2.isNativeEncoding(encoding) || iconv.encodingExists(encoding);
      };
      original.BufferByteLength = Buffer2.byteLength;
      Buffer2.byteLength = SlowBuffer.byteLength = function(str, encoding) {
        encoding = String(encoding || "utf8").toLowerCase();
        if (Buffer2.isNativeEncoding(encoding))
          return original.BufferByteLength.call(this, str, encoding);
        return iconv.encode(str, encoding).length;
      };
      original.BufferToString = Buffer2.prototype.toString;
      Buffer2.prototype.toString = function(encoding, start, end) {
        encoding = String(encoding || "utf8").toLowerCase();
        if (Buffer2.isNativeEncoding(encoding))
          return original.BufferToString.call(this, encoding, start, end);
        if (typeof start == "undefined")
          start = 0;
        if (typeof end == "undefined")
          end = this.length;
        return iconv.decode(this.slice(start, end), encoding);
      };
      original.BufferWrite = Buffer2.prototype.write;
      Buffer2.prototype.write = function(string, offset, length, encoding) {
        var _offset = offset, _length = length, _encoding = encoding;
        if (isFinite(offset)) {
          if (!isFinite(length)) {
            encoding = length;
            length = undefined;
          }
        } else {
          var swap = encoding;
          encoding = offset;
          offset = length;
          length = swap;
        }
        encoding = String(encoding || "utf8").toLowerCase();
        if (Buffer2.isNativeEncoding(encoding))
          return original.BufferWrite.call(this, string, _offset, _length, _encoding);
        offset = +offset || 0;
        var remaining = this.length - offset;
        if (!length) {
          length = remaining;
        } else {
          length = +length;
          if (length > remaining) {
            length = remaining;
          }
        }
        if (string.length > 0 && (length < 0 || offset < 0))
          throw new RangeError("attempt to write beyond buffer bounds");
        var buf = iconv.encode(string, encoding);
        if (buf.length < length)
          length = buf.length;
        buf.copy(this, offset, 0, length);
        return length;
      };
      if (iconv.supportsStreams) {
        var Readable = __require("stream").Readable;
        original.ReadableSetEncoding = Readable.prototype.setEncoding;
        Readable.prototype.setEncoding = function setEncoding(enc, options) {
          this._readableState.decoder = iconv.getDecoder(enc, options);
          this._readableState.encoding = enc;
        };
        Readable.prototype.collect = iconv._collect;
      }
    };
    iconv.undoExtendNodeEncodings = function undoExtendNodeEncodings() {
      if (!iconv.supportsNodeEncodingsExtension)
        return;
      if (!original)
        throw new Error("require('iconv-lite').undoExtendNodeEncodings(): Nothing to undo; extendNodeEncodings() is not called.");
      delete Buffer2.isNativeEncoding;
      var SlowBuffer = __require("buffer").SlowBuffer;
      SlowBuffer.prototype.toString = original.SlowBufferToString;
      SlowBuffer.prototype.write = original.SlowBufferWrite;
      Buffer2.isEncoding = original.BufferIsEncoding;
      Buffer2.byteLength = original.BufferByteLength;
      Buffer2.prototype.toString = original.BufferToString;
      Buffer2.prototype.write = original.BufferWrite;
      if (iconv.supportsStreams) {
        var Readable = __require("stream").Readable;
        Readable.prototype.setEncoding = original.ReadableSetEncoding;
        delete Readable.prototype.collect;
      }
      original = undefined;
    };
  };
});

// node_modules/iconv-lite/lib/index.js
var require_lib = __commonJS((exports, module) => {
  var Buffer2 = require_safer().Buffer;
  var bomHandling = require_bom_handling();
  var iconv = exports;
  iconv.encodings = null;
  iconv.defaultCharUnicode = "";
  iconv.defaultCharSingleByte = "?";
  iconv.encode = function encode(str, encoding, options) {
    str = "" + (str || "");
    var encoder = iconv.getEncoder(encoding, options);
    var res = encoder.write(str);
    var trail = encoder.end();
    return trail && trail.length > 0 ? Buffer2.concat([res, trail]) : res;
  };
  iconv.decode = function decode(buf, encoding, options) {
    if (typeof buf === "string") {
      if (!iconv.skipDecodeWarning) {
        console.error("Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding");
        iconv.skipDecodeWarning = true;
      }
      buf = Buffer2.from("" + (buf || ""), "binary");
    }
    var decoder = iconv.getDecoder(encoding, options);
    var res = decoder.write(buf);
    var trail = decoder.end();
    return trail ? res + trail : res;
  };
  iconv.encodingExists = function encodingExists(enc) {
    try {
      iconv.getCodec(enc);
      return true;
    } catch (e) {
      return false;
    }
  };
  iconv.toEncoding = iconv.encode;
  iconv.fromEncoding = iconv.decode;
  iconv._codecDataCache = {};
  iconv.getCodec = function getCodec(encoding) {
    if (!iconv.encodings)
      iconv.encodings = require_encodings();
    var enc = iconv._canonicalizeEncoding(encoding);
    var codecOptions = {};
    while (true) {
      var codec = iconv._codecDataCache[enc];
      if (codec)
        return codec;
      var codecDef = iconv.encodings[enc];
      switch (typeof codecDef) {
        case "string":
          enc = codecDef;
          break;
        case "object":
          for (var key in codecDef)
            codecOptions[key] = codecDef[key];
          if (!codecOptions.encodingName)
            codecOptions.encodingName = enc;
          enc = codecDef.type;
          break;
        case "function":
          if (!codecOptions.encodingName)
            codecOptions.encodingName = enc;
          codec = new codecDef(codecOptions, iconv);
          iconv._codecDataCache[codecOptions.encodingName] = codec;
          return codec;
        default:
          throw new Error("Encoding not recognized: '" + encoding + "' (searched as: '" + enc + "')");
      }
    }
  };
  iconv._canonicalizeEncoding = function(encoding) {
    return ("" + encoding).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
  };
  iconv.getEncoder = function getEncoder(encoding, options) {
    var codec = iconv.getCodec(encoding), encoder = new codec.encoder(options, codec);
    if (codec.bomAware && options && options.addBOM)
      encoder = new bomHandling.PrependBOM(encoder, options);
    return encoder;
  };
  iconv.getDecoder = function getDecoder(encoding, options) {
    var codec = iconv.getCodec(encoding), decoder = new codec.decoder(options, codec);
    if (codec.bomAware && !(options && options.stripBOM === false))
      decoder = new bomHandling.StripBOM(decoder, options);
    return decoder;
  };
  var nodeVer = typeof process !== "undefined" && process.versions && process.versions.node;
  if (nodeVer) {
    nodeVerArr = nodeVer.split(".").map(Number);
    if (nodeVerArr[0] > 0 || nodeVerArr[1] >= 10) {
      require_streams()(iconv);
    }
    require_extend_node()(iconv);
  }
  var nodeVerArr;
  if (false) {}
});

// node_modules/unpipe/index.js
var require_unpipe = __commonJS((exports, module) => {
  /*!
   * unpipe
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  module.exports = unpipe;
  function hasPipeDataListeners(stream) {
    var listeners = stream.listeners("data");
    for (var i = 0;i < listeners.length; i++) {
      if (listeners[i].name === "ondata") {
        return true;
      }
    }
    return false;
  }
  function unpipe(stream) {
    if (!stream) {
      throw new TypeError("argument stream is required");
    }
    if (typeof stream.unpipe === "function") {
      stream.unpipe();
      return;
    }
    if (!hasPipeDataListeners(stream)) {
      return;
    }
    var listener;
    var listeners = stream.listeners("close");
    for (var i = 0;i < listeners.length; i++) {
      listener = listeners[i];
      if (listener.name !== "cleanup" && listener.name !== "onclose") {
        continue;
      }
      listener.call(stream);
    }
  }
});

// node_modules/raw-body/index.js
var require_raw_body = __commonJS((exports, module) => {
  /*!
   * raw-body
   * Copyright(c) 2013-2014 Jonathan Ong
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  var bytes = require_bytes();
  var createError = require_http_errors();
  var iconv = require_lib();
  var unpipe = require_unpipe();
  module.exports = getRawBody;
  var ICONV_ENCODING_MESSAGE_REGEXP = /^Encoding not recognized: /;
  function getDecoder(encoding) {
    if (!encoding)
      return null;
    try {
      return iconv.getDecoder(encoding);
    } catch (e) {
      if (!ICONV_ENCODING_MESSAGE_REGEXP.test(e.message))
        throw e;
      throw createError(415, "specified encoding unsupported", {
        encoding,
        type: "encoding.unsupported"
      });
    }
  }
  function getRawBody(stream, options, callback) {
    var done = callback;
    var opts = options || {};
    if (options === true || typeof options === "string") {
      opts = {
        encoding: options
      };
    }
    if (typeof options === "function") {
      done = options;
      opts = {};
    }
    if (done !== undefined && typeof done !== "function") {
      throw new TypeError("argument callback must be a function");
    }
    if (!done && !global.Promise) {
      throw new TypeError("argument callback is required");
    }
    var encoding = opts.encoding !== true ? opts.encoding : "utf-8";
    var limit = bytes.parse(opts.limit);
    var length = opts.length != null && !isNaN(opts.length) ? parseInt(opts.length, 10) : null;
    if (done) {
      return readStream(stream, encoding, length, limit, done);
    }
    return new Promise(function executor(resolve, reject) {
      readStream(stream, encoding, length, limit, function onRead(err, buf) {
        if (err)
          return reject(err);
        resolve(buf);
      });
    });
  }
  function halt(stream) {
    unpipe(stream);
    if (typeof stream.pause === "function") {
      stream.pause();
    }
  }
  function readStream(stream, encoding, length, limit, callback) {
    var complete = false;
    var sync = true;
    if (limit !== null && length !== null && length > limit) {
      return done(createError(413, "request entity too large", {
        expected: length,
        length,
        limit,
        type: "entity.too.large"
      }));
    }
    var state = stream._readableState;
    if (stream._decoder || state && (state.encoding || state.decoder)) {
      return done(createError(500, "stream encoding should not be set", {
        type: "stream.encoding.set"
      }));
    }
    var received = 0;
    var decoder;
    try {
      decoder = getDecoder(encoding);
    } catch (err) {
      return done(err);
    }
    var buffer = decoder ? "" : [];
    stream.on("aborted", onAborted);
    stream.on("close", cleanup);
    stream.on("data", onData);
    stream.on("end", onEnd);
    stream.on("error", onEnd);
    sync = false;
    function done() {
      var args2 = new Array(arguments.length);
      for (var i = 0;i < args2.length; i++) {
        args2[i] = arguments[i];
      }
      complete = true;
      if (sync) {
        process.nextTick(invokeCallback);
      } else {
        invokeCallback();
      }
      function invokeCallback() {
        cleanup();
        if (args2[0]) {
          halt(stream);
        }
        callback.apply(null, args2);
      }
    }
    function onAborted() {
      if (complete)
        return;
      done(createError(400, "request aborted", {
        code: "ECONNABORTED",
        expected: length,
        length,
        received,
        type: "request.aborted"
      }));
    }
    function onData(chunk) {
      if (complete)
        return;
      received += chunk.length;
      if (limit !== null && received > limit) {
        done(createError(413, "request entity too large", {
          limit,
          received,
          type: "entity.too.large"
        }));
      } else if (decoder) {
        buffer += decoder.write(chunk);
      } else {
        buffer.push(chunk);
      }
    }
    function onEnd(err) {
      if (complete)
        return;
      if (err)
        return done(err);
      if (length !== null && received !== length) {
        done(createError(400, "request size did not match content length", {
          expected: length,
          length,
          received,
          type: "request.size.invalid"
        }));
      } else {
        var string = decoder ? buffer + (decoder.end() || "") : Buffer.concat(buffer);
        done(null, string);
      }
    }
    function cleanup() {
      buffer = null;
      stream.removeListener("aborted", onAborted);
      stream.removeListener("data", onData);
      stream.removeListener("end", onEnd);
      stream.removeListener("error", onEnd);
      stream.removeListener("close", cleanup);
    }
  }
});

// node_modules/ee-first/index.js
var require_ee_first = __commonJS((exports, module) => {
  /*!
   * ee-first
   * Copyright(c) 2014 Jonathan Ong
   * MIT Licensed
   */
  module.exports = first;
  function first(stuff, done) {
    if (!Array.isArray(stuff))
      throw new TypeError("arg must be an array of [ee, events...] arrays");
    var cleanups = [];
    for (var i = 0;i < stuff.length; i++) {
      var arr = stuff[i];
      if (!Array.isArray(arr) || arr.length < 2)
        throw new TypeError("each array member must be [ee, events...]");
      var ee = arr[0];
      for (var j = 1;j < arr.length; j++) {
        var event = arr[j];
        var fn2 = listener(event, callback);
        ee.on(event, fn2);
        cleanups.push({
          ee,
          event,
          fn: fn2
        });
      }
    }
    function callback() {
      cleanup();
      done.apply(null, arguments);
    }
    function cleanup() {
      var x;
      for (var i2 = 0;i2 < cleanups.length; i2++) {
        x = cleanups[i2];
        x.ee.removeListener(x.event, x.fn);
      }
    }
    function thunk(fn3) {
      done = fn3;
    }
    thunk.cancel = cleanup;
    return thunk;
  }
  function listener(event, done) {
    return function onevent(arg1) {
      var args2 = new Array(arguments.length);
      var ee = this;
      var err = event === "error" ? arg1 : null;
      for (var i = 0;i < args2.length; i++) {
        args2[i] = arguments[i];
      }
      done(err, ee, event, args2);
    };
  }
});

// node_modules/on-finished/index.js
var require_on_finished = __commonJS((exports, module) => {
  /*!
   * on-finished
   * Copyright(c) 2013 Jonathan Ong
   * Copyright(c) 2014 Douglas Christopher Wilson
   * MIT Licensed
   */
  module.exports = onFinished;
  module.exports.isFinished = isFinished;
  var first = require_ee_first();
  var defer = typeof setImmediate === "function" ? setImmediate : function(fn2) {
    process.nextTick(fn2.bind.apply(fn2, arguments));
  };
  function onFinished(msg, listener) {
    if (isFinished(msg) !== false) {
      defer(listener, null, msg);
      return msg;
    }
    attachListener(msg, listener);
    return msg;
  }
  function isFinished(msg) {
    var socket = msg.socket;
    if (typeof msg.finished === "boolean") {
      return Boolean(msg.finished || socket && !socket.writable);
    }
    if (typeof msg.complete === "boolean") {
      return Boolean(msg.upgrade || !socket || !socket.readable || msg.complete && !msg.readable);
    }
    return;
  }
  function attachFinishedListener(msg, callback) {
    var eeMsg;
    var eeSocket;
    var finished = false;
    function onFinish(error) {
      eeMsg.cancel();
      eeSocket.cancel();
      finished = true;
      callback(error);
    }
    eeMsg = eeSocket = first([[msg, "end", "finish"]], onFinish);
    function onSocket(socket) {
      msg.removeListener("socket", onSocket);
      if (finished)
        return;
      if (eeMsg !== eeSocket)
        return;
      eeSocket = first([[socket, "error", "close"]], onFinish);
    }
    if (msg.socket) {
      onSocket(msg.socket);
      return;
    }
    msg.on("socket", onSocket);
    if (msg.socket === undefined) {
      patchAssignSocket(msg, onSocket);
    }
  }
  function attachListener(msg, listener) {
    var attached = msg.__onFinished;
    if (!attached || !attached.queue) {
      attached = msg.__onFinished = createListener(msg);
      attachFinishedListener(msg, attached);
    }
    attached.queue.push(listener);
  }
  function createListener(msg) {
    function listener(err) {
      if (msg.__onFinished === listener)
        msg.__onFinished = null;
      if (!listener.queue)
        return;
      var queue = listener.queue;
      listener.queue = null;
      for (var i = 0;i < queue.length; i++) {
        queue[i](err, msg);
      }
    }
    listener.queue = [];
    return listener;
  }
  function patchAssignSocket(res, callback) {
    var assignSocket = res.assignSocket;
    if (typeof assignSocket !== "function")
      return;
    res.assignSocket = function _assignSocket(socket) {
      assignSocket.call(this, socket);
      callback(socket);
    };
  }
});

// node_modules/body-parser/lib/read.js
var require_read = __commonJS((exports, module) => {
  /*!
   * body-parser
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  var createError = require_http_errors();
  var getBody = require_raw_body();
  var iconv = require_lib();
  var onFinished = require_on_finished();
  var zlib = __require("zlib");
  module.exports = read;
  function read(req, res, next, parse, debug, options) {
    var length;
    var opts = options;
    var stream;
    req._body = true;
    var encoding = opts.encoding !== null ? opts.encoding : null;
    var verify = opts.verify;
    try {
      stream = contentstream(req, debug, opts.inflate);
      length = stream.length;
      stream.length = undefined;
    } catch (err) {
      return next(err);
    }
    opts.length = length;
    opts.encoding = verify ? null : encoding;
    if (opts.encoding === null && encoding !== null && !iconv.encodingExists(encoding)) {
      return next(createError(415, 'unsupported charset "' + encoding.toUpperCase() + '"', {
        charset: encoding.toLowerCase(),
        type: "charset.unsupported"
      }));
    }
    debug("read body");
    getBody(stream, opts, function(error, body) {
      if (error) {
        var _error;
        if (error.type === "encoding.unsupported") {
          _error = createError(415, 'unsupported charset "' + encoding.toUpperCase() + '"', {
            charset: encoding.toLowerCase(),
            type: "charset.unsupported"
          });
        } else {
          _error = createError(400, error);
        }
        stream.resume();
        onFinished(req, function onfinished() {
          next(createError(400, _error));
        });
        return;
      }
      if (verify) {
        try {
          debug("verify body");
          verify(req, res, body, encoding);
        } catch (err) {
          next(createError(403, err, {
            body,
            type: err.type || "entity.verify.failed"
          }));
          return;
        }
      }
      var str = body;
      try {
        debug("parse body");
        str = typeof body !== "string" && encoding !== null ? iconv.decode(body, encoding) : body;
        req.body = parse(str);
      } catch (err) {
        next(createError(400, err, {
          body: str,
          type: err.type || "entity.parse.failed"
        }));
        return;
      }
      next();
    });
  }
  function contentstream(req, debug, inflate) {
    var encoding = (req.headers["content-encoding"] || "identity").toLowerCase();
    var length = req.headers["content-length"];
    var stream;
    debug('content-encoding "%s"', encoding);
    if (inflate === false && encoding !== "identity") {
      throw createError(415, "content encoding unsupported", {
        encoding,
        type: "encoding.unsupported"
      });
    }
    switch (encoding) {
      case "deflate":
        stream = zlib.createInflate();
        debug("inflate body");
        req.pipe(stream);
        break;
      case "gzip":
        stream = zlib.createGunzip();
        debug("gunzip body");
        req.pipe(stream);
        break;
      case "identity":
        stream = req;
        stream.length = length;
        break;
      default:
        throw createError(415, 'unsupported content encoding "' + encoding + '"', {
          encoding,
          type: "encoding.unsupported"
        });
    }
    return stream;
  }
});

// node_modules/media-typer/index.js
var require_media_typer = __commonJS((exports) => {
  /*!
   * media-typer
   * Copyright(c) 2014 Douglas Christopher Wilson
   * MIT Licensed
   */
  var paramRegExp = /; *([!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) *= *("(?:[ !\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u0020-\u007e])*"|[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) */g;
  var textRegExp = /^[\u0020-\u007e\u0080-\u00ff]+$/;
  var tokenRegExp = /^[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+$/;
  var qescRegExp = /\\([\u0000-\u007f])/g;
  var quoteRegExp = /([\\"])/g;
  var subtypeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_.-]{0,126}$/;
  var typeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126}$/;
  var typeRegExp = /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/;
  exports.format = format;
  exports.parse = parse;
  function format(obj) {
    if (!obj || typeof obj !== "object") {
      throw new TypeError("argument obj is required");
    }
    var parameters = obj.parameters;
    var subtype = obj.subtype;
    var suffix = obj.suffix;
    var type = obj.type;
    if (!type || !typeNameRegExp.test(type)) {
      throw new TypeError("invalid type");
    }
    if (!subtype || !subtypeNameRegExp.test(subtype)) {
      throw new TypeError("invalid subtype");
    }
    var string = type + "/" + subtype;
    if (suffix) {
      if (!typeNameRegExp.test(suffix)) {
        throw new TypeError("invalid suffix");
      }
      string += "+" + suffix;
    }
    if (parameters && typeof parameters === "object") {
      var param;
      var params = Object.keys(parameters).sort();
      for (var i = 0;i < params.length; i++) {
        param = params[i];
        if (!tokenRegExp.test(param)) {
          throw new TypeError("invalid parameter name");
        }
        string += "; " + param + "=" + qstring(parameters[param]);
      }
    }
    return string;
  }
  function parse(string) {
    if (!string) {
      throw new TypeError("argument string is required");
    }
    if (typeof string === "object") {
      string = getcontenttype(string);
    }
    if (typeof string !== "string") {
      throw new TypeError("argument string is required to be a string");
    }
    var index = string.indexOf(";");
    var type = index !== -1 ? string.substr(0, index) : string;
    var key;
    var match;
    var obj = splitType(type);
    var params = {};
    var value;
    paramRegExp.lastIndex = index;
    while (match = paramRegExp.exec(string)) {
      if (match.index !== index) {
        throw new TypeError("invalid parameter format");
      }
      index += match[0].length;
      key = match[1].toLowerCase();
      value = match[2];
      if (value[0] === '"') {
        value = value.substr(1, value.length - 2).replace(qescRegExp, "$1");
      }
      params[key] = value;
    }
    if (index !== -1 && index !== string.length) {
      throw new TypeError("invalid parameter format");
    }
    obj.parameters = params;
    return obj;
  }
  function getcontenttype(obj) {
    if (typeof obj.getHeader === "function") {
      return obj.getHeader("content-type");
    }
    if (typeof obj.headers === "object") {
      return obj.headers && obj.headers["content-type"];
    }
  }
  function qstring(val) {
    var str = String(val);
    if (tokenRegExp.test(str)) {
      return str;
    }
    if (str.length > 0 && !textRegExp.test(str)) {
      throw new TypeError("invalid parameter value");
    }
    return '"' + str.replace(quoteRegExp, "\\$1") + '"';
  }
  function splitType(string) {
    var match = typeRegExp.exec(string.toLowerCase());
    if (!match) {
      throw new TypeError("invalid media type");
    }
    var type = match[1];
    var subtype = match[2];
    var suffix;
    var index = subtype.lastIndexOf("+");
    if (index !== -1) {
      suffix = subtype.substr(index + 1);
      subtype = subtype.substr(0, index);
    }
    var obj = {
      type,
      subtype,
      suffix
    };
    return obj;
  }
});

// node_modules/mime-db/db.json
var require_db = __commonJS((exports, module) => {
  module.exports = {
    "application/1d-interleaved-parityfec": {
      source: "iana"
    },
    "application/3gpdash-qoe-report+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/3gpp-ims+xml": {
      source: "iana",
      compressible: true
    },
    "application/3gpphal+json": {
      source: "iana",
      compressible: true
    },
    "application/3gpphalforms+json": {
      source: "iana",
      compressible: true
    },
    "application/a2l": {
      source: "iana"
    },
    "application/activemessage": {
      source: "iana"
    },
    "application/activity+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-costmap+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-costmapfilter+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-directory+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointcost+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointcostparams+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointprop+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointpropparams+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-error+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-networkmap+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-networkmapfilter+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-updatestreamcontrol+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-updatestreamparams+json": {
      source: "iana",
      compressible: true
    },
    "application/aml": {
      source: "iana"
    },
    "application/andrew-inset": {
      source: "iana",
      extensions: ["ez"]
    },
    "application/applefile": {
      source: "iana"
    },
    "application/applixware": {
      source: "apache",
      extensions: ["aw"]
    },
    "application/atf": {
      source: "iana"
    },
    "application/atfx": {
      source: "iana"
    },
    "application/atom+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atom"]
    },
    "application/atomcat+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atomcat"]
    },
    "application/atomdeleted+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atomdeleted"]
    },
    "application/atomicmail": {
      source: "iana"
    },
    "application/atomsvc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atomsvc"]
    },
    "application/atsc-dwd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["dwd"]
    },
    "application/atsc-dynamic-event-message": {
      source: "iana"
    },
    "application/atsc-held+xml": {
      source: "iana",
      compressible: true,
      extensions: ["held"]
    },
    "application/atsc-rdt+json": {
      source: "iana",
      compressible: true
    },
    "application/atsc-rsat+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rsat"]
    },
    "application/atxml": {
      source: "iana"
    },
    "application/auth-policy+xml": {
      source: "iana",
      compressible: true
    },
    "application/bacnet-xdd+zip": {
      source: "iana",
      compressible: false
    },
    "application/batch-smtp": {
      source: "iana"
    },
    "application/bdoc": {
      compressible: false,
      extensions: ["bdoc"]
    },
    "application/beep+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/calendar+json": {
      source: "iana",
      compressible: true
    },
    "application/calendar+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xcs"]
    },
    "application/call-completion": {
      source: "iana"
    },
    "application/cals-1840": {
      source: "iana"
    },
    "application/captive+json": {
      source: "iana",
      compressible: true
    },
    "application/cbor": {
      source: "iana"
    },
    "application/cbor-seq": {
      source: "iana"
    },
    "application/cccex": {
      source: "iana"
    },
    "application/ccmp+xml": {
      source: "iana",
      compressible: true
    },
    "application/ccxml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ccxml"]
    },
    "application/cdfx+xml": {
      source: "iana",
      compressible: true,
      extensions: ["cdfx"]
    },
    "application/cdmi-capability": {
      source: "iana",
      extensions: ["cdmia"]
    },
    "application/cdmi-container": {
      source: "iana",
      extensions: ["cdmic"]
    },
    "application/cdmi-domain": {
      source: "iana",
      extensions: ["cdmid"]
    },
    "application/cdmi-object": {
      source: "iana",
      extensions: ["cdmio"]
    },
    "application/cdmi-queue": {
      source: "iana",
      extensions: ["cdmiq"]
    },
    "application/cdni": {
      source: "iana"
    },
    "application/cea": {
      source: "iana"
    },
    "application/cea-2018+xml": {
      source: "iana",
      compressible: true
    },
    "application/cellml+xml": {
      source: "iana",
      compressible: true
    },
    "application/cfw": {
      source: "iana"
    },
    "application/clr": {
      source: "iana"
    },
    "application/clue+xml": {
      source: "iana",
      compressible: true
    },
    "application/clue_info+xml": {
      source: "iana",
      compressible: true
    },
    "application/cms": {
      source: "iana"
    },
    "application/cnrp+xml": {
      source: "iana",
      compressible: true
    },
    "application/coap-group+json": {
      source: "iana",
      compressible: true
    },
    "application/coap-payload": {
      source: "iana"
    },
    "application/commonground": {
      source: "iana"
    },
    "application/conference-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/cose": {
      source: "iana"
    },
    "application/cose-key": {
      source: "iana"
    },
    "application/cose-key-set": {
      source: "iana"
    },
    "application/cpl+xml": {
      source: "iana",
      compressible: true
    },
    "application/csrattrs": {
      source: "iana"
    },
    "application/csta+xml": {
      source: "iana",
      compressible: true
    },
    "application/cstadata+xml": {
      source: "iana",
      compressible: true
    },
    "application/csvm+json": {
      source: "iana",
      compressible: true
    },
    "application/cu-seeme": {
      source: "apache",
      extensions: ["cu"]
    },
    "application/cwt": {
      source: "iana"
    },
    "application/cybercash": {
      source: "iana"
    },
    "application/dart": {
      compressible: true
    },
    "application/dash+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpd"]
    },
    "application/dashdelta": {
      source: "iana"
    },
    "application/davmount+xml": {
      source: "iana",
      compressible: true,
      extensions: ["davmount"]
    },
    "application/dca-rft": {
      source: "iana"
    },
    "application/dcd": {
      source: "iana"
    },
    "application/dec-dx": {
      source: "iana"
    },
    "application/dialog-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/dicom": {
      source: "iana"
    },
    "application/dicom+json": {
      source: "iana",
      compressible: true
    },
    "application/dicom+xml": {
      source: "iana",
      compressible: true
    },
    "application/dii": {
      source: "iana"
    },
    "application/dit": {
      source: "iana"
    },
    "application/dns": {
      source: "iana"
    },
    "application/dns+json": {
      source: "iana",
      compressible: true
    },
    "application/dns-message": {
      source: "iana"
    },
    "application/docbook+xml": {
      source: "apache",
      compressible: true,
      extensions: ["dbk"]
    },
    "application/dots+cbor": {
      source: "iana"
    },
    "application/dskpp+xml": {
      source: "iana",
      compressible: true
    },
    "application/dssc+der": {
      source: "iana",
      extensions: ["dssc"]
    },
    "application/dssc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xdssc"]
    },
    "application/dvcs": {
      source: "iana"
    },
    "application/ecmascript": {
      source: "iana",
      compressible: true,
      extensions: ["es", "ecma"]
    },
    "application/edi-consent": {
      source: "iana"
    },
    "application/edi-x12": {
      source: "iana",
      compressible: false
    },
    "application/edifact": {
      source: "iana",
      compressible: false
    },
    "application/efi": {
      source: "iana"
    },
    "application/elm+json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/elm+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.cap+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/emergencycalldata.comment+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.control+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.deviceinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.ecall.msd": {
      source: "iana"
    },
    "application/emergencycalldata.providerinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.serviceinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.subscriberinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.veds+xml": {
      source: "iana",
      compressible: true
    },
    "application/emma+xml": {
      source: "iana",
      compressible: true,
      extensions: ["emma"]
    },
    "application/emotionml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["emotionml"]
    },
    "application/encaprtp": {
      source: "iana"
    },
    "application/epp+xml": {
      source: "iana",
      compressible: true
    },
    "application/epub+zip": {
      source: "iana",
      compressible: false,
      extensions: ["epub"]
    },
    "application/eshop": {
      source: "iana"
    },
    "application/exi": {
      source: "iana",
      extensions: ["exi"]
    },
    "application/expect-ct-report+json": {
      source: "iana",
      compressible: true
    },
    "application/fastinfoset": {
      source: "iana"
    },
    "application/fastsoap": {
      source: "iana"
    },
    "application/fdt+xml": {
      source: "iana",
      compressible: true,
      extensions: ["fdt"]
    },
    "application/fhir+json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/fhir+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/fido.trusted-apps+json": {
      compressible: true
    },
    "application/fits": {
      source: "iana"
    },
    "application/flexfec": {
      source: "iana"
    },
    "application/font-sfnt": {
      source: "iana"
    },
    "application/font-tdpfr": {
      source: "iana",
      extensions: ["pfr"]
    },
    "application/font-woff": {
      source: "iana",
      compressible: false
    },
    "application/framework-attributes+xml": {
      source: "iana",
      compressible: true
    },
    "application/geo+json": {
      source: "iana",
      compressible: true,
      extensions: ["geojson"]
    },
    "application/geo+json-seq": {
      source: "iana"
    },
    "application/geopackage+sqlite3": {
      source: "iana"
    },
    "application/geoxacml+xml": {
      source: "iana",
      compressible: true
    },
    "application/gltf-buffer": {
      source: "iana"
    },
    "application/gml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["gml"]
    },
    "application/gpx+xml": {
      source: "apache",
      compressible: true,
      extensions: ["gpx"]
    },
    "application/gxf": {
      source: "apache",
      extensions: ["gxf"]
    },
    "application/gzip": {
      source: "iana",
      compressible: false,
      extensions: ["gz"]
    },
    "application/h224": {
      source: "iana"
    },
    "application/held+xml": {
      source: "iana",
      compressible: true
    },
    "application/hjson": {
      extensions: ["hjson"]
    },
    "application/http": {
      source: "iana"
    },
    "application/hyperstudio": {
      source: "iana",
      extensions: ["stk"]
    },
    "application/ibe-key-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/ibe-pkg-reply+xml": {
      source: "iana",
      compressible: true
    },
    "application/ibe-pp-data": {
      source: "iana"
    },
    "application/iges": {
      source: "iana"
    },
    "application/im-iscomposing+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/index": {
      source: "iana"
    },
    "application/index.cmd": {
      source: "iana"
    },
    "application/index.obj": {
      source: "iana"
    },
    "application/index.response": {
      source: "iana"
    },
    "application/index.vnd": {
      source: "iana"
    },
    "application/inkml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ink", "inkml"]
    },
    "application/iotp": {
      source: "iana"
    },
    "application/ipfix": {
      source: "iana",
      extensions: ["ipfix"]
    },
    "application/ipp": {
      source: "iana"
    },
    "application/isup": {
      source: "iana"
    },
    "application/its+xml": {
      source: "iana",
      compressible: true,
      extensions: ["its"]
    },
    "application/java-archive": {
      source: "apache",
      compressible: false,
      extensions: ["jar", "war", "ear"]
    },
    "application/java-serialized-object": {
      source: "apache",
      compressible: false,
      extensions: ["ser"]
    },
    "application/java-vm": {
      source: "apache",
      compressible: false,
      extensions: ["class"]
    },
    "application/javascript": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["js", "mjs"]
    },
    "application/jf2feed+json": {
      source: "iana",
      compressible: true
    },
    "application/jose": {
      source: "iana"
    },
    "application/jose+json": {
      source: "iana",
      compressible: true
    },
    "application/jrd+json": {
      source: "iana",
      compressible: true
    },
    "application/jscalendar+json": {
      source: "iana",
      compressible: true
    },
    "application/json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["json", "map"]
    },
    "application/json-patch+json": {
      source: "iana",
      compressible: true
    },
    "application/json-seq": {
      source: "iana"
    },
    "application/json5": {
      extensions: ["json5"]
    },
    "application/jsonml+json": {
      source: "apache",
      compressible: true,
      extensions: ["jsonml"]
    },
    "application/jwk+json": {
      source: "iana",
      compressible: true
    },
    "application/jwk-set+json": {
      source: "iana",
      compressible: true
    },
    "application/jwt": {
      source: "iana"
    },
    "application/kpml-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/kpml-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/ld+json": {
      source: "iana",
      compressible: true,
      extensions: ["jsonld"]
    },
    "application/lgr+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lgr"]
    },
    "application/link-format": {
      source: "iana"
    },
    "application/load-control+xml": {
      source: "iana",
      compressible: true
    },
    "application/lost+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lostxml"]
    },
    "application/lostsync+xml": {
      source: "iana",
      compressible: true
    },
    "application/lpf+zip": {
      source: "iana",
      compressible: false
    },
    "application/lxf": {
      source: "iana"
    },
    "application/mac-binhex40": {
      source: "iana",
      extensions: ["hqx"]
    },
    "application/mac-compactpro": {
      source: "apache",
      extensions: ["cpt"]
    },
    "application/macwriteii": {
      source: "iana"
    },
    "application/mads+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mads"]
    },
    "application/manifest+json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["webmanifest"]
    },
    "application/marc": {
      source: "iana",
      extensions: ["mrc"]
    },
    "application/marcxml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mrcx"]
    },
    "application/mathematica": {
      source: "iana",
      extensions: ["ma", "nb", "mb"]
    },
    "application/mathml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mathml"]
    },
    "application/mathml-content+xml": {
      source: "iana",
      compressible: true
    },
    "application/mathml-presentation+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-associated-procedure-description+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-deregister+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-envelope+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-msk+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-msk-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-protection-description+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-reception-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-register+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-register-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-schedule+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-user-service-description+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbox": {
      source: "iana",
      extensions: ["mbox"]
    },
    "application/media-policy-dataset+xml": {
      source: "iana",
      compressible: true
    },
    "application/media_control+xml": {
      source: "iana",
      compressible: true
    },
    "application/mediaservercontrol+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mscml"]
    },
    "application/merge-patch+json": {
      source: "iana",
      compressible: true
    },
    "application/metalink+xml": {
      source: "apache",
      compressible: true,
      extensions: ["metalink"]
    },
    "application/metalink4+xml": {
      source: "iana",
      compressible: true,
      extensions: ["meta4"]
    },
    "application/mets+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mets"]
    },
    "application/mf4": {
      source: "iana"
    },
    "application/mikey": {
      source: "iana"
    },
    "application/mipc": {
      source: "iana"
    },
    "application/missing-blocks+cbor-seq": {
      source: "iana"
    },
    "application/mmt-aei+xml": {
      source: "iana",
      compressible: true,
      extensions: ["maei"]
    },
    "application/mmt-usd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["musd"]
    },
    "application/mods+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mods"]
    },
    "application/moss-keys": {
      source: "iana"
    },
    "application/moss-signature": {
      source: "iana"
    },
    "application/mosskey-data": {
      source: "iana"
    },
    "application/mosskey-request": {
      source: "iana"
    },
    "application/mp21": {
      source: "iana",
      extensions: ["m21", "mp21"]
    },
    "application/mp4": {
      source: "iana",
      extensions: ["mp4s", "m4p"]
    },
    "application/mpeg4-generic": {
      source: "iana"
    },
    "application/mpeg4-iod": {
      source: "iana"
    },
    "application/mpeg4-iod-xmt": {
      source: "iana"
    },
    "application/mrb-consumer+xml": {
      source: "iana",
      compressible: true
    },
    "application/mrb-publish+xml": {
      source: "iana",
      compressible: true
    },
    "application/msc-ivr+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/msc-mixer+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/msword": {
      source: "iana",
      compressible: false,
      extensions: ["doc", "dot"]
    },
    "application/mud+json": {
      source: "iana",
      compressible: true
    },
    "application/multipart-core": {
      source: "iana"
    },
    "application/mxf": {
      source: "iana",
      extensions: ["mxf"]
    },
    "application/n-quads": {
      source: "iana",
      extensions: ["nq"]
    },
    "application/n-triples": {
      source: "iana",
      extensions: ["nt"]
    },
    "application/nasdata": {
      source: "iana"
    },
    "application/news-checkgroups": {
      source: "iana",
      charset: "US-ASCII"
    },
    "application/news-groupinfo": {
      source: "iana",
      charset: "US-ASCII"
    },
    "application/news-transmission": {
      source: "iana"
    },
    "application/nlsml+xml": {
      source: "iana",
      compressible: true
    },
    "application/node": {
      source: "iana",
      extensions: ["cjs"]
    },
    "application/nss": {
      source: "iana"
    },
    "application/oauth-authz-req+jwt": {
      source: "iana"
    },
    "application/ocsp-request": {
      source: "iana"
    },
    "application/ocsp-response": {
      source: "iana"
    },
    "application/octet-stream": {
      source: "iana",
      compressible: false,
      extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
    },
    "application/oda": {
      source: "iana",
      extensions: ["oda"]
    },
    "application/odm+xml": {
      source: "iana",
      compressible: true
    },
    "application/odx": {
      source: "iana"
    },
    "application/oebps-package+xml": {
      source: "iana",
      compressible: true,
      extensions: ["opf"]
    },
    "application/ogg": {
      source: "iana",
      compressible: false,
      extensions: ["ogx"]
    },
    "application/omdoc+xml": {
      source: "apache",
      compressible: true,
      extensions: ["omdoc"]
    },
    "application/onenote": {
      source: "apache",
      extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
    },
    "application/opc-nodeset+xml": {
      source: "iana",
      compressible: true
    },
    "application/oscore": {
      source: "iana"
    },
    "application/oxps": {
      source: "iana",
      extensions: ["oxps"]
    },
    "application/p21+zip": {
      source: "iana",
      compressible: false
    },
    "application/p2p-overlay+xml": {
      source: "iana",
      compressible: true,
      extensions: ["relo"]
    },
    "application/parityfec": {
      source: "iana"
    },
    "application/passport": {
      source: "iana"
    },
    "application/patch-ops-error+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xer"]
    },
    "application/pdf": {
      source: "iana",
      compressible: false,
      extensions: ["pdf"]
    },
    "application/pdx": {
      source: "iana"
    },
    "application/pem-certificate-chain": {
      source: "iana"
    },
    "application/pgp-encrypted": {
      source: "iana",
      compressible: false,
      extensions: ["pgp"]
    },
    "application/pgp-keys": {
      source: "iana"
    },
    "application/pgp-signature": {
      source: "iana",
      extensions: ["asc", "sig"]
    },
    "application/pics-rules": {
      source: "apache",
      extensions: ["prf"]
    },
    "application/pidf+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/pidf-diff+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/pkcs10": {
      source: "iana",
      extensions: ["p10"]
    },
    "application/pkcs12": {
      source: "iana"
    },
    "application/pkcs7-mime": {
      source: "iana",
      extensions: ["p7m", "p7c"]
    },
    "application/pkcs7-signature": {
      source: "iana",
      extensions: ["p7s"]
    },
    "application/pkcs8": {
      source: "iana",
      extensions: ["p8"]
    },
    "application/pkcs8-encrypted": {
      source: "iana"
    },
    "application/pkix-attr-cert": {
      source: "iana",
      extensions: ["ac"]
    },
    "application/pkix-cert": {
      source: "iana",
      extensions: ["cer"]
    },
    "application/pkix-crl": {
      source: "iana",
      extensions: ["crl"]
    },
    "application/pkix-pkipath": {
      source: "iana",
      extensions: ["pkipath"]
    },
    "application/pkixcmp": {
      source: "iana",
      extensions: ["pki"]
    },
    "application/pls+xml": {
      source: "iana",
      compressible: true,
      extensions: ["pls"]
    },
    "application/poc-settings+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/postscript": {
      source: "iana",
      compressible: true,
      extensions: ["ai", "eps", "ps"]
    },
    "application/ppsp-tracker+json": {
      source: "iana",
      compressible: true
    },
    "application/problem+json": {
      source: "iana",
      compressible: true
    },
    "application/problem+xml": {
      source: "iana",
      compressible: true
    },
    "application/provenance+xml": {
      source: "iana",
      compressible: true,
      extensions: ["provx"]
    },
    "application/prs.alvestrand.titrax-sheet": {
      source: "iana"
    },
    "application/prs.cww": {
      source: "iana",
      extensions: ["cww"]
    },
    "application/prs.cyn": {
      source: "iana",
      charset: "7-BIT"
    },
    "application/prs.hpub+zip": {
      source: "iana",
      compressible: false
    },
    "application/prs.nprend": {
      source: "iana"
    },
    "application/prs.plucker": {
      source: "iana"
    },
    "application/prs.rdf-xml-crypt": {
      source: "iana"
    },
    "application/prs.xsf+xml": {
      source: "iana",
      compressible: true
    },
    "application/pskc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["pskcxml"]
    },
    "application/pvd+json": {
      source: "iana",
      compressible: true
    },
    "application/qsig": {
      source: "iana"
    },
    "application/raml+yaml": {
      compressible: true,
      extensions: ["raml"]
    },
    "application/raptorfec": {
      source: "iana"
    },
    "application/rdap+json": {
      source: "iana",
      compressible: true
    },
    "application/rdf+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rdf", "owl"]
    },
    "application/reginfo+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rif"]
    },
    "application/relax-ng-compact-syntax": {
      source: "iana",
      extensions: ["rnc"]
    },
    "application/remote-printing": {
      source: "iana"
    },
    "application/reputon+json": {
      source: "iana",
      compressible: true
    },
    "application/resource-lists+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rl"]
    },
    "application/resource-lists-diff+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rld"]
    },
    "application/rfc+xml": {
      source: "iana",
      compressible: true
    },
    "application/riscos": {
      source: "iana"
    },
    "application/rlmi+xml": {
      source: "iana",
      compressible: true
    },
    "application/rls-services+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rs"]
    },
    "application/route-apd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rapd"]
    },
    "application/route-s-tsid+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sls"]
    },
    "application/route-usd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rusd"]
    },
    "application/rpki-ghostbusters": {
      source: "iana",
      extensions: ["gbr"]
    },
    "application/rpki-manifest": {
      source: "iana",
      extensions: ["mft"]
    },
    "application/rpki-publication": {
      source: "iana"
    },
    "application/rpki-roa": {
      source: "iana",
      extensions: ["roa"]
    },
    "application/rpki-updown": {
      source: "iana"
    },
    "application/rsd+xml": {
      source: "apache",
      compressible: true,
      extensions: ["rsd"]
    },
    "application/rss+xml": {
      source: "apache",
      compressible: true,
      extensions: ["rss"]
    },
    "application/rtf": {
      source: "iana",
      compressible: true,
      extensions: ["rtf"]
    },
    "application/rtploopback": {
      source: "iana"
    },
    "application/rtx": {
      source: "iana"
    },
    "application/samlassertion+xml": {
      source: "iana",
      compressible: true
    },
    "application/samlmetadata+xml": {
      source: "iana",
      compressible: true
    },
    "application/sarif+json": {
      source: "iana",
      compressible: true
    },
    "application/sarif-external-properties+json": {
      source: "iana",
      compressible: true
    },
    "application/sbe": {
      source: "iana"
    },
    "application/sbml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sbml"]
    },
    "application/scaip+xml": {
      source: "iana",
      compressible: true
    },
    "application/scim+json": {
      source: "iana",
      compressible: true
    },
    "application/scvp-cv-request": {
      source: "iana",
      extensions: ["scq"]
    },
    "application/scvp-cv-response": {
      source: "iana",
      extensions: ["scs"]
    },
    "application/scvp-vp-request": {
      source: "iana",
      extensions: ["spq"]
    },
    "application/scvp-vp-response": {
      source: "iana",
      extensions: ["spp"]
    },
    "application/sdp": {
      source: "iana",
      extensions: ["sdp"]
    },
    "application/secevent+jwt": {
      source: "iana"
    },
    "application/senml+cbor": {
      source: "iana"
    },
    "application/senml+json": {
      source: "iana",
      compressible: true
    },
    "application/senml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["senmlx"]
    },
    "application/senml-etch+cbor": {
      source: "iana"
    },
    "application/senml-etch+json": {
      source: "iana",
      compressible: true
    },
    "application/senml-exi": {
      source: "iana"
    },
    "application/sensml+cbor": {
      source: "iana"
    },
    "application/sensml+json": {
      source: "iana",
      compressible: true
    },
    "application/sensml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sensmlx"]
    },
    "application/sensml-exi": {
      source: "iana"
    },
    "application/sep+xml": {
      source: "iana",
      compressible: true
    },
    "application/sep-exi": {
      source: "iana"
    },
    "application/session-info": {
      source: "iana"
    },
    "application/set-payment": {
      source: "iana"
    },
    "application/set-payment-initiation": {
      source: "iana",
      extensions: ["setpay"]
    },
    "application/set-registration": {
      source: "iana"
    },
    "application/set-registration-initiation": {
      source: "iana",
      extensions: ["setreg"]
    },
    "application/sgml": {
      source: "iana"
    },
    "application/sgml-open-catalog": {
      source: "iana"
    },
    "application/shf+xml": {
      source: "iana",
      compressible: true,
      extensions: ["shf"]
    },
    "application/sieve": {
      source: "iana",
      extensions: ["siv", "sieve"]
    },
    "application/simple-filter+xml": {
      source: "iana",
      compressible: true
    },
    "application/simple-message-summary": {
      source: "iana"
    },
    "application/simplesymbolcontainer": {
      source: "iana"
    },
    "application/sipc": {
      source: "iana"
    },
    "application/slate": {
      source: "iana"
    },
    "application/smil": {
      source: "iana"
    },
    "application/smil+xml": {
      source: "iana",
      compressible: true,
      extensions: ["smi", "smil"]
    },
    "application/smpte336m": {
      source: "iana"
    },
    "application/soap+fastinfoset": {
      source: "iana"
    },
    "application/soap+xml": {
      source: "iana",
      compressible: true
    },
    "application/sparql-query": {
      source: "iana",
      extensions: ["rq"]
    },
    "application/sparql-results+xml": {
      source: "iana",
      compressible: true,
      extensions: ["srx"]
    },
    "application/spirits-event+xml": {
      source: "iana",
      compressible: true
    },
    "application/sql": {
      source: "iana"
    },
    "application/srgs": {
      source: "iana",
      extensions: ["gram"]
    },
    "application/srgs+xml": {
      source: "iana",
      compressible: true,
      extensions: ["grxml"]
    },
    "application/sru+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sru"]
    },
    "application/ssdl+xml": {
      source: "apache",
      compressible: true,
      extensions: ["ssdl"]
    },
    "application/ssml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ssml"]
    },
    "application/stix+json": {
      source: "iana",
      compressible: true
    },
    "application/swid+xml": {
      source: "iana",
      compressible: true,
      extensions: ["swidtag"]
    },
    "application/tamp-apex-update": {
      source: "iana"
    },
    "application/tamp-apex-update-confirm": {
      source: "iana"
    },
    "application/tamp-community-update": {
      source: "iana"
    },
    "application/tamp-community-update-confirm": {
      source: "iana"
    },
    "application/tamp-error": {
      source: "iana"
    },
    "application/tamp-sequence-adjust": {
      source: "iana"
    },
    "application/tamp-sequence-adjust-confirm": {
      source: "iana"
    },
    "application/tamp-status-query": {
      source: "iana"
    },
    "application/tamp-status-response": {
      source: "iana"
    },
    "application/tamp-update": {
      source: "iana"
    },
    "application/tamp-update-confirm": {
      source: "iana"
    },
    "application/tar": {
      compressible: true
    },
    "application/taxii+json": {
      source: "iana",
      compressible: true
    },
    "application/td+json": {
      source: "iana",
      compressible: true
    },
    "application/tei+xml": {
      source: "iana",
      compressible: true,
      extensions: ["tei", "teicorpus"]
    },
    "application/tetra_isi": {
      source: "iana"
    },
    "application/thraud+xml": {
      source: "iana",
      compressible: true,
      extensions: ["tfi"]
    },
    "application/timestamp-query": {
      source: "iana"
    },
    "application/timestamp-reply": {
      source: "iana"
    },
    "application/timestamped-data": {
      source: "iana",
      extensions: ["tsd"]
    },
    "application/tlsrpt+gzip": {
      source: "iana"
    },
    "application/tlsrpt+json": {
      source: "iana",
      compressible: true
    },
    "application/tnauthlist": {
      source: "iana"
    },
    "application/toml": {
      compressible: true,
      extensions: ["toml"]
    },
    "application/trickle-ice-sdpfrag": {
      source: "iana"
    },
    "application/trig": {
      source: "iana",
      extensions: ["trig"]
    },
    "application/ttml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ttml"]
    },
    "application/tve-trigger": {
      source: "iana"
    },
    "application/tzif": {
      source: "iana"
    },
    "application/tzif-leap": {
      source: "iana"
    },
    "application/ubjson": {
      compressible: false,
      extensions: ["ubj"]
    },
    "application/ulpfec": {
      source: "iana"
    },
    "application/urc-grpsheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/urc-ressheet+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rsheet"]
    },
    "application/urc-targetdesc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["td"]
    },
    "application/urc-uisocketdesc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vcard+json": {
      source: "iana",
      compressible: true
    },
    "application/vcard+xml": {
      source: "iana",
      compressible: true
    },
    "application/vemmi": {
      source: "iana"
    },
    "application/vividence.scriptfile": {
      source: "apache"
    },
    "application/vnd.1000minds.decision-model+xml": {
      source: "iana",
      compressible: true,
      extensions: ["1km"]
    },
    "application/vnd.3gpp-prose+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp-prose-pc3ch+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp-v2x-local-service-information": {
      source: "iana"
    },
    "application/vnd.3gpp.5gnas": {
      source: "iana"
    },
    "application/vnd.3gpp.access-transfer-events+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.bsf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.gmop+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.gtpc": {
      source: "iana"
    },
    "application/vnd.3gpp.interworking-data": {
      source: "iana"
    },
    "application/vnd.3gpp.lpp": {
      source: "iana"
    },
    "application/vnd.3gpp.mc-signalling-ear": {
      source: "iana"
    },
    "application/vnd.3gpp.mcdata-affiliation-command+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-payload": {
      source: "iana"
    },
    "application/vnd.3gpp.mcdata-service-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-signalling": {
      source: "iana"
    },
    "application/vnd.3gpp.mcdata-ue-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-user-profile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-affiliation-command+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-floor-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-location-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-service-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-signed+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-ue-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-ue-init-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-user-profile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-location-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-service-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-transmission-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-ue-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-user-profile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mid-call+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.ngap": {
      source: "iana"
    },
    "application/vnd.3gpp.pfcp": {
      source: "iana"
    },
    "application/vnd.3gpp.pic-bw-large": {
      source: "iana",
      extensions: ["plb"]
    },
    "application/vnd.3gpp.pic-bw-small": {
      source: "iana",
      extensions: ["psb"]
    },
    "application/vnd.3gpp.pic-bw-var": {
      source: "iana",
      extensions: ["pvb"]
    },
    "application/vnd.3gpp.s1ap": {
      source: "iana"
    },
    "application/vnd.3gpp.sms": {
      source: "iana"
    },
    "application/vnd.3gpp.sms+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.srvcc-ext+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.srvcc-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.state-and-event-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.ussd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp2.bcmcsinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp2.sms": {
      source: "iana"
    },
    "application/vnd.3gpp2.tcap": {
      source: "iana",
      extensions: ["tcap"]
    },
    "application/vnd.3lightssoftware.imagescal": {
      source: "iana"
    },
    "application/vnd.3m.post-it-notes": {
      source: "iana",
      extensions: ["pwn"]
    },
    "application/vnd.accpac.simply.aso": {
      source: "iana",
      extensions: ["aso"]
    },
    "application/vnd.accpac.simply.imp": {
      source: "iana",
      extensions: ["imp"]
    },
    "application/vnd.acucobol": {
      source: "iana",
      extensions: ["acu"]
    },
    "application/vnd.acucorp": {
      source: "iana",
      extensions: ["atc", "acutc"]
    },
    "application/vnd.adobe.air-application-installer-package+zip": {
      source: "apache",
      compressible: false,
      extensions: ["air"]
    },
    "application/vnd.adobe.flash.movie": {
      source: "iana"
    },
    "application/vnd.adobe.formscentral.fcdt": {
      source: "iana",
      extensions: ["fcdt"]
    },
    "application/vnd.adobe.fxp": {
      source: "iana",
      extensions: ["fxp", "fxpl"]
    },
    "application/vnd.adobe.partial-upload": {
      source: "iana"
    },
    "application/vnd.adobe.xdp+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xdp"]
    },
    "application/vnd.adobe.xfdf": {
      source: "iana",
      extensions: ["xfdf"]
    },
    "application/vnd.aether.imp": {
      source: "iana"
    },
    "application/vnd.afpc.afplinedata": {
      source: "iana"
    },
    "application/vnd.afpc.afplinedata-pagedef": {
      source: "iana"
    },
    "application/vnd.afpc.cmoca-cmresource": {
      source: "iana"
    },
    "application/vnd.afpc.foca-charset": {
      source: "iana"
    },
    "application/vnd.afpc.foca-codedfont": {
      source: "iana"
    },
    "application/vnd.afpc.foca-codepage": {
      source: "iana"
    },
    "application/vnd.afpc.modca": {
      source: "iana"
    },
    "application/vnd.afpc.modca-cmtable": {
      source: "iana"
    },
    "application/vnd.afpc.modca-formdef": {
      source: "iana"
    },
    "application/vnd.afpc.modca-mediummap": {
      source: "iana"
    },
    "application/vnd.afpc.modca-objectcontainer": {
      source: "iana"
    },
    "application/vnd.afpc.modca-overlay": {
      source: "iana"
    },
    "application/vnd.afpc.modca-pagesegment": {
      source: "iana"
    },
    "application/vnd.ah-barcode": {
      source: "iana"
    },
    "application/vnd.ahead.space": {
      source: "iana",
      extensions: ["ahead"]
    },
    "application/vnd.airzip.filesecure.azf": {
      source: "iana",
      extensions: ["azf"]
    },
    "application/vnd.airzip.filesecure.azs": {
      source: "iana",
      extensions: ["azs"]
    },
    "application/vnd.amadeus+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.amazon.ebook": {
      source: "apache",
      extensions: ["azw"]
    },
    "application/vnd.amazon.mobi8-ebook": {
      source: "iana"
    },
    "application/vnd.americandynamics.acc": {
      source: "iana",
      extensions: ["acc"]
    },
    "application/vnd.amiga.ami": {
      source: "iana",
      extensions: ["ami"]
    },
    "application/vnd.amundsen.maze+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.android.ota": {
      source: "iana"
    },
    "application/vnd.android.package-archive": {
      source: "apache",
      compressible: false,
      extensions: ["apk"]
    },
    "application/vnd.anki": {
      source: "iana"
    },
    "application/vnd.anser-web-certificate-issue-initiation": {
      source: "iana",
      extensions: ["cii"]
    },
    "application/vnd.anser-web-funds-transfer-initiation": {
      source: "apache",
      extensions: ["fti"]
    },
    "application/vnd.antix.game-component": {
      source: "iana",
      extensions: ["atx"]
    },
    "application/vnd.apache.arrow.file": {
      source: "iana"
    },
    "application/vnd.apache.arrow.stream": {
      source: "iana"
    },
    "application/vnd.apache.thrift.binary": {
      source: "iana"
    },
    "application/vnd.apache.thrift.compact": {
      source: "iana"
    },
    "application/vnd.apache.thrift.json": {
      source: "iana"
    },
    "application/vnd.api+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.aplextor.warrp+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.apothekende.reservation+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.apple.installer+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpkg"]
    },
    "application/vnd.apple.keynote": {
      source: "iana",
      extensions: ["key"]
    },
    "application/vnd.apple.mpegurl": {
      source: "iana",
      extensions: ["m3u8"]
    },
    "application/vnd.apple.numbers": {
      source: "iana",
      extensions: ["numbers"]
    },
    "application/vnd.apple.pages": {
      source: "iana",
      extensions: ["pages"]
    },
    "application/vnd.apple.pkpass": {
      compressible: false,
      extensions: ["pkpass"]
    },
    "application/vnd.arastra.swi": {
      source: "iana"
    },
    "application/vnd.aristanetworks.swi": {
      source: "iana",
      extensions: ["swi"]
    },
    "application/vnd.artisan+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.artsquare": {
      source: "iana"
    },
    "application/vnd.astraea-software.iota": {
      source: "iana",
      extensions: ["iota"]
    },
    "application/vnd.audiograph": {
      source: "iana",
      extensions: ["aep"]
    },
    "application/vnd.autopackage": {
      source: "iana"
    },
    "application/vnd.avalon+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.avistar+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.balsamiq.bmml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["bmml"]
    },
    "application/vnd.balsamiq.bmpr": {
      source: "iana"
    },
    "application/vnd.banana-accounting": {
      source: "iana"
    },
    "application/vnd.bbf.usp.error": {
      source: "iana"
    },
    "application/vnd.bbf.usp.msg": {
      source: "iana"
    },
    "application/vnd.bbf.usp.msg+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.bekitzur-stech+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.bint.med-content": {
      source: "iana"
    },
    "application/vnd.biopax.rdf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.blink-idb-value-wrapper": {
      source: "iana"
    },
    "application/vnd.blueice.multipass": {
      source: "iana",
      extensions: ["mpm"]
    },
    "application/vnd.bluetooth.ep.oob": {
      source: "iana"
    },
    "application/vnd.bluetooth.le.oob": {
      source: "iana"
    },
    "application/vnd.bmi": {
      source: "iana",
      extensions: ["bmi"]
    },
    "application/vnd.bpf": {
      source: "iana"
    },
    "application/vnd.bpf3": {
      source: "iana"
    },
    "application/vnd.businessobjects": {
      source: "iana",
      extensions: ["rep"]
    },
    "application/vnd.byu.uapi+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cab-jscript": {
      source: "iana"
    },
    "application/vnd.canon-cpdl": {
      source: "iana"
    },
    "application/vnd.canon-lips": {
      source: "iana"
    },
    "application/vnd.capasystems-pg+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cendio.thinlinc.clientconf": {
      source: "iana"
    },
    "application/vnd.century-systems.tcp_stream": {
      source: "iana"
    },
    "application/vnd.chemdraw+xml": {
      source: "iana",
      compressible: true,
      extensions: ["cdxml"]
    },
    "application/vnd.chess-pgn": {
      source: "iana"
    },
    "application/vnd.chipnuts.karaoke-mmd": {
      source: "iana",
      extensions: ["mmd"]
    },
    "application/vnd.ciedi": {
      source: "iana"
    },
    "application/vnd.cinderella": {
      source: "iana",
      extensions: ["cdy"]
    },
    "application/vnd.cirpack.isdn-ext": {
      source: "iana"
    },
    "application/vnd.citationstyles.style+xml": {
      source: "iana",
      compressible: true,
      extensions: ["csl"]
    },
    "application/vnd.claymore": {
      source: "iana",
      extensions: ["cla"]
    },
    "application/vnd.cloanto.rp9": {
      source: "iana",
      extensions: ["rp9"]
    },
    "application/vnd.clonk.c4group": {
      source: "iana",
      extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
    },
    "application/vnd.cluetrust.cartomobile-config": {
      source: "iana",
      extensions: ["c11amc"]
    },
    "application/vnd.cluetrust.cartomobile-config-pkg": {
      source: "iana",
      extensions: ["c11amz"]
    },
    "application/vnd.coffeescript": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.document": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.document-template": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.presentation": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.presentation-template": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.spreadsheet": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.spreadsheet-template": {
      source: "iana"
    },
    "application/vnd.collection+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.collection.doc+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.collection.next+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.comicbook+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.comicbook-rar": {
      source: "iana"
    },
    "application/vnd.commerce-battelle": {
      source: "iana"
    },
    "application/vnd.commonspace": {
      source: "iana",
      extensions: ["csp"]
    },
    "application/vnd.contact.cmsg": {
      source: "iana",
      extensions: ["cdbcmsg"]
    },
    "application/vnd.coreos.ignition+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cosmocaller": {
      source: "iana",
      extensions: ["cmc"]
    },
    "application/vnd.crick.clicker": {
      source: "iana",
      extensions: ["clkx"]
    },
    "application/vnd.crick.clicker.keyboard": {
      source: "iana",
      extensions: ["clkk"]
    },
    "application/vnd.crick.clicker.palette": {
      source: "iana",
      extensions: ["clkp"]
    },
    "application/vnd.crick.clicker.template": {
      source: "iana",
      extensions: ["clkt"]
    },
    "application/vnd.crick.clicker.wordbank": {
      source: "iana",
      extensions: ["clkw"]
    },
    "application/vnd.criticaltools.wbs+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wbs"]
    },
    "application/vnd.cryptii.pipe+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.crypto-shade-file": {
      source: "iana"
    },
    "application/vnd.cryptomator.encrypted": {
      source: "iana"
    },
    "application/vnd.cryptomator.vault": {
      source: "iana"
    },
    "application/vnd.ctc-posml": {
      source: "iana",
      extensions: ["pml"]
    },
    "application/vnd.ctct.ws+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cups-pdf": {
      source: "iana"
    },
    "application/vnd.cups-postscript": {
      source: "iana"
    },
    "application/vnd.cups-ppd": {
      source: "iana",
      extensions: ["ppd"]
    },
    "application/vnd.cups-raster": {
      source: "iana"
    },
    "application/vnd.cups-raw": {
      source: "iana"
    },
    "application/vnd.curl": {
      source: "iana"
    },
    "application/vnd.curl.car": {
      source: "apache",
      extensions: ["car"]
    },
    "application/vnd.curl.pcurl": {
      source: "apache",
      extensions: ["pcurl"]
    },
    "application/vnd.cyan.dean.root+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cybank": {
      source: "iana"
    },
    "application/vnd.cyclonedx+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cyclonedx+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.d2l.coursepackage1p0+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.d3m-dataset": {
      source: "iana"
    },
    "application/vnd.d3m-problem": {
      source: "iana"
    },
    "application/vnd.dart": {
      source: "iana",
      compressible: true,
      extensions: ["dart"]
    },
    "application/vnd.data-vision.rdz": {
      source: "iana",
      extensions: ["rdz"]
    },
    "application/vnd.datapackage+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dataresource+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dbf": {
      source: "iana",
      extensions: ["dbf"]
    },
    "application/vnd.debian.binary-package": {
      source: "iana"
    },
    "application/vnd.dece.data": {
      source: "iana",
      extensions: ["uvf", "uvvf", "uvd", "uvvd"]
    },
    "application/vnd.dece.ttml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["uvt", "uvvt"]
    },
    "application/vnd.dece.unspecified": {
      source: "iana",
      extensions: ["uvx", "uvvx"]
    },
    "application/vnd.dece.zip": {
      source: "iana",
      extensions: ["uvz", "uvvz"]
    },
    "application/vnd.denovo.fcselayout-link": {
      source: "iana",
      extensions: ["fe_launch"]
    },
    "application/vnd.desmume.movie": {
      source: "iana"
    },
    "application/vnd.dir-bi.plate-dl-nosuffix": {
      source: "iana"
    },
    "application/vnd.dm.delegation+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dna": {
      source: "iana",
      extensions: ["dna"]
    },
    "application/vnd.document+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dolby.mlp": {
      source: "apache",
      extensions: ["mlp"]
    },
    "application/vnd.dolby.mobile.1": {
      source: "iana"
    },
    "application/vnd.dolby.mobile.2": {
      source: "iana"
    },
    "application/vnd.doremir.scorecloud-binary-document": {
      source: "iana"
    },
    "application/vnd.dpgraph": {
      source: "iana",
      extensions: ["dpg"]
    },
    "application/vnd.dreamfactory": {
      source: "iana",
      extensions: ["dfac"]
    },
    "application/vnd.drive+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ds-keypoint": {
      source: "apache",
      extensions: ["kpxx"]
    },
    "application/vnd.dtg.local": {
      source: "iana"
    },
    "application/vnd.dtg.local.flash": {
      source: "iana"
    },
    "application/vnd.dtg.local.html": {
      source: "iana"
    },
    "application/vnd.dvb.ait": {
      source: "iana",
      extensions: ["ait"]
    },
    "application/vnd.dvb.dvbisl+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.dvbj": {
      source: "iana"
    },
    "application/vnd.dvb.esgcontainer": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcdftnotifaccess": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcesgaccess": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcesgaccess2": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcesgpdd": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcroaming": {
      source: "iana"
    },
    "application/vnd.dvb.iptv.alfec-base": {
      source: "iana"
    },
    "application/vnd.dvb.iptv.alfec-enhancement": {
      source: "iana"
    },
    "application/vnd.dvb.notif-aggregate-root+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-container+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-generic+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-ia-msglist+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-ia-registration-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-ia-registration-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-init+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.pfr": {
      source: "iana"
    },
    "application/vnd.dvb.service": {
      source: "iana",
      extensions: ["svc"]
    },
    "application/vnd.dxr": {
      source: "iana"
    },
    "application/vnd.dynageo": {
      source: "iana",
      extensions: ["geo"]
    },
    "application/vnd.dzr": {
      source: "iana"
    },
    "application/vnd.easykaraoke.cdgdownload": {
      source: "iana"
    },
    "application/vnd.ecdis-update": {
      source: "iana"
    },
    "application/vnd.ecip.rlp": {
      source: "iana"
    },
    "application/vnd.ecowin.chart": {
      source: "iana",
      extensions: ["mag"]
    },
    "application/vnd.ecowin.filerequest": {
      source: "iana"
    },
    "application/vnd.ecowin.fileupdate": {
      source: "iana"
    },
    "application/vnd.ecowin.series": {
      source: "iana"
    },
    "application/vnd.ecowin.seriesrequest": {
      source: "iana"
    },
    "application/vnd.ecowin.seriesupdate": {
      source: "iana"
    },
    "application/vnd.efi.img": {
      source: "iana"
    },
    "application/vnd.efi.iso": {
      source: "iana"
    },
    "application/vnd.emclient.accessrequest+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.enliven": {
      source: "iana",
      extensions: ["nml"]
    },
    "application/vnd.enphase.envoy": {
      source: "iana"
    },
    "application/vnd.eprints.data+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.epson.esf": {
      source: "iana",
      extensions: ["esf"]
    },
    "application/vnd.epson.msf": {
      source: "iana",
      extensions: ["msf"]
    },
    "application/vnd.epson.quickanime": {
      source: "iana",
      extensions: ["qam"]
    },
    "application/vnd.epson.salt": {
      source: "iana",
      extensions: ["slt"]
    },
    "application/vnd.epson.ssf": {
      source: "iana",
      extensions: ["ssf"]
    },
    "application/vnd.ericsson.quickcall": {
      source: "iana"
    },
    "application/vnd.espass-espass+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.eszigno3+xml": {
      source: "iana",
      compressible: true,
      extensions: ["es3", "et3"]
    },
    "application/vnd.etsi.aoc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.asic-e+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.etsi.asic-s+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.etsi.cug+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvcommand+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvdiscovery+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsad-bc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsad-cod+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsad-npvr+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvservice+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsync+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvueprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.mcid+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.mheg5": {
      source: "iana"
    },
    "application/vnd.etsi.overload-control-policy-dataset+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.pstn+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.sci+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.simservs+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.timestamp-token": {
      source: "iana"
    },
    "application/vnd.etsi.tsl+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.tsl.der": {
      source: "iana"
    },
    "application/vnd.eudora.data": {
      source: "iana"
    },
    "application/vnd.evolv.ecig.profile": {
      source: "iana"
    },
    "application/vnd.evolv.ecig.settings": {
      source: "iana"
    },
    "application/vnd.evolv.ecig.theme": {
      source: "iana"
    },
    "application/vnd.exstream-empower+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.exstream-package": {
      source: "iana"
    },
    "application/vnd.ezpix-album": {
      source: "iana",
      extensions: ["ez2"]
    },
    "application/vnd.ezpix-package": {
      source: "iana",
      extensions: ["ez3"]
    },
    "application/vnd.f-secure.mobile": {
      source: "iana"
    },
    "application/vnd.fastcopy-disk-image": {
      source: "iana"
    },
    "application/vnd.fdf": {
      source: "iana",
      extensions: ["fdf"]
    },
    "application/vnd.fdsn.mseed": {
      source: "iana",
      extensions: ["mseed"]
    },
    "application/vnd.fdsn.seed": {
      source: "iana",
      extensions: ["seed", "dataless"]
    },
    "application/vnd.ffsns": {
      source: "iana"
    },
    "application/vnd.ficlab.flb+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.filmit.zfc": {
      source: "iana"
    },
    "application/vnd.fints": {
      source: "iana"
    },
    "application/vnd.firemonkeys.cloudcell": {
      source: "iana"
    },
    "application/vnd.flographit": {
      source: "iana",
      extensions: ["gph"]
    },
    "application/vnd.fluxtime.clip": {
      source: "iana",
      extensions: ["ftc"]
    },
    "application/vnd.font-fontforge-sfd": {
      source: "iana"
    },
    "application/vnd.framemaker": {
      source: "iana",
      extensions: ["fm", "frame", "maker", "book"]
    },
    "application/vnd.frogans.fnc": {
      source: "iana",
      extensions: ["fnc"]
    },
    "application/vnd.frogans.ltf": {
      source: "iana",
      extensions: ["ltf"]
    },
    "application/vnd.fsc.weblaunch": {
      source: "iana",
      extensions: ["fsc"]
    },
    "application/vnd.fujifilm.fb.docuworks": {
      source: "iana"
    },
    "application/vnd.fujifilm.fb.docuworks.binder": {
      source: "iana"
    },
    "application/vnd.fujifilm.fb.docuworks.container": {
      source: "iana"
    },
    "application/vnd.fujifilm.fb.jfi+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.fujitsu.oasys": {
      source: "iana",
      extensions: ["oas"]
    },
    "application/vnd.fujitsu.oasys2": {
      source: "iana",
      extensions: ["oa2"]
    },
    "application/vnd.fujitsu.oasys3": {
      source: "iana",
      extensions: ["oa3"]
    },
    "application/vnd.fujitsu.oasysgp": {
      source: "iana",
      extensions: ["fg5"]
    },
    "application/vnd.fujitsu.oasysprs": {
      source: "iana",
      extensions: ["bh2"]
    },
    "application/vnd.fujixerox.art-ex": {
      source: "iana"
    },
    "application/vnd.fujixerox.art4": {
      source: "iana"
    },
    "application/vnd.fujixerox.ddd": {
      source: "iana",
      extensions: ["ddd"]
    },
    "application/vnd.fujixerox.docuworks": {
      source: "iana",
      extensions: ["xdw"]
    },
    "application/vnd.fujixerox.docuworks.binder": {
      source: "iana",
      extensions: ["xbd"]
    },
    "application/vnd.fujixerox.docuworks.container": {
      source: "iana"
    },
    "application/vnd.fujixerox.hbpl": {
      source: "iana"
    },
    "application/vnd.fut-misnet": {
      source: "iana"
    },
    "application/vnd.futoin+cbor": {
      source: "iana"
    },
    "application/vnd.futoin+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.fuzzysheet": {
      source: "iana",
      extensions: ["fzs"]
    },
    "application/vnd.genomatix.tuxedo": {
      source: "iana",
      extensions: ["txd"]
    },
    "application/vnd.gentics.grd+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.geo+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.geocube+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.geogebra.file": {
      source: "iana",
      extensions: ["ggb"]
    },
    "application/vnd.geogebra.slides": {
      source: "iana"
    },
    "application/vnd.geogebra.tool": {
      source: "iana",
      extensions: ["ggt"]
    },
    "application/vnd.geometry-explorer": {
      source: "iana",
      extensions: ["gex", "gre"]
    },
    "application/vnd.geonext": {
      source: "iana",
      extensions: ["gxt"]
    },
    "application/vnd.geoplan": {
      source: "iana",
      extensions: ["g2w"]
    },
    "application/vnd.geospace": {
      source: "iana",
      extensions: ["g3w"]
    },
    "application/vnd.gerber": {
      source: "iana"
    },
    "application/vnd.globalplatform.card-content-mgt": {
      source: "iana"
    },
    "application/vnd.globalplatform.card-content-mgt-response": {
      source: "iana"
    },
    "application/vnd.gmx": {
      source: "iana",
      extensions: ["gmx"]
    },
    "application/vnd.google-apps.document": {
      compressible: false,
      extensions: ["gdoc"]
    },
    "application/vnd.google-apps.presentation": {
      compressible: false,
      extensions: ["gslides"]
    },
    "application/vnd.google-apps.spreadsheet": {
      compressible: false,
      extensions: ["gsheet"]
    },
    "application/vnd.google-earth.kml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["kml"]
    },
    "application/vnd.google-earth.kmz": {
      source: "iana",
      compressible: false,
      extensions: ["kmz"]
    },
    "application/vnd.gov.sk.e-form+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.gov.sk.e-form+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.gov.sk.xmldatacontainer+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.grafeq": {
      source: "iana",
      extensions: ["gqf", "gqs"]
    },
    "application/vnd.gridmp": {
      source: "iana"
    },
    "application/vnd.groove-account": {
      source: "iana",
      extensions: ["gac"]
    },
    "application/vnd.groove-help": {
      source: "iana",
      extensions: ["ghf"]
    },
    "application/vnd.groove-identity-message": {
      source: "iana",
      extensions: ["gim"]
    },
    "application/vnd.groove-injector": {
      source: "iana",
      extensions: ["grv"]
    },
    "application/vnd.groove-tool-message": {
      source: "iana",
      extensions: ["gtm"]
    },
    "application/vnd.groove-tool-template": {
      source: "iana",
      extensions: ["tpl"]
    },
    "application/vnd.groove-vcard": {
      source: "iana",
      extensions: ["vcg"]
    },
    "application/vnd.hal+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hal+xml": {
      source: "iana",
      compressible: true,
      extensions: ["hal"]
    },
    "application/vnd.handheld-entertainment+xml": {
      source: "iana",
      compressible: true,
      extensions: ["zmm"]
    },
    "application/vnd.hbci": {
      source: "iana",
      extensions: ["hbci"]
    },
    "application/vnd.hc+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hcl-bireports": {
      source: "iana"
    },
    "application/vnd.hdt": {
      source: "iana"
    },
    "application/vnd.heroku+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hhe.lesson-player": {
      source: "iana",
      extensions: ["les"]
    },
    "application/vnd.hp-hpgl": {
      source: "iana",
      extensions: ["hpgl"]
    },
    "application/vnd.hp-hpid": {
      source: "iana",
      extensions: ["hpid"]
    },
    "application/vnd.hp-hps": {
      source: "iana",
      extensions: ["hps"]
    },
    "application/vnd.hp-jlyt": {
      source: "iana",
      extensions: ["jlt"]
    },
    "application/vnd.hp-pcl": {
      source: "iana",
      extensions: ["pcl"]
    },
    "application/vnd.hp-pclxl": {
      source: "iana",
      extensions: ["pclxl"]
    },
    "application/vnd.httphone": {
      source: "iana"
    },
    "application/vnd.hydrostatix.sof-data": {
      source: "iana",
      extensions: ["sfd-hdstx"]
    },
    "application/vnd.hyper+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hyper-item+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hyperdrive+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hzn-3d-crossword": {
      source: "iana"
    },
    "application/vnd.ibm.afplinedata": {
      source: "iana"
    },
    "application/vnd.ibm.electronic-media": {
      source: "iana"
    },
    "application/vnd.ibm.minipay": {
      source: "iana",
      extensions: ["mpy"]
    },
    "application/vnd.ibm.modcap": {
      source: "iana",
      extensions: ["afp", "listafp", "list3820"]
    },
    "application/vnd.ibm.rights-management": {
      source: "iana",
      extensions: ["irm"]
    },
    "application/vnd.ibm.secure-container": {
      source: "iana",
      extensions: ["sc"]
    },
    "application/vnd.iccprofile": {
      source: "iana",
      extensions: ["icc", "icm"]
    },
    "application/vnd.ieee.1905": {
      source: "iana"
    },
    "application/vnd.igloader": {
      source: "iana",
      extensions: ["igl"]
    },
    "application/vnd.imagemeter.folder+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.imagemeter.image+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.immervision-ivp": {
      source: "iana",
      extensions: ["ivp"]
    },
    "application/vnd.immervision-ivu": {
      source: "iana",
      extensions: ["ivu"]
    },
    "application/vnd.ims.imsccv1p1": {
      source: "iana"
    },
    "application/vnd.ims.imsccv1p2": {
      source: "iana"
    },
    "application/vnd.ims.imsccv1p3": {
      source: "iana"
    },
    "application/vnd.ims.lis.v2.result+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolproxy+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolproxy.id+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolsettings+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolsettings.simple+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.informedcontrol.rms+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.informix-visionary": {
      source: "iana"
    },
    "application/vnd.infotech.project": {
      source: "iana"
    },
    "application/vnd.infotech.project+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.innopath.wamp.notification": {
      source: "iana"
    },
    "application/vnd.insors.igm": {
      source: "iana",
      extensions: ["igm"]
    },
    "application/vnd.intercon.formnet": {
      source: "iana",
      extensions: ["xpw", "xpx"]
    },
    "application/vnd.intergeo": {
      source: "iana",
      extensions: ["i2g"]
    },
    "application/vnd.intertrust.digibox": {
      source: "iana"
    },
    "application/vnd.intertrust.nncp": {
      source: "iana"
    },
    "application/vnd.intu.qbo": {
      source: "iana",
      extensions: ["qbo"]
    },
    "application/vnd.intu.qfx": {
      source: "iana",
      extensions: ["qfx"]
    },
    "application/vnd.iptc.g2.catalogitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.conceptitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.knowledgeitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.newsitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.newsmessage+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.packageitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.planningitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ipunplugged.rcprofile": {
      source: "iana",
      extensions: ["rcprofile"]
    },
    "application/vnd.irepository.package+xml": {
      source: "iana",
      compressible: true,
      extensions: ["irp"]
    },
    "application/vnd.is-xpr": {
      source: "iana",
      extensions: ["xpr"]
    },
    "application/vnd.isac.fcs": {
      source: "iana",
      extensions: ["fcs"]
    },
    "application/vnd.iso11783-10+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.jam": {
      source: "iana",
      extensions: ["jam"]
    },
    "application/vnd.japannet-directory-service": {
      source: "iana"
    },
    "application/vnd.japannet-jpnstore-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-payment-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-registration": {
      source: "iana"
    },
    "application/vnd.japannet-registration-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-setstore-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-verification": {
      source: "iana"
    },
    "application/vnd.japannet-verification-wakeup": {
      source: "iana"
    },
    "application/vnd.jcp.javame.midlet-rms": {
      source: "iana",
      extensions: ["rms"]
    },
    "application/vnd.jisp": {
      source: "iana",
      extensions: ["jisp"]
    },
    "application/vnd.joost.joda-archive": {
      source: "iana",
      extensions: ["joda"]
    },
    "application/vnd.jsk.isdn-ngn": {
      source: "iana"
    },
    "application/vnd.kahootz": {
      source: "iana",
      extensions: ["ktz", "ktr"]
    },
    "application/vnd.kde.karbon": {
      source: "iana",
      extensions: ["karbon"]
    },
    "application/vnd.kde.kchart": {
      source: "iana",
      extensions: ["chrt"]
    },
    "application/vnd.kde.kformula": {
      source: "iana",
      extensions: ["kfo"]
    },
    "application/vnd.kde.kivio": {
      source: "iana",
      extensions: ["flw"]
    },
    "application/vnd.kde.kontour": {
      source: "iana",
      extensions: ["kon"]
    },
    "application/vnd.kde.kpresenter": {
      source: "iana",
      extensions: ["kpr", "kpt"]
    },
    "application/vnd.kde.kspread": {
      source: "iana",
      extensions: ["ksp"]
    },
    "application/vnd.kde.kword": {
      source: "iana",
      extensions: ["kwd", "kwt"]
    },
    "application/vnd.kenameaapp": {
      source: "iana",
      extensions: ["htke"]
    },
    "application/vnd.kidspiration": {
      source: "iana",
      extensions: ["kia"]
    },
    "application/vnd.kinar": {
      source: "iana",
      extensions: ["kne", "knp"]
    },
    "application/vnd.koan": {
      source: "iana",
      extensions: ["skp", "skd", "skt", "skm"]
    },
    "application/vnd.kodak-descriptor": {
      source: "iana",
      extensions: ["sse"]
    },
    "application/vnd.las": {
      source: "iana"
    },
    "application/vnd.las.las+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.las.las+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lasxml"]
    },
    "application/vnd.laszip": {
      source: "iana"
    },
    "application/vnd.leap+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.liberty-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.llamagraphics.life-balance.desktop": {
      source: "iana",
      extensions: ["lbd"]
    },
    "application/vnd.llamagraphics.life-balance.exchange+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lbe"]
    },
    "application/vnd.logipipe.circuit+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.loom": {
      source: "iana"
    },
    "application/vnd.lotus-1-2-3": {
      source: "iana",
      extensions: ["123"]
    },
    "application/vnd.lotus-approach": {
      source: "iana",
      extensions: ["apr"]
    },
    "application/vnd.lotus-freelance": {
      source: "iana",
      extensions: ["pre"]
    },
    "application/vnd.lotus-notes": {
      source: "iana",
      extensions: ["nsf"]
    },
    "application/vnd.lotus-organizer": {
      source: "iana",
      extensions: ["org"]
    },
    "application/vnd.lotus-screencam": {
      source: "iana",
      extensions: ["scm"]
    },
    "application/vnd.lotus-wordpro": {
      source: "iana",
      extensions: ["lwp"]
    },
    "application/vnd.macports.portpkg": {
      source: "iana",
      extensions: ["portpkg"]
    },
    "application/vnd.mapbox-vector-tile": {
      source: "iana",
      extensions: ["mvt"]
    },
    "application/vnd.marlin.drm.actiontoken+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.marlin.drm.conftoken+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.marlin.drm.license+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.marlin.drm.mdcf": {
      source: "iana"
    },
    "application/vnd.mason+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.maxmind.maxmind-db": {
      source: "iana"
    },
    "application/vnd.mcd": {
      source: "iana",
      extensions: ["mcd"]
    },
    "application/vnd.medcalcdata": {
      source: "iana",
      extensions: ["mc1"]
    },
    "application/vnd.mediastation.cdkey": {
      source: "iana",
      extensions: ["cdkey"]
    },
    "application/vnd.meridian-slingshot": {
      source: "iana"
    },
    "application/vnd.mfer": {
      source: "iana",
      extensions: ["mwf"]
    },
    "application/vnd.mfmp": {
      source: "iana",
      extensions: ["mfm"]
    },
    "application/vnd.micro+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.micrografx.flo": {
      source: "iana",
      extensions: ["flo"]
    },
    "application/vnd.micrografx.igx": {
      source: "iana",
      extensions: ["igx"]
    },
    "application/vnd.microsoft.portable-executable": {
      source: "iana"
    },
    "application/vnd.microsoft.windows.thumbnail-cache": {
      source: "iana"
    },
    "application/vnd.miele+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.mif": {
      source: "iana",
      extensions: ["mif"]
    },
    "application/vnd.minisoft-hp3000-save": {
      source: "iana"
    },
    "application/vnd.mitsubishi.misty-guard.trustweb": {
      source: "iana"
    },
    "application/vnd.mobius.daf": {
      source: "iana",
      extensions: ["daf"]
    },
    "application/vnd.mobius.dis": {
      source: "iana",
      extensions: ["dis"]
    },
    "application/vnd.mobius.mbk": {
      source: "iana",
      extensions: ["mbk"]
    },
    "application/vnd.mobius.mqy": {
      source: "iana",
      extensions: ["mqy"]
    },
    "application/vnd.mobius.msl": {
      source: "iana",
      extensions: ["msl"]
    },
    "application/vnd.mobius.plc": {
      source: "iana",
      extensions: ["plc"]
    },
    "application/vnd.mobius.txf": {
      source: "iana",
      extensions: ["txf"]
    },
    "application/vnd.mophun.application": {
      source: "iana",
      extensions: ["mpn"]
    },
    "application/vnd.mophun.certificate": {
      source: "iana",
      extensions: ["mpc"]
    },
    "application/vnd.motorola.flexsuite": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.adsi": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.fis": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.gotap": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.kmr": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.ttc": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.wem": {
      source: "iana"
    },
    "application/vnd.motorola.iprm": {
      source: "iana"
    },
    "application/vnd.mozilla.xul+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xul"]
    },
    "application/vnd.ms-3mfdocument": {
      source: "iana"
    },
    "application/vnd.ms-artgalry": {
      source: "iana",
      extensions: ["cil"]
    },
    "application/vnd.ms-asf": {
      source: "iana"
    },
    "application/vnd.ms-cab-compressed": {
      source: "iana",
      extensions: ["cab"]
    },
    "application/vnd.ms-color.iccprofile": {
      source: "apache"
    },
    "application/vnd.ms-excel": {
      source: "iana",
      compressible: false,
      extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
    },
    "application/vnd.ms-excel.addin.macroenabled.12": {
      source: "iana",
      extensions: ["xlam"]
    },
    "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
      source: "iana",
      extensions: ["xlsb"]
    },
    "application/vnd.ms-excel.sheet.macroenabled.12": {
      source: "iana",
      extensions: ["xlsm"]
    },
    "application/vnd.ms-excel.template.macroenabled.12": {
      source: "iana",
      extensions: ["xltm"]
    },
    "application/vnd.ms-fontobject": {
      source: "iana",
      compressible: true,
      extensions: ["eot"]
    },
    "application/vnd.ms-htmlhelp": {
      source: "iana",
      extensions: ["chm"]
    },
    "application/vnd.ms-ims": {
      source: "iana",
      extensions: ["ims"]
    },
    "application/vnd.ms-lrm": {
      source: "iana",
      extensions: ["lrm"]
    },
    "application/vnd.ms-office.activex+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-officetheme": {
      source: "iana",
      extensions: ["thmx"]
    },
    "application/vnd.ms-opentype": {
      source: "apache",
      compressible: true
    },
    "application/vnd.ms-outlook": {
      compressible: false,
      extensions: ["msg"]
    },
    "application/vnd.ms-package.obfuscated-opentype": {
      source: "apache"
    },
    "application/vnd.ms-pki.seccat": {
      source: "apache",
      extensions: ["cat"]
    },
    "application/vnd.ms-pki.stl": {
      source: "apache",
      extensions: ["stl"]
    },
    "application/vnd.ms-playready.initiator+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-powerpoint": {
      source: "iana",
      compressible: false,
      extensions: ["ppt", "pps", "pot"]
    },
    "application/vnd.ms-powerpoint.addin.macroenabled.12": {
      source: "iana",
      extensions: ["ppam"]
    },
    "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
      source: "iana",
      extensions: ["pptm"]
    },
    "application/vnd.ms-powerpoint.slide.macroenabled.12": {
      source: "iana",
      extensions: ["sldm"]
    },
    "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
      source: "iana",
      extensions: ["ppsm"]
    },
    "application/vnd.ms-powerpoint.template.macroenabled.12": {
      source: "iana",
      extensions: ["potm"]
    },
    "application/vnd.ms-printdevicecapabilities+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-printing.printticket+xml": {
      source: "apache",
      compressible: true
    },
    "application/vnd.ms-printschematicket+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-project": {
      source: "iana",
      extensions: ["mpp", "mpt"]
    },
    "application/vnd.ms-tnef": {
      source: "iana"
    },
    "application/vnd.ms-windows.devicepairing": {
      source: "iana"
    },
    "application/vnd.ms-windows.nwprinting.oob": {
      source: "iana"
    },
    "application/vnd.ms-windows.printerpairing": {
      source: "iana"
    },
    "application/vnd.ms-windows.wsd.oob": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.lic-chlg-req": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.lic-resp": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.meter-chlg-req": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.meter-resp": {
      source: "iana"
    },
    "application/vnd.ms-word.document.macroenabled.12": {
      source: "iana",
      extensions: ["docm"]
    },
    "application/vnd.ms-word.template.macroenabled.12": {
      source: "iana",
      extensions: ["dotm"]
    },
    "application/vnd.ms-works": {
      source: "iana",
      extensions: ["wps", "wks", "wcm", "wdb"]
    },
    "application/vnd.ms-wpl": {
      source: "iana",
      extensions: ["wpl"]
    },
    "application/vnd.ms-xpsdocument": {
      source: "iana",
      compressible: false,
      extensions: ["xps"]
    },
    "application/vnd.msa-disk-image": {
      source: "iana"
    },
    "application/vnd.mseq": {
      source: "iana",
      extensions: ["mseq"]
    },
    "application/vnd.msign": {
      source: "iana"
    },
    "application/vnd.multiad.creator": {
      source: "iana"
    },
    "application/vnd.multiad.creator.cif": {
      source: "iana"
    },
    "application/vnd.music-niff": {
      source: "iana"
    },
    "application/vnd.musician": {
      source: "iana",
      extensions: ["mus"]
    },
    "application/vnd.muvee.style": {
      source: "iana",
      extensions: ["msty"]
    },
    "application/vnd.mynfc": {
      source: "iana",
      extensions: ["taglet"]
    },
    "application/vnd.ncd.control": {
      source: "iana"
    },
    "application/vnd.ncd.reference": {
      source: "iana"
    },
    "application/vnd.nearst.inv+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nebumind.line": {
      source: "iana"
    },
    "application/vnd.nervana": {
      source: "iana"
    },
    "application/vnd.netfpx": {
      source: "iana"
    },
    "application/vnd.neurolanguage.nlu": {
      source: "iana",
      extensions: ["nlu"]
    },
    "application/vnd.nimn": {
      source: "iana"
    },
    "application/vnd.nintendo.nitro.rom": {
      source: "iana"
    },
    "application/vnd.nintendo.snes.rom": {
      source: "iana"
    },
    "application/vnd.nitf": {
      source: "iana",
      extensions: ["ntf", "nitf"]
    },
    "application/vnd.noblenet-directory": {
      source: "iana",
      extensions: ["nnd"]
    },
    "application/vnd.noblenet-sealer": {
      source: "iana",
      extensions: ["nns"]
    },
    "application/vnd.noblenet-web": {
      source: "iana",
      extensions: ["nnw"]
    },
    "application/vnd.nokia.catalogs": {
      source: "iana"
    },
    "application/vnd.nokia.conml+wbxml": {
      source: "iana"
    },
    "application/vnd.nokia.conml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.iptv.config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.isds-radio-presets": {
      source: "iana"
    },
    "application/vnd.nokia.landmark+wbxml": {
      source: "iana"
    },
    "application/vnd.nokia.landmark+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.landmarkcollection+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.n-gage.ac+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ac"]
    },
    "application/vnd.nokia.n-gage.data": {
      source: "iana",
      extensions: ["ngdat"]
    },
    "application/vnd.nokia.n-gage.symbian.install": {
      source: "iana",
      extensions: ["n-gage"]
    },
    "application/vnd.nokia.ncd": {
      source: "iana"
    },
    "application/vnd.nokia.pcd+wbxml": {
      source: "iana"
    },
    "application/vnd.nokia.pcd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.radio-preset": {
      source: "iana",
      extensions: ["rpst"]
    },
    "application/vnd.nokia.radio-presets": {
      source: "iana",
      extensions: ["rpss"]
    },
    "application/vnd.novadigm.edm": {
      source: "iana",
      extensions: ["edm"]
    },
    "application/vnd.novadigm.edx": {
      source: "iana",
      extensions: ["edx"]
    },
    "application/vnd.novadigm.ext": {
      source: "iana",
      extensions: ["ext"]
    },
    "application/vnd.ntt-local.content-share": {
      source: "iana"
    },
    "application/vnd.ntt-local.file-transfer": {
      source: "iana"
    },
    "application/vnd.ntt-local.ogw_remote-access": {
      source: "iana"
    },
    "application/vnd.ntt-local.sip-ta_remote": {
      source: "iana"
    },
    "application/vnd.ntt-local.sip-ta_tcp_stream": {
      source: "iana"
    },
    "application/vnd.oasis.opendocument.chart": {
      source: "iana",
      extensions: ["odc"]
    },
    "application/vnd.oasis.opendocument.chart-template": {
      source: "iana",
      extensions: ["otc"]
    },
    "application/vnd.oasis.opendocument.database": {
      source: "iana",
      extensions: ["odb"]
    },
    "application/vnd.oasis.opendocument.formula": {
      source: "iana",
      extensions: ["odf"]
    },
    "application/vnd.oasis.opendocument.formula-template": {
      source: "iana",
      extensions: ["odft"]
    },
    "application/vnd.oasis.opendocument.graphics": {
      source: "iana",
      compressible: false,
      extensions: ["odg"]
    },
    "application/vnd.oasis.opendocument.graphics-template": {
      source: "iana",
      extensions: ["otg"]
    },
    "application/vnd.oasis.opendocument.image": {
      source: "iana",
      extensions: ["odi"]
    },
    "application/vnd.oasis.opendocument.image-template": {
      source: "iana",
      extensions: ["oti"]
    },
    "application/vnd.oasis.opendocument.presentation": {
      source: "iana",
      compressible: false,
      extensions: ["odp"]
    },
    "application/vnd.oasis.opendocument.presentation-template": {
      source: "iana",
      extensions: ["otp"]
    },
    "application/vnd.oasis.opendocument.spreadsheet": {
      source: "iana",
      compressible: false,
      extensions: ["ods"]
    },
    "application/vnd.oasis.opendocument.spreadsheet-template": {
      source: "iana",
      extensions: ["ots"]
    },
    "application/vnd.oasis.opendocument.text": {
      source: "iana",
      compressible: false,
      extensions: ["odt"]
    },
    "application/vnd.oasis.opendocument.text-master": {
      source: "iana",
      extensions: ["odm"]
    },
    "application/vnd.oasis.opendocument.text-template": {
      source: "iana",
      extensions: ["ott"]
    },
    "application/vnd.oasis.opendocument.text-web": {
      source: "iana",
      extensions: ["oth"]
    },
    "application/vnd.obn": {
      source: "iana"
    },
    "application/vnd.ocf+cbor": {
      source: "iana"
    },
    "application/vnd.oci.image.manifest.v1+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oftn.l10n+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.contentaccessdownload+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.contentaccessstreaming+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.cspg-hexbinary": {
      source: "iana"
    },
    "application/vnd.oipf.dae.svg+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.dae.xhtml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.mippvcontrolmessage+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.pae.gem": {
      source: "iana"
    },
    "application/vnd.oipf.spdiscovery+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.spdlist+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.ueprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.userprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.olpc-sugar": {
      source: "iana",
      extensions: ["xo"]
    },
    "application/vnd.oma-scws-config": {
      source: "iana"
    },
    "application/vnd.oma-scws-http-request": {
      source: "iana"
    },
    "application/vnd.oma-scws-http-response": {
      source: "iana"
    },
    "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.drm-trigger+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.imd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.ltkm": {
      source: "iana"
    },
    "application/vnd.oma.bcast.notification+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.provisioningtrigger": {
      source: "iana"
    },
    "application/vnd.oma.bcast.sgboot": {
      source: "iana"
    },
    "application/vnd.oma.bcast.sgdd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.sgdu": {
      source: "iana"
    },
    "application/vnd.oma.bcast.simple-symbol-container": {
      source: "iana"
    },
    "application/vnd.oma.bcast.smartcard-trigger+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.sprov+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.stkm": {
      source: "iana"
    },
    "application/vnd.oma.cab-address-book+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-feature-handler+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-pcc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-subs-invite+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-user-prefs+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.dcd": {
      source: "iana"
    },
    "application/vnd.oma.dcdc": {
      source: "iana"
    },
    "application/vnd.oma.dd2+xml": {
      source: "iana",
      compressible: true,
      extensions: ["dd2"]
    },
    "application/vnd.oma.drm.risd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.group-usage-list+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.lwm2m+cbor": {
      source: "iana"
    },
    "application/vnd.oma.lwm2m+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.lwm2m+tlv": {
      source: "iana"
    },
    "application/vnd.oma.pal+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.detailed-progress-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.final-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.groups+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.invocation-descriptor+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.optimized-progress-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.push": {
      source: "iana"
    },
    "application/vnd.oma.scidm.messages+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.xcap-directory+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.omads-email+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.omads-file+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.omads-folder+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.omaloc-supl-init": {
      source: "iana"
    },
    "application/vnd.onepager": {
      source: "iana"
    },
    "application/vnd.onepagertamp": {
      source: "iana"
    },
    "application/vnd.onepagertamx": {
      source: "iana"
    },
    "application/vnd.onepagertat": {
      source: "iana"
    },
    "application/vnd.onepagertatp": {
      source: "iana"
    },
    "application/vnd.onepagertatx": {
      source: "iana"
    },
    "application/vnd.openblox.game+xml": {
      source: "iana",
      compressible: true,
      extensions: ["obgx"]
    },
    "application/vnd.openblox.game-binary": {
      source: "iana"
    },
    "application/vnd.openeye.oeb": {
      source: "iana"
    },
    "application/vnd.openofficeorg.extension": {
      source: "apache",
      extensions: ["oxt"]
    },
    "application/vnd.openstreetmap.data+xml": {
      source: "iana",
      compressible: true,
      extensions: ["osm"]
    },
    "application/vnd.opentimestamps.ots": {
      source: "iana"
    },
    "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawing+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
      source: "iana",
      compressible: false,
      extensions: ["pptx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slide": {
      source: "iana",
      extensions: ["sldx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
      source: "iana",
      extensions: ["ppsx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.template": {
      source: "iana",
      extensions: ["potx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
      source: "iana",
      compressible: false,
      extensions: ["xlsx"]
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
      source: "iana",
      extensions: ["xltx"]
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.theme+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.vmldrawing": {
      source: "iana"
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
      source: "iana",
      compressible: false,
      extensions: ["docx"]
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
      source: "iana",
      extensions: ["dotx"]
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-package.core-properties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-package.relationships+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oracle.resource+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.orange.indata": {
      source: "iana"
    },
    "application/vnd.osa.netdeploy": {
      source: "iana"
    },
    "application/vnd.osgeo.mapguide.package": {
      source: "iana",
      extensions: ["mgp"]
    },
    "application/vnd.osgi.bundle": {
      source: "iana"
    },
    "application/vnd.osgi.dp": {
      source: "iana",
      extensions: ["dp"]
    },
    "application/vnd.osgi.subsystem": {
      source: "iana",
      extensions: ["esa"]
    },
    "application/vnd.otps.ct-kip+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oxli.countgraph": {
      source: "iana"
    },
    "application/vnd.pagerduty+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.palm": {
      source: "iana",
      extensions: ["pdb", "pqa", "oprc"]
    },
    "application/vnd.panoply": {
      source: "iana"
    },
    "application/vnd.paos.xml": {
      source: "iana"
    },
    "application/vnd.patentdive": {
      source: "iana"
    },
    "application/vnd.patientecommsdoc": {
      source: "iana"
    },
    "application/vnd.pawaafile": {
      source: "iana",
      extensions: ["paw"]
    },
    "application/vnd.pcos": {
      source: "iana"
    },
    "application/vnd.pg.format": {
      source: "iana",
      extensions: ["str"]
    },
    "application/vnd.pg.osasli": {
      source: "iana",
      extensions: ["ei6"]
    },
    "application/vnd.piaccess.application-licence": {
      source: "iana"
    },
    "application/vnd.picsel": {
      source: "iana",
      extensions: ["efif"]
    },
    "application/vnd.pmi.widget": {
      source: "iana",
      extensions: ["wg"]
    },
    "application/vnd.poc.group-advertisement+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.pocketlearn": {
      source: "iana",
      extensions: ["plf"]
    },
    "application/vnd.powerbuilder6": {
      source: "iana",
      extensions: ["pbd"]
    },
    "application/vnd.powerbuilder6-s": {
      source: "iana"
    },
    "application/vnd.powerbuilder7": {
      source: "iana"
    },
    "application/vnd.powerbuilder7-s": {
      source: "iana"
    },
    "application/vnd.powerbuilder75": {
      source: "iana"
    },
    "application/vnd.powerbuilder75-s": {
      source: "iana"
    },
    "application/vnd.preminet": {
      source: "iana"
    },
    "application/vnd.previewsystems.box": {
      source: "iana",
      extensions: ["box"]
    },
    "application/vnd.proteus.magazine": {
      source: "iana",
      extensions: ["mgz"]
    },
    "application/vnd.psfs": {
      source: "iana"
    },
    "application/vnd.publishare-delta-tree": {
      source: "iana",
      extensions: ["qps"]
    },
    "application/vnd.pvi.ptid1": {
      source: "iana",
      extensions: ["ptid"]
    },
    "application/vnd.pwg-multiplexed": {
      source: "iana"
    },
    "application/vnd.pwg-xhtml-print+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.qualcomm.brew-app-res": {
      source: "iana"
    },
    "application/vnd.quarantainenet": {
      source: "iana"
    },
    "application/vnd.quark.quarkxpress": {
      source: "iana",
      extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
    },
    "application/vnd.quobject-quoxdocument": {
      source: "iana"
    },
    "application/vnd.radisys.moml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-conf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-conn+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-dialog+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-stream+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-conf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-base+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-fax-detect+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-group+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-speech+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-transform+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.rainstor.data": {
      source: "iana"
    },
    "application/vnd.rapid": {
      source: "iana"
    },
    "application/vnd.rar": {
      source: "iana",
      extensions: ["rar"]
    },
    "application/vnd.realvnc.bed": {
      source: "iana",
      extensions: ["bed"]
    },
    "application/vnd.recordare.musicxml": {
      source: "iana",
      extensions: ["mxl"]
    },
    "application/vnd.recordare.musicxml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["musicxml"]
    },
    "application/vnd.renlearn.rlprint": {
      source: "iana"
    },
    "application/vnd.resilient.logic": {
      source: "iana"
    },
    "application/vnd.restful+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.rig.cryptonote": {
      source: "iana",
      extensions: ["cryptonote"]
    },
    "application/vnd.rim.cod": {
      source: "apache",
      extensions: ["cod"]
    },
    "application/vnd.rn-realmedia": {
      source: "apache",
      extensions: ["rm"]
    },
    "application/vnd.rn-realmedia-vbr": {
      source: "apache",
      extensions: ["rmvb"]
    },
    "application/vnd.route66.link66+xml": {
      source: "iana",
      compressible: true,
      extensions: ["link66"]
    },
    "application/vnd.rs-274x": {
      source: "iana"
    },
    "application/vnd.ruckus.download": {
      source: "iana"
    },
    "application/vnd.s3sms": {
      source: "iana"
    },
    "application/vnd.sailingtracker.track": {
      source: "iana",
      extensions: ["st"]
    },
    "application/vnd.sar": {
      source: "iana"
    },
    "application/vnd.sbm.cid": {
      source: "iana"
    },
    "application/vnd.sbm.mid2": {
      source: "iana"
    },
    "application/vnd.scribus": {
      source: "iana"
    },
    "application/vnd.sealed.3df": {
      source: "iana"
    },
    "application/vnd.sealed.csf": {
      source: "iana"
    },
    "application/vnd.sealed.doc": {
      source: "iana"
    },
    "application/vnd.sealed.eml": {
      source: "iana"
    },
    "application/vnd.sealed.mht": {
      source: "iana"
    },
    "application/vnd.sealed.net": {
      source: "iana"
    },
    "application/vnd.sealed.ppt": {
      source: "iana"
    },
    "application/vnd.sealed.tiff": {
      source: "iana"
    },
    "application/vnd.sealed.xls": {
      source: "iana"
    },
    "application/vnd.sealedmedia.softseal.html": {
      source: "iana"
    },
    "application/vnd.sealedmedia.softseal.pdf": {
      source: "iana"
    },
    "application/vnd.seemail": {
      source: "iana",
      extensions: ["see"]
    },
    "application/vnd.seis+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.sema": {
      source: "iana",
      extensions: ["sema"]
    },
    "application/vnd.semd": {
      source: "iana",
      extensions: ["semd"]
    },
    "application/vnd.semf": {
      source: "iana",
      extensions: ["semf"]
    },
    "application/vnd.shade-save-file": {
      source: "iana"
    },
    "application/vnd.shana.informed.formdata": {
      source: "iana",
      extensions: ["ifm"]
    },
    "application/vnd.shana.informed.formtemplate": {
      source: "iana",
      extensions: ["itp"]
    },
    "application/vnd.shana.informed.interchange": {
      source: "iana",
      extensions: ["iif"]
    },
    "application/vnd.shana.informed.package": {
      source: "iana",
      extensions: ["ipk"]
    },
    "application/vnd.shootproof+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.shopkick+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.shp": {
      source: "iana"
    },
    "application/vnd.shx": {
      source: "iana"
    },
    "application/vnd.sigrok.session": {
      source: "iana"
    },
    "application/vnd.simtech-mindmapper": {
      source: "iana",
      extensions: ["twd", "twds"]
    },
    "application/vnd.siren+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.smaf": {
      source: "iana",
      extensions: ["mmf"]
    },
    "application/vnd.smart.notebook": {
      source: "iana"
    },
    "application/vnd.smart.teacher": {
      source: "iana",
      extensions: ["teacher"]
    },
    "application/vnd.snesdev-page-table": {
      source: "iana"
    },
    "application/vnd.software602.filler.form+xml": {
      source: "iana",
      compressible: true,
      extensions: ["fo"]
    },
    "application/vnd.software602.filler.form-xml-zip": {
      source: "iana"
    },
    "application/vnd.solent.sdkm+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sdkm", "sdkd"]
    },
    "application/vnd.spotfire.dxp": {
      source: "iana",
      extensions: ["dxp"]
    },
    "application/vnd.spotfire.sfs": {
      source: "iana",
      extensions: ["sfs"]
    },
    "application/vnd.sqlite3": {
      source: "iana"
    },
    "application/vnd.sss-cod": {
      source: "iana"
    },
    "application/vnd.sss-dtf": {
      source: "iana"
    },
    "application/vnd.sss-ntf": {
      source: "iana"
    },
    "application/vnd.stardivision.calc": {
      source: "apache",
      extensions: ["sdc"]
    },
    "application/vnd.stardivision.draw": {
      source: "apache",
      extensions: ["sda"]
    },
    "application/vnd.stardivision.impress": {
      source: "apache",
      extensions: ["sdd"]
    },
    "application/vnd.stardivision.math": {
      source: "apache",
      extensions: ["smf"]
    },
    "application/vnd.stardivision.writer": {
      source: "apache",
      extensions: ["sdw", "vor"]
    },
    "application/vnd.stardivision.writer-global": {
      source: "apache",
      extensions: ["sgl"]
    },
    "application/vnd.stepmania.package": {
      source: "iana",
      extensions: ["smzip"]
    },
    "application/vnd.stepmania.stepchart": {
      source: "iana",
      extensions: ["sm"]
    },
    "application/vnd.street-stream": {
      source: "iana"
    },
    "application/vnd.sun.wadl+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wadl"]
    },
    "application/vnd.sun.xml.calc": {
      source: "apache",
      extensions: ["sxc"]
    },
    "application/vnd.sun.xml.calc.template": {
      source: "apache",
      extensions: ["stc"]
    },
    "application/vnd.sun.xml.draw": {
      source: "apache",
      extensions: ["sxd"]
    },
    "application/vnd.sun.xml.draw.template": {
      source: "apache",
      extensions: ["std"]
    },
    "application/vnd.sun.xml.impress": {
      source: "apache",
      extensions: ["sxi"]
    },
    "application/vnd.sun.xml.impress.template": {
      source: "apache",
      extensions: ["sti"]
    },
    "application/vnd.sun.xml.math": {
      source: "apache",
      extensions: ["sxm"]
    },
    "application/vnd.sun.xml.writer": {
      source: "apache",
      extensions: ["sxw"]
    },
    "application/vnd.sun.xml.writer.global": {
      source: "apache",
      extensions: ["sxg"]
    },
    "application/vnd.sun.xml.writer.template": {
      source: "apache",
      extensions: ["stw"]
    },
    "application/vnd.sus-calendar": {
      source: "iana",
      extensions: ["sus", "susp"]
    },
    "application/vnd.svd": {
      source: "iana",
      extensions: ["svd"]
    },
    "application/vnd.swiftview-ics": {
      source: "iana"
    },
    "application/vnd.sycle+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.symbian.install": {
      source: "apache",
      extensions: ["sis", "sisx"]
    },
    "application/vnd.syncml+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["xsm"]
    },
    "application/vnd.syncml.dm+wbxml": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["bdm"]
    },
    "application/vnd.syncml.dm+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["xdm"]
    },
    "application/vnd.syncml.dm.notification": {
      source: "iana"
    },
    "application/vnd.syncml.dmddf+wbxml": {
      source: "iana"
    },
    "application/vnd.syncml.dmddf+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["ddf"]
    },
    "application/vnd.syncml.dmtnds+wbxml": {
      source: "iana"
    },
    "application/vnd.syncml.dmtnds+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.syncml.ds.notification": {
      source: "iana"
    },
    "application/vnd.tableschema+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.tao.intent-module-archive": {
      source: "iana",
      extensions: ["tao"]
    },
    "application/vnd.tcpdump.pcap": {
      source: "iana",
      extensions: ["pcap", "cap", "dmp"]
    },
    "application/vnd.think-cell.ppttc+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.tmd.mediaflex.api+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.tml": {
      source: "iana"
    },
    "application/vnd.tmobile-livetv": {
      source: "iana",
      extensions: ["tmo"]
    },
    "application/vnd.tri.onesource": {
      source: "iana"
    },
    "application/vnd.trid.tpt": {
      source: "iana",
      extensions: ["tpt"]
    },
    "application/vnd.triscape.mxs": {
      source: "iana",
      extensions: ["mxs"]
    },
    "application/vnd.trueapp": {
      source: "iana",
      extensions: ["tra"]
    },
    "application/vnd.truedoc": {
      source: "iana"
    },
    "application/vnd.ubisoft.webplayer": {
      source: "iana"
    },
    "application/vnd.ufdl": {
      source: "iana",
      extensions: ["ufd", "ufdl"]
    },
    "application/vnd.uiq.theme": {
      source: "iana",
      extensions: ["utz"]
    },
    "application/vnd.umajin": {
      source: "iana",
      extensions: ["umj"]
    },
    "application/vnd.unity": {
      source: "iana",
      extensions: ["unityweb"]
    },
    "application/vnd.uoml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["uoml"]
    },
    "application/vnd.uplanet.alert": {
      source: "iana"
    },
    "application/vnd.uplanet.alert-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.bearer-choice": {
      source: "iana"
    },
    "application/vnd.uplanet.bearer-choice-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.cacheop": {
      source: "iana"
    },
    "application/vnd.uplanet.cacheop-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.channel": {
      source: "iana"
    },
    "application/vnd.uplanet.channel-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.list": {
      source: "iana"
    },
    "application/vnd.uplanet.list-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.listcmd": {
      source: "iana"
    },
    "application/vnd.uplanet.listcmd-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.signal": {
      source: "iana"
    },
    "application/vnd.uri-map": {
      source: "iana"
    },
    "application/vnd.valve.source.material": {
      source: "iana"
    },
    "application/vnd.vcx": {
      source: "iana",
      extensions: ["vcx"]
    },
    "application/vnd.vd-study": {
      source: "iana"
    },
    "application/vnd.vectorworks": {
      source: "iana"
    },
    "application/vnd.vel+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.verimatrix.vcas": {
      source: "iana"
    },
    "application/vnd.veritone.aion+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.veryant.thin": {
      source: "iana"
    },
    "application/vnd.ves.encrypted": {
      source: "iana"
    },
    "application/vnd.vidsoft.vidconference": {
      source: "iana"
    },
    "application/vnd.visio": {
      source: "iana",
      extensions: ["vsd", "vst", "vss", "vsw"]
    },
    "application/vnd.visionary": {
      source: "iana",
      extensions: ["vis"]
    },
    "application/vnd.vividence.scriptfile": {
      source: "iana"
    },
    "application/vnd.vsf": {
      source: "iana",
      extensions: ["vsf"]
    },
    "application/vnd.wap.sic": {
      source: "iana"
    },
    "application/vnd.wap.slc": {
      source: "iana"
    },
    "application/vnd.wap.wbxml": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["wbxml"]
    },
    "application/vnd.wap.wmlc": {
      source: "iana",
      extensions: ["wmlc"]
    },
    "application/vnd.wap.wmlscriptc": {
      source: "iana",
      extensions: ["wmlsc"]
    },
    "application/vnd.webturbo": {
      source: "iana",
      extensions: ["wtb"]
    },
    "application/vnd.wfa.dpp": {
      source: "iana"
    },
    "application/vnd.wfa.p2p": {
      source: "iana"
    },
    "application/vnd.wfa.wsc": {
      source: "iana"
    },
    "application/vnd.windows.devicepairing": {
      source: "iana"
    },
    "application/vnd.wmc": {
      source: "iana"
    },
    "application/vnd.wmf.bootstrap": {
      source: "iana"
    },
    "application/vnd.wolfram.mathematica": {
      source: "iana"
    },
    "application/vnd.wolfram.mathematica.package": {
      source: "iana"
    },
    "application/vnd.wolfram.player": {
      source: "iana",
      extensions: ["nbp"]
    },
    "application/vnd.wordperfect": {
      source: "iana",
      extensions: ["wpd"]
    },
    "application/vnd.wqd": {
      source: "iana",
      extensions: ["wqd"]
    },
    "application/vnd.wrq-hp3000-labelled": {
      source: "iana"
    },
    "application/vnd.wt.stf": {
      source: "iana",
      extensions: ["stf"]
    },
    "application/vnd.wv.csp+wbxml": {
      source: "iana"
    },
    "application/vnd.wv.csp+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.wv.ssp+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.xacml+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.xara": {
      source: "iana",
      extensions: ["xar"]
    },
    "application/vnd.xfdl": {
      source: "iana",
      extensions: ["xfdl"]
    },
    "application/vnd.xfdl.webform": {
      source: "iana"
    },
    "application/vnd.xmi+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.xmpie.cpkg": {
      source: "iana"
    },
    "application/vnd.xmpie.dpkg": {
      source: "iana"
    },
    "application/vnd.xmpie.plan": {
      source: "iana"
    },
    "application/vnd.xmpie.ppkg": {
      source: "iana"
    },
    "application/vnd.xmpie.xlim": {
      source: "iana"
    },
    "application/vnd.yamaha.hv-dic": {
      source: "iana",
      extensions: ["hvd"]
    },
    "application/vnd.yamaha.hv-script": {
      source: "iana",
      extensions: ["hvs"]
    },
    "application/vnd.yamaha.hv-voice": {
      source: "iana",
      extensions: ["hvp"]
    },
    "application/vnd.yamaha.openscoreformat": {
      source: "iana",
      extensions: ["osf"]
    },
    "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
      source: "iana",
      compressible: true,
      extensions: ["osfpvg"]
    },
    "application/vnd.yamaha.remote-setup": {
      source: "iana"
    },
    "application/vnd.yamaha.smaf-audio": {
      source: "iana",
      extensions: ["saf"]
    },
    "application/vnd.yamaha.smaf-phrase": {
      source: "iana",
      extensions: ["spf"]
    },
    "application/vnd.yamaha.through-ngn": {
      source: "iana"
    },
    "application/vnd.yamaha.tunnel-udpencap": {
      source: "iana"
    },
    "application/vnd.yaoweme": {
      source: "iana"
    },
    "application/vnd.yellowriver-custom-menu": {
      source: "iana",
      extensions: ["cmp"]
    },
    "application/vnd.youtube.yt": {
      source: "iana"
    },
    "application/vnd.zul": {
      source: "iana",
      extensions: ["zir", "zirz"]
    },
    "application/vnd.zzazz.deck+xml": {
      source: "iana",
      compressible: true,
      extensions: ["zaz"]
    },
    "application/voicexml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["vxml"]
    },
    "application/voucher-cms+json": {
      source: "iana",
      compressible: true
    },
    "application/vq-rtcpxr": {
      source: "iana"
    },
    "application/wasm": {
      source: "iana",
      compressible: true,
      extensions: ["wasm"]
    },
    "application/watcherinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/webpush-options+json": {
      source: "iana",
      compressible: true
    },
    "application/whoispp-query": {
      source: "iana"
    },
    "application/whoispp-response": {
      source: "iana"
    },
    "application/widget": {
      source: "iana",
      extensions: ["wgt"]
    },
    "application/winhlp": {
      source: "apache",
      extensions: ["hlp"]
    },
    "application/wita": {
      source: "iana"
    },
    "application/wordperfect5.1": {
      source: "iana"
    },
    "application/wsdl+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wsdl"]
    },
    "application/wspolicy+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wspolicy"]
    },
    "application/x-7z-compressed": {
      source: "apache",
      compressible: false,
      extensions: ["7z"]
    },
    "application/x-abiword": {
      source: "apache",
      extensions: ["abw"]
    },
    "application/x-ace-compressed": {
      source: "apache",
      extensions: ["ace"]
    },
    "application/x-amf": {
      source: "apache"
    },
    "application/x-apple-diskimage": {
      source: "apache",
      extensions: ["dmg"]
    },
    "application/x-arj": {
      compressible: false,
      extensions: ["arj"]
    },
    "application/x-authorware-bin": {
      source: "apache",
      extensions: ["aab", "x32", "u32", "vox"]
    },
    "application/x-authorware-map": {
      source: "apache",
      extensions: ["aam"]
    },
    "application/x-authorware-seg": {
      source: "apache",
      extensions: ["aas"]
    },
    "application/x-bcpio": {
      source: "apache",
      extensions: ["bcpio"]
    },
    "application/x-bdoc": {
      compressible: false,
      extensions: ["bdoc"]
    },
    "application/x-bittorrent": {
      source: "apache",
      extensions: ["torrent"]
    },
    "application/x-blorb": {
      source: "apache",
      extensions: ["blb", "blorb"]
    },
    "application/x-bzip": {
      source: "apache",
      compressible: false,
      extensions: ["bz"]
    },
    "application/x-bzip2": {
      source: "apache",
      compressible: false,
      extensions: ["bz2", "boz"]
    },
    "application/x-cbr": {
      source: "apache",
      extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
    },
    "application/x-cdlink": {
      source: "apache",
      extensions: ["vcd"]
    },
    "application/x-cfs-compressed": {
      source: "apache",
      extensions: ["cfs"]
    },
    "application/x-chat": {
      source: "apache",
      extensions: ["chat"]
    },
    "application/x-chess-pgn": {
      source: "apache",
      extensions: ["pgn"]
    },
    "application/x-chrome-extension": {
      extensions: ["crx"]
    },
    "application/x-cocoa": {
      source: "nginx",
      extensions: ["cco"]
    },
    "application/x-compress": {
      source: "apache"
    },
    "application/x-conference": {
      source: "apache",
      extensions: ["nsc"]
    },
    "application/x-cpio": {
      source: "apache",
      extensions: ["cpio"]
    },
    "application/x-csh": {
      source: "apache",
      extensions: ["csh"]
    },
    "application/x-deb": {
      compressible: false
    },
    "application/x-debian-package": {
      source: "apache",
      extensions: ["deb", "udeb"]
    },
    "application/x-dgc-compressed": {
      source: "apache",
      extensions: ["dgc"]
    },
    "application/x-director": {
      source: "apache",
      extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
    },
    "application/x-doom": {
      source: "apache",
      extensions: ["wad"]
    },
    "application/x-dtbncx+xml": {
      source: "apache",
      compressible: true,
      extensions: ["ncx"]
    },
    "application/x-dtbook+xml": {
      source: "apache",
      compressible: true,
      extensions: ["dtb"]
    },
    "application/x-dtbresource+xml": {
      source: "apache",
      compressible: true,
      extensions: ["res"]
    },
    "application/x-dvi": {
      source: "apache",
      compressible: false,
      extensions: ["dvi"]
    },
    "application/x-envoy": {
      source: "apache",
      extensions: ["evy"]
    },
    "application/x-eva": {
      source: "apache",
      extensions: ["eva"]
    },
    "application/x-font-bdf": {
      source: "apache",
      extensions: ["bdf"]
    },
    "application/x-font-dos": {
      source: "apache"
    },
    "application/x-font-framemaker": {
      source: "apache"
    },
    "application/x-font-ghostscript": {
      source: "apache",
      extensions: ["gsf"]
    },
    "application/x-font-libgrx": {
      source: "apache"
    },
    "application/x-font-linux-psf": {
      source: "apache",
      extensions: ["psf"]
    },
    "application/x-font-pcf": {
      source: "apache",
      extensions: ["pcf"]
    },
    "application/x-font-snf": {
      source: "apache",
      extensions: ["snf"]
    },
    "application/x-font-speedo": {
      source: "apache"
    },
    "application/x-font-sunos-news": {
      source: "apache"
    },
    "application/x-font-type1": {
      source: "apache",
      extensions: ["pfa", "pfb", "pfm", "afm"]
    },
    "application/x-font-vfont": {
      source: "apache"
    },
    "application/x-freearc": {
      source: "apache",
      extensions: ["arc"]
    },
    "application/x-futuresplash": {
      source: "apache",
      extensions: ["spl"]
    },
    "application/x-gca-compressed": {
      source: "apache",
      extensions: ["gca"]
    },
    "application/x-glulx": {
      source: "apache",
      extensions: ["ulx"]
    },
    "application/x-gnumeric": {
      source: "apache",
      extensions: ["gnumeric"]
    },
    "application/x-gramps-xml": {
      source: "apache",
      extensions: ["gramps"]
    },
    "application/x-gtar": {
      source: "apache",
      extensions: ["gtar"]
    },
    "application/x-gzip": {
      source: "apache"
    },
    "application/x-hdf": {
      source: "apache",
      extensions: ["hdf"]
    },
    "application/x-httpd-php": {
      compressible: true,
      extensions: ["php"]
    },
    "application/x-install-instructions": {
      source: "apache",
      extensions: ["install"]
    },
    "application/x-iso9660-image": {
      source: "apache",
      extensions: ["iso"]
    },
    "application/x-java-archive-diff": {
      source: "nginx",
      extensions: ["jardiff"]
    },
    "application/x-java-jnlp-file": {
      source: "apache",
      compressible: false,
      extensions: ["jnlp"]
    },
    "application/x-javascript": {
      compressible: true
    },
    "application/x-keepass2": {
      extensions: ["kdbx"]
    },
    "application/x-latex": {
      source: "apache",
      compressible: false,
      extensions: ["latex"]
    },
    "application/x-lua-bytecode": {
      extensions: ["luac"]
    },
    "application/x-lzh-compressed": {
      source: "apache",
      extensions: ["lzh", "lha"]
    },
    "application/x-makeself": {
      source: "nginx",
      extensions: ["run"]
    },
    "application/x-mie": {
      source: "apache",
      extensions: ["mie"]
    },
    "application/x-mobipocket-ebook": {
      source: "apache",
      extensions: ["prc", "mobi"]
    },
    "application/x-mpegurl": {
      compressible: false
    },
    "application/x-ms-application": {
      source: "apache",
      extensions: ["application"]
    },
    "application/x-ms-shortcut": {
      source: "apache",
      extensions: ["lnk"]
    },
    "application/x-ms-wmd": {
      source: "apache",
      extensions: ["wmd"]
    },
    "application/x-ms-wmz": {
      source: "apache",
      extensions: ["wmz"]
    },
    "application/x-ms-xbap": {
      source: "apache",
      extensions: ["xbap"]
    },
    "application/x-msaccess": {
      source: "apache",
      extensions: ["mdb"]
    },
    "application/x-msbinder": {
      source: "apache",
      extensions: ["obd"]
    },
    "application/x-mscardfile": {
      source: "apache",
      extensions: ["crd"]
    },
    "application/x-msclip": {
      source: "apache",
      extensions: ["clp"]
    },
    "application/x-msdos-program": {
      extensions: ["exe"]
    },
    "application/x-msdownload": {
      source: "apache",
      extensions: ["exe", "dll", "com", "bat", "msi"]
    },
    "application/x-msmediaview": {
      source: "apache",
      extensions: ["mvb", "m13", "m14"]
    },
    "application/x-msmetafile": {
      source: "apache",
      extensions: ["wmf", "wmz", "emf", "emz"]
    },
    "application/x-msmoney": {
      source: "apache",
      extensions: ["mny"]
    },
    "application/x-mspublisher": {
      source: "apache",
      extensions: ["pub"]
    },
    "application/x-msschedule": {
      source: "apache",
      extensions: ["scd"]
    },
    "application/x-msterminal": {
      source: "apache",
      extensions: ["trm"]
    },
    "application/x-mswrite": {
      source: "apache",
      extensions: ["wri"]
    },
    "application/x-netcdf": {
      source: "apache",
      extensions: ["nc", "cdf"]
    },
    "application/x-ns-proxy-autoconfig": {
      compressible: true,
      extensions: ["pac"]
    },
    "application/x-nzb": {
      source: "apache",
      extensions: ["nzb"]
    },
    "application/x-perl": {
      source: "nginx",
      extensions: ["pl", "pm"]
    },
    "application/x-pilot": {
      source: "nginx",
      extensions: ["prc", "pdb"]
    },
    "application/x-pkcs12": {
      source: "apache",
      compressible: false,
      extensions: ["p12", "pfx"]
    },
    "application/x-pkcs7-certificates": {
      source: "apache",
      extensions: ["p7b", "spc"]
    },
    "application/x-pkcs7-certreqresp": {
      source: "apache",
      extensions: ["p7r"]
    },
    "application/x-pki-message": {
      source: "iana"
    },
    "application/x-rar-compressed": {
      source: "apache",
      compressible: false,
      extensions: ["rar"]
    },
    "application/x-redhat-package-manager": {
      source: "nginx",
      extensions: ["rpm"]
    },
    "application/x-research-info-systems": {
      source: "apache",
      extensions: ["ris"]
    },
    "application/x-sea": {
      source: "nginx",
      extensions: ["sea"]
    },
    "application/x-sh": {
      source: "apache",
      compressible: true,
      extensions: ["sh"]
    },
    "application/x-shar": {
      source: "apache",
      extensions: ["shar"]
    },
    "application/x-shockwave-flash": {
      source: "apache",
      compressible: false,
      extensions: ["swf"]
    },
    "application/x-silverlight-app": {
      source: "apache",
      extensions: ["xap"]
    },
    "application/x-sql": {
      source: "apache",
      extensions: ["sql"]
    },
    "application/x-stuffit": {
      source: "apache",
      compressible: false,
      extensions: ["sit"]
    },
    "application/x-stuffitx": {
      source: "apache",
      extensions: ["sitx"]
    },
    "application/x-subrip": {
      source: "apache",
      extensions: ["srt"]
    },
    "application/x-sv4cpio": {
      source: "apache",
      extensions: ["sv4cpio"]
    },
    "application/x-sv4crc": {
      source: "apache",
      extensions: ["sv4crc"]
    },
    "application/x-t3vm-image": {
      source: "apache",
      extensions: ["t3"]
    },
    "application/x-tads": {
      source: "apache",
      extensions: ["gam"]
    },
    "application/x-tar": {
      source: "apache",
      compressible: true,
      extensions: ["tar"]
    },
    "application/x-tcl": {
      source: "apache",
      extensions: ["tcl", "tk"]
    },
    "application/x-tex": {
      source: "apache",
      extensions: ["tex"]
    },
    "application/x-tex-tfm": {
      source: "apache",
      extensions: ["tfm"]
    },
    "application/x-texinfo": {
      source: "apache",
      extensions: ["texinfo", "texi"]
    },
    "application/x-tgif": {
      source: "apache",
      extensions: ["obj"]
    },
    "application/x-ustar": {
      source: "apache",
      extensions: ["ustar"]
    },
    "application/x-virtualbox-hdd": {
      compressible: true,
      extensions: ["hdd"]
    },
    "application/x-virtualbox-ova": {
      compressible: true,
      extensions: ["ova"]
    },
    "application/x-virtualbox-ovf": {
      compressible: true,
      extensions: ["ovf"]
    },
    "application/x-virtualbox-vbox": {
      compressible: true,
      extensions: ["vbox"]
    },
    "application/x-virtualbox-vbox-extpack": {
      compressible: false,
      extensions: ["vbox-extpack"]
    },
    "application/x-virtualbox-vdi": {
      compressible: true,
      extensions: ["vdi"]
    },
    "application/x-virtualbox-vhd": {
      compressible: true,
      extensions: ["vhd"]
    },
    "application/x-virtualbox-vmdk": {
      compressible: true,
      extensions: ["vmdk"]
    },
    "application/x-wais-source": {
      source: "apache",
      extensions: ["src"]
    },
    "application/x-web-app-manifest+json": {
      compressible: true,
      extensions: ["webapp"]
    },
    "application/x-www-form-urlencoded": {
      source: "iana",
      compressible: true
    },
    "application/x-x509-ca-cert": {
      source: "iana",
      extensions: ["der", "crt", "pem"]
    },
    "application/x-x509-ca-ra-cert": {
      source: "iana"
    },
    "application/x-x509-next-ca-cert": {
      source: "iana"
    },
    "application/x-xfig": {
      source: "apache",
      extensions: ["fig"]
    },
    "application/x-xliff+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xlf"]
    },
    "application/x-xpinstall": {
      source: "apache",
      compressible: false,
      extensions: ["xpi"]
    },
    "application/x-xz": {
      source: "apache",
      extensions: ["xz"]
    },
    "application/x-zmachine": {
      source: "apache",
      extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
    },
    "application/x400-bp": {
      source: "iana"
    },
    "application/xacml+xml": {
      source: "iana",
      compressible: true
    },
    "application/xaml+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xaml"]
    },
    "application/xcap-att+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xav"]
    },
    "application/xcap-caps+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xca"]
    },
    "application/xcap-diff+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xdf"]
    },
    "application/xcap-el+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xel"]
    },
    "application/xcap-error+xml": {
      source: "iana",
      compressible: true
    },
    "application/xcap-ns+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xns"]
    },
    "application/xcon-conference-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/xcon-conference-info-diff+xml": {
      source: "iana",
      compressible: true
    },
    "application/xenc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xenc"]
    },
    "application/xhtml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xhtml", "xht"]
    },
    "application/xhtml-voice+xml": {
      source: "apache",
      compressible: true
    },
    "application/xliff+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xlf"]
    },
    "application/xml": {
      source: "iana",
      compressible: true,
      extensions: ["xml", "xsl", "xsd", "rng"]
    },
    "application/xml-dtd": {
      source: "iana",
      compressible: true,
      extensions: ["dtd"]
    },
    "application/xml-external-parsed-entity": {
      source: "iana"
    },
    "application/xml-patch+xml": {
      source: "iana",
      compressible: true
    },
    "application/xmpp+xml": {
      source: "iana",
      compressible: true
    },
    "application/xop+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xop"]
    },
    "application/xproc+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xpl"]
    },
    "application/xslt+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xsl", "xslt"]
    },
    "application/xspf+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xspf"]
    },
    "application/xv+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mxml", "xhvml", "xvml", "xvm"]
    },
    "application/yang": {
      source: "iana",
      extensions: ["yang"]
    },
    "application/yang-data+json": {
      source: "iana",
      compressible: true
    },
    "application/yang-data+xml": {
      source: "iana",
      compressible: true
    },
    "application/yang-patch+json": {
      source: "iana",
      compressible: true
    },
    "application/yang-patch+xml": {
      source: "iana",
      compressible: true
    },
    "application/yin+xml": {
      source: "iana",
      compressible: true,
      extensions: ["yin"]
    },
    "application/zip": {
      source: "iana",
      compressible: false,
      extensions: ["zip"]
    },
    "application/zlib": {
      source: "iana"
    },
    "application/zstd": {
      source: "iana"
    },
    "audio/1d-interleaved-parityfec": {
      source: "iana"
    },
    "audio/32kadpcm": {
      source: "iana"
    },
    "audio/3gpp": {
      source: "iana",
      compressible: false,
      extensions: ["3gpp"]
    },
    "audio/3gpp2": {
      source: "iana"
    },
    "audio/aac": {
      source: "iana"
    },
    "audio/ac3": {
      source: "iana"
    },
    "audio/adpcm": {
      source: "apache",
      extensions: ["adp"]
    },
    "audio/amr": {
      source: "iana",
      extensions: ["amr"]
    },
    "audio/amr-wb": {
      source: "iana"
    },
    "audio/amr-wb+": {
      source: "iana"
    },
    "audio/aptx": {
      source: "iana"
    },
    "audio/asc": {
      source: "iana"
    },
    "audio/atrac-advanced-lossless": {
      source: "iana"
    },
    "audio/atrac-x": {
      source: "iana"
    },
    "audio/atrac3": {
      source: "iana"
    },
    "audio/basic": {
      source: "iana",
      compressible: false,
      extensions: ["au", "snd"]
    },
    "audio/bv16": {
      source: "iana"
    },
    "audio/bv32": {
      source: "iana"
    },
    "audio/clearmode": {
      source: "iana"
    },
    "audio/cn": {
      source: "iana"
    },
    "audio/dat12": {
      source: "iana"
    },
    "audio/dls": {
      source: "iana"
    },
    "audio/dsr-es201108": {
      source: "iana"
    },
    "audio/dsr-es202050": {
      source: "iana"
    },
    "audio/dsr-es202211": {
      source: "iana"
    },
    "audio/dsr-es202212": {
      source: "iana"
    },
    "audio/dv": {
      source: "iana"
    },
    "audio/dvi4": {
      source: "iana"
    },
    "audio/eac3": {
      source: "iana"
    },
    "audio/encaprtp": {
      source: "iana"
    },
    "audio/evrc": {
      source: "iana"
    },
    "audio/evrc-qcp": {
      source: "iana"
    },
    "audio/evrc0": {
      source: "iana"
    },
    "audio/evrc1": {
      source: "iana"
    },
    "audio/evrcb": {
      source: "iana"
    },
    "audio/evrcb0": {
      source: "iana"
    },
    "audio/evrcb1": {
      source: "iana"
    },
    "audio/evrcnw": {
      source: "iana"
    },
    "audio/evrcnw0": {
      source: "iana"
    },
    "audio/evrcnw1": {
      source: "iana"
    },
    "audio/evrcwb": {
      source: "iana"
    },
    "audio/evrcwb0": {
      source: "iana"
    },
    "audio/evrcwb1": {
      source: "iana"
    },
    "audio/evs": {
      source: "iana"
    },
    "audio/flexfec": {
      source: "iana"
    },
    "audio/fwdred": {
      source: "iana"
    },
    "audio/g711-0": {
      source: "iana"
    },
    "audio/g719": {
      source: "iana"
    },
    "audio/g722": {
      source: "iana"
    },
    "audio/g7221": {
      source: "iana"
    },
    "audio/g723": {
      source: "iana"
    },
    "audio/g726-16": {
      source: "iana"
    },
    "audio/g726-24": {
      source: "iana"
    },
    "audio/g726-32": {
      source: "iana"
    },
    "audio/g726-40": {
      source: "iana"
    },
    "audio/g728": {
      source: "iana"
    },
    "audio/g729": {
      source: "iana"
    },
    "audio/g7291": {
      source: "iana"
    },
    "audio/g729d": {
      source: "iana"
    },
    "audio/g729e": {
      source: "iana"
    },
    "audio/gsm": {
      source: "iana"
    },
    "audio/gsm-efr": {
      source: "iana"
    },
    "audio/gsm-hr-08": {
      source: "iana"
    },
    "audio/ilbc": {
      source: "iana"
    },
    "audio/ip-mr_v2.5": {
      source: "iana"
    },
    "audio/isac": {
      source: "apache"
    },
    "audio/l16": {
      source: "iana"
    },
    "audio/l20": {
      source: "iana"
    },
    "audio/l24": {
      source: "iana",
      compressible: false
    },
    "audio/l8": {
      source: "iana"
    },
    "audio/lpc": {
      source: "iana"
    },
    "audio/melp": {
      source: "iana"
    },
    "audio/melp1200": {
      source: "iana"
    },
    "audio/melp2400": {
      source: "iana"
    },
    "audio/melp600": {
      source: "iana"
    },
    "audio/mhas": {
      source: "iana"
    },
    "audio/midi": {
      source: "apache",
      extensions: ["mid", "midi", "kar", "rmi"]
    },
    "audio/mobile-xmf": {
      source: "iana",
      extensions: ["mxmf"]
    },
    "audio/mp3": {
      compressible: false,
      extensions: ["mp3"]
    },
    "audio/mp4": {
      source: "iana",
      compressible: false,
      extensions: ["m4a", "mp4a"]
    },
    "audio/mp4a-latm": {
      source: "iana"
    },
    "audio/mpa": {
      source: "iana"
    },
    "audio/mpa-robust": {
      source: "iana"
    },
    "audio/mpeg": {
      source: "iana",
      compressible: false,
      extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
    },
    "audio/mpeg4-generic": {
      source: "iana"
    },
    "audio/musepack": {
      source: "apache"
    },
    "audio/ogg": {
      source: "iana",
      compressible: false,
      extensions: ["oga", "ogg", "spx", "opus"]
    },
    "audio/opus": {
      source: "iana"
    },
    "audio/parityfec": {
      source: "iana"
    },
    "audio/pcma": {
      source: "iana"
    },
    "audio/pcma-wb": {
      source: "iana"
    },
    "audio/pcmu": {
      source: "iana"
    },
    "audio/pcmu-wb": {
      source: "iana"
    },
    "audio/prs.sid": {
      source: "iana"
    },
    "audio/qcelp": {
      source: "iana"
    },
    "audio/raptorfec": {
      source: "iana"
    },
    "audio/red": {
      source: "iana"
    },
    "audio/rtp-enc-aescm128": {
      source: "iana"
    },
    "audio/rtp-midi": {
      source: "iana"
    },
    "audio/rtploopback": {
      source: "iana"
    },
    "audio/rtx": {
      source: "iana"
    },
    "audio/s3m": {
      source: "apache",
      extensions: ["s3m"]
    },
    "audio/scip": {
      source: "iana"
    },
    "audio/silk": {
      source: "apache",
      extensions: ["sil"]
    },
    "audio/smv": {
      source: "iana"
    },
    "audio/smv-qcp": {
      source: "iana"
    },
    "audio/smv0": {
      source: "iana"
    },
    "audio/sofa": {
      source: "iana"
    },
    "audio/sp-midi": {
      source: "iana"
    },
    "audio/speex": {
      source: "iana"
    },
    "audio/t140c": {
      source: "iana"
    },
    "audio/t38": {
      source: "iana"
    },
    "audio/telephone-event": {
      source: "iana"
    },
    "audio/tetra_acelp": {
      source: "iana"
    },
    "audio/tetra_acelp_bb": {
      source: "iana"
    },
    "audio/tone": {
      source: "iana"
    },
    "audio/tsvcis": {
      source: "iana"
    },
    "audio/uemclip": {
      source: "iana"
    },
    "audio/ulpfec": {
      source: "iana"
    },
    "audio/usac": {
      source: "iana"
    },
    "audio/vdvi": {
      source: "iana"
    },
    "audio/vmr-wb": {
      source: "iana"
    },
    "audio/vnd.3gpp.iufp": {
      source: "iana"
    },
    "audio/vnd.4sb": {
      source: "iana"
    },
    "audio/vnd.audiokoz": {
      source: "iana"
    },
    "audio/vnd.celp": {
      source: "iana"
    },
    "audio/vnd.cisco.nse": {
      source: "iana"
    },
    "audio/vnd.cmles.radio-events": {
      source: "iana"
    },
    "audio/vnd.cns.anp1": {
      source: "iana"
    },
    "audio/vnd.cns.inf1": {
      source: "iana"
    },
    "audio/vnd.dece.audio": {
      source: "iana",
      extensions: ["uva", "uvva"]
    },
    "audio/vnd.digital-winds": {
      source: "iana",
      extensions: ["eol"]
    },
    "audio/vnd.dlna.adts": {
      source: "iana"
    },
    "audio/vnd.dolby.heaac.1": {
      source: "iana"
    },
    "audio/vnd.dolby.heaac.2": {
      source: "iana"
    },
    "audio/vnd.dolby.mlp": {
      source: "iana"
    },
    "audio/vnd.dolby.mps": {
      source: "iana"
    },
    "audio/vnd.dolby.pl2": {
      source: "iana"
    },
    "audio/vnd.dolby.pl2x": {
      source: "iana"
    },
    "audio/vnd.dolby.pl2z": {
      source: "iana"
    },
    "audio/vnd.dolby.pulse.1": {
      source: "iana"
    },
    "audio/vnd.dra": {
      source: "iana",
      extensions: ["dra"]
    },
    "audio/vnd.dts": {
      source: "iana",
      extensions: ["dts"]
    },
    "audio/vnd.dts.hd": {
      source: "iana",
      extensions: ["dtshd"]
    },
    "audio/vnd.dts.uhd": {
      source: "iana"
    },
    "audio/vnd.dvb.file": {
      source: "iana"
    },
    "audio/vnd.everad.plj": {
      source: "iana"
    },
    "audio/vnd.hns.audio": {
      source: "iana"
    },
    "audio/vnd.lucent.voice": {
      source: "iana",
      extensions: ["lvp"]
    },
    "audio/vnd.ms-playready.media.pya": {
      source: "iana",
      extensions: ["pya"]
    },
    "audio/vnd.nokia.mobile-xmf": {
      source: "iana"
    },
    "audio/vnd.nortel.vbk": {
      source: "iana"
    },
    "audio/vnd.nuera.ecelp4800": {
      source: "iana",
      extensions: ["ecelp4800"]
    },
    "audio/vnd.nuera.ecelp7470": {
      source: "iana",
      extensions: ["ecelp7470"]
    },
    "audio/vnd.nuera.ecelp9600": {
      source: "iana",
      extensions: ["ecelp9600"]
    },
    "audio/vnd.octel.sbc": {
      source: "iana"
    },
    "audio/vnd.presonus.multitrack": {
      source: "iana"
    },
    "audio/vnd.qcelp": {
      source: "iana"
    },
    "audio/vnd.rhetorex.32kadpcm": {
      source: "iana"
    },
    "audio/vnd.rip": {
      source: "iana",
      extensions: ["rip"]
    },
    "audio/vnd.rn-realaudio": {
      compressible: false
    },
    "audio/vnd.sealedmedia.softseal.mpeg": {
      source: "iana"
    },
    "audio/vnd.vmx.cvsd": {
      source: "iana"
    },
    "audio/vnd.wave": {
      compressible: false
    },
    "audio/vorbis": {
      source: "iana",
      compressible: false
    },
    "audio/vorbis-config": {
      source: "iana"
    },
    "audio/wav": {
      compressible: false,
      extensions: ["wav"]
    },
    "audio/wave": {
      compressible: false,
      extensions: ["wav"]
    },
    "audio/webm": {
      source: "apache",
      compressible: false,
      extensions: ["weba"]
    },
    "audio/x-aac": {
      source: "apache",
      compressible: false,
      extensions: ["aac"]
    },
    "audio/x-aiff": {
      source: "apache",
      extensions: ["aif", "aiff", "aifc"]
    },
    "audio/x-caf": {
      source: "apache",
      compressible: false,
      extensions: ["caf"]
    },
    "audio/x-flac": {
      source: "apache",
      extensions: ["flac"]
    },
    "audio/x-m4a": {
      source: "nginx",
      extensions: ["m4a"]
    },
    "audio/x-matroska": {
      source: "apache",
      extensions: ["mka"]
    },
    "audio/x-mpegurl": {
      source: "apache",
      extensions: ["m3u"]
    },
    "audio/x-ms-wax": {
      source: "apache",
      extensions: ["wax"]
    },
    "audio/x-ms-wma": {
      source: "apache",
      extensions: ["wma"]
    },
    "audio/x-pn-realaudio": {
      source: "apache",
      extensions: ["ram", "ra"]
    },
    "audio/x-pn-realaudio-plugin": {
      source: "apache",
      extensions: ["rmp"]
    },
    "audio/x-realaudio": {
      source: "nginx",
      extensions: ["ra"]
    },
    "audio/x-tta": {
      source: "apache"
    },
    "audio/x-wav": {
      source: "apache",
      extensions: ["wav"]
    },
    "audio/xm": {
      source: "apache",
      extensions: ["xm"]
    },
    "chemical/x-cdx": {
      source: "apache",
      extensions: ["cdx"]
    },
    "chemical/x-cif": {
      source: "apache",
      extensions: ["cif"]
    },
    "chemical/x-cmdf": {
      source: "apache",
      extensions: ["cmdf"]
    },
    "chemical/x-cml": {
      source: "apache",
      extensions: ["cml"]
    },
    "chemical/x-csml": {
      source: "apache",
      extensions: ["csml"]
    },
    "chemical/x-pdb": {
      source: "apache"
    },
    "chemical/x-xyz": {
      source: "apache",
      extensions: ["xyz"]
    },
    "font/collection": {
      source: "iana",
      extensions: ["ttc"]
    },
    "font/otf": {
      source: "iana",
      compressible: true,
      extensions: ["otf"]
    },
    "font/sfnt": {
      source: "iana"
    },
    "font/ttf": {
      source: "iana",
      compressible: true,
      extensions: ["ttf"]
    },
    "font/woff": {
      source: "iana",
      extensions: ["woff"]
    },
    "font/woff2": {
      source: "iana",
      extensions: ["woff2"]
    },
    "image/aces": {
      source: "iana",
      extensions: ["exr"]
    },
    "image/apng": {
      compressible: false,
      extensions: ["apng"]
    },
    "image/avci": {
      source: "iana"
    },
    "image/avcs": {
      source: "iana"
    },
    "image/avif": {
      source: "iana",
      compressible: false,
      extensions: ["avif"]
    },
    "image/bmp": {
      source: "iana",
      compressible: true,
      extensions: ["bmp"]
    },
    "image/cgm": {
      source: "iana",
      extensions: ["cgm"]
    },
    "image/dicom-rle": {
      source: "iana",
      extensions: ["drle"]
    },
    "image/emf": {
      source: "iana",
      extensions: ["emf"]
    },
    "image/fits": {
      source: "iana",
      extensions: ["fits"]
    },
    "image/g3fax": {
      source: "iana",
      extensions: ["g3"]
    },
    "image/gif": {
      source: "iana",
      compressible: false,
      extensions: ["gif"]
    },
    "image/heic": {
      source: "iana",
      extensions: ["heic"]
    },
    "image/heic-sequence": {
      source: "iana",
      extensions: ["heics"]
    },
    "image/heif": {
      source: "iana",
      extensions: ["heif"]
    },
    "image/heif-sequence": {
      source: "iana",
      extensions: ["heifs"]
    },
    "image/hej2k": {
      source: "iana",
      extensions: ["hej2"]
    },
    "image/hsj2": {
      source: "iana",
      extensions: ["hsj2"]
    },
    "image/ief": {
      source: "iana",
      extensions: ["ief"]
    },
    "image/jls": {
      source: "iana",
      extensions: ["jls"]
    },
    "image/jp2": {
      source: "iana",
      compressible: false,
      extensions: ["jp2", "jpg2"]
    },
    "image/jpeg": {
      source: "iana",
      compressible: false,
      extensions: ["jpeg", "jpg", "jpe"]
    },
    "image/jph": {
      source: "iana",
      extensions: ["jph"]
    },
    "image/jphc": {
      source: "iana",
      extensions: ["jhc"]
    },
    "image/jpm": {
      source: "iana",
      compressible: false,
      extensions: ["jpm"]
    },
    "image/jpx": {
      source: "iana",
      compressible: false,
      extensions: ["jpx", "jpf"]
    },
    "image/jxr": {
      source: "iana",
      extensions: ["jxr"]
    },
    "image/jxra": {
      source: "iana",
      extensions: ["jxra"]
    },
    "image/jxrs": {
      source: "iana",
      extensions: ["jxrs"]
    },
    "image/jxs": {
      source: "iana",
      extensions: ["jxs"]
    },
    "image/jxsc": {
      source: "iana",
      extensions: ["jxsc"]
    },
    "image/jxsi": {
      source: "iana",
      extensions: ["jxsi"]
    },
    "image/jxss": {
      source: "iana",
      extensions: ["jxss"]
    },
    "image/ktx": {
      source: "iana",
      extensions: ["ktx"]
    },
    "image/ktx2": {
      source: "iana",
      extensions: ["ktx2"]
    },
    "image/naplps": {
      source: "iana"
    },
    "image/pjpeg": {
      compressible: false
    },
    "image/png": {
      source: "iana",
      compressible: false,
      extensions: ["png"]
    },
    "image/prs.btif": {
      source: "iana",
      extensions: ["btif"]
    },
    "image/prs.pti": {
      source: "iana",
      extensions: ["pti"]
    },
    "image/pwg-raster": {
      source: "iana"
    },
    "image/sgi": {
      source: "apache",
      extensions: ["sgi"]
    },
    "image/svg+xml": {
      source: "iana",
      compressible: true,
      extensions: ["svg", "svgz"]
    },
    "image/t38": {
      source: "iana",
      extensions: ["t38"]
    },
    "image/tiff": {
      source: "iana",
      compressible: false,
      extensions: ["tif", "tiff"]
    },
    "image/tiff-fx": {
      source: "iana",
      extensions: ["tfx"]
    },
    "image/vnd.adobe.photoshop": {
      source: "iana",
      compressible: true,
      extensions: ["psd"]
    },
    "image/vnd.airzip.accelerator.azv": {
      source: "iana",
      extensions: ["azv"]
    },
    "image/vnd.cns.inf2": {
      source: "iana"
    },
    "image/vnd.dece.graphic": {
      source: "iana",
      extensions: ["uvi", "uvvi", "uvg", "uvvg"]
    },
    "image/vnd.djvu": {
      source: "iana",
      extensions: ["djvu", "djv"]
    },
    "image/vnd.dvb.subtitle": {
      source: "iana",
      extensions: ["sub"]
    },
    "image/vnd.dwg": {
      source: "iana",
      extensions: ["dwg"]
    },
    "image/vnd.dxf": {
      source: "iana",
      extensions: ["dxf"]
    },
    "image/vnd.fastbidsheet": {
      source: "iana",
      extensions: ["fbs"]
    },
    "image/vnd.fpx": {
      source: "iana",
      extensions: ["fpx"]
    },
    "image/vnd.fst": {
      source: "iana",
      extensions: ["fst"]
    },
    "image/vnd.fujixerox.edmics-mmr": {
      source: "iana",
      extensions: ["mmr"]
    },
    "image/vnd.fujixerox.edmics-rlc": {
      source: "iana",
      extensions: ["rlc"]
    },
    "image/vnd.globalgraphics.pgb": {
      source: "iana"
    },
    "image/vnd.microsoft.icon": {
      source: "iana",
      extensions: ["ico"]
    },
    "image/vnd.mix": {
      source: "iana"
    },
    "image/vnd.mozilla.apng": {
      source: "iana"
    },
    "image/vnd.ms-dds": {
      extensions: ["dds"]
    },
    "image/vnd.ms-modi": {
      source: "iana",
      extensions: ["mdi"]
    },
    "image/vnd.ms-photo": {
      source: "apache",
      extensions: ["wdp"]
    },
    "image/vnd.net-fpx": {
      source: "iana",
      extensions: ["npx"]
    },
    "image/vnd.pco.b16": {
      source: "iana",
      extensions: ["b16"]
    },
    "image/vnd.radiance": {
      source: "iana"
    },
    "image/vnd.sealed.png": {
      source: "iana"
    },
    "image/vnd.sealedmedia.softseal.gif": {
      source: "iana"
    },
    "image/vnd.sealedmedia.softseal.jpg": {
      source: "iana"
    },
    "image/vnd.svf": {
      source: "iana"
    },
    "image/vnd.tencent.tap": {
      source: "iana",
      extensions: ["tap"]
    },
    "image/vnd.valve.source.texture": {
      source: "iana",
      extensions: ["vtf"]
    },
    "image/vnd.wap.wbmp": {
      source: "iana",
      extensions: ["wbmp"]
    },
    "image/vnd.xiff": {
      source: "iana",
      extensions: ["xif"]
    },
    "image/vnd.zbrush.pcx": {
      source: "iana",
      extensions: ["pcx"]
    },
    "image/webp": {
      source: "apache",
      extensions: ["webp"]
    },
    "image/wmf": {
      source: "iana",
      extensions: ["wmf"]
    },
    "image/x-3ds": {
      source: "apache",
      extensions: ["3ds"]
    },
    "image/x-cmu-raster": {
      source: "apache",
      extensions: ["ras"]
    },
    "image/x-cmx": {
      source: "apache",
      extensions: ["cmx"]
    },
    "image/x-freehand": {
      source: "apache",
      extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
    },
    "image/x-icon": {
      source: "apache",
      compressible: true,
      extensions: ["ico"]
    },
    "image/x-jng": {
      source: "nginx",
      extensions: ["jng"]
    },
    "image/x-mrsid-image": {
      source: "apache",
      extensions: ["sid"]
    },
    "image/x-ms-bmp": {
      source: "nginx",
      compressible: true,
      extensions: ["bmp"]
    },
    "image/x-pcx": {
      source: "apache",
      extensions: ["pcx"]
    },
    "image/x-pict": {
      source: "apache",
      extensions: ["pic", "pct"]
    },
    "image/x-portable-anymap": {
      source: "apache",
      extensions: ["pnm"]
    },
    "image/x-portable-bitmap": {
      source: "apache",
      extensions: ["pbm"]
    },
    "image/x-portable-graymap": {
      source: "apache",
      extensions: ["pgm"]
    },
    "image/x-portable-pixmap": {
      source: "apache",
      extensions: ["ppm"]
    },
    "image/x-rgb": {
      source: "apache",
      extensions: ["rgb"]
    },
    "image/x-tga": {
      source: "apache",
      extensions: ["tga"]
    },
    "image/x-xbitmap": {
      source: "apache",
      extensions: ["xbm"]
    },
    "image/x-xcf": {
      compressible: false
    },
    "image/x-xpixmap": {
      source: "apache",
      extensions: ["xpm"]
    },
    "image/x-xwindowdump": {
      source: "apache",
      extensions: ["xwd"]
    },
    "message/cpim": {
      source: "iana"
    },
    "message/delivery-status": {
      source: "iana"
    },
    "message/disposition-notification": {
      source: "iana",
      extensions: [
        "disposition-notification"
      ]
    },
    "message/external-body": {
      source: "iana"
    },
    "message/feedback-report": {
      source: "iana"
    },
    "message/global": {
      source: "iana",
      extensions: ["u8msg"]
    },
    "message/global-delivery-status": {
      source: "iana",
      extensions: ["u8dsn"]
    },
    "message/global-disposition-notification": {
      source: "iana",
      extensions: ["u8mdn"]
    },
    "message/global-headers": {
      source: "iana",
      extensions: ["u8hdr"]
    },
    "message/http": {
      source: "iana",
      compressible: false
    },
    "message/imdn+xml": {
      source: "iana",
      compressible: true
    },
    "message/news": {
      source: "iana"
    },
    "message/partial": {
      source: "iana",
      compressible: false
    },
    "message/rfc822": {
      source: "iana",
      compressible: true,
      extensions: ["eml", "mime"]
    },
    "message/s-http": {
      source: "iana"
    },
    "message/sip": {
      source: "iana"
    },
    "message/sipfrag": {
      source: "iana"
    },
    "message/tracking-status": {
      source: "iana"
    },
    "message/vnd.si.simp": {
      source: "iana"
    },
    "message/vnd.wfa.wsc": {
      source: "iana",
      extensions: ["wsc"]
    },
    "model/3mf": {
      source: "iana",
      extensions: ["3mf"]
    },
    "model/e57": {
      source: "iana"
    },
    "model/gltf+json": {
      source: "iana",
      compressible: true,
      extensions: ["gltf"]
    },
    "model/gltf-binary": {
      source: "iana",
      compressible: true,
      extensions: ["glb"]
    },
    "model/iges": {
      source: "iana",
      compressible: false,
      extensions: ["igs", "iges"]
    },
    "model/mesh": {
      source: "iana",
      compressible: false,
      extensions: ["msh", "mesh", "silo"]
    },
    "model/mtl": {
      source: "iana",
      extensions: ["mtl"]
    },
    "model/obj": {
      source: "iana",
      extensions: ["obj"]
    },
    "model/step+zip": {
      source: "iana",
      compressible: false,
      extensions: ["stpz"]
    },
    "model/step-xml+zip": {
      source: "iana",
      compressible: false,
      extensions: ["stpxz"]
    },
    "model/stl": {
      source: "iana",
      extensions: ["stl"]
    },
    "model/vnd.collada+xml": {
      source: "iana",
      compressible: true,
      extensions: ["dae"]
    },
    "model/vnd.dwf": {
      source: "iana",
      extensions: ["dwf"]
    },
    "model/vnd.flatland.3dml": {
      source: "iana"
    },
    "model/vnd.gdl": {
      source: "iana",
      extensions: ["gdl"]
    },
    "model/vnd.gs-gdl": {
      source: "apache"
    },
    "model/vnd.gs.gdl": {
      source: "iana"
    },
    "model/vnd.gtw": {
      source: "iana",
      extensions: ["gtw"]
    },
    "model/vnd.moml+xml": {
      source: "iana",
      compressible: true
    },
    "model/vnd.mts": {
      source: "iana",
      extensions: ["mts"]
    },
    "model/vnd.opengex": {
      source: "iana",
      extensions: ["ogex"]
    },
    "model/vnd.parasolid.transmit.binary": {
      source: "iana",
      extensions: ["x_b"]
    },
    "model/vnd.parasolid.transmit.text": {
      source: "iana",
      extensions: ["x_t"]
    },
    "model/vnd.pytha.pyox": {
      source: "iana"
    },
    "model/vnd.rosette.annotated-data-model": {
      source: "iana"
    },
    "model/vnd.sap.vds": {
      source: "iana",
      extensions: ["vds"]
    },
    "model/vnd.usdz+zip": {
      source: "iana",
      compressible: false,
      extensions: ["usdz"]
    },
    "model/vnd.valve.source.compiled-map": {
      source: "iana",
      extensions: ["bsp"]
    },
    "model/vnd.vtu": {
      source: "iana",
      extensions: ["vtu"]
    },
    "model/vrml": {
      source: "iana",
      compressible: false,
      extensions: ["wrl", "vrml"]
    },
    "model/x3d+binary": {
      source: "apache",
      compressible: false,
      extensions: ["x3db", "x3dbz"]
    },
    "model/x3d+fastinfoset": {
      source: "iana",
      extensions: ["x3db"]
    },
    "model/x3d+vrml": {
      source: "apache",
      compressible: false,
      extensions: ["x3dv", "x3dvz"]
    },
    "model/x3d+xml": {
      source: "iana",
      compressible: true,
      extensions: ["x3d", "x3dz"]
    },
    "model/x3d-vrml": {
      source: "iana",
      extensions: ["x3dv"]
    },
    "multipart/alternative": {
      source: "iana",
      compressible: false
    },
    "multipart/appledouble": {
      source: "iana"
    },
    "multipart/byteranges": {
      source: "iana"
    },
    "multipart/digest": {
      source: "iana"
    },
    "multipart/encrypted": {
      source: "iana",
      compressible: false
    },
    "multipart/form-data": {
      source: "iana",
      compressible: false
    },
    "multipart/header-set": {
      source: "iana"
    },
    "multipart/mixed": {
      source: "iana"
    },
    "multipart/multilingual": {
      source: "iana"
    },
    "multipart/parallel": {
      source: "iana"
    },
    "multipart/related": {
      source: "iana",
      compressible: false
    },
    "multipart/report": {
      source: "iana"
    },
    "multipart/signed": {
      source: "iana",
      compressible: false
    },
    "multipart/vnd.bint.med-plus": {
      source: "iana"
    },
    "multipart/voice-message": {
      source: "iana"
    },
    "multipart/x-mixed-replace": {
      source: "iana"
    },
    "text/1d-interleaved-parityfec": {
      source: "iana"
    },
    "text/cache-manifest": {
      source: "iana",
      compressible: true,
      extensions: ["appcache", "manifest"]
    },
    "text/calendar": {
      source: "iana",
      extensions: ["ics", "ifb"]
    },
    "text/calender": {
      compressible: true
    },
    "text/cmd": {
      compressible: true
    },
    "text/coffeescript": {
      extensions: ["coffee", "litcoffee"]
    },
    "text/cql": {
      source: "iana"
    },
    "text/cql-expression": {
      source: "iana"
    },
    "text/cql-identifier": {
      source: "iana"
    },
    "text/css": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["css"]
    },
    "text/csv": {
      source: "iana",
      compressible: true,
      extensions: ["csv"]
    },
    "text/csv-schema": {
      source: "iana"
    },
    "text/directory": {
      source: "iana"
    },
    "text/dns": {
      source: "iana"
    },
    "text/ecmascript": {
      source: "iana"
    },
    "text/encaprtp": {
      source: "iana"
    },
    "text/enriched": {
      source: "iana"
    },
    "text/fhirpath": {
      source: "iana"
    },
    "text/flexfec": {
      source: "iana"
    },
    "text/fwdred": {
      source: "iana"
    },
    "text/gff3": {
      source: "iana"
    },
    "text/grammar-ref-list": {
      source: "iana"
    },
    "text/html": {
      source: "iana",
      compressible: true,
      extensions: ["html", "htm", "shtml"]
    },
    "text/jade": {
      extensions: ["jade"]
    },
    "text/javascript": {
      source: "iana",
      compressible: true
    },
    "text/jcr-cnd": {
      source: "iana"
    },
    "text/jsx": {
      compressible: true,
      extensions: ["jsx"]
    },
    "text/less": {
      compressible: true,
      extensions: ["less"]
    },
    "text/markdown": {
      source: "iana",
      compressible: true,
      extensions: ["markdown", "md"]
    },
    "text/mathml": {
      source: "nginx",
      extensions: ["mml"]
    },
    "text/mdx": {
      compressible: true,
      extensions: ["mdx"]
    },
    "text/mizar": {
      source: "iana"
    },
    "text/n3": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["n3"]
    },
    "text/parameters": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/parityfec": {
      source: "iana"
    },
    "text/plain": {
      source: "iana",
      compressible: true,
      extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
    },
    "text/provenance-notation": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/prs.fallenstein.rst": {
      source: "iana"
    },
    "text/prs.lines.tag": {
      source: "iana",
      extensions: ["dsc"]
    },
    "text/prs.prop.logic": {
      source: "iana"
    },
    "text/raptorfec": {
      source: "iana"
    },
    "text/red": {
      source: "iana"
    },
    "text/rfc822-headers": {
      source: "iana"
    },
    "text/richtext": {
      source: "iana",
      compressible: true,
      extensions: ["rtx"]
    },
    "text/rtf": {
      source: "iana",
      compressible: true,
      extensions: ["rtf"]
    },
    "text/rtp-enc-aescm128": {
      source: "iana"
    },
    "text/rtploopback": {
      source: "iana"
    },
    "text/rtx": {
      source: "iana"
    },
    "text/sgml": {
      source: "iana",
      extensions: ["sgml", "sgm"]
    },
    "text/shaclc": {
      source: "iana"
    },
    "text/shex": {
      source: "iana",
      extensions: ["shex"]
    },
    "text/slim": {
      extensions: ["slim", "slm"]
    },
    "text/spdx": {
      source: "iana",
      extensions: ["spdx"]
    },
    "text/strings": {
      source: "iana"
    },
    "text/stylus": {
      extensions: ["stylus", "styl"]
    },
    "text/t140": {
      source: "iana"
    },
    "text/tab-separated-values": {
      source: "iana",
      compressible: true,
      extensions: ["tsv"]
    },
    "text/troff": {
      source: "iana",
      extensions: ["t", "tr", "roff", "man", "me", "ms"]
    },
    "text/turtle": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["ttl"]
    },
    "text/ulpfec": {
      source: "iana"
    },
    "text/uri-list": {
      source: "iana",
      compressible: true,
      extensions: ["uri", "uris", "urls"]
    },
    "text/vcard": {
      source: "iana",
      compressible: true,
      extensions: ["vcard"]
    },
    "text/vnd.a": {
      source: "iana"
    },
    "text/vnd.abc": {
      source: "iana"
    },
    "text/vnd.ascii-art": {
      source: "iana"
    },
    "text/vnd.curl": {
      source: "iana",
      extensions: ["curl"]
    },
    "text/vnd.curl.dcurl": {
      source: "apache",
      extensions: ["dcurl"]
    },
    "text/vnd.curl.mcurl": {
      source: "apache",
      extensions: ["mcurl"]
    },
    "text/vnd.curl.scurl": {
      source: "apache",
      extensions: ["scurl"]
    },
    "text/vnd.debian.copyright": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/vnd.dmclientscript": {
      source: "iana"
    },
    "text/vnd.dvb.subtitle": {
      source: "iana",
      extensions: ["sub"]
    },
    "text/vnd.esmertec.theme-descriptor": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/vnd.ficlab.flt": {
      source: "iana"
    },
    "text/vnd.fly": {
      source: "iana",
      extensions: ["fly"]
    },
    "text/vnd.fmi.flexstor": {
      source: "iana",
      extensions: ["flx"]
    },
    "text/vnd.gml": {
      source: "iana"
    },
    "text/vnd.graphviz": {
      source: "iana",
      extensions: ["gv"]
    },
    "text/vnd.hans": {
      source: "iana"
    },
    "text/vnd.hgl": {
      source: "iana"
    },
    "text/vnd.in3d.3dml": {
      source: "iana",
      extensions: ["3dml"]
    },
    "text/vnd.in3d.spot": {
      source: "iana",
      extensions: ["spot"]
    },
    "text/vnd.iptc.newsml": {
      source: "iana"
    },
    "text/vnd.iptc.nitf": {
      source: "iana"
    },
    "text/vnd.latex-z": {
      source: "iana"
    },
    "text/vnd.motorola.reflex": {
      source: "iana"
    },
    "text/vnd.ms-mediapackage": {
      source: "iana"
    },
    "text/vnd.net2phone.commcenter.command": {
      source: "iana"
    },
    "text/vnd.radisys.msml-basic-layout": {
      source: "iana"
    },
    "text/vnd.senx.warpscript": {
      source: "iana"
    },
    "text/vnd.si.uricatalogue": {
      source: "iana"
    },
    "text/vnd.sosi": {
      source: "iana"
    },
    "text/vnd.sun.j2me.app-descriptor": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["jad"]
    },
    "text/vnd.trolltech.linguist": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/vnd.wap.si": {
      source: "iana"
    },
    "text/vnd.wap.sl": {
      source: "iana"
    },
    "text/vnd.wap.wml": {
      source: "iana",
      extensions: ["wml"]
    },
    "text/vnd.wap.wmlscript": {
      source: "iana",
      extensions: ["wmls"]
    },
    "text/vtt": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["vtt"]
    },
    "text/x-asm": {
      source: "apache",
      extensions: ["s", "asm"]
    },
    "text/x-c": {
      source: "apache",
      extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
    },
    "text/x-component": {
      source: "nginx",
      extensions: ["htc"]
    },
    "text/x-fortran": {
      source: "apache",
      extensions: ["f", "for", "f77", "f90"]
    },
    "text/x-gwt-rpc": {
      compressible: true
    },
    "text/x-handlebars-template": {
      extensions: ["hbs"]
    },
    "text/x-java-source": {
      source: "apache",
      extensions: ["java"]
    },
    "text/x-jquery-tmpl": {
      compressible: true
    },
    "text/x-lua": {
      extensions: ["lua"]
    },
    "text/x-markdown": {
      compressible: true,
      extensions: ["mkd"]
    },
    "text/x-nfo": {
      source: "apache",
      extensions: ["nfo"]
    },
    "text/x-opml": {
      source: "apache",
      extensions: ["opml"]
    },
    "text/x-org": {
      compressible: true,
      extensions: ["org"]
    },
    "text/x-pascal": {
      source: "apache",
      extensions: ["p", "pas"]
    },
    "text/x-processing": {
      compressible: true,
      extensions: ["pde"]
    },
    "text/x-sass": {
      extensions: ["sass"]
    },
    "text/x-scss": {
      extensions: ["scss"]
    },
    "text/x-setext": {
      source: "apache",
      extensions: ["etx"]
    },
    "text/x-sfv": {
      source: "apache",
      extensions: ["sfv"]
    },
    "text/x-suse-ymp": {
      compressible: true,
      extensions: ["ymp"]
    },
    "text/x-uuencode": {
      source: "apache",
      extensions: ["uu"]
    },
    "text/x-vcalendar": {
      source: "apache",
      extensions: ["vcs"]
    },
    "text/x-vcard": {
      source: "apache",
      extensions: ["vcf"]
    },
    "text/xml": {
      source: "iana",
      compressible: true,
      extensions: ["xml"]
    },
    "text/xml-external-parsed-entity": {
      source: "iana"
    },
    "text/yaml": {
      compressible: true,
      extensions: ["yaml", "yml"]
    },
    "video/1d-interleaved-parityfec": {
      source: "iana"
    },
    "video/3gpp": {
      source: "iana",
      extensions: ["3gp", "3gpp"]
    },
    "video/3gpp-tt": {
      source: "iana"
    },
    "video/3gpp2": {
      source: "iana",
      extensions: ["3g2"]
    },
    "video/av1": {
      source: "iana"
    },
    "video/bmpeg": {
      source: "iana"
    },
    "video/bt656": {
      source: "iana"
    },
    "video/celb": {
      source: "iana"
    },
    "video/dv": {
      source: "iana"
    },
    "video/encaprtp": {
      source: "iana"
    },
    "video/ffv1": {
      source: "iana"
    },
    "video/flexfec": {
      source: "iana"
    },
    "video/h261": {
      source: "iana",
      extensions: ["h261"]
    },
    "video/h263": {
      source: "iana",
      extensions: ["h263"]
    },
    "video/h263-1998": {
      source: "iana"
    },
    "video/h263-2000": {
      source: "iana"
    },
    "video/h264": {
      source: "iana",
      extensions: ["h264"]
    },
    "video/h264-rcdo": {
      source: "iana"
    },
    "video/h264-svc": {
      source: "iana"
    },
    "video/h265": {
      source: "iana"
    },
    "video/iso.segment": {
      source: "iana",
      extensions: ["m4s"]
    },
    "video/jpeg": {
      source: "iana",
      extensions: ["jpgv"]
    },
    "video/jpeg2000": {
      source: "iana"
    },
    "video/jpm": {
      source: "apache",
      extensions: ["jpm", "jpgm"]
    },
    "video/mj2": {
      source: "iana",
      extensions: ["mj2", "mjp2"]
    },
    "video/mp1s": {
      source: "iana"
    },
    "video/mp2p": {
      source: "iana"
    },
    "video/mp2t": {
      source: "iana",
      extensions: ["ts"]
    },
    "video/mp4": {
      source: "iana",
      compressible: false,
      extensions: ["mp4", "mp4v", "mpg4"]
    },
    "video/mp4v-es": {
      source: "iana"
    },
    "video/mpeg": {
      source: "iana",
      compressible: false,
      extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
    },
    "video/mpeg4-generic": {
      source: "iana"
    },
    "video/mpv": {
      source: "iana"
    },
    "video/nv": {
      source: "iana"
    },
    "video/ogg": {
      source: "iana",
      compressible: false,
      extensions: ["ogv"]
    },
    "video/parityfec": {
      source: "iana"
    },
    "video/pointer": {
      source: "iana"
    },
    "video/quicktime": {
      source: "iana",
      compressible: false,
      extensions: ["qt", "mov"]
    },
    "video/raptorfec": {
      source: "iana"
    },
    "video/raw": {
      source: "iana"
    },
    "video/rtp-enc-aescm128": {
      source: "iana"
    },
    "video/rtploopback": {
      source: "iana"
    },
    "video/rtx": {
      source: "iana"
    },
    "video/scip": {
      source: "iana"
    },
    "video/smpte291": {
      source: "iana"
    },
    "video/smpte292m": {
      source: "iana"
    },
    "video/ulpfec": {
      source: "iana"
    },
    "video/vc1": {
      source: "iana"
    },
    "video/vc2": {
      source: "iana"
    },
    "video/vnd.cctv": {
      source: "iana"
    },
    "video/vnd.dece.hd": {
      source: "iana",
      extensions: ["uvh", "uvvh"]
    },
    "video/vnd.dece.mobile": {
      source: "iana",
      extensions: ["uvm", "uvvm"]
    },
    "video/vnd.dece.mp4": {
      source: "iana"
    },
    "video/vnd.dece.pd": {
      source: "iana",
      extensions: ["uvp", "uvvp"]
    },
    "video/vnd.dece.sd": {
      source: "iana",
      extensions: ["uvs", "uvvs"]
    },
    "video/vnd.dece.video": {
      source: "iana",
      extensions: ["uvv", "uvvv"]
    },
    "video/vnd.directv.mpeg": {
      source: "iana"
    },
    "video/vnd.directv.mpeg-tts": {
      source: "iana"
    },
    "video/vnd.dlna.mpeg-tts": {
      source: "iana"
    },
    "video/vnd.dvb.file": {
      source: "iana",
      extensions: ["dvb"]
    },
    "video/vnd.fvt": {
      source: "iana",
      extensions: ["fvt"]
    },
    "video/vnd.hns.video": {
      source: "iana"
    },
    "video/vnd.iptvforum.1dparityfec-1010": {
      source: "iana"
    },
    "video/vnd.iptvforum.1dparityfec-2005": {
      source: "iana"
    },
    "video/vnd.iptvforum.2dparityfec-1010": {
      source: "iana"
    },
    "video/vnd.iptvforum.2dparityfec-2005": {
      source: "iana"
    },
    "video/vnd.iptvforum.ttsavc": {
      source: "iana"
    },
    "video/vnd.iptvforum.ttsmpeg2": {
      source: "iana"
    },
    "video/vnd.motorola.video": {
      source: "iana"
    },
    "video/vnd.motorola.videop": {
      source: "iana"
    },
    "video/vnd.mpegurl": {
      source: "iana",
      extensions: ["mxu", "m4u"]
    },
    "video/vnd.ms-playready.media.pyv": {
      source: "iana",
      extensions: ["pyv"]
    },
    "video/vnd.nokia.interleaved-multimedia": {
      source: "iana"
    },
    "video/vnd.nokia.mp4vr": {
      source: "iana"
    },
    "video/vnd.nokia.videovoip": {
      source: "iana"
    },
    "video/vnd.objectvideo": {
      source: "iana"
    },
    "video/vnd.radgamettools.bink": {
      source: "iana"
    },
    "video/vnd.radgamettools.smacker": {
      source: "iana"
    },
    "video/vnd.sealed.mpeg1": {
      source: "iana"
    },
    "video/vnd.sealed.mpeg4": {
      source: "iana"
    },
    "video/vnd.sealed.swf": {
      source: "iana"
    },
    "video/vnd.sealedmedia.softseal.mov": {
      source: "iana"
    },
    "video/vnd.uvvu.mp4": {
      source: "iana",
      extensions: ["uvu", "uvvu"]
    },
    "video/vnd.vivo": {
      source: "iana",
      extensions: ["viv"]
    },
    "video/vnd.youtube.yt": {
      source: "iana"
    },
    "video/vp8": {
      source: "iana"
    },
    "video/vp9": {
      source: "iana"
    },
    "video/webm": {
      source: "apache",
      compressible: false,
      extensions: ["webm"]
    },
    "video/x-f4v": {
      source: "apache",
      extensions: ["f4v"]
    },
    "video/x-fli": {
      source: "apache",
      extensions: ["fli"]
    },
    "video/x-flv": {
      source: "apache",
      compressible: false,
      extensions: ["flv"]
    },
    "video/x-m4v": {
      source: "apache",
      extensions: ["m4v"]
    },
    "video/x-matroska": {
      source: "apache",
      compressible: false,
      extensions: ["mkv", "mk3d", "mks"]
    },
    "video/x-mng": {
      source: "apache",
      extensions: ["mng"]
    },
    "video/x-ms-asf": {
      source: "apache",
      extensions: ["asf", "asx"]
    },
    "video/x-ms-vob": {
      source: "apache",
      extensions: ["vob"]
    },
    "video/x-ms-wm": {
      source: "apache",
      extensions: ["wm"]
    },
    "video/x-ms-wmv": {
      source: "apache",
      compressible: false,
      extensions: ["wmv"]
    },
    "video/x-ms-wmx": {
      source: "apache",
      extensions: ["wmx"]
    },
    "video/x-ms-wvx": {
      source: "apache",
      extensions: ["wvx"]
    },
    "video/x-msvideo": {
      source: "apache",
      extensions: ["avi"]
    },
    "video/x-sgi-movie": {
      source: "apache",
      extensions: ["movie"]
    },
    "video/x-smv": {
      source: "apache",
      extensions: ["smv"]
    },
    "x-conference/x-cooltalk": {
      source: "apache",
      extensions: ["ice"]
    },
    "x-shader/x-fragment": {
      compressible: true
    },
    "x-shader/x-vertex": {
      compressible: true
    }
  };
});

// node_modules/mime-db/index.js
var require_mime_db = __commonJS((exports, module) => {
  /*!
   * mime-db
   * Copyright(c) 2014 Jonathan Ong
   * MIT Licensed
   */
  module.exports = require_db();
});

// node_modules/mime-types/index.js
var require_mime_types = __commonJS((exports) => {
  /*!
   * mime-types
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  var db = require_mime_db();
  var extname = __require("path").extname;
  var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
  var TEXT_TYPE_REGEXP = /^text\//i;
  exports.charset = charset;
  exports.charsets = { lookup: charset };
  exports.contentType = contentType;
  exports.extension = extension;
  exports.extensions = Object.create(null);
  exports.lookup = lookup;
  exports.types = Object.create(null);
  populateMaps(exports.extensions, exports.types);
  function charset(type) {
    if (!type || typeof type !== "string") {
      return false;
    }
    var match = EXTRACT_TYPE_REGEXP.exec(type);
    var mime = match && db[match[1].toLowerCase()];
    if (mime && mime.charset) {
      return mime.charset;
    }
    if (match && TEXT_TYPE_REGEXP.test(match[1])) {
      return "UTF-8";
    }
    return false;
  }
  function contentType(str) {
    if (!str || typeof str !== "string") {
      return false;
    }
    var mime = str.indexOf("/") === -1 ? exports.lookup(str) : str;
    if (!mime) {
      return false;
    }
    if (mime.indexOf("charset") === -1) {
      var charset2 = exports.charset(mime);
      if (charset2)
        mime += "; charset=" + charset2.toLowerCase();
    }
    return mime;
  }
  function extension(type) {
    if (!type || typeof type !== "string") {
      return false;
    }
    var match = EXTRACT_TYPE_REGEXP.exec(type);
    var exts = match && exports.extensions[match[1].toLowerCase()];
    if (!exts || !exts.length) {
      return false;
    }
    return exts[0];
  }
  function lookup(path) {
    if (!path || typeof path !== "string") {
      return false;
    }
    var extension2 = extname("x." + path).toLowerCase().substr(1);
    if (!extension2) {
      return false;
    }
    return exports.types[extension2] || false;
  }
  function populateMaps(extensions, types) {
    var preference = ["nginx", "apache", undefined, "iana"];
    Object.keys(db).forEach(function forEachMimeType(type) {
      var mime = db[type];
      var exts = mime.extensions;
      if (!exts || !exts.length) {
        return;
      }
      extensions[type] = exts;
      for (var i = 0;i < exts.length; i++) {
        var extension2 = exts[i];
        if (types[extension2]) {
          var from = preference.indexOf(db[types[extension2]].source);
          var to = preference.indexOf(mime.source);
          if (types[extension2] !== "application/octet-stream" && (from > to || from === to && types[extension2].substr(0, 12) === "application/")) {
            continue;
          }
        }
        types[extension2] = type;
      }
    });
  }
});

// node_modules/type-is/index.js
var require_type_is = __commonJS((exports, module) => {
  /*!
   * type-is
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  var typer = require_media_typer();
  var mime = require_mime_types();
  module.exports = typeofrequest;
  module.exports.is = typeis;
  module.exports.hasBody = hasbody;
  module.exports.normalize = normalize;
  module.exports.match = mimeMatch;
  function typeis(value, types_) {
    var i;
    var types = types_;
    var val = tryNormalizeType(value);
    if (!val) {
      return false;
    }
    if (types && !Array.isArray(types)) {
      types = new Array(arguments.length - 1);
      for (i = 0;i < types.length; i++) {
        types[i] = arguments[i + 1];
      }
    }
    if (!types || !types.length) {
      return val;
    }
    var type;
    for (i = 0;i < types.length; i++) {
      if (mimeMatch(normalize(type = types[i]), val)) {
        return type[0] === "+" || type.indexOf("*") !== -1 ? val : type;
      }
    }
    return false;
  }
  function hasbody(req) {
    return req.headers["transfer-encoding"] !== undefined || !isNaN(req.headers["content-length"]);
  }
  function typeofrequest(req, types_) {
    var types = types_;
    if (!hasbody(req)) {
      return null;
    }
    if (arguments.length > 2) {
      types = new Array(arguments.length - 1);
      for (var i = 0;i < types.length; i++) {
        types[i] = arguments[i + 1];
      }
    }
    var value = req.headers["content-type"];
    return typeis(value, types);
  }
  function normalize(type) {
    if (typeof type !== "string") {
      return false;
    }
    switch (type) {
      case "urlencoded":
        return "application/x-www-form-urlencoded";
      case "multipart":
        return "multipart/*";
    }
    if (type[0] === "+") {
      return "*/*" + type;
    }
    return type.indexOf("/") === -1 ? mime.lookup(type) : type;
  }
  function mimeMatch(expected, actual) {
    if (expected === false) {
      return false;
    }
    var actualParts = actual.split("/");
    var expectedParts = expected.split("/");
    if (actualParts.length !== 2 || expectedParts.length !== 2) {
      return false;
    }
    if (expectedParts[0] !== "*" && expectedParts[0] !== actualParts[0]) {
      return false;
    }
    if (expectedParts[1].substr(0, 2) === "*+") {
      return expectedParts[1].length <= actualParts[1].length + 1 && expectedParts[1].substr(1) === actualParts[1].substr(1 - expectedParts[1].length);
    }
    if (expectedParts[1] !== "*" && expectedParts[1] !== actualParts[1]) {
      return false;
    }
    return true;
  }
  function normalizeType(value) {
    var type = typer.parse(value);
    type.parameters = undefined;
    return typer.format(type);
  }
  function tryNormalizeType(value) {
    if (!value) {
      return null;
    }
    try {
      return normalizeType(value);
    } catch (err) {
      return null;
    }
  }
});

// node_modules/body-parser/lib/types/json.js
var require_json = __commonJS((exports, module) => {
  /*!
   * body-parser
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  var bytes = require_bytes();
  var contentType = require_content_type();
  var createError = require_http_errors();
  var debug = require_src()("body-parser:json");
  var read = require_read();
  var typeis = require_type_is();
  module.exports = json;
  var FIRST_CHAR_REGEXP = /^[\x20\x09\x0a\x0d]*(.)/;
  function json(options) {
    var opts = options || {};
    var limit = typeof opts.limit !== "number" ? bytes.parse(opts.limit || "100kb") : opts.limit;
    var inflate = opts.inflate !== false;
    var reviver = opts.reviver;
    var strict = opts.strict !== false;
    var type = opts.type || "application/json";
    var verify = opts.verify || false;
    if (verify !== false && typeof verify !== "function") {
      throw new TypeError("option verify must be function");
    }
    var shouldParse = typeof type !== "function" ? typeChecker(type) : type;
    function parse(body) {
      if (body.length === 0) {
        return {};
      }
      if (strict) {
        var first = firstchar(body);
        if (first !== "{" && first !== "[") {
          debug("strict violation");
          throw createStrictSyntaxError(body, first);
        }
      }
      try {
        debug("parse json");
        return JSON.parse(body, reviver);
      } catch (e) {
        throw normalizeJsonSyntaxError(e, {
          message: e.message,
          stack: e.stack
        });
      }
    }
    return function jsonParser(req, res, next) {
      if (req._body) {
        debug("body already parsed");
        next();
        return;
      }
      req.body = req.body || {};
      if (!typeis.hasBody(req)) {
        debug("skip empty body");
        next();
        return;
      }
      debug("content-type %j", req.headers["content-type"]);
      if (!shouldParse(req)) {
        debug("skip parsing");
        next();
        return;
      }
      var charset = getCharset(req) || "utf-8";
      if (charset.substr(0, 4) !== "utf-") {
        debug("invalid charset");
        next(createError(415, 'unsupported charset "' + charset.toUpperCase() + '"', {
          charset,
          type: "charset.unsupported"
        }));
        return;
      }
      read(req, res, next, parse, debug, {
        encoding: charset,
        inflate,
        limit,
        verify
      });
    };
  }
  function createStrictSyntaxError(str, char) {
    var index = str.indexOf(char);
    var partial = str.substring(0, index) + "#";
    try {
      JSON.parse(partial);
      throw new SyntaxError("strict violation");
    } catch (e) {
      return normalizeJsonSyntaxError(e, {
        message: e.message.replace("#", char),
        stack: e.stack
      });
    }
  }
  function firstchar(str) {
    return FIRST_CHAR_REGEXP.exec(str)[1];
  }
  function getCharset(req) {
    try {
      return (contentType.parse(req).parameters.charset || "").toLowerCase();
    } catch (e) {
      return;
    }
  }
  function normalizeJsonSyntaxError(error, obj) {
    var keys = Object.getOwnPropertyNames(error);
    for (var i = 0;i < keys.length; i++) {
      var key = keys[i];
      if (key !== "stack" && key !== "message") {
        delete error[key];
      }
    }
    error.stack = obj.stack.replace(error.message, obj.message);
    error.message = obj.message;
    return error;
  }
  function typeChecker(type) {
    return function checkType(req) {
      return Boolean(typeis(req, type));
    };
  }
});

// node_modules/body-parser/lib/types/raw.js
var require_raw = __commonJS((exports, module) => {
  /*!
   * body-parser
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  var bytes = require_bytes();
  var debug = require_src()("body-parser:raw");
  var read = require_read();
  var typeis = require_type_is();
  module.exports = raw;
  function raw(options) {
    var opts = options || {};
    var inflate = opts.inflate !== false;
    var limit = typeof opts.limit !== "number" ? bytes.parse(opts.limit || "100kb") : opts.limit;
    var type = opts.type || "application/octet-stream";
    var verify = opts.verify || false;
    if (verify !== false && typeof verify !== "function") {
      throw new TypeError("option verify must be function");
    }
    var shouldParse = typeof type !== "function" ? typeChecker(type) : type;
    function parse(buf) {
      return buf;
    }
    return function rawParser(req, res, next) {
      if (req._body) {
        debug("body already parsed");
        next();
        return;
      }
      req.body = req.body || {};
      if (!typeis.hasBody(req)) {
        debug("skip empty body");
        next();
        return;
      }
      debug("content-type %j", req.headers["content-type"]);
      if (!shouldParse(req)) {
        debug("skip parsing");
        next();
        return;
      }
      read(req, res, next, parse, debug, {
        encoding: null,
        inflate,
        limit,
        verify
      });
    };
  }
  function typeChecker(type) {
    return function checkType(req) {
      return Boolean(typeis(req, type));
    };
  }
});

// node_modules/body-parser/lib/types/text.js
var require_text = __commonJS((exports, module) => {
  /*!
   * body-parser
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  var bytes = require_bytes();
  var contentType = require_content_type();
  var debug = require_src()("body-parser:text");
  var read = require_read();
  var typeis = require_type_is();
  module.exports = text;
  function text(options) {
    var opts = options || {};
    var defaultCharset = opts.defaultCharset || "utf-8";
    var inflate = opts.inflate !== false;
    var limit = typeof opts.limit !== "number" ? bytes.parse(opts.limit || "100kb") : opts.limit;
    var type = opts.type || "text/plain";
    var verify = opts.verify || false;
    if (verify !== false && typeof verify !== "function") {
      throw new TypeError("option verify must be function");
    }
    var shouldParse = typeof type !== "function" ? typeChecker(type) : type;
    function parse(buf) {
      return buf;
    }
    return function textParser(req, res, next) {
      if (req._body) {
        debug("body already parsed");
        next();
        return;
      }
      req.body = req.body || {};
      if (!typeis.hasBody(req)) {
        debug("skip empty body");
        next();
        return;
      }
      debug("content-type %j", req.headers["content-type"]);
      if (!shouldParse(req)) {
        debug("skip parsing");
        next();
        return;
      }
      var charset = getCharset(req) || defaultCharset;
      read(req, res, next, parse, debug, {
        encoding: charset,
        inflate,
        limit,
        verify
      });
    };
  }
  function getCharset(req) {
    try {
      return (contentType.parse(req).parameters.charset || "").toLowerCase();
    } catch (e) {
      return;
    }
  }
  function typeChecker(type) {
    return function checkType(req) {
      return Boolean(typeis(req, type));
    };
  }
});

// node_modules/qs/lib/utils.js
var require_utils = __commonJS((exports, module) => {
  var has = Object.prototype.hasOwnProperty;
  var isArray = Array.isArray;
  var hexTable = function() {
    var array = [];
    for (var i = 0;i < 256; ++i) {
      array.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
    }
    return array;
  }();
  var compactQueue = function compactQueue(queue) {
    while (queue.length > 1) {
      var item = queue.pop();
      var obj = item.obj[item.prop];
      if (isArray(obj)) {
        var compacted = [];
        for (var j = 0;j < obj.length; ++j) {
          if (typeof obj[j] !== "undefined") {
            compacted.push(obj[j]);
          }
        }
        item.obj[item.prop] = compacted;
      }
    }
  };
  var arrayToObject = function arrayToObject(source, options) {
    var obj = options && options.plainObjects ? Object.create(null) : {};
    for (var i = 0;i < source.length; ++i) {
      if (typeof source[i] !== "undefined") {
        obj[i] = source[i];
      }
    }
    return obj;
  };
  var merge = function merge(target, source, options) {
    if (!source) {
      return target;
    }
    if (typeof source !== "object") {
      if (isArray(target)) {
        target.push(source);
      } else if (target && typeof target === "object") {
        if (options && (options.plainObjects || options.allowPrototypes) || !has.call(Object.prototype, source)) {
          target[source] = true;
        }
      } else {
        return [target, source];
      }
      return target;
    }
    if (!target || typeof target !== "object") {
      return [target].concat(source);
    }
    var mergeTarget = target;
    if (isArray(target) && !isArray(source)) {
      mergeTarget = arrayToObject(target, options);
    }
    if (isArray(target) && isArray(source)) {
      source.forEach(function(item, i) {
        if (has.call(target, i)) {
          var targetItem = target[i];
          if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
            target[i] = merge(targetItem, item, options);
          } else {
            target.push(item);
          }
        } else {
          target[i] = item;
        }
      });
      return target;
    }
    return Object.keys(source).reduce(function(acc, key) {
      var value = source[key];
      if (has.call(acc, key)) {
        acc[key] = merge(acc[key], value, options);
      } else {
        acc[key] = value;
      }
      return acc;
    }, mergeTarget);
  };
  var assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function(acc, key) {
      acc[key] = source[key];
      return acc;
    }, target);
  };
  var decode = function(str, decoder, charset) {
    var strWithoutPlus = str.replace(/\+/g, " ");
    if (charset === "iso-8859-1") {
      return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
    }
    try {
      return decodeURIComponent(strWithoutPlus);
    } catch (e) {
      return strWithoutPlus;
    }
  };
  var encode = function encode(str, defaultEncoder, charset) {
    if (str.length === 0) {
      return str;
    }
    var string = typeof str === "string" ? str : String(str);
    if (charset === "iso-8859-1") {
      return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
        return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
      });
    }
    var out = "";
    for (var i = 0;i < string.length; ++i) {
      var c = string.charCodeAt(i);
      if (c === 45 || c === 46 || c === 95 || c === 126 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122) {
        out += string.charAt(i);
        continue;
      }
      if (c < 128) {
        out = out + hexTable[c];
        continue;
      }
      if (c < 2048) {
        out = out + (hexTable[192 | c >> 6] + hexTable[128 | c & 63]);
        continue;
      }
      if (c < 55296 || c >= 57344) {
        out = out + (hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63]);
        continue;
      }
      i += 1;
      c = 65536 + ((c & 1023) << 10 | string.charCodeAt(i) & 1023);
      out += hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
    }
    return out;
  };
  var compact = function compact(value) {
    var queue = [{ obj: { o: value }, prop: "o" }];
    var refs = [];
    for (var i = 0;i < queue.length; ++i) {
      var item = queue[i];
      var obj = item.obj[item.prop];
      var keys = Object.keys(obj);
      for (var j = 0;j < keys.length; ++j) {
        var key = keys[j];
        var val = obj[key];
        if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
          queue.push({ obj, prop: key });
          refs.push(val);
        }
      }
    }
    compactQueue(queue);
    return value;
  };
  var isRegExp = function isRegExp(obj) {
    return Object.prototype.toString.call(obj) === "[object RegExp]";
  };
  var isBuffer = function isBuffer(obj) {
    if (!obj || typeof obj !== "object") {
      return false;
    }
    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
  };
  var combine = function combine(a, b) {
    return [].concat(a, b);
  };
  module.exports = {
    arrayToObject,
    assign,
    combine,
    compact,
    decode,
    encode,
    isBuffer,
    isRegExp,
    merge
  };
});

// node_modules/qs/lib/formats.js
var require_formats = __commonJS((exports, module) => {
  var replace = String.prototype.replace;
  var percentTwenties = /%20/g;
  module.exports = {
    default: "RFC3986",
    formatters: {
      RFC1738: function(value) {
        return replace.call(value, percentTwenties, "+");
      },
      RFC3986: function(value) {
        return value;
      }
    },
    RFC1738: "RFC1738",
    RFC3986: "RFC3986"
  };
});

// node_modules/qs/lib/stringify.js
var require_stringify = __commonJS((exports, module) => {
  var utils = require_utils();
  var formats = require_formats();
  var has = Object.prototype.hasOwnProperty;
  var arrayPrefixGenerators = {
    brackets: function brackets(prefix) {
      return prefix + "[]";
    },
    comma: "comma",
    indices: function indices(prefix, key) {
      return prefix + "[" + key + "]";
    },
    repeat: function repeat(prefix) {
      return prefix;
    }
  };
  var isArray = Array.isArray;
  var push = Array.prototype.push;
  var pushToArray = function(arr, valueOrArray) {
    push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
  };
  var toISO = Date.prototype.toISOString;
  var defaults = {
    addQueryPrefix: false,
    allowDots: false,
    charset: "utf-8",
    charsetSentinel: false,
    delimiter: "&",
    encode: true,
    encoder: utils.encode,
    encodeValuesOnly: false,
    formatter: formats.formatters[formats["default"]],
    indices: false,
    serializeDate: function serializeDate(date) {
      return toISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
  };
  var stringify = function stringify(object, prefix, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, formatter, encodeValuesOnly, charset) {
    var obj = object;
    if (typeof filter === "function") {
      obj = filter(prefix, obj);
    } else if (obj instanceof Date) {
      obj = serializeDate(obj);
    } else if (generateArrayPrefix === "comma" && isArray(obj)) {
      obj = obj.join(",");
    }
    if (obj === null) {
      if (strictNullHandling) {
        return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset) : prefix;
      }
      obj = "";
    }
    if (typeof obj === "string" || typeof obj === "number" || typeof obj === "boolean" || utils.isBuffer(obj)) {
      if (encoder) {
        var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset);
        return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults.encoder, charset))];
      }
      return [formatter(prefix) + "=" + formatter(String(obj))];
    }
    var values = [];
    if (typeof obj === "undefined") {
      return values;
    }
    var objKeys;
    if (isArray(filter)) {
      objKeys = filter;
    } else {
      var keys = Object.keys(obj);
      objKeys = sort ? keys.sort(sort) : keys;
    }
    for (var i = 0;i < objKeys.length; ++i) {
      var key = objKeys[i];
      if (skipNulls && obj[key] === null) {
        continue;
      }
      if (isArray(obj)) {
        pushToArray(values, stringify(obj[key], typeof generateArrayPrefix === "function" ? generateArrayPrefix(prefix, key) : prefix, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, formatter, encodeValuesOnly, charset));
      } else {
        pushToArray(values, stringify(obj[key], prefix + (allowDots ? "." + key : "[" + key + "]"), generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, formatter, encodeValuesOnly, charset));
      }
    }
    return values;
  };
  var normalizeStringifyOptions = function normalizeStringifyOptions(opts) {
    if (!opts) {
      return defaults;
    }
    if (opts.encoder !== null && opts.encoder !== undefined && typeof opts.encoder !== "function") {
      throw new TypeError("Encoder has to be a function.");
    }
    var charset = opts.charset || defaults.charset;
    if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
      throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
    }
    var format = formats["default"];
    if (typeof opts.format !== "undefined") {
      if (!has.call(formats.formatters, opts.format)) {
        throw new TypeError("Unknown format option provided.");
      }
      format = opts.format;
    }
    var formatter = formats.formatters[format];
    var filter = defaults.filter;
    if (typeof opts.filter === "function" || isArray(opts.filter)) {
      filter = opts.filter;
    }
    return {
      addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults.addQueryPrefix,
      allowDots: typeof opts.allowDots === "undefined" ? defaults.allowDots : !!opts.allowDots,
      charset,
      charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
      delimiter: typeof opts.delimiter === "undefined" ? defaults.delimiter : opts.delimiter,
      encode: typeof opts.encode === "boolean" ? opts.encode : defaults.encode,
      encoder: typeof opts.encoder === "function" ? opts.encoder : defaults.encoder,
      encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
      filter,
      formatter,
      serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults.serializeDate,
      skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults.skipNulls,
      sort: typeof opts.sort === "function" ? opts.sort : null,
      strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
    };
  };
  module.exports = function(object, opts) {
    var obj = object;
    var options = normalizeStringifyOptions(opts);
    var objKeys;
    var filter;
    if (typeof options.filter === "function") {
      filter = options.filter;
      obj = filter("", obj);
    } else if (isArray(options.filter)) {
      filter = options.filter;
      objKeys = filter;
    }
    var keys = [];
    if (typeof obj !== "object" || obj === null) {
      return "";
    }
    var arrayFormat;
    if (opts && opts.arrayFormat in arrayPrefixGenerators) {
      arrayFormat = opts.arrayFormat;
    } else if (opts && "indices" in opts) {
      arrayFormat = opts.indices ? "indices" : "repeat";
    } else {
      arrayFormat = "indices";
    }
    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
    if (!objKeys) {
      objKeys = Object.keys(obj);
    }
    if (options.sort) {
      objKeys.sort(options.sort);
    }
    for (var i = 0;i < objKeys.length; ++i) {
      var key = objKeys[i];
      if (options.skipNulls && obj[key] === null) {
        continue;
      }
      pushToArray(keys, stringify(obj[key], key, generateArrayPrefix, options.strictNullHandling, options.skipNulls, options.encode ? options.encoder : null, options.filter, options.sort, options.allowDots, options.serializeDate, options.formatter, options.encodeValuesOnly, options.charset));
    }
    var joined = keys.join(options.delimiter);
    var prefix = options.addQueryPrefix === true ? "?" : "";
    if (options.charsetSentinel) {
      if (options.charset === "iso-8859-1") {
        prefix += "utf8=%26%2310003%3B&";
      } else {
        prefix += "utf8=%E2%9C%93&";
      }
    }
    return joined.length > 0 ? prefix + joined : "";
  };
});

// node_modules/qs/lib/parse.js
var require_parse = __commonJS((exports, module) => {
  var utils = require_utils();
  var has = Object.prototype.hasOwnProperty;
  var defaults = {
    allowDots: false,
    allowPrototypes: false,
    arrayLimit: 20,
    charset: "utf-8",
    charsetSentinel: false,
    comma: false,
    decoder: utils.decode,
    delimiter: "&",
    depth: 5,
    ignoreQueryPrefix: false,
    interpretNumericEntities: false,
    parameterLimit: 1000,
    parseArrays: true,
    plainObjects: false,
    strictNullHandling: false
  };
  var interpretNumericEntities = function(str) {
    return str.replace(/&#(\d+);/g, function($0, numberStr) {
      return String.fromCharCode(parseInt(numberStr, 10));
    });
  };
  var isoSentinel = "utf8=%26%2310003%3B";
  var charsetSentinel = "utf8=%E2%9C%93";
  var parseValues = function parseQueryStringValues(str, options) {
    var obj = {};
    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
    var parts = cleanStr.split(options.delimiter, limit);
    var skipIndex = -1;
    var i;
    var charset = options.charset;
    if (options.charsetSentinel) {
      for (i = 0;i < parts.length; ++i) {
        if (parts[i].indexOf("utf8=") === 0) {
          if (parts[i] === charsetSentinel) {
            charset = "utf-8";
          } else if (parts[i] === isoSentinel) {
            charset = "iso-8859-1";
          }
          skipIndex = i;
          i = parts.length;
        }
      }
    }
    for (i = 0;i < parts.length; ++i) {
      if (i === skipIndex) {
        continue;
      }
      var part = parts[i];
      var bracketEqualsPos = part.indexOf("]=");
      var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
      var key, val;
      if (pos === -1) {
        key = options.decoder(part, defaults.decoder, charset);
        val = options.strictNullHandling ? null : "";
      } else {
        key = options.decoder(part.slice(0, pos), defaults.decoder, charset);
        val = options.decoder(part.slice(pos + 1), defaults.decoder, charset);
      }
      if (val && options.interpretNumericEntities && charset === "iso-8859-1") {
        val = interpretNumericEntities(val);
      }
      if (val && options.comma && val.indexOf(",") > -1) {
        val = val.split(",");
      }
      if (has.call(obj, key)) {
        obj[key] = utils.combine(obj[key], val);
      } else {
        obj[key] = val;
      }
    }
    return obj;
  };
  var parseObject = function(chain, val, options) {
    var leaf = val;
    for (var i = chain.length - 1;i >= 0; --i) {
      var obj;
      var root = chain[i];
      if (root === "[]" && options.parseArrays) {
        obj = [].concat(leaf);
      } else {
        obj = options.plainObjects ? Object.create(null) : {};
        var cleanRoot = root.charAt(0) === "[" && root.charAt(root.length - 1) === "]" ? root.slice(1, -1) : root;
        var index = parseInt(cleanRoot, 10);
        if (!options.parseArrays && cleanRoot === "") {
          obj = { 0: leaf };
        } else if (!isNaN(index) && root !== cleanRoot && String(index) === cleanRoot && index >= 0 && (options.parseArrays && index <= options.arrayLimit)) {
          obj = [];
          obj[index] = leaf;
        } else {
          obj[cleanRoot] = leaf;
        }
      }
      leaf = obj;
    }
    return leaf;
  };
  var parseKeys = function parseQueryStringKeys(givenKey, val, options) {
    if (!givenKey) {
      return;
    }
    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;
    var segment = brackets.exec(key);
    var parent = segment ? key.slice(0, segment.index) : key;
    var keys = [];
    if (parent) {
      if (!options.plainObjects && has.call(Object.prototype, parent)) {
        if (!options.allowPrototypes) {
          return;
        }
      }
      keys.push(parent);
    }
    var i = 0;
    while ((segment = child.exec(key)) !== null && i < options.depth) {
      i += 1;
      if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
        if (!options.allowPrototypes) {
          return;
        }
      }
      keys.push(segment[1]);
    }
    if (segment) {
      keys.push("[" + key.slice(segment.index) + "]");
    }
    return parseObject(keys, val, options);
  };
  var normalizeParseOptions = function normalizeParseOptions(opts) {
    if (!opts) {
      return defaults;
    }
    if (opts.decoder !== null && opts.decoder !== undefined && typeof opts.decoder !== "function") {
      throw new TypeError("Decoder has to be a function.");
    }
    if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
      throw new Error("The charset option must be either utf-8, iso-8859-1, or undefined");
    }
    var charset = typeof opts.charset === "undefined" ? defaults.charset : opts.charset;
    return {
      allowDots: typeof opts.allowDots === "undefined" ? defaults.allowDots : !!opts.allowDots,
      allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults.allowPrototypes,
      arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults.arrayLimit,
      charset,
      charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
      comma: typeof opts.comma === "boolean" ? opts.comma : defaults.comma,
      decoder: typeof opts.decoder === "function" ? opts.decoder : defaults.decoder,
      delimiter: typeof opts.delimiter === "string" || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
      depth: typeof opts.depth === "number" ? opts.depth : defaults.depth,
      ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
      interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
      parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults.parameterLimit,
      parseArrays: opts.parseArrays !== false,
      plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults.plainObjects,
      strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
    };
  };
  module.exports = function(str, opts) {
    var options = normalizeParseOptions(opts);
    if (str === "" || str === null || typeof str === "undefined") {
      return options.plainObjects ? Object.create(null) : {};
    }
    var tempObj = typeof str === "string" ? parseValues(str, options) : str;
    var obj = options.plainObjects ? Object.create(null) : {};
    var keys = Object.keys(tempObj);
    for (var i = 0;i < keys.length; ++i) {
      var key = keys[i];
      var newObj = parseKeys(key, tempObj[key], options);
      obj = utils.merge(obj, newObj, options);
    }
    return utils.compact(obj);
  };
});

// node_modules/qs/lib/index.js
var require_lib2 = __commonJS((exports, module) => {
  var stringify = require_stringify();
  var parse = require_parse();
  var formats = require_formats();
  module.exports = {
    formats,
    parse,
    stringify
  };
});

// node_modules/body-parser/lib/types/urlencoded.js
var require_urlencoded = __commonJS((exports, module) => {
  /*!
   * body-parser
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  var bytes = require_bytes();
  var contentType = require_content_type();
  var createError = require_http_errors();
  var debug = require_src()("body-parser:urlencoded");
  var deprecate2 = require_depd()("body-parser");
  var read = require_read();
  var typeis = require_type_is();
  module.exports = urlencoded;
  var parsers = Object.create(null);
  function urlencoded(options) {
    var opts = options || {};
    if (opts.extended === undefined) {
      deprecate2("undefined extended: provide extended option");
    }
    var extended = opts.extended !== false;
    var inflate = opts.inflate !== false;
    var limit = typeof opts.limit !== "number" ? bytes.parse(opts.limit || "100kb") : opts.limit;
    var type = opts.type || "application/x-www-form-urlencoded";
    var verify = opts.verify || false;
    if (verify !== false && typeof verify !== "function") {
      throw new TypeError("option verify must be function");
    }
    var queryparse = extended ? extendedparser(opts) : simpleparser(opts);
    var shouldParse = typeof type !== "function" ? typeChecker(type) : type;
    function parse(body) {
      return body.length ? queryparse(body) : {};
    }
    return function urlencodedParser(req, res, next) {
      if (req._body) {
        debug("body already parsed");
        next();
        return;
      }
      req.body = req.body || {};
      if (!typeis.hasBody(req)) {
        debug("skip empty body");
        next();
        return;
      }
      debug("content-type %j", req.headers["content-type"]);
      if (!shouldParse(req)) {
        debug("skip parsing");
        next();
        return;
      }
      var charset = getCharset(req) || "utf-8";
      if (charset !== "utf-8") {
        debug("invalid charset");
        next(createError(415, 'unsupported charset "' + charset.toUpperCase() + '"', {
          charset,
          type: "charset.unsupported"
        }));
        return;
      }
      read(req, res, next, parse, debug, {
        debug,
        encoding: charset,
        inflate,
        limit,
        verify
      });
    };
  }
  function extendedparser(options) {
    var parameterLimit = options.parameterLimit !== undefined ? options.parameterLimit : 1000;
    var parse = parser("qs");
    if (isNaN(parameterLimit) || parameterLimit < 1) {
      throw new TypeError("option parameterLimit must be a positive number");
    }
    if (isFinite(parameterLimit)) {
      parameterLimit = parameterLimit | 0;
    }
    return function queryparse(body) {
      var paramCount = parameterCount(body, parameterLimit);
      if (paramCount === undefined) {
        debug("too many parameters");
        throw createError(413, "too many parameters", {
          type: "parameters.too.many"
        });
      }
      var arrayLimit = Math.max(100, paramCount);
      debug("parse extended urlencoding");
      return parse(body, {
        allowPrototypes: true,
        arrayLimit,
        depth: Infinity,
        parameterLimit
      });
    };
  }
  function getCharset(req) {
    try {
      return (contentType.parse(req).parameters.charset || "").toLowerCase();
    } catch (e) {
      return;
    }
  }
  function parameterCount(body, limit) {
    var count = 0;
    var index = 0;
    while ((index = body.indexOf("&", index)) !== -1) {
      count++;
      index++;
      if (count === limit) {
        return;
      }
    }
    return count;
  }
  function parser(name) {
    var mod2 = parsers[name];
    if (mod2 !== undefined) {
      return mod2.parse;
    }
    switch (name) {
      case "qs":
        mod2 = require_lib2();
        break;
      case "querystring":
        mod2 = __require("querystring");
        break;
    }
    parsers[name] = mod2;
    return mod2.parse;
  }
  function simpleparser(options) {
    var parameterLimit = options.parameterLimit !== undefined ? options.parameterLimit : 1000;
    var parse = parser("querystring");
    if (isNaN(parameterLimit) || parameterLimit < 1) {
      throw new TypeError("option parameterLimit must be a positive number");
    }
    if (isFinite(parameterLimit)) {
      parameterLimit = parameterLimit | 0;
    }
    return function queryparse(body) {
      var paramCount = parameterCount(body, parameterLimit);
      if (paramCount === undefined) {
        debug("too many parameters");
        throw createError(413, "too many parameters", {
          type: "parameters.too.many"
        });
      }
      debug("parse urlencoding");
      return parse(body, undefined, undefined, { maxKeys: parameterLimit });
    };
  }
  function typeChecker(type) {
    return function checkType(req) {
      return Boolean(typeis(req, type));
    };
  }
});

// node_modules/body-parser/index.js
var require_body_parser = __commonJS((exports, module) => {
  /*!
   * body-parser
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  var deprecate2 = require_depd()("body-parser");
  var parsers = Object.create(null);
  exports = module.exports = deprecate2.function(bodyParser, "bodyParser: use individual json/urlencoded middlewares");
  Object.defineProperty(exports, "json", {
    configurable: true,
    enumerable: true,
    get: createParserGetter("json")
  });
  Object.defineProperty(exports, "raw", {
    configurable: true,
    enumerable: true,
    get: createParserGetter("raw")
  });
  Object.defineProperty(exports, "text", {
    configurable: true,
    enumerable: true,
    get: createParserGetter("text")
  });
  Object.defineProperty(exports, "urlencoded", {
    configurable: true,
    enumerable: true,
    get: createParserGetter("urlencoded")
  });
  function bodyParser(options) {
    var opts = {};
    if (options) {
      for (var prop in options) {
        if (prop !== "type") {
          opts[prop] = options[prop];
        }
      }
    }
    var _urlencoded = exports.urlencoded(opts);
    var _json = exports.json(opts);
    return function bodyParser(req, res, next) {
      _json(req, res, function(err) {
        if (err)
          return next(err);
        _urlencoded(req, res, next);
      });
    };
  }
  function createParserGetter(name) {
    return function get() {
      return loadParser(name);
    };
  }
  function loadParser(parserName) {
    var parser = parsers[parserName];
    if (parser !== undefined) {
      return parser;
    }
    switch (parserName) {
      case "json":
        parser = require_json();
        break;
      case "raw":
        parser = require_raw();
        break;
      case "text":
        parser = require_text();
        break;
      case "urlencoded":
        parser = require_urlencoded();
        break;
    }
    return parsers[parserName] = parser;
  }
});

// node_modules/merge-descriptors/index.js
var require_merge_descriptors = __commonJS((exports, module) => {
  /*!
   * merge-descriptors
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  module.exports = merge;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  function merge(dest, src, redefine) {
    if (!dest) {
      throw new TypeError("argument dest is required");
    }
    if (!src) {
      throw new TypeError("argument src is required");
    }
    if (redefine === undefined) {
      redefine = true;
    }
    Object.getOwnPropertyNames(src).forEach(function forEachOwnPropertyName(name) {
      if (!redefine && hasOwnProperty.call(dest, name)) {
        return;
      }
      var descriptor = Object.getOwnPropertyDescriptor(src, name);
      Object.defineProperty(dest, name, descriptor);
    });
    return dest;
  }
});

// node_modules/finalhandler/node_modules/debug/node_modules/ms/index.js
var require_ms2 = __commonJS((exports, module) => {
  var s = 1000;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var y = d * 365.25;
  module.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse(val);
    } else if (type === "number" && isNaN(val) === false) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
  function parse(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return;
    }
  }
  function fmtShort(ms) {
    if (ms >= d) {
      return Math.round(ms / d) + "d";
    }
    if (ms >= h) {
      return Math.round(ms / h) + "h";
    }
    if (ms >= m) {
      return Math.round(ms / m) + "m";
    }
    if (ms >= s) {
      return Math.round(ms / s) + "s";
    }
    return ms + "ms";
  }
  function fmtLong(ms) {
    return plural(ms, d, "day") || plural(ms, h, "hour") || plural(ms, m, "minute") || plural(ms, s, "second") || ms + " ms";
  }
  function plural(ms, n, name) {
    if (ms < n) {
      return;
    }
    if (ms < n * 1.5) {
      return Math.floor(ms / n) + " " + name;
    }
    return Math.ceil(ms / n) + " " + name + "s";
  }
});

// node_modules/finalhandler/node_modules/debug/src/debug.js
var require_debug2 = __commonJS((exports, module) => {
  exports = module.exports = createDebug.debug = createDebug["default"] = createDebug;
  exports.coerce = coerce;
  exports.disable = disable;
  exports.enable = enable;
  exports.enabled = enabled;
  exports.humanize = require_ms2();
  exports.names = [];
  exports.skips = [];
  exports.formatters = {};
  var prevTime;
  function selectColor(namespace) {
    var hash = 0, i;
    for (i in namespace) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i);
      hash |= 0;
    }
    return exports.colors[Math.abs(hash) % exports.colors.length];
  }
  function createDebug(namespace) {
    function debug() {
      if (!debug.enabled)
        return;
      var self2 = debug;
      var curr = +new Date;
      var ms = curr - (prevTime || curr);
      self2.diff = ms;
      self2.prev = prevTime;
      self2.curr = curr;
      prevTime = curr;
      var args2 = new Array(arguments.length);
      for (var i = 0;i < args2.length; i++) {
        args2[i] = arguments[i];
      }
      args2[0] = exports.coerce(args2[0]);
      if (typeof args2[0] !== "string") {
        args2.unshift("%O");
      }
      var index = 0;
      args2[0] = args2[0].replace(/%([a-zA-Z%])/g, function(match, format) {
        if (match === "%%")
          return match;
        index++;
        var formatter = exports.formatters[format];
        if (typeof formatter === "function") {
          var val = args2[index];
          match = formatter.call(self2, val);
          args2.splice(index, 1);
          index--;
        }
        return match;
      });
      exports.formatArgs.call(self2, args2);
      var logFn = debug.log || exports.log || console.log.bind(console);
      logFn.apply(self2, args2);
    }
    debug.namespace = namespace;
    debug.enabled = exports.enabled(namespace);
    debug.useColors = exports.useColors();
    debug.color = selectColor(namespace);
    if (typeof exports.init === "function") {
      exports.init(debug);
    }
    return debug;
  }
  function enable(namespaces) {
    exports.save(namespaces);
    exports.names = [];
    exports.skips = [];
    var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
    var len = split.length;
    for (var i = 0;i < len; i++) {
      if (!split[i])
        continue;
      namespaces = split[i].replace(/\*/g, ".*?");
      if (namespaces[0] === "-") {
        exports.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
      } else {
        exports.names.push(new RegExp("^" + namespaces + "$"));
      }
    }
  }
  function disable() {
    exports.enable("");
  }
  function enabled(name) {
    var i, len;
    for (i = 0, len = exports.skips.length;i < len; i++) {
      if (exports.skips[i].test(name)) {
        return false;
      }
    }
    for (i = 0, len = exports.names.length;i < len; i++) {
      if (exports.names[i].test(name)) {
        return true;
      }
    }
    return false;
  }
  function coerce(val) {
    if (val instanceof Error)
      return val.stack || val.message;
    return val;
  }
});

// node_modules/finalhandler/node_modules/debug/src/browser.js
var require_browser2 = __commonJS((exports, module) => {
  exports = module.exports = require_debug2();
  exports.log = log;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = typeof chrome != "undefined" && typeof chrome.storage != "undefined" ? chrome.storage.local : localstorage();
  exports.colors = [
    "lightseagreen",
    "forestgreen",
    "goldenrod",
    "dodgerblue",
    "darkorchid",
    "crimson"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
      return true;
    }
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  exports.formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (err) {
      return "[UnexpectedJSONParseError]: " + err.message;
    }
  };
  function formatArgs(args2) {
    var useColors2 = this.useColors;
    args2[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args2[0] + (useColors2 ? "%c " : " ") + "+" + exports.humanize(this.diff);
    if (!useColors2)
      return;
    var c = "color: " + this.color;
    args2.splice(1, 0, c, "color: inherit");
    var index = 0;
    var lastC = 0;
    args2[0].replace(/%[a-zA-Z%]/g, function(match) {
      if (match === "%%")
        return;
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args2.splice(lastC, 0, c);
  }
  function log() {
    return typeof console === "object" && console.log && Function.prototype.apply.call(console.log, console, arguments);
  }
  function save(namespaces) {
    try {
      if (namespaces == null) {
        exports.storage.removeItem("debug");
      } else {
        exports.storage.debug = namespaces;
      }
    } catch (e) {}
  }
  function load() {
    var r;
    try {
      r = exports.storage.debug;
    } catch (e) {}
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = process.env.DEBUG;
    }
    return r;
  }
  exports.enable(load());
  function localstorage() {
    try {
      return window.localStorage;
    } catch (e) {}
  }
});

// node_modules/finalhandler/node_modules/debug/src/node.js
var require_node2 = __commonJS((exports, module) => {
  var tty = __require("tty");
  var util = __require("util");
  exports = module.exports = require_debug2();
  exports.init = init;
  exports.log = log;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.colors = [6, 2, 3, 4, 5, 1];
  exports.inspectOpts = Object.keys(process.env).filter(function(key) {
    return /^debug_/i.test(key);
  }).reduce(function(obj, key) {
    var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function(_, k) {
      return k.toUpperCase();
    });
    var val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val))
      val = true;
    else if (/^(no|off|false|disabled)$/i.test(val))
      val = false;
    else if (val === "null")
      val = null;
    else
      val = Number(val);
    obj[prop] = val;
    return obj;
  }, {});
  var fd = parseInt(process.env.DEBUG_FD, 10) || 2;
  if (fd !== 1 && fd !== 2) {
    util.deprecate(function() {}, "except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)")();
  }
  var stream = fd === 1 ? process.stdout : fd === 2 ? process.stderr : createWritableStdioStream(fd);
  function useColors() {
    return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(fd);
  }
  exports.formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts).split(`
`).map(function(str) {
      return str.trim();
    }).join(" ");
  };
  exports.formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts);
  };
  function formatArgs(args2) {
    var name = this.namespace;
    var useColors2 = this.useColors;
    if (useColors2) {
      var c = this.color;
      var prefix = "  \x1B[3" + c + ";1m" + name + " " + "\x1B[0m";
      args2[0] = prefix + args2[0].split(`
`).join(`
` + prefix);
      args2.push("\x1B[3" + c + "m+" + exports.humanize(this.diff) + "\x1B[0m");
    } else {
      args2[0] = new Date().toUTCString() + " " + name + " " + args2[0];
    }
  }
  function log() {
    return stream.write(util.format.apply(util, arguments) + `
`);
  }
  function save(namespaces) {
    if (namespaces == null) {
      delete process.env.DEBUG;
    } else {
      process.env.DEBUG = namespaces;
    }
  }
  function load() {
    return process.env.DEBUG;
  }
  function createWritableStdioStream(fd2) {
    var stream2;
    var tty_wrap = process.binding("tty_wrap");
    switch (tty_wrap.guessHandleType(fd2)) {
      case "TTY":
        stream2 = new tty.WriteStream(fd2);
        stream2._type = "tty";
        if (stream2._handle && stream2._handle.unref) {
          stream2._handle.unref();
        }
        break;
      case "FILE":
        var fs = __require("fs");
        stream2 = new fs.SyncWriteStream(fd2, { autoClose: false });
        stream2._type = "fs";
        break;
      case "PIPE":
      case "TCP":
        var net = __require("net");
        stream2 = new net.Socket({
          fd: fd2,
          readable: false,
          writable: true
        });
        stream2.readable = false;
        stream2.read = null;
        stream2._type = "pipe";
        if (stream2._handle && stream2._handle.unref) {
          stream2._handle.unref();
        }
        break;
      default:
        throw new Error("Implement me. Unknown stream file type!");
    }
    stream2.fd = fd2;
    stream2._isStdio = true;
    return stream2;
  }
  function init(debug) {
    debug.inspectOpts = {};
    var keys = Object.keys(exports.inspectOpts);
    for (var i = 0;i < keys.length; i++) {
      debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
    }
  }
  exports.enable(load());
});

// node_modules/finalhandler/node_modules/debug/src/index.js
var require_src2 = __commonJS((exports, module) => {
  if (typeof process !== "undefined" && process.type === "renderer") {
    module.exports = require_browser2();
  } else {
    module.exports = require_node2();
  }
});

// node_modules/encodeurl/index.js
var require_encodeurl = __commonJS((exports, module) => {
  /*!
   * encodeurl
   * Copyright(c) 2016 Douglas Christopher Wilson
   * MIT Licensed
   */
  module.exports = encodeUrl;
  var ENCODE_CHARS_REGEXP = /(?:[^\x21\x25\x26-\x3B\x3D\x3F-\x5B\x5D\x5F\x61-\x7A\x7E]|%(?:[^0-9A-Fa-f]|[0-9A-Fa-f][^0-9A-Fa-f]|$))+/g;
  var UNMATCHED_SURROGATE_PAIR_REGEXP = /(^|[^\uD800-\uDBFF])[\uDC00-\uDFFF]|[\uD800-\uDBFF]([^\uDC00-\uDFFF]|$)/g;
  var UNMATCHED_SURROGATE_PAIR_REPLACE = "$1$2";
  function encodeUrl(url) {
    return String(url).replace(UNMATCHED_SURROGATE_PAIR_REGEXP, UNMATCHED_SURROGATE_PAIR_REPLACE).replace(ENCODE_CHARS_REGEXP, encodeURI);
  }
});

// node_modules/escape-html/index.js
var require_escape_html = __commonJS((exports, module) => {
  /*!
   * escape-html
   * Copyright(c) 2012-2013 TJ Holowaychuk
   * Copyright(c) 2015 Andreas Lubbe
   * Copyright(c) 2015 Tiancheng "Timothy" Gu
   * MIT Licensed
   */
  var matchHtmlRegExp = /["'&<>]/;
  module.exports = escapeHtml;
  function escapeHtml(string) {
    var str = "" + string;
    var match = matchHtmlRegExp.exec(str);
    if (!match) {
      return str;
    }
    var escape2;
    var html = "";
    var index = 0;
    var lastIndex = 0;
    for (index = match.index;index < str.length; index++) {
      switch (str.charCodeAt(index)) {
        case 34:
          escape2 = "&quot;";
          break;
        case 38:
          escape2 = "&amp;";
          break;
        case 39:
          escape2 = "&#39;";
          break;
        case 60:
          escape2 = "&lt;";
          break;
        case 62:
          escape2 = "&gt;";
          break;
        default:
          continue;
      }
      if (lastIndex !== index) {
        html += str.substring(lastIndex, index);
      }
      lastIndex = index + 1;
      html += escape2;
    }
    return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
  }
});

// node_modules/parseurl/index.js
var require_parseurl = __commonJS((exports, module) => {
  /*!
   * parseurl
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2014-2017 Douglas Christopher Wilson
   * MIT Licensed
   */
  var url = __require("url");
  var parse = url.parse;
  var Url = url.Url;
  module.exports = parseurl;
  module.exports.original = originalurl;
  function parseurl(req) {
    var url2 = req.url;
    if (url2 === undefined) {
      return;
    }
    var parsed = req._parsedUrl;
    if (fresh(url2, parsed)) {
      return parsed;
    }
    parsed = fastparse(url2);
    parsed._raw = url2;
    return req._parsedUrl = parsed;
  }
  function originalurl(req) {
    var url2 = req.originalUrl;
    if (typeof url2 !== "string") {
      return parseurl(req);
    }
    var parsed = req._parsedOriginalUrl;
    if (fresh(url2, parsed)) {
      return parsed;
    }
    parsed = fastparse(url2);
    parsed._raw = url2;
    return req._parsedOriginalUrl = parsed;
  }
  function fastparse(str) {
    if (typeof str !== "string" || str.charCodeAt(0) !== 47) {
      return parse(str);
    }
    var pathname = str;
    var query = null;
    var search = null;
    for (var i = 1;i < str.length; i++) {
      switch (str.charCodeAt(i)) {
        case 63:
          if (search === null) {
            pathname = str.substring(0, i);
            query = str.substring(i + 1);
            search = str.substring(i);
          }
          break;
        case 9:
        case 10:
        case 12:
        case 13:
        case 32:
        case 35:
        case 160:
        case 65279:
          return parse(str);
      }
    }
    var url2 = Url !== undefined ? new Url : {};
    url2.path = str;
    url2.href = str;
    url2.pathname = pathname;
    if (search !== null) {
      url2.query = query;
      url2.search = search;
    }
    return url2;
  }
  function fresh(url2, parsedUrl) {
    return typeof parsedUrl === "object" && parsedUrl !== null && (Url === undefined || parsedUrl instanceof Url) && parsedUrl._raw === url2;
  }
});

// node_modules/finalhandler/index.js
var require_finalhandler = __commonJS((exports, module) => {
  /*!
   * finalhandler
   * Copyright(c) 2014-2017 Douglas Christopher Wilson
   * MIT Licensed
   */
  var debug = require_src2()("finalhandler");
  var encodeUrl = require_encodeurl();
  var escapeHtml = require_escape_html();
  var onFinished = require_on_finished();
  var parseUrl = require_parseurl();
  var statuses = require_statuses();
  var unpipe = require_unpipe();
  var DOUBLE_SPACE_REGEXP = /\x20{2}/g;
  var NEWLINE_REGEXP = /\n/g;
  var defer = typeof setImmediate === "function" ? setImmediate : function(fn2) {
    process.nextTick(fn2.bind.apply(fn2, arguments));
  };
  var isFinished = onFinished.isFinished;
  function createHtmlDocument(message2) {
    var body = escapeHtml(message2).replace(NEWLINE_REGEXP, "<br>").replace(DOUBLE_SPACE_REGEXP, " &nbsp;");
    return `<!DOCTYPE html>
` + `<html lang="en">
` + `<head>
` + `<meta charset="utf-8">
` + `<title>Error</title>
` + `</head>
` + `<body>
` + "<pre>" + body + `</pre>
` + `</body>
` + `</html>
`;
  }
  module.exports = finalhandler;
  function finalhandler(req, res, options) {
    var opts = options || {};
    var env = opts.env || "development";
    var onerror = opts.onerror;
    return function(err) {
      var headers;
      var msg;
      var status;
      if (!err && headersSent(res)) {
        debug("cannot 404 after headers sent");
        return;
      }
      if (err) {
        status = getErrorStatusCode(err);
        if (status === undefined) {
          status = getResponseStatusCode(res);
        } else {
          headers = getErrorHeaders(err);
        }
        msg = getErrorMessage(err, status, env);
      } else {
        status = 404;
        msg = "Cannot " + req.method + " " + encodeUrl(getResourceName(req));
      }
      debug("default %s", status);
      if (err && onerror) {
        defer(onerror, err, req, res);
      }
      if (headersSent(res)) {
        debug("cannot %d after headers sent", status);
        req.socket.destroy();
        return;
      }
      send(req, res, status, headers, msg);
    };
  }
  function getErrorHeaders(err) {
    if (!err.headers || typeof err.headers !== "object") {
      return;
    }
    var headers = Object.create(null);
    var keys = Object.keys(err.headers);
    for (var i = 0;i < keys.length; i++) {
      var key = keys[i];
      headers[key] = err.headers[key];
    }
    return headers;
  }
  function getErrorMessage(err, status, env) {
    var msg;
    if (env !== "production") {
      msg = err.stack;
      if (!msg && typeof err.toString === "function") {
        msg = err.toString();
      }
    }
    return msg || statuses[status];
  }
  function getErrorStatusCode(err) {
    if (typeof err.status === "number" && err.status >= 400 && err.status < 600) {
      return err.status;
    }
    if (typeof err.statusCode === "number" && err.statusCode >= 400 && err.statusCode < 600) {
      return err.statusCode;
    }
    return;
  }
  function getResourceName(req) {
    try {
      return parseUrl.original(req).pathname;
    } catch (e) {
      return "resource";
    }
  }
  function getResponseStatusCode(res) {
    var status = res.statusCode;
    if (typeof status !== "number" || status < 400 || status > 599) {
      status = 500;
    }
    return status;
  }
  function headersSent(res) {
    return typeof res.headersSent !== "boolean" ? Boolean(res._header) : res.headersSent;
  }
  function send(req, res, status, headers, message2) {
    function write() {
      var body = createHtmlDocument(message2);
      res.statusCode = status;
      res.statusMessage = statuses[status];
      setHeaders(res, headers);
      res.setHeader("Content-Security-Policy", "default-src 'none'");
      res.setHeader("X-Content-Type-Options", "nosniff");
      res.setHeader("Content-Type", "text/html; charset=utf-8");
      res.setHeader("Content-Length", Buffer.byteLength(body, "utf8"));
      if (req.method === "HEAD") {
        res.end();
        return;
      }
      res.end(body, "utf8");
    }
    if (isFinished(req)) {
      write();
      return;
    }
    unpipe(req);
    onFinished(req, write);
    req.resume();
  }
  function setHeaders(res, headers) {
    if (!headers) {
      return;
    }
    var keys = Object.keys(headers);
    for (var i = 0;i < keys.length; i++) {
      var key = keys[i];
      res.setHeader(key, headers[key]);
    }
  }
});

// node_modules/express/node_modules/debug/node_modules/ms/index.js
var require_ms3 = __commonJS((exports, module) => {
  var s = 1000;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var y = d * 365.25;
  module.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse(val);
    } else if (type === "number" && isNaN(val) === false) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
  function parse(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return;
    }
  }
  function fmtShort(ms) {
    if (ms >= d) {
      return Math.round(ms / d) + "d";
    }
    if (ms >= h) {
      return Math.round(ms / h) + "h";
    }
    if (ms >= m) {
      return Math.round(ms / m) + "m";
    }
    if (ms >= s) {
      return Math.round(ms / s) + "s";
    }
    return ms + "ms";
  }
  function fmtLong(ms) {
    return plural(ms, d, "day") || plural(ms, h, "hour") || plural(ms, m, "minute") || plural(ms, s, "second") || ms + " ms";
  }
  function plural(ms, n, name) {
    if (ms < n) {
      return;
    }
    if (ms < n * 1.5) {
      return Math.floor(ms / n) + " " + name;
    }
    return Math.ceil(ms / n) + " " + name + "s";
  }
});

// node_modules/express/node_modules/debug/src/debug.js
var require_debug3 = __commonJS((exports, module) => {
  exports = module.exports = createDebug.debug = createDebug["default"] = createDebug;
  exports.coerce = coerce;
  exports.disable = disable;
  exports.enable = enable;
  exports.enabled = enabled;
  exports.humanize = require_ms3();
  exports.names = [];
  exports.skips = [];
  exports.formatters = {};
  var prevTime;
  function selectColor(namespace) {
    var hash = 0, i;
    for (i in namespace) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i);
      hash |= 0;
    }
    return exports.colors[Math.abs(hash) % exports.colors.length];
  }
  function createDebug(namespace) {
    function debug() {
      if (!debug.enabled)
        return;
      var self2 = debug;
      var curr = +new Date;
      var ms = curr - (prevTime || curr);
      self2.diff = ms;
      self2.prev = prevTime;
      self2.curr = curr;
      prevTime = curr;
      var args2 = new Array(arguments.length);
      for (var i = 0;i < args2.length; i++) {
        args2[i] = arguments[i];
      }
      args2[0] = exports.coerce(args2[0]);
      if (typeof args2[0] !== "string") {
        args2.unshift("%O");
      }
      var index = 0;
      args2[0] = args2[0].replace(/%([a-zA-Z%])/g, function(match, format) {
        if (match === "%%")
          return match;
        index++;
        var formatter = exports.formatters[format];
        if (typeof formatter === "function") {
          var val = args2[index];
          match = formatter.call(self2, val);
          args2.splice(index, 1);
          index--;
        }
        return match;
      });
      exports.formatArgs.call(self2, args2);
      var logFn = debug.log || exports.log || console.log.bind(console);
      logFn.apply(self2, args2);
    }
    debug.namespace = namespace;
    debug.enabled = exports.enabled(namespace);
    debug.useColors = exports.useColors();
    debug.color = selectColor(namespace);
    if (typeof exports.init === "function") {
      exports.init(debug);
    }
    return debug;
  }
  function enable(namespaces) {
    exports.save(namespaces);
    exports.names = [];
    exports.skips = [];
    var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
    var len = split.length;
    for (var i = 0;i < len; i++) {
      if (!split[i])
        continue;
      namespaces = split[i].replace(/\*/g, ".*?");
      if (namespaces[0] === "-") {
        exports.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
      } else {
        exports.names.push(new RegExp("^" + namespaces + "$"));
      }
    }
  }
  function disable() {
    exports.enable("");
  }
  function enabled(name) {
    var i, len;
    for (i = 0, len = exports.skips.length;i < len; i++) {
      if (exports.skips[i].test(name)) {
        return false;
      }
    }
    for (i = 0, len = exports.names.length;i < len; i++) {
      if (exports.names[i].test(name)) {
        return true;
      }
    }
    return false;
  }
  function coerce(val) {
    if (val instanceof Error)
      return val.stack || val.message;
    return val;
  }
});

// node_modules/express/node_modules/debug/src/browser.js
var require_browser3 = __commonJS((exports, module) => {
  exports = module.exports = require_debug3();
  exports.log = log;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = typeof chrome != "undefined" && typeof chrome.storage != "undefined" ? chrome.storage.local : localstorage();
  exports.colors = [
    "lightseagreen",
    "forestgreen",
    "goldenrod",
    "dodgerblue",
    "darkorchid",
    "crimson"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
      return true;
    }
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  exports.formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (err) {
      return "[UnexpectedJSONParseError]: " + err.message;
    }
  };
  function formatArgs(args2) {
    var useColors2 = this.useColors;
    args2[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args2[0] + (useColors2 ? "%c " : " ") + "+" + exports.humanize(this.diff);
    if (!useColors2)
      return;
    var c = "color: " + this.color;
    args2.splice(1, 0, c, "color: inherit");
    var index = 0;
    var lastC = 0;
    args2[0].replace(/%[a-zA-Z%]/g, function(match) {
      if (match === "%%")
        return;
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args2.splice(lastC, 0, c);
  }
  function log() {
    return typeof console === "object" && console.log && Function.prototype.apply.call(console.log, console, arguments);
  }
  function save(namespaces) {
    try {
      if (namespaces == null) {
        exports.storage.removeItem("debug");
      } else {
        exports.storage.debug = namespaces;
      }
    } catch (e) {}
  }
  function load() {
    var r;
    try {
      r = exports.storage.debug;
    } catch (e) {}
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = process.env.DEBUG;
    }
    return r;
  }
  exports.enable(load());
  function localstorage() {
    try {
      return window.localStorage;
    } catch (e) {}
  }
});

// node_modules/express/node_modules/debug/src/node.js
var require_node3 = __commonJS((exports, module) => {
  var tty = __require("tty");
  var util = __require("util");
  exports = module.exports = require_debug3();
  exports.init = init;
  exports.log = log;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.colors = [6, 2, 3, 4, 5, 1];
  exports.inspectOpts = Object.keys(process.env).filter(function(key) {
    return /^debug_/i.test(key);
  }).reduce(function(obj, key) {
    var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function(_, k) {
      return k.toUpperCase();
    });
    var val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val))
      val = true;
    else if (/^(no|off|false|disabled)$/i.test(val))
      val = false;
    else if (val === "null")
      val = null;
    else
      val = Number(val);
    obj[prop] = val;
    return obj;
  }, {});
  var fd = parseInt(process.env.DEBUG_FD, 10) || 2;
  if (fd !== 1 && fd !== 2) {
    util.deprecate(function() {}, "except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)")();
  }
  var stream = fd === 1 ? process.stdout : fd === 2 ? process.stderr : createWritableStdioStream(fd);
  function useColors() {
    return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(fd);
  }
  exports.formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts).split(`
`).map(function(str) {
      return str.trim();
    }).join(" ");
  };
  exports.formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts);
  };
  function formatArgs(args2) {
    var name = this.namespace;
    var useColors2 = this.useColors;
    if (useColors2) {
      var c = this.color;
      var prefix = "  \x1B[3" + c + ";1m" + name + " " + "\x1B[0m";
      args2[0] = prefix + args2[0].split(`
`).join(`
` + prefix);
      args2.push("\x1B[3" + c + "m+" + exports.humanize(this.diff) + "\x1B[0m");
    } else {
      args2[0] = new Date().toUTCString() + " " + name + " " + args2[0];
    }
  }
  function log() {
    return stream.write(util.format.apply(util, arguments) + `
`);
  }
  function save(namespaces) {
    if (namespaces == null) {
      delete process.env.DEBUG;
    } else {
      process.env.DEBUG = namespaces;
    }
  }
  function load() {
    return process.env.DEBUG;
  }
  function createWritableStdioStream(fd2) {
    var stream2;
    var tty_wrap = process.binding("tty_wrap");
    switch (tty_wrap.guessHandleType(fd2)) {
      case "TTY":
        stream2 = new tty.WriteStream(fd2);
        stream2._type = "tty";
        if (stream2._handle && stream2._handle.unref) {
          stream2._handle.unref();
        }
        break;
      case "FILE":
        var fs = __require("fs");
        stream2 = new fs.SyncWriteStream(fd2, { autoClose: false });
        stream2._type = "fs";
        break;
      case "PIPE":
      case "TCP":
        var net = __require("net");
        stream2 = new net.Socket({
          fd: fd2,
          readable: false,
          writable: true
        });
        stream2.readable = false;
        stream2.read = null;
        stream2._type = "pipe";
        if (stream2._handle && stream2._handle.unref) {
          stream2._handle.unref();
        }
        break;
      default:
        throw new Error("Implement me. Unknown stream file type!");
    }
    stream2.fd = fd2;
    stream2._isStdio = true;
    return stream2;
  }
  function init(debug) {
    debug.inspectOpts = {};
    var keys = Object.keys(exports.inspectOpts);
    for (var i = 0;i < keys.length; i++) {
      debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
    }
  }
  exports.enable(load());
});

// node_modules/express/node_modules/debug/src/index.js
var require_src3 = __commonJS((exports, module) => {
  if (typeof process !== "undefined" && process.type === "renderer") {
    module.exports = require_browser3();
  } else {
    module.exports = require_node3();
  }
});

// node_modules/array-flatten/array-flatten.js
var require_array_flatten = __commonJS((exports, module) => {
  module.exports = arrayFlatten;
  function flattenWithDepth(array, result, depth) {
    for (var i = 0;i < array.length; i++) {
      var value = array[i];
      if (depth > 0 && Array.isArray(value)) {
        flattenWithDepth(value, result, depth - 1);
      } else {
        result.push(value);
      }
    }
    return result;
  }
  function flattenForever(array, result) {
    for (var i = 0;i < array.length; i++) {
      var value = array[i];
      if (Array.isArray(value)) {
        flattenForever(value, result);
      } else {
        result.push(value);
      }
    }
    return result;
  }
  function arrayFlatten(array, depth) {
    if (depth == null) {
      return flattenForever(array, []);
    }
    return flattenWithDepth(array, [], depth);
  }
});

// node_modules/path-to-regexp/index.js
var require_path_to_regexp = __commonJS((exports, module) => {
  module.exports = pathtoRegexp;
  var MATCHING_GROUP_REGEXP = /\((?!\?)/g;
  function pathtoRegexp(path, keys, options) {
    options = options || {};
    keys = keys || [];
    var strict = options.strict;
    var end = options.end !== false;
    var flags = options.sensitive ? "" : "i";
    var extraOffset = 0;
    var keysOffset = keys.length;
    var i = 0;
    var name = 0;
    var m;
    if (path instanceof RegExp) {
      while (m = MATCHING_GROUP_REGEXP.exec(path.source)) {
        keys.push({
          name: name++,
          optional: false,
          offset: m.index
        });
      }
      return path;
    }
    if (Array.isArray(path)) {
      path = path.map(function(value) {
        return pathtoRegexp(value, keys, options).source;
      });
      return new RegExp("(?:" + path.join("|") + ")", flags);
    }
    path = ("^" + path + (strict ? "" : path[path.length - 1] === "/" ? "?" : "/?")).replace(/\/\(/g, "/(?:").replace(/([\/\.])/g, "\\$1").replace(/(\\\/)?(\\\.)?:(\w+)(\(.*?\))?(\*)?(\?)?/g, function(match, slash, format, key, capture, star, optional, offset) {
      slash = slash || "";
      format = format || "";
      capture = capture || "([^\\/" + format + "]+?)";
      optional = optional || "";
      keys.push({
        name: key,
        optional: !!optional,
        offset: offset + extraOffset
      });
      var result = "" + (optional ? "" : slash) + "(?:" + format + (optional ? slash : "") + capture + (star ? "((?:[\\/" + format + "].+?)?)" : "") + ")" + optional;
      extraOffset += result.length - match.length;
      return result;
    }).replace(/\*/g, function(star, index2) {
      var len = keys.length;
      while (len-- > keysOffset && keys[len].offset > index2) {
        keys[len].offset += 3;
      }
      return "(.*)";
    });
    while (m = MATCHING_GROUP_REGEXP.exec(path)) {
      var escapeCount = 0;
      var index = m.index;
      while (path.charAt(--index) === "\\") {
        escapeCount++;
      }
      if (escapeCount % 2 === 1) {
        continue;
      }
      if (keysOffset + i === keys.length || keys[keysOffset + i].offset > m.index) {
        keys.splice(keysOffset + i, 0, {
          name: name++,
          optional: false,
          offset: m.index
        });
      }
      i++;
    }
    path += end ? "$" : path[path.length - 1] === "/" ? "" : "(?=\\/|$)";
    return new RegExp(path, flags);
  }
});

// node_modules/express/lib/router/layer.js
var require_layer = __commonJS((exports, module) => {
  /*!
   * express
   * Copyright(c) 2009-2013 TJ Holowaychuk
   * Copyright(c) 2013 Roman Shtylman
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  var pathRegexp = require_path_to_regexp();
  var debug = require_src3()("express:router:layer");
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  module.exports = Layer;
  function Layer(path, options, fn2) {
    if (!(this instanceof Layer)) {
      return new Layer(path, options, fn2);
    }
    debug("new %o", path);
    var opts = options || {};
    this.handle = fn2;
    this.name = fn2.name || "<anonymous>";
    this.params = undefined;
    this.path = undefined;
    this.regexp = pathRegexp(path, this.keys = [], opts);
    this.regexp.fast_star = path === "*";
    this.regexp.fast_slash = path === "/" && opts.end === false;
  }
  Layer.prototype.handle_error = function handle_error(error, req, res, next) {
    var fn2 = this.handle;
    if (fn2.length !== 4) {
      return next(error);
    }
    try {
      fn2(error, req, res, next);
    } catch (err) {
      next(err);
    }
  };
  Layer.prototype.handle_request = function handle(req, res, next) {
    var fn2 = this.handle;
    if (fn2.length > 3) {
      return next();
    }
    try {
      fn2(req, res, next);
    } catch (err) {
      next(err);
    }
  };
  Layer.prototype.match = function match(path) {
    var match;
    if (path != null) {
      if (this.regexp.fast_slash) {
        this.params = {};
        this.path = "";
        return true;
      }
      if (this.regexp.fast_star) {
        this.params = { "0": decode_param(path) };
        this.path = path;
        return true;
      }
      match = this.regexp.exec(path);
    }
    if (!match) {
      this.params = undefined;
      this.path = undefined;
      return false;
    }
    this.params = {};
    this.path = match[0];
    var keys = this.keys;
    var params = this.params;
    for (var i = 1;i < match.length; i++) {
      var key = keys[i - 1];
      var prop = key.name;
      var val = decode_param(match[i]);
      if (val !== undefined || !hasOwnProperty.call(params, prop)) {
        params[prop] = val;
      }
    }
    return true;
  };
  function decode_param(val) {
    if (typeof val !== "string" || val.length === 0) {
      return val;
    }
    try {
      return decodeURIComponent(val);
    } catch (err) {
      if (err instanceof URIError) {
        err.message = "Failed to decode param '" + val + "'";
        err.status = err.statusCode = 400;
      }
      throw err;
    }
  }
});

// node_modules/methods/index.js
var require_methods = __commonJS((exports, module) => {
  /*!
   * methods
   * Copyright(c) 2013-2014 TJ Holowaychuk
   * Copyright(c) 2015-2016 Douglas Christopher Wilson
   * MIT Licensed
   */
  var http = __require("http");
  module.exports = getCurrentNodeMethods() || getBasicNodeMethods();
  function getCurrentNodeMethods() {
    return http.METHODS && http.METHODS.map(function lowerCaseMethod(method) {
      return method.toLowerCase();
    });
  }
  function getBasicNodeMethods() {
    return [
      "get",
      "post",
      "put",
      "head",
      "delete",
      "options",
      "trace",
      "copy",
      "lock",
      "mkcol",
      "move",
      "purge",
      "propfind",
      "proppatch",
      "unlock",
      "report",
      "mkactivity",
      "checkout",
      "merge",
      "m-search",
      "notify",
      "subscribe",
      "unsubscribe",
      "patch",
      "search",
      "connect"
    ];
  }
});

// node_modules/express/lib/router/route.js
var require_route = __commonJS((exports, module) => {
  /*!
   * express
   * Copyright(c) 2009-2013 TJ Holowaychuk
   * Copyright(c) 2013 Roman Shtylman
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  var debug = require_src3()("express:router:route");
  var flatten = require_array_flatten();
  var Layer = require_layer();
  var methods = require_methods();
  var slice = Array.prototype.slice;
  var toString = Object.prototype.toString;
  module.exports = Route;
  function Route(path) {
    this.path = path;
    this.stack = [];
    debug("new %o", path);
    this.methods = {};
  }
  Route.prototype._handles_method = function _handles_method(method) {
    if (this.methods._all) {
      return true;
    }
    var name = method.toLowerCase();
    if (name === "head" && !this.methods["head"]) {
      name = "get";
    }
    return Boolean(this.methods[name]);
  };
  Route.prototype._options = function _options() {
    var methods2 = Object.keys(this.methods);
    if (this.methods.get && !this.methods.head) {
      methods2.push("head");
    }
    for (var i = 0;i < methods2.length; i++) {
      methods2[i] = methods2[i].toUpperCase();
    }
    return methods2;
  };
  Route.prototype.dispatch = function dispatch(req, res, done) {
    var idx = 0;
    var stack2 = this.stack;
    if (stack2.length === 0) {
      return done();
    }
    var method = req.method.toLowerCase();
    if (method === "head" && !this.methods["head"]) {
      method = "get";
    }
    req.route = this;
    next();
    function next(err) {
      if (err && err === "route") {
        return done();
      }
      if (err && err === "router") {
        return done(err);
      }
      var layer = stack2[idx++];
      if (!layer) {
        return done(err);
      }
      if (layer.method && layer.method !== method) {
        return next(err);
      }
      if (err) {
        layer.handle_error(err, req, res, next);
      } else {
        layer.handle_request(req, res, next);
      }
    }
  };
  Route.prototype.all = function all() {
    var handles = flatten(slice.call(arguments));
    for (var i = 0;i < handles.length; i++) {
      var handle = handles[i];
      if (typeof handle !== "function") {
        var type = toString.call(handle);
        var msg = "Route.all() requires a callback function but got a " + type;
        throw new TypeError(msg);
      }
      var layer = Layer("/", {}, handle);
      layer.method = undefined;
      this.methods._all = true;
      this.stack.push(layer);
    }
    return this;
  };
  methods.forEach(function(method) {
    Route.prototype[method] = function() {
      var handles = flatten(slice.call(arguments));
      for (var i = 0;i < handles.length; i++) {
        var handle = handles[i];
        if (typeof handle !== "function") {
          var type = toString.call(handle);
          var msg = "Route." + method + "() requires a callback function but got a " + type;
          throw new Error(msg);
        }
        debug("%s %o", method, this.path);
        var layer = Layer("/", {}, handle);
        layer.method = method;
        this.methods[method] = true;
        this.stack.push(layer);
      }
      return this;
    };
  });
});

// node_modules/utils-merge/index.js
var require_utils_merge = __commonJS((exports, module) => {
  exports = module.exports = function(a, b) {
    if (a && b) {
      for (var key in b) {
        a[key] = b[key];
      }
    }
    return a;
  };
});

// node_modules/express/lib/router/index.js
var require_router = __commonJS((exports, module) => {
  /*!
   * express
   * Copyright(c) 2009-2013 TJ Holowaychuk
   * Copyright(c) 2013 Roman Shtylman
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  var Route = require_route();
  var Layer = require_layer();
  var methods = require_methods();
  var mixin = require_utils_merge();
  var debug = require_src3()("express:router");
  var deprecate2 = require_depd()("express");
  var flatten = require_array_flatten();
  var parseUrl = require_parseurl();
  var setPrototypeOf = require_setprototypeof();
  var objectRegExp = /^\[object (\S+)\]$/;
  var slice = Array.prototype.slice;
  var toString = Object.prototype.toString;
  var proto = module.exports = function(options) {
    var opts = options || {};
    function router(req, res, next) {
      router.handle(req, res, next);
    }
    setPrototypeOf(router, proto);
    router.params = {};
    router._params = [];
    router.caseSensitive = opts.caseSensitive;
    router.mergeParams = opts.mergeParams;
    router.strict = opts.strict;
    router.stack = [];
    return router;
  };
  proto.param = function param(name, fn2) {
    if (typeof name === "function") {
      deprecate2("router.param(fn): Refactor to use path params");
      this._params.push(name);
      return;
    }
    var params = this._params;
    var len = params.length;
    var ret;
    if (name[0] === ":") {
      deprecate2("router.param(" + JSON.stringify(name) + ", fn): Use router.param(" + JSON.stringify(name.substr(1)) + ", fn) instead");
      name = name.substr(1);
    }
    for (var i = 0;i < len; ++i) {
      if (ret = params[i](name, fn2)) {
        fn2 = ret;
      }
    }
    if (typeof fn2 !== "function") {
      throw new Error("invalid param() call for " + name + ", got " + fn2);
    }
    (this.params[name] = this.params[name] || []).push(fn2);
    return this;
  };
  proto.handle = function handle(req, res, out) {
    var self2 = this;
    debug("dispatching %s %s", req.method, req.url);
    var idx = 0;
    var protohost = getProtohost(req.url) || "";
    var removed = "";
    var slashAdded = false;
    var paramcalled = {};
    var options = [];
    var stack2 = self2.stack;
    var parentParams = req.params;
    var parentUrl = req.baseUrl || "";
    var done = restore(out, req, "baseUrl", "next", "params");
    req.next = next;
    if (req.method === "OPTIONS") {
      done = wrap(done, function(old, err) {
        if (err || options.length === 0)
          return old(err);
        sendOptionsResponse(res, options, old);
      });
    }
    req.baseUrl = parentUrl;
    req.originalUrl = req.originalUrl || req.url;
    next();
    function next(err) {
      var layerError = err === "route" ? null : err;
      if (slashAdded) {
        req.url = req.url.substr(1);
        slashAdded = false;
      }
      if (removed.length !== 0) {
        req.baseUrl = parentUrl;
        req.url = protohost + removed + req.url.substr(protohost.length);
        removed = "";
      }
      if (layerError === "router") {
        setImmediate(done, null);
        return;
      }
      if (idx >= stack2.length) {
        setImmediate(done, layerError);
        return;
      }
      var path = getPathname(req);
      if (path == null) {
        return done(layerError);
      }
      var layer;
      var match;
      var route;
      while (match !== true && idx < stack2.length) {
        layer = stack2[idx++];
        match = matchLayer(layer, path);
        route = layer.route;
        if (typeof match !== "boolean") {
          layerError = layerError || match;
        }
        if (match !== true) {
          continue;
        }
        if (!route) {
          continue;
        }
        if (layerError) {
          match = false;
          continue;
        }
        var method = req.method;
        var has_method = route._handles_method(method);
        if (!has_method && method === "OPTIONS") {
          appendMethods(options, route._options());
        }
        if (!has_method && method !== "HEAD") {
          match = false;
          continue;
        }
      }
      if (match !== true) {
        return done(layerError);
      }
      if (route) {
        req.route = route;
      }
      req.params = self2.mergeParams ? mergeParams(layer.params, parentParams) : layer.params;
      var layerPath = layer.path;
      self2.process_params(layer, paramcalled, req, res, function(err2) {
        if (err2) {
          return next(layerError || err2);
        }
        if (route) {
          return layer.handle_request(req, res, next);
        }
        trim_prefix(layer, layerError, layerPath, path);
      });
    }
    function trim_prefix(layer, layerError, layerPath, path) {
      if (layerPath.length !== 0) {
        var c = path[layerPath.length];
        if (c && c !== "/" && c !== ".")
          return next(layerError);
        debug("trim prefix (%s) from url %s", layerPath, req.url);
        removed = layerPath;
        req.url = protohost + req.url.substr(protohost.length + removed.length);
        if (!protohost && req.url[0] !== "/") {
          req.url = "/" + req.url;
          slashAdded = true;
        }
        req.baseUrl = parentUrl + (removed[removed.length - 1] === "/" ? removed.substring(0, removed.length - 1) : removed);
      }
      debug("%s %s : %s", layer.name, layerPath, req.originalUrl);
      if (layerError) {
        layer.handle_error(layerError, req, res, next);
      } else {
        layer.handle_request(req, res, next);
      }
    }
  };
  proto.process_params = function process_params(layer, called, req, res, done) {
    var params = this.params;
    var keys = layer.keys;
    if (!keys || keys.length === 0) {
      return done();
    }
    var i = 0;
    var name;
    var paramIndex = 0;
    var key;
    var paramVal;
    var paramCallbacks;
    var paramCalled;
    function param(err) {
      if (err) {
        return done(err);
      }
      if (i >= keys.length) {
        return done();
      }
      paramIndex = 0;
      key = keys[i++];
      name = key.name;
      paramVal = req.params[name];
      paramCallbacks = params[name];
      paramCalled = called[name];
      if (paramVal === undefined || !paramCallbacks) {
        return param();
      }
      if (paramCalled && (paramCalled.match === paramVal || paramCalled.error && paramCalled.error !== "route")) {
        req.params[name] = paramCalled.value;
        return param(paramCalled.error);
      }
      called[name] = paramCalled = {
        error: null,
        match: paramVal,
        value: paramVal
      };
      paramCallback();
    }
    function paramCallback(err) {
      var fn2 = paramCallbacks[paramIndex++];
      paramCalled.value = req.params[key.name];
      if (err) {
        paramCalled.error = err;
        param(err);
        return;
      }
      if (!fn2)
        return param();
      try {
        fn2(req, res, paramCallback, paramVal, key.name);
      } catch (e) {
        paramCallback(e);
      }
    }
    param();
  };
  proto.use = function use(fn2) {
    var offset = 0;
    var path = "/";
    if (typeof fn2 !== "function") {
      var arg = fn2;
      while (Array.isArray(arg) && arg.length !== 0) {
        arg = arg[0];
      }
      if (typeof arg !== "function") {
        offset = 1;
        path = fn2;
      }
    }
    var callbacks = flatten(slice.call(arguments, offset));
    if (callbacks.length === 0) {
      throw new TypeError("Router.use() requires a middleware function");
    }
    for (var i = 0;i < callbacks.length; i++) {
      var fn2 = callbacks[i];
      if (typeof fn2 !== "function") {
        throw new TypeError("Router.use() requires a middleware function but got a " + gettype(fn2));
      }
      debug("use %o %s", path, fn2.name || "<anonymous>");
      var layer = new Layer(path, {
        sensitive: this.caseSensitive,
        strict: false,
        end: false
      }, fn2);
      layer.route = undefined;
      this.stack.push(layer);
    }
    return this;
  };
  proto.route = function route(path) {
    var route = new Route(path);
    var layer = new Layer(path, {
      sensitive: this.caseSensitive,
      strict: this.strict,
      end: true
    }, route.dispatch.bind(route));
    layer.route = route;
    this.stack.push(layer);
    return route;
  };
  methods.concat("all").forEach(function(method) {
    proto[method] = function(path) {
      var route = this.route(path);
      route[method].apply(route, slice.call(arguments, 1));
      return this;
    };
  });
  function appendMethods(list, addition) {
    for (var i = 0;i < addition.length; i++) {
      var method = addition[i];
      if (list.indexOf(method) === -1) {
        list.push(method);
      }
    }
  }
  function getPathname(req) {
    try {
      return parseUrl(req).pathname;
    } catch (err) {
      return;
    }
  }
  function getProtohost(url) {
    if (typeof url !== "string" || url.length === 0 || url[0] === "/") {
      return;
    }
    var searchIndex = url.indexOf("?");
    var pathLength = searchIndex !== -1 ? searchIndex : url.length;
    var fqdnIndex = url.substr(0, pathLength).indexOf("://");
    return fqdnIndex !== -1 ? url.substr(0, url.indexOf("/", 3 + fqdnIndex)) : undefined;
  }
  function gettype(obj) {
    var type = typeof obj;
    if (type !== "object") {
      return type;
    }
    return toString.call(obj).replace(objectRegExp, "$1");
  }
  function matchLayer(layer, path) {
    try {
      return layer.match(path);
    } catch (err) {
      return err;
    }
  }
  function mergeParams(params, parent) {
    if (typeof parent !== "object" || !parent) {
      return params;
    }
    var obj = mixin({}, parent);
    if (!(0 in params) || !(0 in parent)) {
      return mixin(obj, params);
    }
    var i = 0;
    var o = 0;
    while (i in params) {
      i++;
    }
    while (o in parent) {
      o++;
    }
    for (i--;i >= 0; i--) {
      params[i + o] = params[i];
      if (i < o) {
        delete params[i];
      }
    }
    return mixin(obj, params);
  }
  function restore(fn2, obj) {
    var props = new Array(arguments.length - 2);
    var vals = new Array(arguments.length - 2);
    for (var i = 0;i < props.length; i++) {
      props[i] = arguments[i + 2];
      vals[i] = obj[props[i]];
    }
    return function() {
      for (var i2 = 0;i2 < props.length; i2++) {
        obj[props[i2]] = vals[i2];
      }
      return fn2.apply(this, arguments);
    };
  }
  function sendOptionsResponse(res, options, next) {
    try {
      var body = options.join(",");
      res.set("Allow", body);
      res.send(body);
    } catch (err) {
      next(err);
    }
  }
  function wrap(old, fn2) {
    return function proxy() {
      var args2 = new Array(arguments.length + 1);
      args2[0] = old;
      for (var i = 0, len = arguments.length;i < len; i++) {
        args2[i + 1] = arguments[i];
      }
      fn2.apply(this, args2);
    };
  }
});

// node_modules/express/lib/middleware/init.js
var require_init = __commonJS((exports) => {
  /*!
   * express
   * Copyright(c) 2009-2013 TJ Holowaychuk
   * Copyright(c) 2013 Roman Shtylman
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  var setPrototypeOf = require_setprototypeof();
  exports.init = function(app) {
    return function expressInit(req, res, next) {
      if (app.enabled("x-powered-by"))
        res.setHeader("X-Powered-By", "Express");
      req.res = res;
      res.req = req;
      req.next = next;
      setPrototypeOf(req, app.request);
      setPrototypeOf(res, app.response);
      res.locals = res.locals || Object.create(null);
      next();
    };
  };
});

// node_modules/express/lib/middleware/query.js
var require_query = __commonJS((exports, module) => {
  /*!
   * express
   * Copyright(c) 2009-2013 TJ Holowaychuk
   * Copyright(c) 2013 Roman Shtylman
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  var merge = require_utils_merge();
  var parseUrl = require_parseurl();
  var qs = require_lib2();
  module.exports = function query(options) {
    var opts = merge({}, options);
    var queryparse = qs.parse;
    if (typeof options === "function") {
      queryparse = options;
      opts = undefined;
    }
    if (opts !== undefined && opts.allowPrototypes === undefined) {
      opts.allowPrototypes = true;
    }
    return function query(req, res, next) {
      if (!req.query) {
        var val = parseUrl(req).query;
        req.query = queryparse(val, opts);
      }
      next();
    };
  };
});

// node_modules/express/lib/view.js
var require_view = __commonJS((exports, module) => {
  /*!
   * express
   * Copyright(c) 2009-2013 TJ Holowaychuk
   * Copyright(c) 2013 Roman Shtylman
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  var debug = require_src3()("express:view");
  var path = __require("path");
  var fs = __require("fs");
  var dirname = path.dirname;
  var basename = path.basename;
  var extname = path.extname;
  var join = path.join;
  var resolve = path.resolve;
  module.exports = View;
  function View(name, options) {
    var opts = options || {};
    this.defaultEngine = opts.defaultEngine;
    this.ext = extname(name);
    this.name = name;
    this.root = opts.root;
    if (!this.ext && !this.defaultEngine) {
      throw new Error("No default engine was specified and no extension was provided.");
    }
    var fileName = name;
    if (!this.ext) {
      this.ext = this.defaultEngine[0] !== "." ? "." + this.defaultEngine : this.defaultEngine;
      fileName += this.ext;
    }
    if (!opts.engines[this.ext]) {
      var mod2 = this.ext.substr(1);
      debug('require "%s"', mod2);
      var fn2 = __require(mod2).__express;
      if (typeof fn2 !== "function") {
        throw new Error('Module "' + mod2 + '" does not provide a view engine.');
      }
      opts.engines[this.ext] = fn2;
    }
    this.engine = opts.engines[this.ext];
    this.path = this.lookup(fileName);
  }
  View.prototype.lookup = function lookup(name) {
    var path2;
    var roots = [].concat(this.root);
    debug('lookup "%s"', name);
    for (var i = 0;i < roots.length && !path2; i++) {
      var root = roots[i];
      var loc = resolve(root, name);
      var dir = dirname(loc);
      var file = basename(loc);
      path2 = this.resolve(dir, file);
    }
    return path2;
  };
  View.prototype.render = function render(options, callback) {
    debug('render "%s"', this.path);
    this.engine(this.path, options, callback);
  };
  View.prototype.resolve = function resolve(dir, file) {
    var ext = this.ext;
    var path2 = join(dir, file);
    var stat = tryStat(path2);
    if (stat && stat.isFile()) {
      return path2;
    }
    path2 = join(dir, basename(file, ext), "index" + ext);
    stat = tryStat(path2);
    if (stat && stat.isFile()) {
      return path2;
    }
  };
  function tryStat(path2) {
    debug('stat "%s"', path2);
    try {
      return fs.statSync(path2);
    } catch (e) {
      return;
    }
  }
});

// node_modules/express/node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS((exports, module) => {
  var buffer = __require("buffer");
  var Buffer2 = buffer.Buffer;
  function copyProps(src, dst) {
    for (var key in src) {
      dst[key] = src[key];
    }
  }
  if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
    module.exports = buffer;
  } else {
    copyProps(buffer, exports);
    exports.Buffer = SafeBuffer;
  }
  function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer2(arg, encodingOrOffset, length);
  }
  copyProps(Buffer2, SafeBuffer);
  SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      throw new TypeError("Argument must not be a number");
    }
    return Buffer2(arg, encodingOrOffset, length);
  };
  SafeBuffer.alloc = function(size, fill, encoding) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    var buf = Buffer2(size);
    if (fill !== undefined) {
      if (typeof encoding === "string") {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
    } else {
      buf.fill(0);
    }
    return buf;
  };
  SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return Buffer2(size);
  };
  SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return buffer.SlowBuffer(size);
  };
});

// node_modules/content-disposition/node_modules/safe-buffer/index.js
var require_safe_buffer2 = __commonJS((exports, module) => {
  var buffer = __require("buffer");
  var Buffer2 = buffer.Buffer;
  function copyProps(src, dst) {
    for (var key in src) {
      dst[key] = src[key];
    }
  }
  if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
    module.exports = buffer;
  } else {
    copyProps(buffer, exports);
    exports.Buffer = SafeBuffer;
  }
  function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer2(arg, encodingOrOffset, length);
  }
  copyProps(Buffer2, SafeBuffer);
  SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      throw new TypeError("Argument must not be a number");
    }
    return Buffer2(arg, encodingOrOffset, length);
  };
  SafeBuffer.alloc = function(size, fill, encoding) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    var buf = Buffer2(size);
    if (fill !== undefined) {
      if (typeof encoding === "string") {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
    } else {
      buf.fill(0);
    }
    return buf;
  };
  SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return Buffer2(size);
  };
  SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return buffer.SlowBuffer(size);
  };
});

// node_modules/content-disposition/index.js
var require_content_disposition = __commonJS((exports, module) => {
  /*!
   * content-disposition
   * Copyright(c) 2014-2017 Douglas Christopher Wilson
   * MIT Licensed
   */
  module.exports = contentDisposition;
  module.exports.parse = parse;
  var basename = __require("path").basename;
  var Buffer2 = require_safe_buffer2().Buffer;
  var ENCODE_URL_ATTR_CHAR_REGEXP = /[\x00-\x20"'()*,/:;<=>?@[\\\]{}\x7f]/g;
  var HEX_ESCAPE_REGEXP = /%[0-9A-Fa-f]{2}/;
  var HEX_ESCAPE_REPLACE_REGEXP = /%([0-9A-Fa-f]{2})/g;
  var NON_LATIN1_REGEXP = /[^\x20-\x7e\xa0-\xff]/g;
  var QESC_REGEXP = /\\([\u0000-\u007f])/g;
  var QUOTE_REGEXP = /([\\"])/g;
  var PARAM_REGEXP = /;[\x09\x20]*([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*=[\x09\x20]*("(?:[\x20!\x23-\x5b\x5d-\x7e\x80-\xff]|\\[\x20-\x7e])*"|[!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*/g;
  var TEXT_REGEXP = /^[\x20-\x7e\x80-\xff]+$/;
  var TOKEN_REGEXP = /^[!#$%&'*+.0-9A-Z^_`a-z|~-]+$/;
  var EXT_VALUE_REGEXP = /^([A-Za-z0-9!#$%&+\-^_`{}~]+)'(?:[A-Za-z]{2,3}(?:-[A-Za-z]{3}){0,3}|[A-Za-z]{4,8}|)'((?:%[0-9A-Fa-f]{2}|[A-Za-z0-9!#$&+.^_`|~-])+)$/;
  var DISPOSITION_TYPE_REGEXP = /^([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*(?:$|;)/;
  function contentDisposition(filename, options) {
    var opts = options || {};
    var type = opts.type || "attachment";
    var params = createparams(filename, opts.fallback);
    return format(new ContentDisposition(type, params));
  }
  function createparams(filename, fallback) {
    if (filename === undefined) {
      return;
    }
    var params = {};
    if (typeof filename !== "string") {
      throw new TypeError("filename must be a string");
    }
    if (fallback === undefined) {
      fallback = true;
    }
    if (typeof fallback !== "string" && typeof fallback !== "boolean") {
      throw new TypeError("fallback must be a string or boolean");
    }
    if (typeof fallback === "string" && NON_LATIN1_REGEXP.test(fallback)) {
      throw new TypeError("fallback must be ISO-8859-1 string");
    }
    var name = basename(filename);
    var isQuotedString = TEXT_REGEXP.test(name);
    var fallbackName = typeof fallback !== "string" ? fallback && getlatin1(name) : basename(fallback);
    var hasFallback = typeof fallbackName === "string" && fallbackName !== name;
    if (hasFallback || !isQuotedString || HEX_ESCAPE_REGEXP.test(name)) {
      params["filename*"] = name;
    }
    if (isQuotedString || hasFallback) {
      params.filename = hasFallback ? fallbackName : name;
    }
    return params;
  }
  function format(obj) {
    var parameters = obj.parameters;
    var type = obj.type;
    if (!type || typeof type !== "string" || !TOKEN_REGEXP.test(type)) {
      throw new TypeError("invalid type");
    }
    var string = String(type).toLowerCase();
    if (parameters && typeof parameters === "object") {
      var param;
      var params = Object.keys(parameters).sort();
      for (var i = 0;i < params.length; i++) {
        param = params[i];
        var val = param.substr(-1) === "*" ? ustring(parameters[param]) : qstring(parameters[param]);
        string += "; " + param + "=" + val;
      }
    }
    return string;
  }
  function decodefield(str) {
    var match = EXT_VALUE_REGEXP.exec(str);
    if (!match) {
      throw new TypeError("invalid extended field value");
    }
    var charset = match[1].toLowerCase();
    var encoded = match[2];
    var value;
    var binary = encoded.replace(HEX_ESCAPE_REPLACE_REGEXP, pdecode);
    switch (charset) {
      case "iso-8859-1":
        value = getlatin1(binary);
        break;
      case "utf-8":
        value = Buffer2.from(binary, "binary").toString("utf8");
        break;
      default:
        throw new TypeError("unsupported charset in extended field");
    }
    return value;
  }
  function getlatin1(val) {
    return String(val).replace(NON_LATIN1_REGEXP, "?");
  }
  function parse(string) {
    if (!string || typeof string !== "string") {
      throw new TypeError("argument string is required");
    }
    var match = DISPOSITION_TYPE_REGEXP.exec(string);
    if (!match) {
      throw new TypeError("invalid type format");
    }
    var index = match[0].length;
    var type = match[1].toLowerCase();
    var key;
    var names = [];
    var params = {};
    var value;
    index = PARAM_REGEXP.lastIndex = match[0].substr(-1) === ";" ? index - 1 : index;
    while (match = PARAM_REGEXP.exec(string)) {
      if (match.index !== index) {
        throw new TypeError("invalid parameter format");
      }
      index += match[0].length;
      key = match[1].toLowerCase();
      value = match[2];
      if (names.indexOf(key) !== -1) {
        throw new TypeError("invalid duplicate parameter");
      }
      names.push(key);
      if (key.indexOf("*") + 1 === key.length) {
        key = key.slice(0, -1);
        value = decodefield(value);
        params[key] = value;
        continue;
      }
      if (typeof params[key] === "string") {
        continue;
      }
      if (value[0] === '"') {
        value = value.substr(1, value.length - 2).replace(QESC_REGEXP, "$1");
      }
      params[key] = value;
    }
    if (index !== -1 && index !== string.length) {
      throw new TypeError("invalid parameter format");
    }
    return new ContentDisposition(type, params);
  }
  function pdecode(str, hex) {
    return String.fromCharCode(parseInt(hex, 16));
  }
  function pencode(char) {
    return "%" + String(char).charCodeAt(0).toString(16).toUpperCase();
  }
  function qstring(val) {
    var str = String(val);
    return '"' + str.replace(QUOTE_REGEXP, "\\$1") + '"';
  }
  function ustring(val) {
    var str = String(val);
    var encoded = encodeURIComponent(str).replace(ENCODE_URL_ATTR_CHAR_REGEXP, pencode);
    return "UTF-8''" + encoded;
  }
  function ContentDisposition(type, parameters) {
    this.type = type;
    this.parameters = parameters;
  }
});

// node_modules/send/node_modules/debug/node_modules/ms/index.js
var require_ms4 = __commonJS((exports, module) => {
  var s = 1000;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var y = d * 365.25;
  module.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse(val);
    } else if (type === "number" && isNaN(val) === false) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
  function parse(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return;
    }
  }
  function fmtShort(ms) {
    if (ms >= d) {
      return Math.round(ms / d) + "d";
    }
    if (ms >= h) {
      return Math.round(ms / h) + "h";
    }
    if (ms >= m) {
      return Math.round(ms / m) + "m";
    }
    if (ms >= s) {
      return Math.round(ms / s) + "s";
    }
    return ms + "ms";
  }
  function fmtLong(ms) {
    return plural(ms, d, "day") || plural(ms, h, "hour") || plural(ms, m, "minute") || plural(ms, s, "second") || ms + " ms";
  }
  function plural(ms, n, name) {
    if (ms < n) {
      return;
    }
    if (ms < n * 1.5) {
      return Math.floor(ms / n) + " " + name;
    }
    return Math.ceil(ms / n) + " " + name + "s";
  }
});

// node_modules/send/node_modules/debug/src/debug.js
var require_debug4 = __commonJS((exports, module) => {
  exports = module.exports = createDebug.debug = createDebug["default"] = createDebug;
  exports.coerce = coerce;
  exports.disable = disable;
  exports.enable = enable;
  exports.enabled = enabled;
  exports.humanize = require_ms4();
  exports.names = [];
  exports.skips = [];
  exports.formatters = {};
  var prevTime;
  function selectColor(namespace) {
    var hash = 0, i;
    for (i in namespace) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i);
      hash |= 0;
    }
    return exports.colors[Math.abs(hash) % exports.colors.length];
  }
  function createDebug(namespace) {
    function debug() {
      if (!debug.enabled)
        return;
      var self2 = debug;
      var curr = +new Date;
      var ms = curr - (prevTime || curr);
      self2.diff = ms;
      self2.prev = prevTime;
      self2.curr = curr;
      prevTime = curr;
      var args2 = new Array(arguments.length);
      for (var i = 0;i < args2.length; i++) {
        args2[i] = arguments[i];
      }
      args2[0] = exports.coerce(args2[0]);
      if (typeof args2[0] !== "string") {
        args2.unshift("%O");
      }
      var index = 0;
      args2[0] = args2[0].replace(/%([a-zA-Z%])/g, function(match, format) {
        if (match === "%%")
          return match;
        index++;
        var formatter = exports.formatters[format];
        if (typeof formatter === "function") {
          var val = args2[index];
          match = formatter.call(self2, val);
          args2.splice(index, 1);
          index--;
        }
        return match;
      });
      exports.formatArgs.call(self2, args2);
      var logFn = debug.log || exports.log || console.log.bind(console);
      logFn.apply(self2, args2);
    }
    debug.namespace = namespace;
    debug.enabled = exports.enabled(namespace);
    debug.useColors = exports.useColors();
    debug.color = selectColor(namespace);
    if (typeof exports.init === "function") {
      exports.init(debug);
    }
    return debug;
  }
  function enable(namespaces) {
    exports.save(namespaces);
    exports.names = [];
    exports.skips = [];
    var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
    var len = split.length;
    for (var i = 0;i < len; i++) {
      if (!split[i])
        continue;
      namespaces = split[i].replace(/\*/g, ".*?");
      if (namespaces[0] === "-") {
        exports.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
      } else {
        exports.names.push(new RegExp("^" + namespaces + "$"));
      }
    }
  }
  function disable() {
    exports.enable("");
  }
  function enabled(name) {
    var i, len;
    for (i = 0, len = exports.skips.length;i < len; i++) {
      if (exports.skips[i].test(name)) {
        return false;
      }
    }
    for (i = 0, len = exports.names.length;i < len; i++) {
      if (exports.names[i].test(name)) {
        return true;
      }
    }
    return false;
  }
  function coerce(val) {
    if (val instanceof Error)
      return val.stack || val.message;
    return val;
  }
});

// node_modules/send/node_modules/debug/src/browser.js
var require_browser4 = __commonJS((exports, module) => {
  exports = module.exports = require_debug4();
  exports.log = log;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = typeof chrome != "undefined" && typeof chrome.storage != "undefined" ? chrome.storage.local : localstorage();
  exports.colors = [
    "lightseagreen",
    "forestgreen",
    "goldenrod",
    "dodgerblue",
    "darkorchid",
    "crimson"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
      return true;
    }
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  exports.formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (err) {
      return "[UnexpectedJSONParseError]: " + err.message;
    }
  };
  function formatArgs(args2) {
    var useColors2 = this.useColors;
    args2[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args2[0] + (useColors2 ? "%c " : " ") + "+" + exports.humanize(this.diff);
    if (!useColors2)
      return;
    var c = "color: " + this.color;
    args2.splice(1, 0, c, "color: inherit");
    var index = 0;
    var lastC = 0;
    args2[0].replace(/%[a-zA-Z%]/g, function(match) {
      if (match === "%%")
        return;
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args2.splice(lastC, 0, c);
  }
  function log() {
    return typeof console === "object" && console.log && Function.prototype.apply.call(console.log, console, arguments);
  }
  function save(namespaces) {
    try {
      if (namespaces == null) {
        exports.storage.removeItem("debug");
      } else {
        exports.storage.debug = namespaces;
      }
    } catch (e) {}
  }
  function load() {
    var r;
    try {
      r = exports.storage.debug;
    } catch (e) {}
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = process.env.DEBUG;
    }
    return r;
  }
  exports.enable(load());
  function localstorage() {
    try {
      return window.localStorage;
    } catch (e) {}
  }
});

// node_modules/send/node_modules/debug/src/node.js
var require_node4 = __commonJS((exports, module) => {
  var tty = __require("tty");
  var util = __require("util");
  exports = module.exports = require_debug4();
  exports.init = init;
  exports.log = log;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.colors = [6, 2, 3, 4, 5, 1];
  exports.inspectOpts = Object.keys(process.env).filter(function(key) {
    return /^debug_/i.test(key);
  }).reduce(function(obj, key) {
    var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function(_, k) {
      return k.toUpperCase();
    });
    var val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val))
      val = true;
    else if (/^(no|off|false|disabled)$/i.test(val))
      val = false;
    else if (val === "null")
      val = null;
    else
      val = Number(val);
    obj[prop] = val;
    return obj;
  }, {});
  var fd = parseInt(process.env.DEBUG_FD, 10) || 2;
  if (fd !== 1 && fd !== 2) {
    util.deprecate(function() {}, "except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)")();
  }
  var stream = fd === 1 ? process.stdout : fd === 2 ? process.stderr : createWritableStdioStream(fd);
  function useColors() {
    return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(fd);
  }
  exports.formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts).split(`
`).map(function(str) {
      return str.trim();
    }).join(" ");
  };
  exports.formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts);
  };
  function formatArgs(args2) {
    var name = this.namespace;
    var useColors2 = this.useColors;
    if (useColors2) {
      var c = this.color;
      var prefix = "  \x1B[3" + c + ";1m" + name + " " + "\x1B[0m";
      args2[0] = prefix + args2[0].split(`
`).join(`
` + prefix);
      args2.push("\x1B[3" + c + "m+" + exports.humanize(this.diff) + "\x1B[0m");
    } else {
      args2[0] = new Date().toUTCString() + " " + name + " " + args2[0];
    }
  }
  function log() {
    return stream.write(util.format.apply(util, arguments) + `
`);
  }
  function save(namespaces) {
    if (namespaces == null) {
      delete process.env.DEBUG;
    } else {
      process.env.DEBUG = namespaces;
    }
  }
  function load() {
    return process.env.DEBUG;
  }
  function createWritableStdioStream(fd2) {
    var stream2;
    var tty_wrap = process.binding("tty_wrap");
    switch (tty_wrap.guessHandleType(fd2)) {
      case "TTY":
        stream2 = new tty.WriteStream(fd2);
        stream2._type = "tty";
        if (stream2._handle && stream2._handle.unref) {
          stream2._handle.unref();
        }
        break;
      case "FILE":
        var fs = __require("fs");
        stream2 = new fs.SyncWriteStream(fd2, { autoClose: false });
        stream2._type = "fs";
        break;
      case "PIPE":
      case "TCP":
        var net = __require("net");
        stream2 = new net.Socket({
          fd: fd2,
          readable: false,
          writable: true
        });
        stream2.readable = false;
        stream2.read = null;
        stream2._type = "pipe";
        if (stream2._handle && stream2._handle.unref) {
          stream2._handle.unref();
        }
        break;
      default:
        throw new Error("Implement me. Unknown stream file type!");
    }
    stream2.fd = fd2;
    stream2._isStdio = true;
    return stream2;
  }
  function init(debug) {
    debug.inspectOpts = {};
    var keys = Object.keys(exports.inspectOpts);
    for (var i = 0;i < keys.length; i++) {
      debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
    }
  }
  exports.enable(load());
});

// node_modules/send/node_modules/debug/src/index.js
var require_src4 = __commonJS((exports, module) => {
  if (typeof process !== "undefined" && process.type === "renderer") {
    module.exports = require_browser4();
  } else {
    module.exports = require_node4();
  }
});

// node_modules/destroy/index.js
var require_destroy = __commonJS((exports, module) => {
  /*!
   * destroy
   * Copyright(c) 2014 Jonathan Ong
   * MIT Licensed
   */
  var ReadStream = __require("fs").ReadStream;
  var Stream = __require("stream");
  module.exports = destroy;
  function destroy(stream) {
    if (stream instanceof ReadStream) {
      return destroyReadStream(stream);
    }
    if (!(stream instanceof Stream)) {
      return stream;
    }
    if (typeof stream.destroy === "function") {
      stream.destroy();
    }
    return stream;
  }
  function destroyReadStream(stream) {
    stream.destroy();
    if (typeof stream.close === "function") {
      stream.on("open", onOpenClose);
    }
    return stream;
  }
  function onOpenClose() {
    if (typeof this.fd === "number") {
      this.close();
    }
  }
});

// node_modules/etag/index.js
var require_etag = __commonJS((exports, module) => {
  /*!
   * etag
   * Copyright(c) 2014-2016 Douglas Christopher Wilson
   * MIT Licensed
   */
  module.exports = etag;
  var crypto = __require("crypto");
  var Stats = __require("fs").Stats;
  var toString = Object.prototype.toString;
  function entitytag(entity) {
    if (entity.length === 0) {
      return '"0-2jmj7l5rSw0yVb/vlWAYkK/YBwk"';
    }
    var hash = crypto.createHash("sha1").update(entity, "utf8").digest("base64").substring(0, 27);
    var len = typeof entity === "string" ? Buffer.byteLength(entity, "utf8") : entity.length;
    return '"' + len.toString(16) + "-" + hash + '"';
  }
  function etag(entity, options) {
    if (entity == null) {
      throw new TypeError("argument entity is required");
    }
    var isStats = isstats(entity);
    var weak = options && typeof options.weak === "boolean" ? options.weak : isStats;
    if (!isStats && typeof entity !== "string" && !Buffer.isBuffer(entity)) {
      throw new TypeError("argument entity must be string, Buffer, or fs.Stats");
    }
    var tag = isStats ? stattag(entity) : entitytag(entity);
    return weak ? "W/" + tag : tag;
  }
  function isstats(obj) {
    if (typeof Stats === "function" && obj instanceof Stats) {
      return true;
    }
    return obj && typeof obj === "object" && "ctime" in obj && toString.call(obj.ctime) === "[object Date]" && "mtime" in obj && toString.call(obj.mtime) === "[object Date]" && "ino" in obj && typeof obj.ino === "number" && "size" in obj && typeof obj.size === "number";
  }
  function stattag(stat) {
    var mtime = stat.mtime.getTime().toString(16);
    var size = stat.size.toString(16);
    return '"' + size + "-" + mtime + '"';
  }
});

// node_modules/fresh/index.js
var require_fresh = __commonJS((exports, module) => {
  /*!
   * fresh
   * Copyright(c) 2012 TJ Holowaychuk
   * Copyright(c) 2016-2017 Douglas Christopher Wilson
   * MIT Licensed
   */
  var CACHE_CONTROL_NO_CACHE_REGEXP = /(?:^|,)\s*?no-cache\s*?(?:,|$)/;
  module.exports = fresh;
  function fresh(reqHeaders, resHeaders) {
    var modifiedSince = reqHeaders["if-modified-since"];
    var noneMatch = reqHeaders["if-none-match"];
    if (!modifiedSince && !noneMatch) {
      return false;
    }
    var cacheControl = reqHeaders["cache-control"];
    if (cacheControl && CACHE_CONTROL_NO_CACHE_REGEXP.test(cacheControl)) {
      return false;
    }
    if (noneMatch && noneMatch !== "*") {
      var etag = resHeaders["etag"];
      if (!etag) {
        return false;
      }
      var etagStale = true;
      var matches = parseTokenList(noneMatch);
      for (var i = 0;i < matches.length; i++) {
        var match = matches[i];
        if (match === etag || match === "W/" + etag || "W/" + match === etag) {
          etagStale = false;
          break;
        }
      }
      if (etagStale) {
        return false;
      }
    }
    if (modifiedSince) {
      var lastModified = resHeaders["last-modified"];
      var modifiedStale = !lastModified || !(parseHttpDate(lastModified) <= parseHttpDate(modifiedSince));
      if (modifiedStale) {
        return false;
      }
    }
    return true;
  }
  function parseHttpDate(date) {
    var timestamp = date && Date.parse(date);
    return typeof timestamp === "number" ? timestamp : NaN;
  }
  function parseTokenList(str) {
    var end = 0;
    var list = [];
    var start = 0;
    for (var i = 0, len = str.length;i < len; i++) {
      switch (str.charCodeAt(i)) {
        case 32:
          if (start === end) {
            start = end = i + 1;
          }
          break;
        case 44:
          list.push(str.substring(start, end));
          start = end = i + 1;
          break;
        default:
          end = i + 1;
          break;
      }
    }
    list.push(str.substring(start, end));
    return list;
  }
});

// node_modules/mime/types.json
var require_types = __commonJS((exports, module) => {
  module.exports = { "application/andrew-inset": ["ez"], "application/applixware": ["aw"], "application/atom+xml": ["atom"], "application/atomcat+xml": ["atomcat"], "application/atomsvc+xml": ["atomsvc"], "application/bdoc": ["bdoc"], "application/ccxml+xml": ["ccxml"], "application/cdmi-capability": ["cdmia"], "application/cdmi-container": ["cdmic"], "application/cdmi-domain": ["cdmid"], "application/cdmi-object": ["cdmio"], "application/cdmi-queue": ["cdmiq"], "application/cu-seeme": ["cu"], "application/dash+xml": ["mpd"], "application/davmount+xml": ["davmount"], "application/docbook+xml": ["dbk"], "application/dssc+der": ["dssc"], "application/dssc+xml": ["xdssc"], "application/ecmascript": ["ecma"], "application/emma+xml": ["emma"], "application/epub+zip": ["epub"], "application/exi": ["exi"], "application/font-tdpfr": ["pfr"], "application/font-woff": [], "application/font-woff2": [], "application/geo+json": ["geojson"], "application/gml+xml": ["gml"], "application/gpx+xml": ["gpx"], "application/gxf": ["gxf"], "application/gzip": ["gz"], "application/hyperstudio": ["stk"], "application/inkml+xml": ["ink", "inkml"], "application/ipfix": ["ipfix"], "application/java-archive": ["jar", "war", "ear"], "application/java-serialized-object": ["ser"], "application/java-vm": ["class"], "application/javascript": ["js", "mjs"], "application/json": ["json", "map"], "application/json5": ["json5"], "application/jsonml+json": ["jsonml"], "application/ld+json": ["jsonld"], "application/lost+xml": ["lostxml"], "application/mac-binhex40": ["hqx"], "application/mac-compactpro": ["cpt"], "application/mads+xml": ["mads"], "application/manifest+json": ["webmanifest"], "application/marc": ["mrc"], "application/marcxml+xml": ["mrcx"], "application/mathematica": ["ma", "nb", "mb"], "application/mathml+xml": ["mathml"], "application/mbox": ["mbox"], "application/mediaservercontrol+xml": ["mscml"], "application/metalink+xml": ["metalink"], "application/metalink4+xml": ["meta4"], "application/mets+xml": ["mets"], "application/mods+xml": ["mods"], "application/mp21": ["m21", "mp21"], "application/mp4": ["mp4s", "m4p"], "application/msword": ["doc", "dot"], "application/mxf": ["mxf"], "application/octet-stream": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"], "application/oda": ["oda"], "application/oebps-package+xml": ["opf"], "application/ogg": ["ogx"], "application/omdoc+xml": ["omdoc"], "application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"], "application/oxps": ["oxps"], "application/patch-ops-error+xml": ["xer"], "application/pdf": ["pdf"], "application/pgp-encrypted": ["pgp"], "application/pgp-signature": ["asc", "sig"], "application/pics-rules": ["prf"], "application/pkcs10": ["p10"], "application/pkcs7-mime": ["p7m", "p7c"], "application/pkcs7-signature": ["p7s"], "application/pkcs8": ["p8"], "application/pkix-attr-cert": ["ac"], "application/pkix-cert": ["cer"], "application/pkix-crl": ["crl"], "application/pkix-pkipath": ["pkipath"], "application/pkixcmp": ["pki"], "application/pls+xml": ["pls"], "application/postscript": ["ai", "eps", "ps"], "application/prs.cww": ["cww"], "application/pskc+xml": ["pskcxml"], "application/raml+yaml": ["raml"], "application/rdf+xml": ["rdf"], "application/reginfo+xml": ["rif"], "application/relax-ng-compact-syntax": ["rnc"], "application/resource-lists+xml": ["rl"], "application/resource-lists-diff+xml": ["rld"], "application/rls-services+xml": ["rs"], "application/rpki-ghostbusters": ["gbr"], "application/rpki-manifest": ["mft"], "application/rpki-roa": ["roa"], "application/rsd+xml": ["rsd"], "application/rss+xml": ["rss"], "application/rtf": ["rtf"], "application/sbml+xml": ["sbml"], "application/scvp-cv-request": ["scq"], "application/scvp-cv-response": ["scs"], "application/scvp-vp-request": ["spq"], "application/scvp-vp-response": ["spp"], "application/sdp": ["sdp"], "application/set-payment-initiation": ["setpay"], "application/set-registration-initiation": ["setreg"], "application/shf+xml": ["shf"], "application/smil+xml": ["smi", "smil"], "application/sparql-query": ["rq"], "application/sparql-results+xml": ["srx"], "application/srgs": ["gram"], "application/srgs+xml": ["grxml"], "application/sru+xml": ["sru"], "application/ssdl+xml": ["ssdl"], "application/ssml+xml": ["ssml"], "application/tei+xml": ["tei", "teicorpus"], "application/thraud+xml": ["tfi"], "application/timestamped-data": ["tsd"], "application/vnd.3gpp.pic-bw-large": ["plb"], "application/vnd.3gpp.pic-bw-small": ["psb"], "application/vnd.3gpp.pic-bw-var": ["pvb"], "application/vnd.3gpp2.tcap": ["tcap"], "application/vnd.3m.post-it-notes": ["pwn"], "application/vnd.accpac.simply.aso": ["aso"], "application/vnd.accpac.simply.imp": ["imp"], "application/vnd.acucobol": ["acu"], "application/vnd.acucorp": ["atc", "acutc"], "application/vnd.adobe.air-application-installer-package+zip": ["air"], "application/vnd.adobe.formscentral.fcdt": ["fcdt"], "application/vnd.adobe.fxp": ["fxp", "fxpl"], "application/vnd.adobe.xdp+xml": ["xdp"], "application/vnd.adobe.xfdf": ["xfdf"], "application/vnd.ahead.space": ["ahead"], "application/vnd.airzip.filesecure.azf": ["azf"], "application/vnd.airzip.filesecure.azs": ["azs"], "application/vnd.amazon.ebook": ["azw"], "application/vnd.americandynamics.acc": ["acc"], "application/vnd.amiga.ami": ["ami"], "application/vnd.android.package-archive": ["apk"], "application/vnd.anser-web-certificate-issue-initiation": ["cii"], "application/vnd.anser-web-funds-transfer-initiation": ["fti"], "application/vnd.antix.game-component": ["atx"], "application/vnd.apple.installer+xml": ["mpkg"], "application/vnd.apple.mpegurl": ["m3u8"], "application/vnd.apple.pkpass": ["pkpass"], "application/vnd.aristanetworks.swi": ["swi"], "application/vnd.astraea-software.iota": ["iota"], "application/vnd.audiograph": ["aep"], "application/vnd.blueice.multipass": ["mpm"], "application/vnd.bmi": ["bmi"], "application/vnd.businessobjects": ["rep"], "application/vnd.chemdraw+xml": ["cdxml"], "application/vnd.chipnuts.karaoke-mmd": ["mmd"], "application/vnd.cinderella": ["cdy"], "application/vnd.claymore": ["cla"], "application/vnd.cloanto.rp9": ["rp9"], "application/vnd.clonk.c4group": ["c4g", "c4d", "c4f", "c4p", "c4u"], "application/vnd.cluetrust.cartomobile-config": ["c11amc"], "application/vnd.cluetrust.cartomobile-config-pkg": ["c11amz"], "application/vnd.commonspace": ["csp"], "application/vnd.contact.cmsg": ["cdbcmsg"], "application/vnd.cosmocaller": ["cmc"], "application/vnd.crick.clicker": ["clkx"], "application/vnd.crick.clicker.keyboard": ["clkk"], "application/vnd.crick.clicker.palette": ["clkp"], "application/vnd.crick.clicker.template": ["clkt"], "application/vnd.crick.clicker.wordbank": ["clkw"], "application/vnd.criticaltools.wbs+xml": ["wbs"], "application/vnd.ctc-posml": ["pml"], "application/vnd.cups-ppd": ["ppd"], "application/vnd.curl.car": ["car"], "application/vnd.curl.pcurl": ["pcurl"], "application/vnd.dart": ["dart"], "application/vnd.data-vision.rdz": ["rdz"], "application/vnd.dece.data": ["uvf", "uvvf", "uvd", "uvvd"], "application/vnd.dece.ttml+xml": ["uvt", "uvvt"], "application/vnd.dece.unspecified": ["uvx", "uvvx"], "application/vnd.dece.zip": ["uvz", "uvvz"], "application/vnd.denovo.fcselayout-link": ["fe_launch"], "application/vnd.dna": ["dna"], "application/vnd.dolby.mlp": ["mlp"], "application/vnd.dpgraph": ["dpg"], "application/vnd.dreamfactory": ["dfac"], "application/vnd.ds-keypoint": ["kpxx"], "application/vnd.dvb.ait": ["ait"], "application/vnd.dvb.service": ["svc"], "application/vnd.dynageo": ["geo"], "application/vnd.ecowin.chart": ["mag"], "application/vnd.enliven": ["nml"], "application/vnd.epson.esf": ["esf"], "application/vnd.epson.msf": ["msf"], "application/vnd.epson.quickanime": ["qam"], "application/vnd.epson.salt": ["slt"], "application/vnd.epson.ssf": ["ssf"], "application/vnd.eszigno3+xml": ["es3", "et3"], "application/vnd.ezpix-album": ["ez2"], "application/vnd.ezpix-package": ["ez3"], "application/vnd.fdf": ["fdf"], "application/vnd.fdsn.mseed": ["mseed"], "application/vnd.fdsn.seed": ["seed", "dataless"], "application/vnd.flographit": ["gph"], "application/vnd.fluxtime.clip": ["ftc"], "application/vnd.framemaker": ["fm", "frame", "maker", "book"], "application/vnd.frogans.fnc": ["fnc"], "application/vnd.frogans.ltf": ["ltf"], "application/vnd.fsc.weblaunch": ["fsc"], "application/vnd.fujitsu.oasys": ["oas"], "application/vnd.fujitsu.oasys2": ["oa2"], "application/vnd.fujitsu.oasys3": ["oa3"], "application/vnd.fujitsu.oasysgp": ["fg5"], "application/vnd.fujitsu.oasysprs": ["bh2"], "application/vnd.fujixerox.ddd": ["ddd"], "application/vnd.fujixerox.docuworks": ["xdw"], "application/vnd.fujixerox.docuworks.binder": ["xbd"], "application/vnd.fuzzysheet": ["fzs"], "application/vnd.genomatix.tuxedo": ["txd"], "application/vnd.geogebra.file": ["ggb"], "application/vnd.geogebra.tool": ["ggt"], "application/vnd.geometry-explorer": ["gex", "gre"], "application/vnd.geonext": ["gxt"], "application/vnd.geoplan": ["g2w"], "application/vnd.geospace": ["g3w"], "application/vnd.gmx": ["gmx"], "application/vnd.google-apps.document": ["gdoc"], "application/vnd.google-apps.presentation": ["gslides"], "application/vnd.google-apps.spreadsheet": ["gsheet"], "application/vnd.google-earth.kml+xml": ["kml"], "application/vnd.google-earth.kmz": ["kmz"], "application/vnd.grafeq": ["gqf", "gqs"], "application/vnd.groove-account": ["gac"], "application/vnd.groove-help": ["ghf"], "application/vnd.groove-identity-message": ["gim"], "application/vnd.groove-injector": ["grv"], "application/vnd.groove-tool-message": ["gtm"], "application/vnd.groove-tool-template": ["tpl"], "application/vnd.groove-vcard": ["vcg"], "application/vnd.hal+xml": ["hal"], "application/vnd.handheld-entertainment+xml": ["zmm"], "application/vnd.hbci": ["hbci"], "application/vnd.hhe.lesson-player": ["les"], "application/vnd.hp-hpgl": ["hpgl"], "application/vnd.hp-hpid": ["hpid"], "application/vnd.hp-hps": ["hps"], "application/vnd.hp-jlyt": ["jlt"], "application/vnd.hp-pcl": ["pcl"], "application/vnd.hp-pclxl": ["pclxl"], "application/vnd.hydrostatix.sof-data": ["sfd-hdstx"], "application/vnd.ibm.minipay": ["mpy"], "application/vnd.ibm.modcap": ["afp", "listafp", "list3820"], "application/vnd.ibm.rights-management": ["irm"], "application/vnd.ibm.secure-container": ["sc"], "application/vnd.iccprofile": ["icc", "icm"], "application/vnd.igloader": ["igl"], "application/vnd.immervision-ivp": ["ivp"], "application/vnd.immervision-ivu": ["ivu"], "application/vnd.insors.igm": ["igm"], "application/vnd.intercon.formnet": ["xpw", "xpx"], "application/vnd.intergeo": ["i2g"], "application/vnd.intu.qbo": ["qbo"], "application/vnd.intu.qfx": ["qfx"], "application/vnd.ipunplugged.rcprofile": ["rcprofile"], "application/vnd.irepository.package+xml": ["irp"], "application/vnd.is-xpr": ["xpr"], "application/vnd.isac.fcs": ["fcs"], "application/vnd.jam": ["jam"], "application/vnd.jcp.javame.midlet-rms": ["rms"], "application/vnd.jisp": ["jisp"], "application/vnd.joost.joda-archive": ["joda"], "application/vnd.kahootz": ["ktz", "ktr"], "application/vnd.kde.karbon": ["karbon"], "application/vnd.kde.kchart": ["chrt"], "application/vnd.kde.kformula": ["kfo"], "application/vnd.kde.kivio": ["flw"], "application/vnd.kde.kontour": ["kon"], "application/vnd.kde.kpresenter": ["kpr", "kpt"], "application/vnd.kde.kspread": ["ksp"], "application/vnd.kde.kword": ["kwd", "kwt"], "application/vnd.kenameaapp": ["htke"], "application/vnd.kidspiration": ["kia"], "application/vnd.kinar": ["kne", "knp"], "application/vnd.koan": ["skp", "skd", "skt", "skm"], "application/vnd.kodak-descriptor": ["sse"], "application/vnd.las.las+xml": ["lasxml"], "application/vnd.llamagraphics.life-balance.desktop": ["lbd"], "application/vnd.llamagraphics.life-balance.exchange+xml": ["lbe"], "application/vnd.lotus-1-2-3": ["123"], "application/vnd.lotus-approach": ["apr"], "application/vnd.lotus-freelance": ["pre"], "application/vnd.lotus-notes": ["nsf"], "application/vnd.lotus-organizer": ["org"], "application/vnd.lotus-screencam": ["scm"], "application/vnd.lotus-wordpro": ["lwp"], "application/vnd.macports.portpkg": ["portpkg"], "application/vnd.mcd": ["mcd"], "application/vnd.medcalcdata": ["mc1"], "application/vnd.mediastation.cdkey": ["cdkey"], "application/vnd.mfer": ["mwf"], "application/vnd.mfmp": ["mfm"], "application/vnd.micrografx.flo": ["flo"], "application/vnd.micrografx.igx": ["igx"], "application/vnd.mif": ["mif"], "application/vnd.mobius.daf": ["daf"], "application/vnd.mobius.dis": ["dis"], "application/vnd.mobius.mbk": ["mbk"], "application/vnd.mobius.mqy": ["mqy"], "application/vnd.mobius.msl": ["msl"], "application/vnd.mobius.plc": ["plc"], "application/vnd.mobius.txf": ["txf"], "application/vnd.mophun.application": ["mpn"], "application/vnd.mophun.certificate": ["mpc"], "application/vnd.mozilla.xul+xml": ["xul"], "application/vnd.ms-artgalry": ["cil"], "application/vnd.ms-cab-compressed": ["cab"], "application/vnd.ms-excel": ["xls", "xlm", "xla", "xlc", "xlt", "xlw"], "application/vnd.ms-excel.addin.macroenabled.12": ["xlam"], "application/vnd.ms-excel.sheet.binary.macroenabled.12": ["xlsb"], "application/vnd.ms-excel.sheet.macroenabled.12": ["xlsm"], "application/vnd.ms-excel.template.macroenabled.12": ["xltm"], "application/vnd.ms-fontobject": ["eot"], "application/vnd.ms-htmlhelp": ["chm"], "application/vnd.ms-ims": ["ims"], "application/vnd.ms-lrm": ["lrm"], "application/vnd.ms-officetheme": ["thmx"], "application/vnd.ms-outlook": ["msg"], "application/vnd.ms-pki.seccat": ["cat"], "application/vnd.ms-pki.stl": ["stl"], "application/vnd.ms-powerpoint": ["ppt", "pps", "pot"], "application/vnd.ms-powerpoint.addin.macroenabled.12": ["ppam"], "application/vnd.ms-powerpoint.presentation.macroenabled.12": ["pptm"], "application/vnd.ms-powerpoint.slide.macroenabled.12": ["sldm"], "application/vnd.ms-powerpoint.slideshow.macroenabled.12": ["ppsm"], "application/vnd.ms-powerpoint.template.macroenabled.12": ["potm"], "application/vnd.ms-project": ["mpp", "mpt"], "application/vnd.ms-word.document.macroenabled.12": ["docm"], "application/vnd.ms-word.template.macroenabled.12": ["dotm"], "application/vnd.ms-works": ["wps", "wks", "wcm", "wdb"], "application/vnd.ms-wpl": ["wpl"], "application/vnd.ms-xpsdocument": ["xps"], "application/vnd.mseq": ["mseq"], "application/vnd.musician": ["mus"], "application/vnd.muvee.style": ["msty"], "application/vnd.mynfc": ["taglet"], "application/vnd.neurolanguage.nlu": ["nlu"], "application/vnd.nitf": ["ntf", "nitf"], "application/vnd.noblenet-directory": ["nnd"], "application/vnd.noblenet-sealer": ["nns"], "application/vnd.noblenet-web": ["nnw"], "application/vnd.nokia.n-gage.data": ["ngdat"], "application/vnd.nokia.n-gage.symbian.install": ["n-gage"], "application/vnd.nokia.radio-preset": ["rpst"], "application/vnd.nokia.radio-presets": ["rpss"], "application/vnd.novadigm.edm": ["edm"], "application/vnd.novadigm.edx": ["edx"], "application/vnd.novadigm.ext": ["ext"], "application/vnd.oasis.opendocument.chart": ["odc"], "application/vnd.oasis.opendocument.chart-template": ["otc"], "application/vnd.oasis.opendocument.database": ["odb"], "application/vnd.oasis.opendocument.formula": ["odf"], "application/vnd.oasis.opendocument.formula-template": ["odft"], "application/vnd.oasis.opendocument.graphics": ["odg"], "application/vnd.oasis.opendocument.graphics-template": ["otg"], "application/vnd.oasis.opendocument.image": ["odi"], "application/vnd.oasis.opendocument.image-template": ["oti"], "application/vnd.oasis.opendocument.presentation": ["odp"], "application/vnd.oasis.opendocument.presentation-template": ["otp"], "application/vnd.oasis.opendocument.spreadsheet": ["ods"], "application/vnd.oasis.opendocument.spreadsheet-template": ["ots"], "application/vnd.oasis.opendocument.text": ["odt"], "application/vnd.oasis.opendocument.text-master": ["odm"], "application/vnd.oasis.opendocument.text-template": ["ott"], "application/vnd.oasis.opendocument.text-web": ["oth"], "application/vnd.olpc-sugar": ["xo"], "application/vnd.oma.dd2+xml": ["dd2"], "application/vnd.openofficeorg.extension": ["oxt"], "application/vnd.openxmlformats-officedocument.presentationml.presentation": ["pptx"], "application/vnd.openxmlformats-officedocument.presentationml.slide": ["sldx"], "application/vnd.openxmlformats-officedocument.presentationml.slideshow": ["ppsx"], "application/vnd.openxmlformats-officedocument.presentationml.template": ["potx"], "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": ["xlsx"], "application/vnd.openxmlformats-officedocument.spreadsheetml.template": ["xltx"], "application/vnd.openxmlformats-officedocument.wordprocessingml.document": ["docx"], "application/vnd.openxmlformats-officedocument.wordprocessingml.template": ["dotx"], "application/vnd.osgeo.mapguide.package": ["mgp"], "application/vnd.osgi.dp": ["dp"], "application/vnd.osgi.subsystem": ["esa"], "application/vnd.palm": ["pdb", "pqa", "oprc"], "application/vnd.pawaafile": ["paw"], "application/vnd.pg.format": ["str"], "application/vnd.pg.osasli": ["ei6"], "application/vnd.picsel": ["efif"], "application/vnd.pmi.widget": ["wg"], "application/vnd.pocketlearn": ["plf"], "application/vnd.powerbuilder6": ["pbd"], "application/vnd.previewsystems.box": ["box"], "application/vnd.proteus.magazine": ["mgz"], "application/vnd.publishare-delta-tree": ["qps"], "application/vnd.pvi.ptid1": ["ptid"], "application/vnd.quark.quarkxpress": ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"], "application/vnd.realvnc.bed": ["bed"], "application/vnd.recordare.musicxml": ["mxl"], "application/vnd.recordare.musicxml+xml": ["musicxml"], "application/vnd.rig.cryptonote": ["cryptonote"], "application/vnd.rim.cod": ["cod"], "application/vnd.rn-realmedia": ["rm"], "application/vnd.rn-realmedia-vbr": ["rmvb"], "application/vnd.route66.link66+xml": ["link66"], "application/vnd.sailingtracker.track": ["st"], "application/vnd.seemail": ["see"], "application/vnd.sema": ["sema"], "application/vnd.semd": ["semd"], "application/vnd.semf": ["semf"], "application/vnd.shana.informed.formdata": ["ifm"], "application/vnd.shana.informed.formtemplate": ["itp"], "application/vnd.shana.informed.interchange": ["iif"], "application/vnd.shana.informed.package": ["ipk"], "application/vnd.simtech-mindmapper": ["twd", "twds"], "application/vnd.smaf": ["mmf"], "application/vnd.smart.teacher": ["teacher"], "application/vnd.solent.sdkm+xml": ["sdkm", "sdkd"], "application/vnd.spotfire.dxp": ["dxp"], "application/vnd.spotfire.sfs": ["sfs"], "application/vnd.stardivision.calc": ["sdc"], "application/vnd.stardivision.draw": ["sda"], "application/vnd.stardivision.impress": ["sdd"], "application/vnd.stardivision.math": ["smf"], "application/vnd.stardivision.writer": ["sdw", "vor"], "application/vnd.stardivision.writer-global": ["sgl"], "application/vnd.stepmania.package": ["smzip"], "application/vnd.stepmania.stepchart": ["sm"], "application/vnd.sun.wadl+xml": ["wadl"], "application/vnd.sun.xml.calc": ["sxc"], "application/vnd.sun.xml.calc.template": ["stc"], "application/vnd.sun.xml.draw": ["sxd"], "application/vnd.sun.xml.draw.template": ["std"], "application/vnd.sun.xml.impress": ["sxi"], "application/vnd.sun.xml.impress.template": ["sti"], "application/vnd.sun.xml.math": ["sxm"], "application/vnd.sun.xml.writer": ["sxw"], "application/vnd.sun.xml.writer.global": ["sxg"], "application/vnd.sun.xml.writer.template": ["stw"], "application/vnd.sus-calendar": ["sus", "susp"], "application/vnd.svd": ["svd"], "application/vnd.symbian.install": ["sis", "sisx"], "application/vnd.syncml+xml": ["xsm"], "application/vnd.syncml.dm+wbxml": ["bdm"], "application/vnd.syncml.dm+xml": ["xdm"], "application/vnd.tao.intent-module-archive": ["tao"], "application/vnd.tcpdump.pcap": ["pcap", "cap", "dmp"], "application/vnd.tmobile-livetv": ["tmo"], "application/vnd.trid.tpt": ["tpt"], "application/vnd.triscape.mxs": ["mxs"], "application/vnd.trueapp": ["tra"], "application/vnd.ufdl": ["ufd", "ufdl"], "application/vnd.uiq.theme": ["utz"], "application/vnd.umajin": ["umj"], "application/vnd.unity": ["unityweb"], "application/vnd.uoml+xml": ["uoml"], "application/vnd.vcx": ["vcx"], "application/vnd.visio": ["vsd", "vst", "vss", "vsw"], "application/vnd.visionary": ["vis"], "application/vnd.vsf": ["vsf"], "application/vnd.wap.wbxml": ["wbxml"], "application/vnd.wap.wmlc": ["wmlc"], "application/vnd.wap.wmlscriptc": ["wmlsc"], "application/vnd.webturbo": ["wtb"], "application/vnd.wolfram.player": ["nbp"], "application/vnd.wordperfect": ["wpd"], "application/vnd.wqd": ["wqd"], "application/vnd.wt.stf": ["stf"], "application/vnd.xara": ["xar"], "application/vnd.xfdl": ["xfdl"], "application/vnd.yamaha.hv-dic": ["hvd"], "application/vnd.yamaha.hv-script": ["hvs"], "application/vnd.yamaha.hv-voice": ["hvp"], "application/vnd.yamaha.openscoreformat": ["osf"], "application/vnd.yamaha.openscoreformat.osfpvg+xml": ["osfpvg"], "application/vnd.yamaha.smaf-audio": ["saf"], "application/vnd.yamaha.smaf-phrase": ["spf"], "application/vnd.yellowriver-custom-menu": ["cmp"], "application/vnd.zul": ["zir", "zirz"], "application/vnd.zzazz.deck+xml": ["zaz"], "application/voicexml+xml": ["vxml"], "application/wasm": ["wasm"], "application/widget": ["wgt"], "application/winhlp": ["hlp"], "application/wsdl+xml": ["wsdl"], "application/wspolicy+xml": ["wspolicy"], "application/x-7z-compressed": ["7z"], "application/x-abiword": ["abw"], "application/x-ace-compressed": ["ace"], "application/x-apple-diskimage": [], "application/x-arj": ["arj"], "application/x-authorware-bin": ["aab", "x32", "u32", "vox"], "application/x-authorware-map": ["aam"], "application/x-authorware-seg": ["aas"], "application/x-bcpio": ["bcpio"], "application/x-bdoc": [], "application/x-bittorrent": ["torrent"], "application/x-blorb": ["blb", "blorb"], "application/x-bzip": ["bz"], "application/x-bzip2": ["bz2", "boz"], "application/x-cbr": ["cbr", "cba", "cbt", "cbz", "cb7"], "application/x-cdlink": ["vcd"], "application/x-cfs-compressed": ["cfs"], "application/x-chat": ["chat"], "application/x-chess-pgn": ["pgn"], "application/x-chrome-extension": ["crx"], "application/x-cocoa": ["cco"], "application/x-conference": ["nsc"], "application/x-cpio": ["cpio"], "application/x-csh": ["csh"], "application/x-debian-package": ["udeb"], "application/x-dgc-compressed": ["dgc"], "application/x-director": ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"], "application/x-doom": ["wad"], "application/x-dtbncx+xml": ["ncx"], "application/x-dtbook+xml": ["dtb"], "application/x-dtbresource+xml": ["res"], "application/x-dvi": ["dvi"], "application/x-envoy": ["evy"], "application/x-eva": ["eva"], "application/x-font-bdf": ["bdf"], "application/x-font-ghostscript": ["gsf"], "application/x-font-linux-psf": ["psf"], "application/x-font-pcf": ["pcf"], "application/x-font-snf": ["snf"], "application/x-font-type1": ["pfa", "pfb", "pfm", "afm"], "application/x-freearc": ["arc"], "application/x-futuresplash": ["spl"], "application/x-gca-compressed": ["gca"], "application/x-glulx": ["ulx"], "application/x-gnumeric": ["gnumeric"], "application/x-gramps-xml": ["gramps"], "application/x-gtar": ["gtar"], "application/x-hdf": ["hdf"], "application/x-httpd-php": ["php"], "application/x-install-instructions": ["install"], "application/x-iso9660-image": [], "application/x-java-archive-diff": ["jardiff"], "application/x-java-jnlp-file": ["jnlp"], "application/x-latex": ["latex"], "application/x-lua-bytecode": ["luac"], "application/x-lzh-compressed": ["lzh", "lha"], "application/x-makeself": ["run"], "application/x-mie": ["mie"], "application/x-mobipocket-ebook": ["prc", "mobi"], "application/x-ms-application": ["application"], "application/x-ms-shortcut": ["lnk"], "application/x-ms-wmd": ["wmd"], "application/x-ms-wmz": ["wmz"], "application/x-ms-xbap": ["xbap"], "application/x-msaccess": ["mdb"], "application/x-msbinder": ["obd"], "application/x-mscardfile": ["crd"], "application/x-msclip": ["clp"], "application/x-msdos-program": [], "application/x-msdownload": ["com", "bat"], "application/x-msmediaview": ["mvb", "m13", "m14"], "application/x-msmetafile": ["wmf", "emf", "emz"], "application/x-msmoney": ["mny"], "application/x-mspublisher": ["pub"], "application/x-msschedule": ["scd"], "application/x-msterminal": ["trm"], "application/x-mswrite": ["wri"], "application/x-netcdf": ["nc", "cdf"], "application/x-ns-proxy-autoconfig": ["pac"], "application/x-nzb": ["nzb"], "application/x-perl": ["pl", "pm"], "application/x-pilot": [], "application/x-pkcs12": ["p12", "pfx"], "application/x-pkcs7-certificates": ["p7b", "spc"], "application/x-pkcs7-certreqresp": ["p7r"], "application/x-rar-compressed": ["rar"], "application/x-redhat-package-manager": ["rpm"], "application/x-research-info-systems": ["ris"], "application/x-sea": ["sea"], "application/x-sh": ["sh"], "application/x-shar": ["shar"], "application/x-shockwave-flash": ["swf"], "application/x-silverlight-app": ["xap"], "application/x-sql": ["sql"], "application/x-stuffit": ["sit"], "application/x-stuffitx": ["sitx"], "application/x-subrip": ["srt"], "application/x-sv4cpio": ["sv4cpio"], "application/x-sv4crc": ["sv4crc"], "application/x-t3vm-image": ["t3"], "application/x-tads": ["gam"], "application/x-tar": ["tar"], "application/x-tcl": ["tcl", "tk"], "application/x-tex": ["tex"], "application/x-tex-tfm": ["tfm"], "application/x-texinfo": ["texinfo", "texi"], "application/x-tgif": ["obj"], "application/x-ustar": ["ustar"], "application/x-virtualbox-hdd": ["hdd"], "application/x-virtualbox-ova": ["ova"], "application/x-virtualbox-ovf": ["ovf"], "application/x-virtualbox-vbox": ["vbox"], "application/x-virtualbox-vbox-extpack": ["vbox-extpack"], "application/x-virtualbox-vdi": ["vdi"], "application/x-virtualbox-vhd": ["vhd"], "application/x-virtualbox-vmdk": ["vmdk"], "application/x-wais-source": ["src"], "application/x-web-app-manifest+json": ["webapp"], "application/x-x509-ca-cert": ["der", "crt", "pem"], "application/x-xfig": ["fig"], "application/x-xliff+xml": ["xlf"], "application/x-xpinstall": ["xpi"], "application/x-xz": ["xz"], "application/x-zmachine": ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"], "application/xaml+xml": ["xaml"], "application/xcap-diff+xml": ["xdf"], "application/xenc+xml": ["xenc"], "application/xhtml+xml": ["xhtml", "xht"], "application/xml": ["xml", "xsl", "xsd", "rng"], "application/xml-dtd": ["dtd"], "application/xop+xml": ["xop"], "application/xproc+xml": ["xpl"], "application/xslt+xml": ["xslt"], "application/xspf+xml": ["xspf"], "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"], "application/yang": ["yang"], "application/yin+xml": ["yin"], "application/zip": ["zip"], "audio/3gpp": [], "audio/adpcm": ["adp"], "audio/basic": ["au", "snd"], "audio/midi": ["mid", "midi", "kar", "rmi"], "audio/mp3": [], "audio/mp4": ["m4a", "mp4a"], "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"], "audio/ogg": ["oga", "ogg", "spx"], "audio/s3m": ["s3m"], "audio/silk": ["sil"], "audio/vnd.dece.audio": ["uva", "uvva"], "audio/vnd.digital-winds": ["eol"], "audio/vnd.dra": ["dra"], "audio/vnd.dts": ["dts"], "audio/vnd.dts.hd": ["dtshd"], "audio/vnd.lucent.voice": ["lvp"], "audio/vnd.ms-playready.media.pya": ["pya"], "audio/vnd.nuera.ecelp4800": ["ecelp4800"], "audio/vnd.nuera.ecelp7470": ["ecelp7470"], "audio/vnd.nuera.ecelp9600": ["ecelp9600"], "audio/vnd.rip": ["rip"], "audio/wav": ["wav"], "audio/wave": [], "audio/webm": ["weba"], "audio/x-aac": ["aac"], "audio/x-aiff": ["aif", "aiff", "aifc"], "audio/x-caf": ["caf"], "audio/x-flac": ["flac"], "audio/x-m4a": [], "audio/x-matroska": ["mka"], "audio/x-mpegurl": ["m3u"], "audio/x-ms-wax": ["wax"], "audio/x-ms-wma": ["wma"], "audio/x-pn-realaudio": ["ram", "ra"], "audio/x-pn-realaudio-plugin": ["rmp"], "audio/x-realaudio": [], "audio/x-wav": [], "audio/xm": ["xm"], "chemical/x-cdx": ["cdx"], "chemical/x-cif": ["cif"], "chemical/x-cmdf": ["cmdf"], "chemical/x-cml": ["cml"], "chemical/x-csml": ["csml"], "chemical/x-xyz": ["xyz"], "font/collection": ["ttc"], "font/otf": ["otf"], "font/ttf": ["ttf"], "font/woff": ["woff"], "font/woff2": ["woff2"], "image/apng": ["apng"], "image/bmp": ["bmp"], "image/cgm": ["cgm"], "image/g3fax": ["g3"], "image/gif": ["gif"], "image/ief": ["ief"], "image/jp2": ["jp2", "jpg2"], "image/jpeg": ["jpeg", "jpg", "jpe"], "image/jpm": ["jpm"], "image/jpx": ["jpx", "jpf"], "image/ktx": ["ktx"], "image/png": ["png"], "image/prs.btif": ["btif"], "image/sgi": ["sgi"], "image/svg+xml": ["svg", "svgz"], "image/tiff": ["tiff", "tif"], "image/vnd.adobe.photoshop": ["psd"], "image/vnd.dece.graphic": ["uvi", "uvvi", "uvg", "uvvg"], "image/vnd.djvu": ["djvu", "djv"], "image/vnd.dvb.subtitle": [], "image/vnd.dwg": ["dwg"], "image/vnd.dxf": ["dxf"], "image/vnd.fastbidsheet": ["fbs"], "image/vnd.fpx": ["fpx"], "image/vnd.fst": ["fst"], "image/vnd.fujixerox.edmics-mmr": ["mmr"], "image/vnd.fujixerox.edmics-rlc": ["rlc"], "image/vnd.ms-modi": ["mdi"], "image/vnd.ms-photo": ["wdp"], "image/vnd.net-fpx": ["npx"], "image/vnd.wap.wbmp": ["wbmp"], "image/vnd.xiff": ["xif"], "image/webp": ["webp"], "image/x-3ds": ["3ds"], "image/x-cmu-raster": ["ras"], "image/x-cmx": ["cmx"], "image/x-freehand": ["fh", "fhc", "fh4", "fh5", "fh7"], "image/x-icon": ["ico"], "image/x-jng": ["jng"], "image/x-mrsid-image": ["sid"], "image/x-ms-bmp": [], "image/x-pcx": ["pcx"], "image/x-pict": ["pic", "pct"], "image/x-portable-anymap": ["pnm"], "image/x-portable-bitmap": ["pbm"], "image/x-portable-graymap": ["pgm"], "image/x-portable-pixmap": ["ppm"], "image/x-rgb": ["rgb"], "image/x-tga": ["tga"], "image/x-xbitmap": ["xbm"], "image/x-xpixmap": ["xpm"], "image/x-xwindowdump": ["xwd"], "message/rfc822": ["eml", "mime"], "model/gltf+json": ["gltf"], "model/gltf-binary": ["glb"], "model/iges": ["igs", "iges"], "model/mesh": ["msh", "mesh", "silo"], "model/vnd.collada+xml": ["dae"], "model/vnd.dwf": ["dwf"], "model/vnd.gdl": ["gdl"], "model/vnd.gtw": ["gtw"], "model/vnd.mts": ["mts"], "model/vnd.vtu": ["vtu"], "model/vrml": ["wrl", "vrml"], "model/x3d+binary": ["x3db", "x3dbz"], "model/x3d+vrml": ["x3dv", "x3dvz"], "model/x3d+xml": ["x3d", "x3dz"], "text/cache-manifest": ["appcache", "manifest"], "text/calendar": ["ics", "ifb"], "text/coffeescript": ["coffee", "litcoffee"], "text/css": ["css"], "text/csv": ["csv"], "text/hjson": ["hjson"], "text/html": ["html", "htm", "shtml"], "text/jade": ["jade"], "text/jsx": ["jsx"], "text/less": ["less"], "text/markdown": ["markdown", "md"], "text/mathml": ["mml"], "text/n3": ["n3"], "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"], "text/prs.lines.tag": ["dsc"], "text/richtext": ["rtx"], "text/rtf": [], "text/sgml": ["sgml", "sgm"], "text/slim": ["slim", "slm"], "text/stylus": ["stylus", "styl"], "text/tab-separated-values": ["tsv"], "text/troff": ["t", "tr", "roff", "man", "me", "ms"], "text/turtle": ["ttl"], "text/uri-list": ["uri", "uris", "urls"], "text/vcard": ["vcard"], "text/vnd.curl": ["curl"], "text/vnd.curl.dcurl": ["dcurl"], "text/vnd.curl.mcurl": ["mcurl"], "text/vnd.curl.scurl": ["scurl"], "text/vnd.dvb.subtitle": ["sub"], "text/vnd.fly": ["fly"], "text/vnd.fmi.flexstor": ["flx"], "text/vnd.graphviz": ["gv"], "text/vnd.in3d.3dml": ["3dml"], "text/vnd.in3d.spot": ["spot"], "text/vnd.sun.j2me.app-descriptor": ["jad"], "text/vnd.wap.wml": ["wml"], "text/vnd.wap.wmlscript": ["wmls"], "text/vtt": ["vtt"], "text/x-asm": ["s", "asm"], "text/x-c": ["c", "cc", "cxx", "cpp", "h", "hh", "dic"], "text/x-component": ["htc"], "text/x-fortran": ["f", "for", "f77", "f90"], "text/x-handlebars-template": ["hbs"], "text/x-java-source": ["java"], "text/x-lua": ["lua"], "text/x-markdown": ["mkd"], "text/x-nfo": ["nfo"], "text/x-opml": ["opml"], "text/x-org": [], "text/x-pascal": ["p", "pas"], "text/x-processing": ["pde"], "text/x-sass": ["sass"], "text/x-scss": ["scss"], "text/x-setext": ["etx"], "text/x-sfv": ["sfv"], "text/x-suse-ymp": ["ymp"], "text/x-uuencode": ["uu"], "text/x-vcalendar": ["vcs"], "text/x-vcard": ["vcf"], "text/xml": [], "text/yaml": ["yaml", "yml"], "video/3gpp": ["3gp", "3gpp"], "video/3gpp2": ["3g2"], "video/h261": ["h261"], "video/h263": ["h263"], "video/h264": ["h264"], "video/jpeg": ["jpgv"], "video/jpm": ["jpgm"], "video/mj2": ["mj2", "mjp2"], "video/mp2t": ["ts"], "video/mp4": ["mp4", "mp4v", "mpg4"], "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"], "video/ogg": ["ogv"], "video/quicktime": ["qt", "mov"], "video/vnd.dece.hd": ["uvh", "uvvh"], "video/vnd.dece.mobile": ["uvm", "uvvm"], "video/vnd.dece.pd": ["uvp", "uvvp"], "video/vnd.dece.sd": ["uvs", "uvvs"], "video/vnd.dece.video": ["uvv", "uvvv"], "video/vnd.dvb.file": ["dvb"], "video/vnd.fvt": ["fvt"], "video/vnd.mpegurl": ["mxu", "m4u"], "video/vnd.ms-playready.media.pyv": ["pyv"], "video/vnd.uvvu.mp4": ["uvu", "uvvu"], "video/vnd.vivo": ["viv"], "video/webm": ["webm"], "video/x-f4v": ["f4v"], "video/x-fli": ["fli"], "video/x-flv": ["flv"], "video/x-m4v": ["m4v"], "video/x-matroska": ["mkv", "mk3d", "mks"], "video/x-mng": ["mng"], "video/x-ms-asf": ["asf", "asx"], "video/x-ms-vob": ["vob"], "video/x-ms-wm": ["wm"], "video/x-ms-wmv": ["wmv"], "video/x-ms-wmx": ["wmx"], "video/x-ms-wvx": ["wvx"], "video/x-msvideo": ["avi"], "video/x-sgi-movie": ["movie"], "video/x-smv": ["smv"], "x-conference/x-cooltalk": ["ice"] };
});

// node_modules/mime/mime.js
var require_mime = __commonJS((exports, module) => {
  var path = __require("path");
  var fs = __require("fs");
  function Mime() {
    this.types = Object.create(null);
    this.extensions = Object.create(null);
  }
  Mime.prototype.define = function(map) {
    for (var type in map) {
      var exts = map[type];
      for (var i = 0;i < exts.length; i++) {
        if (process.env.DEBUG_MIME && this.types[exts[i]]) {
          console.warn((this._loading || "define()").replace(/.*\//, ""), 'changes "' + exts[i] + '" extension type from ' + this.types[exts[i]] + " to " + type);
        }
        this.types[exts[i]] = type;
      }
      if (!this.extensions[type]) {
        this.extensions[type] = exts[0];
      }
    }
  };
  Mime.prototype.load = function(file) {
    this._loading = file;
    var map = {}, content = fs.readFileSync(file, "ascii"), lines = content.split(/[\r\n]+/);
    lines.forEach(function(line) {
      var fields = line.replace(/\s*#.*|^\s*|\s*$/g, "").split(/\s+/);
      map[fields.shift()] = fields;
    });
    this.define(map);
    this._loading = null;
  };
  Mime.prototype.lookup = function(path2, fallback) {
    var ext = path2.replace(/^.*[\.\/\\]/, "").toLowerCase();
    return this.types[ext] || fallback || this.default_type;
  };
  Mime.prototype.extension = function(mimeType) {
    var type = mimeType.match(/^\s*([^;\s]*)(?:;|\s|$)/)[1].toLowerCase();
    return this.extensions[type];
  };
  var mime = new Mime;
  mime.define(require_types());
  mime.default_type = mime.lookup("bin");
  mime.Mime = Mime;
  mime.charsets = {
    lookup: function(mimeType, fallback) {
      return /^text\/|^application\/(javascript|json)/.test(mimeType) ? "UTF-8" : fallback;
    }
  };
  module.exports = mime;
});

// node_modules/send/node_modules/ms/index.js
var require_ms5 = __commonJS((exports, module) => {
  var s = 1000;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  module.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse(val);
    } else if (type === "number" && isNaN(val) === false) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
  function parse(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^((?:\d+)?\-?\d?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return;
    }
  }
  function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return Math.round(ms / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms / s) + "s";
    }
    return ms + "ms";
  }
  function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return plural(ms, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms, msAbs, s, "second");
    }
    return ms + " ms";
  }
  function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
  }
});

// node_modules/range-parser/index.js
var require_range_parser = __commonJS((exports, module) => {
  /*!
   * range-parser
   * Copyright(c) 2012-2014 TJ Holowaychuk
   * Copyright(c) 2015-2016 Douglas Christopher Wilson
   * MIT Licensed
   */
  module.exports = rangeParser;
  function rangeParser(size, str, options) {
    if (typeof str !== "string") {
      throw new TypeError("argument str must be a string");
    }
    var index = str.indexOf("=");
    if (index === -1) {
      return -2;
    }
    var arr = str.slice(index + 1).split(",");
    var ranges = [];
    ranges.type = str.slice(0, index);
    for (var i = 0;i < arr.length; i++) {
      var range = arr[i].split("-");
      var start = parseInt(range[0], 10);
      var end = parseInt(range[1], 10);
      if (isNaN(start)) {
        start = size - end;
        end = size - 1;
      } else if (isNaN(end)) {
        end = size - 1;
      }
      if (end > size - 1) {
        end = size - 1;
      }
      if (isNaN(start) || isNaN(end) || start > end || start < 0) {
        continue;
      }
      ranges.push({
        start,
        end
      });
    }
    if (ranges.length < 1) {
      return -1;
    }
    return options && options.combine ? combineRanges(ranges) : ranges;
  }
  function combineRanges(ranges) {
    var ordered = ranges.map(mapWithIndex).sort(sortByRangeStart);
    for (var j = 0, i = 1;i < ordered.length; i++) {
      var range = ordered[i];
      var current = ordered[j];
      if (range.start > current.end + 1) {
        ordered[++j] = range;
      } else if (range.end > current.end) {
        current.end = range.end;
        current.index = Math.min(current.index, range.index);
      }
    }
    ordered.length = j + 1;
    var combined = ordered.sort(sortByRangeIndex).map(mapWithoutIndex);
    combined.type = ranges.type;
    return combined;
  }
  function mapWithIndex(range, index) {
    return {
      start: range.start,
      end: range.end,
      index
    };
  }
  function mapWithoutIndex(range) {
    return {
      start: range.start,
      end: range.end
    };
  }
  function sortByRangeIndex(a, b) {
    return a.index - b.index;
  }
  function sortByRangeStart(a, b) {
    return a.start - b.start;
  }
});

// node_modules/send/index.js
var require_send = __commonJS((exports, module) => {
  /*!
   * send
   * Copyright(c) 2012 TJ Holowaychuk
   * Copyright(c) 2014-2016 Douglas Christopher Wilson
   * MIT Licensed
   */
  var createError = require_http_errors();
  var debug = require_src4()("send");
  var deprecate2 = require_depd()("send");
  var destroy = require_destroy();
  var encodeUrl = require_encodeurl();
  var escapeHtml = require_escape_html();
  var etag = require_etag();
  var fresh = require_fresh();
  var fs = __require("fs");
  var mime = require_mime();
  var ms = require_ms5();
  var onFinished = require_on_finished();
  var parseRange = require_range_parser();
  var path = __require("path");
  var statuses = require_statuses();
  var Stream = __require("stream");
  var util = __require("util");
  var extname = path.extname;
  var join = path.join;
  var normalize = path.normalize;
  var resolve = path.resolve;
  var sep = path.sep;
  var BYTES_RANGE_REGEXP = /^ *bytes=/;
  var MAX_MAXAGE = 60 * 60 * 24 * 365 * 1000;
  var UP_PATH_REGEXP = /(?:^|[\\/])\.\.(?:[\\/]|$)/;
  module.exports = send;
  module.exports.mime = mime;
  function send(req, path2, options) {
    return new SendStream(req, path2, options);
  }
  function SendStream(req, path2, options) {
    Stream.call(this);
    var opts = options || {};
    this.options = opts;
    this.path = path2;
    this.req = req;
    this._acceptRanges = opts.acceptRanges !== undefined ? Boolean(opts.acceptRanges) : true;
    this._cacheControl = opts.cacheControl !== undefined ? Boolean(opts.cacheControl) : true;
    this._etag = opts.etag !== undefined ? Boolean(opts.etag) : true;
    this._dotfiles = opts.dotfiles !== undefined ? opts.dotfiles : "ignore";
    if (this._dotfiles !== "ignore" && this._dotfiles !== "allow" && this._dotfiles !== "deny") {
      throw new TypeError('dotfiles option must be "allow", "deny", or "ignore"');
    }
    this._hidden = Boolean(opts.hidden);
    if (opts.hidden !== undefined) {
      deprecate2("hidden: use dotfiles: '" + (this._hidden ? "allow" : "ignore") + "' instead");
    }
    if (opts.dotfiles === undefined) {
      this._dotfiles = undefined;
    }
    this._extensions = opts.extensions !== undefined ? normalizeList(opts.extensions, "extensions option") : [];
    this._immutable = opts.immutable !== undefined ? Boolean(opts.immutable) : false;
    this._index = opts.index !== undefined ? normalizeList(opts.index, "index option") : ["index.html"];
    this._lastModified = opts.lastModified !== undefined ? Boolean(opts.lastModified) : true;
    this._maxage = opts.maxAge || opts.maxage;
    this._maxage = typeof this._maxage === "string" ? ms(this._maxage) : Number(this._maxage);
    this._maxage = !isNaN(this._maxage) ? Math.min(Math.max(0, this._maxage), MAX_MAXAGE) : 0;
    this._root = opts.root ? resolve(opts.root) : null;
    if (!this._root && opts.from) {
      this.from(opts.from);
    }
  }
  util.inherits(SendStream, Stream);
  SendStream.prototype.etag = deprecate2.function(function etag(val) {
    this._etag = Boolean(val);
    debug("etag %s", this._etag);
    return this;
  }, "send.etag: pass etag as option");
  SendStream.prototype.hidden = deprecate2.function(function hidden(val) {
    this._hidden = Boolean(val);
    this._dotfiles = undefined;
    debug("hidden %s", this._hidden);
    return this;
  }, "send.hidden: use dotfiles option");
  SendStream.prototype.index = deprecate2.function(function index(paths) {
    var index = !paths ? [] : normalizeList(paths, "paths argument");
    debug("index %o", paths);
    this._index = index;
    return this;
  }, "send.index: pass index as option");
  SendStream.prototype.root = function root(path2) {
    this._root = resolve(String(path2));
    debug("root %s", this._root);
    return this;
  };
  SendStream.prototype.from = deprecate2.function(SendStream.prototype.root, "send.from: pass root as option");
  SendStream.prototype.root = deprecate2.function(SendStream.prototype.root, "send.root: pass root as option");
  SendStream.prototype.maxage = deprecate2.function(function maxage(maxAge) {
    this._maxage = typeof maxAge === "string" ? ms(maxAge) : Number(maxAge);
    this._maxage = !isNaN(this._maxage) ? Math.min(Math.max(0, this._maxage), MAX_MAXAGE) : 0;
    debug("max-age %d", this._maxage);
    return this;
  }, "send.maxage: pass maxAge as option");
  SendStream.prototype.error = function error(status, err) {
    if (hasListeners(this, "error")) {
      return this.emit("error", createError(status, err, {
        expose: false
      }));
    }
    var res = this.res;
    var msg = statuses[status] || String(status);
    var doc = createHtmlDocument("Error", escapeHtml(msg));
    clearHeaders(res);
    if (err && err.headers) {
      setHeaders(res, err.headers);
    }
    res.statusCode = status;
    res.setHeader("Content-Type", "text/html; charset=UTF-8");
    res.setHeader("Content-Length", Buffer.byteLength(doc));
    res.setHeader("Content-Security-Policy", "default-src 'none'");
    res.setHeader("X-Content-Type-Options", "nosniff");
    res.end(doc);
  };
  SendStream.prototype.hasTrailingSlash = function hasTrailingSlash() {
    return this.path[this.path.length - 1] === "/";
  };
  SendStream.prototype.isConditionalGET = function isConditionalGET() {
    return this.req.headers["if-match"] || this.req.headers["if-unmodified-since"] || this.req.headers["if-none-match"] || this.req.headers["if-modified-since"];
  };
  SendStream.prototype.isPreconditionFailure = function isPreconditionFailure() {
    var req = this.req;
    var res = this.res;
    var match = req.headers["if-match"];
    if (match) {
      var etag2 = res.getHeader("ETag");
      return !etag2 || match !== "*" && parseTokenList(match).every(function(match2) {
        return match2 !== etag2 && match2 !== "W/" + etag2 && "W/" + match2 !== etag2;
      });
    }
    var unmodifiedSince = parseHttpDate(req.headers["if-unmodified-since"]);
    if (!isNaN(unmodifiedSince)) {
      var lastModified = parseHttpDate(res.getHeader("Last-Modified"));
      return isNaN(lastModified) || lastModified > unmodifiedSince;
    }
    return false;
  };
  SendStream.prototype.removeContentHeaderFields = function removeContentHeaderFields() {
    var res = this.res;
    var headers = getHeaderNames(res);
    for (var i = 0;i < headers.length; i++) {
      var header = headers[i];
      if (header.substr(0, 8) === "content-" && header !== "content-location") {
        res.removeHeader(header);
      }
    }
  };
  SendStream.prototype.notModified = function notModified() {
    var res = this.res;
    debug("not modified");
    this.removeContentHeaderFields();
    res.statusCode = 304;
    res.end();
  };
  SendStream.prototype.headersAlreadySent = function headersAlreadySent() {
    var err = new Error("Can't set headers after they are sent.");
    debug("headers already sent");
    this.error(500, err);
  };
  SendStream.prototype.isCachable = function isCachable() {
    var statusCode = this.res.statusCode;
    return statusCode >= 200 && statusCode < 300 || statusCode === 304;
  };
  SendStream.prototype.onStatError = function onStatError(error) {
    switch (error.code) {
      case "ENAMETOOLONG":
      case "ENOENT":
      case "ENOTDIR":
        this.error(404, error);
        break;
      default:
        this.error(500, error);
        break;
    }
  };
  SendStream.prototype.isFresh = function isFresh() {
    return fresh(this.req.headers, {
      etag: this.res.getHeader("ETag"),
      "last-modified": this.res.getHeader("Last-Modified")
    });
  };
  SendStream.prototype.isRangeFresh = function isRangeFresh() {
    var ifRange = this.req.headers["if-range"];
    if (!ifRange) {
      return true;
    }
    if (ifRange.indexOf('"') !== -1) {
      var etag2 = this.res.getHeader("ETag");
      return Boolean(etag2 && ifRange.indexOf(etag2) !== -1);
    }
    var lastModified = this.res.getHeader("Last-Modified");
    return parseHttpDate(lastModified) <= parseHttpDate(ifRange);
  };
  SendStream.prototype.redirect = function redirect(path2) {
    var res = this.res;
    if (hasListeners(this, "directory")) {
      this.emit("directory", res, path2);
      return;
    }
    if (this.hasTrailingSlash()) {
      this.error(403);
      return;
    }
    var loc = encodeUrl(collapseLeadingSlashes(this.path + "/"));
    var doc = createHtmlDocument("Redirecting", 'Redirecting to <a href="' + escapeHtml(loc) + '">' + escapeHtml(loc) + "</a>");
    res.statusCode = 301;
    res.setHeader("Content-Type", "text/html; charset=UTF-8");
    res.setHeader("Content-Length", Buffer.byteLength(doc));
    res.setHeader("Content-Security-Policy", "default-src 'none'");
    res.setHeader("X-Content-Type-Options", "nosniff");
    res.setHeader("Location", loc);
    res.end(doc);
  };
  SendStream.prototype.pipe = function pipe(res) {
    var root = this._root;
    this.res = res;
    var path2 = decode(this.path);
    if (path2 === -1) {
      this.error(400);
      return res;
    }
    if (~path2.indexOf("\x00")) {
      this.error(400);
      return res;
    }
    var parts;
    if (root !== null) {
      if (path2) {
        path2 = normalize("." + sep + path2);
      }
      if (UP_PATH_REGEXP.test(path2)) {
        debug('malicious path "%s"', path2);
        this.error(403);
        return res;
      }
      parts = path2.split(sep);
      path2 = normalize(join(root, path2));
    } else {
      if (UP_PATH_REGEXP.test(path2)) {
        debug('malicious path "%s"', path2);
        this.error(403);
        return res;
      }
      parts = normalize(path2).split(sep);
      path2 = resolve(path2);
    }
    if (containsDotFile(parts)) {
      var access = this._dotfiles;
      if (access === undefined) {
        access = parts[parts.length - 1][0] === "." ? this._hidden ? "allow" : "ignore" : "allow";
      }
      debug('%s dotfile "%s"', access, path2);
      switch (access) {
        case "allow":
          break;
        case "deny":
          this.error(403);
          return res;
        case "ignore":
        default:
          this.error(404);
          return res;
      }
    }
    if (this._index.length && this.hasTrailingSlash()) {
      this.sendIndex(path2);
      return res;
    }
    this.sendFile(path2);
    return res;
  };
  SendStream.prototype.send = function send(path2, stat) {
    var len = stat.size;
    var options = this.options;
    var opts = {};
    var res = this.res;
    var req = this.req;
    var ranges = req.headers.range;
    var offset = options.start || 0;
    if (headersSent(res)) {
      this.headersAlreadySent();
      return;
    }
    debug('pipe "%s"', path2);
    this.setHeader(path2, stat);
    this.type(path2);
    if (this.isConditionalGET()) {
      if (this.isPreconditionFailure()) {
        this.error(412);
        return;
      }
      if (this.isCachable() && this.isFresh()) {
        this.notModified();
        return;
      }
    }
    len = Math.max(0, len - offset);
    if (options.end !== undefined) {
      var bytes = options.end - offset + 1;
      if (len > bytes)
        len = bytes;
    }
    if (this._acceptRanges && BYTES_RANGE_REGEXP.test(ranges)) {
      ranges = parseRange(len, ranges, {
        combine: true
      });
      if (!this.isRangeFresh()) {
        debug("range stale");
        ranges = -2;
      }
      if (ranges === -1) {
        debug("range unsatisfiable");
        res.setHeader("Content-Range", contentRange("bytes", len));
        return this.error(416, {
          headers: { "Content-Range": res.getHeader("Content-Range") }
        });
      }
      if (ranges !== -2 && ranges.length === 1) {
        debug("range %j", ranges);
        res.statusCode = 206;
        res.setHeader("Content-Range", contentRange("bytes", len, ranges[0]));
        offset += ranges[0].start;
        len = ranges[0].end - ranges[0].start + 1;
      }
    }
    for (var prop in options) {
      opts[prop] = options[prop];
    }
    opts.start = offset;
    opts.end = Math.max(offset, offset + len - 1);
    res.setHeader("Content-Length", len);
    if (req.method === "HEAD") {
      res.end();
      return;
    }
    this.stream(path2, opts);
  };
  SendStream.prototype.sendFile = function sendFile(path2) {
    var i = 0;
    var self2 = this;
    debug('stat "%s"', path2);
    fs.stat(path2, function onstat(err, stat) {
      if (err && err.code === "ENOENT" && !extname(path2) && path2[path2.length - 1] !== sep) {
        return next(err);
      }
      if (err)
        return self2.onStatError(err);
      if (stat.isDirectory())
        return self2.redirect(path2);
      self2.emit("file", path2, stat);
      self2.send(path2, stat);
    });
    function next(err) {
      if (self2._extensions.length <= i) {
        return err ? self2.onStatError(err) : self2.error(404);
      }
      var p = path2 + "." + self2._extensions[i++];
      debug('stat "%s"', p);
      fs.stat(p, function(err2, stat) {
        if (err2)
          return next(err2);
        if (stat.isDirectory())
          return next();
        self2.emit("file", p, stat);
        self2.send(p, stat);
      });
    }
  };
  SendStream.prototype.sendIndex = function sendIndex(path2) {
    var i = -1;
    var self2 = this;
    function next(err) {
      if (++i >= self2._index.length) {
        if (err)
          return self2.onStatError(err);
        return self2.error(404);
      }
      var p = join(path2, self2._index[i]);
      debug('stat "%s"', p);
      fs.stat(p, function(err2, stat) {
        if (err2)
          return next(err2);
        if (stat.isDirectory())
          return next();
        self2.emit("file", p, stat);
        self2.send(p, stat);
      });
    }
    next();
  };
  SendStream.prototype.stream = function stream(path2, options) {
    var finished = false;
    var self2 = this;
    var res = this.res;
    var stream = fs.createReadStream(path2, options);
    this.emit("stream", stream);
    stream.pipe(res);
    onFinished(res, function onfinished() {
      finished = true;
      destroy(stream);
    });
    stream.on("error", function onerror(err) {
      if (finished)
        return;
      finished = true;
      destroy(stream);
      self2.onStatError(err);
    });
    stream.on("end", function onend() {
      self2.emit("end");
    });
  };
  SendStream.prototype.type = function type(path2) {
    var res = this.res;
    if (res.getHeader("Content-Type"))
      return;
    var type = mime.lookup(path2);
    if (!type) {
      debug("no content-type");
      return;
    }
    var charset = mime.charsets.lookup(type);
    debug("content-type %s", type);
    res.setHeader("Content-Type", type + (charset ? "; charset=" + charset : ""));
  };
  SendStream.prototype.setHeader = function setHeader(path2, stat) {
    var res = this.res;
    this.emit("headers", res, path2, stat);
    if (this._acceptRanges && !res.getHeader("Accept-Ranges")) {
      debug("accept ranges");
      res.setHeader("Accept-Ranges", "bytes");
    }
    if (this._cacheControl && !res.getHeader("Cache-Control")) {
      var cacheControl = "public, max-age=" + Math.floor(this._maxage / 1000);
      if (this._immutable) {
        cacheControl += ", immutable";
      }
      debug("cache-control %s", cacheControl);
      res.setHeader("Cache-Control", cacheControl);
    }
    if (this._lastModified && !res.getHeader("Last-Modified")) {
      var modified = stat.mtime.toUTCString();
      debug("modified %s", modified);
      res.setHeader("Last-Modified", modified);
    }
    if (this._etag && !res.getHeader("ETag")) {
      var val = etag(stat);
      debug("etag %s", val);
      res.setHeader("ETag", val);
    }
  };
  function clearHeaders(res) {
    var headers = getHeaderNames(res);
    for (var i = 0;i < headers.length; i++) {
      res.removeHeader(headers[i]);
    }
  }
  function collapseLeadingSlashes(str) {
    for (var i = 0;i < str.length; i++) {
      if (str[i] !== "/") {
        break;
      }
    }
    return i > 1 ? "/" + str.substr(i) : str;
  }
  function containsDotFile(parts) {
    for (var i = 0;i < parts.length; i++) {
      var part = parts[i];
      if (part.length > 1 && part[0] === ".") {
        return true;
      }
    }
    return false;
  }
  function contentRange(type, size, range) {
    return type + " " + (range ? range.start + "-" + range.end : "*") + "/" + size;
  }
  function createHtmlDocument(title, body) {
    return `<!DOCTYPE html>
` + `<html lang="en">
` + `<head>
` + `<meta charset="utf-8">
` + "<title>" + title + `</title>
` + `</head>
` + `<body>
` + "<pre>" + body + `</pre>
` + `</body>
` + `</html>
`;
  }
  function decode(path2) {
    try {
      return decodeURIComponent(path2);
    } catch (err) {
      return -1;
    }
  }
  function getHeaderNames(res) {
    return typeof res.getHeaderNames !== "function" ? Object.keys(res._headers || {}) : res.getHeaderNames();
  }
  function hasListeners(emitter, type) {
    var count = typeof emitter.listenerCount !== "function" ? emitter.listeners(type).length : emitter.listenerCount(type);
    return count > 0;
  }
  function headersSent(res) {
    return typeof res.headersSent !== "boolean" ? Boolean(res._header) : res.headersSent;
  }
  function normalizeList(val, name) {
    var list = [].concat(val || []);
    for (var i = 0;i < list.length; i++) {
      if (typeof list[i] !== "string") {
        throw new TypeError(name + " must be array of strings or false");
      }
    }
    return list;
  }
  function parseHttpDate(date) {
    var timestamp = date && Date.parse(date);
    return typeof timestamp === "number" ? timestamp : NaN;
  }
  function parseTokenList(str) {
    var end = 0;
    var list = [];
    var start = 0;
    for (var i = 0, len = str.length;i < len; i++) {
      switch (str.charCodeAt(i)) {
        case 32:
          if (start === end) {
            start = end = i + 1;
          }
          break;
        case 44:
          list.push(str.substring(start, end));
          start = end = i + 1;
          break;
        default:
          end = i + 1;
          break;
      }
    }
    list.push(str.substring(start, end));
    return list;
  }
  function setHeaders(res, headers) {
    var keys = Object.keys(headers);
    for (var i = 0;i < keys.length; i++) {
      var key = keys[i];
      res.setHeader(key, headers[key]);
    }
  }
});

// node_modules/forwarded/index.js
var require_forwarded = __commonJS((exports, module) => {
  /*!
   * forwarded
   * Copyright(c) 2014-2017 Douglas Christopher Wilson
   * MIT Licensed
   */
  module.exports = forwarded;
  function forwarded(req) {
    if (!req) {
      throw new TypeError("argument req is required");
    }
    var proxyAddrs = parse(req.headers["x-forwarded-for"] || "");
    var socketAddr = getSocketAddr(req);
    var addrs = [socketAddr].concat(proxyAddrs);
    return addrs;
  }
  function getSocketAddr(req) {
    return req.socket ? req.socket.remoteAddress : req.connection.remoteAddress;
  }
  function parse(header) {
    var end = header.length;
    var list = [];
    var start = header.length;
    for (var i = header.length - 1;i >= 0; i--) {
      switch (header.charCodeAt(i)) {
        case 32:
          if (start === end) {
            start = end = i;
          }
          break;
        case 44:
          if (start !== end) {
            list.push(header.substring(start, end));
          }
          start = end = i;
          break;
        default:
          start = i;
          break;
      }
    }
    if (start !== end) {
      list.push(header.substring(start, end));
    }
    return list;
  }
});

// node_modules/ipaddr.js/lib/ipaddr.js
var require_ipaddr = __commonJS((exports, module) => {
  (function() {
    var expandIPv6, ipaddr, ipv4Part, ipv4Regexes, ipv6Part, ipv6Regexes, matchCIDR, root, zoneIndex;
    ipaddr = {};
    root = this;
    if (typeof module !== "undefined" && module !== null && module.exports) {
      module.exports = ipaddr;
    } else {
      root["ipaddr"] = ipaddr;
    }
    matchCIDR = function(first, second, partSize, cidrBits) {
      var part, shift;
      if (first.length !== second.length) {
        throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
      }
      part = 0;
      while (cidrBits > 0) {
        shift = partSize - cidrBits;
        if (shift < 0) {
          shift = 0;
        }
        if (first[part] >> shift !== second[part] >> shift) {
          return false;
        }
        cidrBits -= partSize;
        part += 1;
      }
      return true;
    };
    ipaddr.subnetMatch = function(address, rangeList, defaultName) {
      var k, len, rangeName, rangeSubnets, subnet;
      if (defaultName == null) {
        defaultName = "unicast";
      }
      for (rangeName in rangeList) {
        rangeSubnets = rangeList[rangeName];
        if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {
          rangeSubnets = [rangeSubnets];
        }
        for (k = 0, len = rangeSubnets.length;k < len; k++) {
          subnet = rangeSubnets[k];
          if (address.kind() === subnet[0].kind()) {
            if (address.match.apply(address, subnet)) {
              return rangeName;
            }
          }
        }
      }
      return defaultName;
    };
    ipaddr.IPv4 = function() {
      function IPv4(octets) {
        var k, len, octet;
        if (octets.length !== 4) {
          throw new Error("ipaddr: ipv4 octet count should be 4");
        }
        for (k = 0, len = octets.length;k < len; k++) {
          octet = octets[k];
          if (!(0 <= octet && octet <= 255)) {
            throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
          }
        }
        this.octets = octets;
      }
      IPv4.prototype.kind = function() {
        return "ipv4";
      };
      IPv4.prototype.toString = function() {
        return this.octets.join(".");
      };
      IPv4.prototype.toNormalizedString = function() {
        return this.toString();
      };
      IPv4.prototype.toByteArray = function() {
        return this.octets.slice(0);
      };
      IPv4.prototype.match = function(other, cidrRange) {
        var ref;
        if (cidrRange === undefined) {
          ref = other, other = ref[0], cidrRange = ref[1];
        }
        if (other.kind() !== "ipv4") {
          throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
        }
        return matchCIDR(this.octets, other.octets, 8, cidrRange);
      };
      IPv4.prototype.SpecialRanges = {
        unspecified: [[new IPv4([0, 0, 0, 0]), 8]],
        broadcast: [[new IPv4([255, 255, 255, 255]), 32]],
        multicast: [[new IPv4([224, 0, 0, 0]), 4]],
        linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],
        loopback: [[new IPv4([127, 0, 0, 0]), 8]],
        carrierGradeNat: [[new IPv4([100, 64, 0, 0]), 10]],
        private: [[new IPv4([10, 0, 0, 0]), 8], [new IPv4([172, 16, 0, 0]), 12], [new IPv4([192, 168, 0, 0]), 16]],
        reserved: [[new IPv4([192, 0, 0, 0]), 24], [new IPv4([192, 0, 2, 0]), 24], [new IPv4([192, 88, 99, 0]), 24], [new IPv4([198, 51, 100, 0]), 24], [new IPv4([203, 0, 113, 0]), 24], [new IPv4([240, 0, 0, 0]), 4]]
      };
      IPv4.prototype.range = function() {
        return ipaddr.subnetMatch(this, this.SpecialRanges);
      };
      IPv4.prototype.toIPv4MappedAddress = function() {
        return ipaddr.IPv6.parse("::ffff:" + this.toString());
      };
      IPv4.prototype.prefixLengthFromSubnetMask = function() {
        var cidr, i, k, octet, stop, zeros, zerotable;
        zerotable = {
          0: 8,
          128: 7,
          192: 6,
          224: 5,
          240: 4,
          248: 3,
          252: 2,
          254: 1,
          255: 0
        };
        cidr = 0;
        stop = false;
        for (i = k = 3;k >= 0; i = k += -1) {
          octet = this.octets[i];
          if (octet in zerotable) {
            zeros = zerotable[octet];
            if (stop && zeros !== 0) {
              return null;
            }
            if (zeros !== 8) {
              stop = true;
            }
            cidr += zeros;
          } else {
            return null;
          }
        }
        return 32 - cidr;
      };
      return IPv4;
    }();
    ipv4Part = "(0?\\d+|0x[a-f0-9]+)";
    ipv4Regexes = {
      fourOctet: new RegExp("^" + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "$", "i"),
      longValue: new RegExp("^" + ipv4Part + "$", "i")
    };
    ipaddr.IPv4.parser = function(string) {
      var match, parseIntAuto, part, shift, value;
      parseIntAuto = function(string2) {
        if (string2[0] === "0" && string2[1] !== "x") {
          return parseInt(string2, 8);
        } else {
          return parseInt(string2);
        }
      };
      if (match = string.match(ipv4Regexes.fourOctet)) {
        return function() {
          var k, len, ref, results;
          ref = match.slice(1, 6);
          results = [];
          for (k = 0, len = ref.length;k < len; k++) {
            part = ref[k];
            results.push(parseIntAuto(part));
          }
          return results;
        }();
      } else if (match = string.match(ipv4Regexes.longValue)) {
        value = parseIntAuto(match[1]);
        if (value > 4294967295 || value < 0) {
          throw new Error("ipaddr: address outside defined range");
        }
        return function() {
          var k, results;
          results = [];
          for (shift = k = 0;k <= 24; shift = k += 8) {
            results.push(value >> shift & 255);
          }
          return results;
        }().reverse();
      } else {
        return null;
      }
    };
    ipaddr.IPv6 = function() {
      function IPv6(parts, zoneId) {
        var i, k, l, len, part, ref;
        if (parts.length === 16) {
          this.parts = [];
          for (i = k = 0;k <= 14; i = k += 2) {
            this.parts.push(parts[i] << 8 | parts[i + 1]);
          }
        } else if (parts.length === 8) {
          this.parts = parts;
        } else {
          throw new Error("ipaddr: ipv6 part count should be 8 or 16");
        }
        ref = this.parts;
        for (l = 0, len = ref.length;l < len; l++) {
          part = ref[l];
          if (!(0 <= part && part <= 65535)) {
            throw new Error("ipaddr: ipv6 part should fit in 16 bits");
          }
        }
        if (zoneId) {
          this.zoneId = zoneId;
        }
      }
      IPv6.prototype.kind = function() {
        return "ipv6";
      };
      IPv6.prototype.toString = function() {
        return this.toNormalizedString().replace(/((^|:)(0(:|$))+)/, "::");
      };
      IPv6.prototype.toRFC5952String = function() {
        var bestMatchIndex, bestMatchLength, match, regex, string;
        regex = /((^|:)(0(:|$)){2,})/g;
        string = this.toNormalizedString();
        bestMatchIndex = 0;
        bestMatchLength = -1;
        while (match = regex.exec(string)) {
          if (match[0].length > bestMatchLength) {
            bestMatchIndex = match.index;
            bestMatchLength = match[0].length;
          }
        }
        if (bestMatchLength < 0) {
          return string;
        }
        return string.substring(0, bestMatchIndex) + "::" + string.substring(bestMatchIndex + bestMatchLength);
      };
      IPv6.prototype.toByteArray = function() {
        var bytes, k, len, part, ref;
        bytes = [];
        ref = this.parts;
        for (k = 0, len = ref.length;k < len; k++) {
          part = ref[k];
          bytes.push(part >> 8);
          bytes.push(part & 255);
        }
        return bytes;
      };
      IPv6.prototype.toNormalizedString = function() {
        var addr, part, suffix;
        addr = function() {
          var k, len, ref, results;
          ref = this.parts;
          results = [];
          for (k = 0, len = ref.length;k < len; k++) {
            part = ref[k];
            results.push(part.toString(16));
          }
          return results;
        }.call(this).join(":");
        suffix = "";
        if (this.zoneId) {
          suffix = "%" + this.zoneId;
        }
        return addr + suffix;
      };
      IPv6.prototype.toFixedLengthString = function() {
        var addr, part, suffix;
        addr = function() {
          var k, len, ref, results;
          ref = this.parts;
          results = [];
          for (k = 0, len = ref.length;k < len; k++) {
            part = ref[k];
            results.push(part.toString(16).padStart(4, "0"));
          }
          return results;
        }.call(this).join(":");
        suffix = "";
        if (this.zoneId) {
          suffix = "%" + this.zoneId;
        }
        return addr + suffix;
      };
      IPv6.prototype.match = function(other, cidrRange) {
        var ref;
        if (cidrRange === undefined) {
          ref = other, other = ref[0], cidrRange = ref[1];
        }
        if (other.kind() !== "ipv6") {
          throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
        }
        return matchCIDR(this.parts, other.parts, 16, cidrRange);
      };
      IPv6.prototype.SpecialRanges = {
        unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],
        linkLocal: [new IPv6([65152, 0, 0, 0, 0, 0, 0, 0]), 10],
        multicast: [new IPv6([65280, 0, 0, 0, 0, 0, 0, 0]), 8],
        loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],
        uniqueLocal: [new IPv6([64512, 0, 0, 0, 0, 0, 0, 0]), 7],
        ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 65535, 0, 0]), 96],
        rfc6145: [new IPv6([0, 0, 0, 0, 65535, 0, 0, 0]), 96],
        rfc6052: [new IPv6([100, 65435, 0, 0, 0, 0, 0, 0]), 96],
        "6to4": [new IPv6([8194, 0, 0, 0, 0, 0, 0, 0]), 16],
        teredo: [new IPv6([8193, 0, 0, 0, 0, 0, 0, 0]), 32],
        reserved: [[new IPv6([8193, 3512, 0, 0, 0, 0, 0, 0]), 32]]
      };
      IPv6.prototype.range = function() {
        return ipaddr.subnetMatch(this, this.SpecialRanges);
      };
      IPv6.prototype.isIPv4MappedAddress = function() {
        return this.range() === "ipv4Mapped";
      };
      IPv6.prototype.toIPv4Address = function() {
        var high, low, ref;
        if (!this.isIPv4MappedAddress()) {
          throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
        }
        ref = this.parts.slice(-2), high = ref[0], low = ref[1];
        return new ipaddr.IPv4([high >> 8, high & 255, low >> 8, low & 255]);
      };
      IPv6.prototype.prefixLengthFromSubnetMask = function() {
        var cidr, i, k, part, stop, zeros, zerotable;
        zerotable = {
          0: 16,
          32768: 15,
          49152: 14,
          57344: 13,
          61440: 12,
          63488: 11,
          64512: 10,
          65024: 9,
          65280: 8,
          65408: 7,
          65472: 6,
          65504: 5,
          65520: 4,
          65528: 3,
          65532: 2,
          65534: 1,
          65535: 0
        };
        cidr = 0;
        stop = false;
        for (i = k = 7;k >= 0; i = k += -1) {
          part = this.parts[i];
          if (part in zerotable) {
            zeros = zerotable[part];
            if (stop && zeros !== 0) {
              return null;
            }
            if (zeros !== 16) {
              stop = true;
            }
            cidr += zeros;
          } else {
            return null;
          }
        }
        return 128 - cidr;
      };
      return IPv6;
    }();
    ipv6Part = "(?:[0-9a-f]+::?)+";
    zoneIndex = "%[0-9a-z]{1,}";
    ipv6Regexes = {
      zoneIndex: new RegExp(zoneIndex, "i"),
      native: new RegExp("^(::)?(" + ipv6Part + ")?([0-9a-f]+)?(::)?(" + zoneIndex + ")?$", "i"),
      transitional: new RegExp("^((?:" + ipv6Part + ")|(?:::)(?:" + ipv6Part + ")?)" + (ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part) + ("(" + zoneIndex + ")?$"), "i")
    };
    expandIPv6 = function(string, parts) {
      var colonCount, lastColon, part, replacement, replacementCount, zoneId;
      if (string.indexOf("::") !== string.lastIndexOf("::")) {
        return null;
      }
      zoneId = (string.match(ipv6Regexes["zoneIndex"]) || [])[0];
      if (zoneId) {
        zoneId = zoneId.substring(1);
        string = string.replace(/%.+$/, "");
      }
      colonCount = 0;
      lastColon = -1;
      while ((lastColon = string.indexOf(":", lastColon + 1)) >= 0) {
        colonCount++;
      }
      if (string.substr(0, 2) === "::") {
        colonCount--;
      }
      if (string.substr(-2, 2) === "::") {
        colonCount--;
      }
      if (colonCount > parts) {
        return null;
      }
      replacementCount = parts - colonCount;
      replacement = ":";
      while (replacementCount--) {
        replacement += "0:";
      }
      string = string.replace("::", replacement);
      if (string[0] === ":") {
        string = string.slice(1);
      }
      if (string[string.length - 1] === ":") {
        string = string.slice(0, -1);
      }
      parts = function() {
        var k, len, ref, results;
        ref = string.split(":");
        results = [];
        for (k = 0, len = ref.length;k < len; k++) {
          part = ref[k];
          results.push(parseInt(part, 16));
        }
        return results;
      }();
      return {
        parts,
        zoneId
      };
    };
    ipaddr.IPv6.parser = function(string) {
      var addr, k, len, match, octet, octets, zoneId;
      if (ipv6Regexes["native"].test(string)) {
        return expandIPv6(string, 8);
      } else if (match = string.match(ipv6Regexes["transitional"])) {
        zoneId = match[6] || "";
        addr = expandIPv6(match[1].slice(0, -1) + zoneId, 6);
        if (addr.parts) {
          octets = [parseInt(match[2]), parseInt(match[3]), parseInt(match[4]), parseInt(match[5])];
          for (k = 0, len = octets.length;k < len; k++) {
            octet = octets[k];
            if (!(0 <= octet && octet <= 255)) {
              return null;
            }
          }
          addr.parts.push(octets[0] << 8 | octets[1]);
          addr.parts.push(octets[2] << 8 | octets[3]);
          return {
            parts: addr.parts,
            zoneId: addr.zoneId
          };
        }
      }
      return null;
    };
    ipaddr.IPv4.isIPv4 = ipaddr.IPv6.isIPv6 = function(string) {
      return this.parser(string) !== null;
    };
    ipaddr.IPv4.isValid = function(string) {
      var e;
      try {
        new this(this.parser(string));
        return true;
      } catch (error1) {
        e = error1;
        return false;
      }
    };
    ipaddr.IPv4.isValidFourPartDecimal = function(string) {
      if (ipaddr.IPv4.isValid(string) && string.match(/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){3}$/)) {
        return true;
      } else {
        return false;
      }
    };
    ipaddr.IPv6.isValid = function(string) {
      var addr, e;
      if (typeof string === "string" && string.indexOf(":") === -1) {
        return false;
      }
      try {
        addr = this.parser(string);
        new this(addr.parts, addr.zoneId);
        return true;
      } catch (error1) {
        e = error1;
        return false;
      }
    };
    ipaddr.IPv4.parse = function(string) {
      var parts;
      parts = this.parser(string);
      if (parts === null) {
        throw new Error("ipaddr: string is not formatted like ip address");
      }
      return new this(parts);
    };
    ipaddr.IPv6.parse = function(string) {
      var addr;
      addr = this.parser(string);
      if (addr.parts === null) {
        throw new Error("ipaddr: string is not formatted like ip address");
      }
      return new this(addr.parts, addr.zoneId);
    };
    ipaddr.IPv4.parseCIDR = function(string) {
      var maskLength, match, parsed;
      if (match = string.match(/^(.+)\/(\d+)$/)) {
        maskLength = parseInt(match[2]);
        if (maskLength >= 0 && maskLength <= 32) {
          parsed = [this.parse(match[1]), maskLength];
          Object.defineProperty(parsed, "toString", {
            value: function() {
              return this.join("/");
            }
          });
          return parsed;
        }
      }
      throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range");
    };
    ipaddr.IPv4.subnetMaskFromPrefixLength = function(prefix) {
      var filledOctetCount, j, octets;
      prefix = parseInt(prefix);
      if (prefix < 0 || prefix > 32) {
        throw new Error("ipaddr: invalid IPv4 prefix length");
      }
      octets = [0, 0, 0, 0];
      j = 0;
      filledOctetCount = Math.floor(prefix / 8);
      while (j < filledOctetCount) {
        octets[j] = 255;
        j++;
      }
      if (filledOctetCount < 4) {
        octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;
      }
      return new this(octets);
    };
    ipaddr.IPv4.broadcastAddressFromCIDR = function(string) {
      var cidr, error, i, ipInterfaceOctets, octets, subnetMaskOctets;
      try {
        cidr = this.parseCIDR(string);
        ipInterfaceOctets = cidr[0].toByteArray();
        subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
        octets = [];
        i = 0;
        while (i < 4) {
          octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);
          i++;
        }
        return new this(octets);
      } catch (error1) {
        error = error1;
        throw new Error("ipaddr: the address does not have IPv4 CIDR format");
      }
    };
    ipaddr.IPv4.networkAddressFromCIDR = function(string) {
      var cidr, error, i, ipInterfaceOctets, octets, subnetMaskOctets;
      try {
        cidr = this.parseCIDR(string);
        ipInterfaceOctets = cidr[0].toByteArray();
        subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
        octets = [];
        i = 0;
        while (i < 4) {
          octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));
          i++;
        }
        return new this(octets);
      } catch (error1) {
        error = error1;
        throw new Error("ipaddr: the address does not have IPv4 CIDR format");
      }
    };
    ipaddr.IPv6.parseCIDR = function(string) {
      var maskLength, match, parsed;
      if (match = string.match(/^(.+)\/(\d+)$/)) {
        maskLength = parseInt(match[2]);
        if (maskLength >= 0 && maskLength <= 128) {
          parsed = [this.parse(match[1]), maskLength];
          Object.defineProperty(parsed, "toString", {
            value: function() {
              return this.join("/");
            }
          });
          return parsed;
        }
      }
      throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range");
    };
    ipaddr.isValid = function(string) {
      return ipaddr.IPv6.isValid(string) || ipaddr.IPv4.isValid(string);
    };
    ipaddr.parse = function(string) {
      if (ipaddr.IPv6.isValid(string)) {
        return ipaddr.IPv6.parse(string);
      } else if (ipaddr.IPv4.isValid(string)) {
        return ipaddr.IPv4.parse(string);
      } else {
        throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
      }
    };
    ipaddr.parseCIDR = function(string) {
      var e;
      try {
        return ipaddr.IPv6.parseCIDR(string);
      } catch (error1) {
        e = error1;
        try {
          return ipaddr.IPv4.parseCIDR(string);
        } catch (error12) {
          e = error12;
          throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format");
        }
      }
    };
    ipaddr.fromByteArray = function(bytes) {
      var length;
      length = bytes.length;
      if (length === 4) {
        return new ipaddr.IPv4(bytes);
      } else if (length === 16) {
        return new ipaddr.IPv6(bytes);
      } else {
        throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address");
      }
    };
    ipaddr.process = function(string) {
      var addr;
      addr = this.parse(string);
      if (addr.kind() === "ipv6" && addr.isIPv4MappedAddress()) {
        return addr.toIPv4Address();
      } else {
        return addr;
      }
    };
  }).call(exports);
});

// node_modules/proxy-addr/index.js
var require_proxy_addr = __commonJS((exports, module) => {
  /*!
   * proxy-addr
   * Copyright(c) 2014-2016 Douglas Christopher Wilson
   * MIT Licensed
   */
  module.exports = proxyaddr;
  module.exports.all = alladdrs;
  module.exports.compile = compile;
  var forwarded = require_forwarded();
  var ipaddr = require_ipaddr();
  var DIGIT_REGEXP = /^[0-9]+$/;
  var isip = ipaddr.isValid;
  var parseip = ipaddr.parse;
  var IP_RANGES = {
    linklocal: ["169.254.0.0/16", "fe80::/10"],
    loopback: ["127.0.0.1/8", "::1/128"],
    uniquelocal: ["10.0.0.0/8", "172.16.0.0/12", "192.168.0.0/16", "fc00::/7"]
  };
  function alladdrs(req, trust) {
    var addrs = forwarded(req);
    if (!trust) {
      return addrs;
    }
    if (typeof trust !== "function") {
      trust = compile(trust);
    }
    for (var i = 0;i < addrs.length - 1; i++) {
      if (trust(addrs[i], i))
        continue;
      addrs.length = i + 1;
    }
    return addrs;
  }
  function compile(val) {
    if (!val) {
      throw new TypeError("argument is required");
    }
    var trust;
    if (typeof val === "string") {
      trust = [val];
    } else if (Array.isArray(val)) {
      trust = val.slice();
    } else {
      throw new TypeError("unsupported trust argument");
    }
    for (var i = 0;i < trust.length; i++) {
      val = trust[i];
      if (!Object.prototype.hasOwnProperty.call(IP_RANGES, val)) {
        continue;
      }
      val = IP_RANGES[val];
      trust.splice.apply(trust, [i, 1].concat(val));
      i += val.length - 1;
    }
    return compileTrust(compileRangeSubnets(trust));
  }
  function compileRangeSubnets(arr) {
    var rangeSubnets = new Array(arr.length);
    for (var i = 0;i < arr.length; i++) {
      rangeSubnets[i] = parseipNotation(arr[i]);
    }
    return rangeSubnets;
  }
  function compileTrust(rangeSubnets) {
    var len = rangeSubnets.length;
    return len === 0 ? trustNone : len === 1 ? trustSingle(rangeSubnets[0]) : trustMulti(rangeSubnets);
  }
  function parseipNotation(note) {
    var pos = note.lastIndexOf("/");
    var str = pos !== -1 ? note.substring(0, pos) : note;
    if (!isip(str)) {
      throw new TypeError("invalid IP address: " + str);
    }
    var ip = parseip(str);
    if (pos === -1 && ip.kind() === "ipv6" && ip.isIPv4MappedAddress()) {
      ip = ip.toIPv4Address();
    }
    var max = ip.kind() === "ipv6" ? 128 : 32;
    var range = pos !== -1 ? note.substring(pos + 1, note.length) : null;
    if (range === null) {
      range = max;
    } else if (DIGIT_REGEXP.test(range)) {
      range = parseInt(range, 10);
    } else if (ip.kind() === "ipv4" && isip(range)) {
      range = parseNetmask(range);
    } else {
      range = null;
    }
    if (range <= 0 || range > max) {
      throw new TypeError("invalid range on address: " + note);
    }
    return [ip, range];
  }
  function parseNetmask(netmask) {
    var ip = parseip(netmask);
    var kind = ip.kind();
    return kind === "ipv4" ? ip.prefixLengthFromSubnetMask() : null;
  }
  function proxyaddr(req, trust) {
    if (!req) {
      throw new TypeError("req argument is required");
    }
    if (!trust) {
      throw new TypeError("trust argument is required");
    }
    var addrs = alladdrs(req, trust);
    var addr = addrs[addrs.length - 1];
    return addr;
  }
  function trustNone() {
    return false;
  }
  function trustMulti(subnets) {
    return function trust(addr) {
      if (!isip(addr))
        return false;
      var ip = parseip(addr);
      var ipconv;
      var kind = ip.kind();
      for (var i = 0;i < subnets.length; i++) {
        var subnet = subnets[i];
        var subnetip = subnet[0];
        var subnetkind = subnetip.kind();
        var subnetrange = subnet[1];
        var trusted = ip;
        if (kind !== subnetkind) {
          if (subnetkind === "ipv4" && !ip.isIPv4MappedAddress()) {
            continue;
          }
          if (!ipconv) {
            ipconv = subnetkind === "ipv4" ? ip.toIPv4Address() : ip.toIPv4MappedAddress();
          }
          trusted = ipconv;
        }
        if (trusted.match(subnetip, subnetrange)) {
          return true;
        }
      }
      return false;
    };
  }
  function trustSingle(subnet) {
    var subnetip = subnet[0];
    var subnetkind = subnetip.kind();
    var subnetisipv4 = subnetkind === "ipv4";
    var subnetrange = subnet[1];
    return function trust(addr) {
      if (!isip(addr))
        return false;
      var ip = parseip(addr);
      var kind = ip.kind();
      if (kind !== subnetkind) {
        if (subnetisipv4 && !ip.isIPv4MappedAddress()) {
          return false;
        }
        ip = subnetisipv4 ? ip.toIPv4Address() : ip.toIPv4MappedAddress();
      }
      return ip.match(subnetip, subnetrange);
    };
  }
});

// node_modules/express/lib/utils.js
var require_utils2 = __commonJS((exports) => {
  /*!
   * express
   * Copyright(c) 2009-2013 TJ Holowaychuk
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  var Buffer2 = require_safe_buffer().Buffer;
  var contentDisposition = require_content_disposition();
  var contentType = require_content_type();
  var deprecate2 = require_depd()("express");
  var flatten = require_array_flatten();
  var mime = require_send().mime;
  var etag = require_etag();
  var proxyaddr = require_proxy_addr();
  var qs = require_lib2();
  var querystring = __require("querystring");
  exports.etag = createETagGenerator({ weak: false });
  exports.wetag = createETagGenerator({ weak: true });
  exports.isAbsolute = function(path) {
    if (path[0] === "/")
      return true;
    if (path[1] === ":" && (path[2] === "\\" || path[2] === "/"))
      return true;
    if (path.substring(0, 2) === "\\\\")
      return true;
  };
  exports.flatten = deprecate2.function(flatten, "utils.flatten: use array-flatten npm module instead");
  exports.normalizeType = function(type) {
    return ~type.indexOf("/") ? acceptParams(type) : { value: mime.lookup(type), params: {} };
  };
  exports.normalizeTypes = function(types) {
    var ret = [];
    for (var i = 0;i < types.length; ++i) {
      ret.push(exports.normalizeType(types[i]));
    }
    return ret;
  };
  exports.contentDisposition = deprecate2.function(contentDisposition, "utils.contentDisposition: use content-disposition npm module instead");
  function acceptParams(str, index) {
    var parts = str.split(/ *; */);
    var ret = { value: parts[0], quality: 1, params: {}, originalIndex: index };
    for (var i = 1;i < parts.length; ++i) {
      var pms = parts[i].split(/ *= */);
      if (pms[0] === "q") {
        ret.quality = parseFloat(pms[1]);
      } else {
        ret.params[pms[0]] = pms[1];
      }
    }
    return ret;
  }
  exports.compileETag = function(val) {
    var fn2;
    if (typeof val === "function") {
      return val;
    }
    switch (val) {
      case true:
        fn2 = exports.wetag;
        break;
      case false:
        break;
      case "strong":
        fn2 = exports.etag;
        break;
      case "weak":
        fn2 = exports.wetag;
        break;
      default:
        throw new TypeError("unknown value for etag function: " + val);
    }
    return fn2;
  };
  exports.compileQueryParser = function compileQueryParser(val) {
    var fn2;
    if (typeof val === "function") {
      return val;
    }
    switch (val) {
      case true:
        fn2 = querystring.parse;
        break;
      case false:
        fn2 = newObject;
        break;
      case "extended":
        fn2 = parseExtendedQueryString;
        break;
      case "simple":
        fn2 = querystring.parse;
        break;
      default:
        throw new TypeError("unknown value for query parser function: " + val);
    }
    return fn2;
  };
  exports.compileTrust = function(val) {
    if (typeof val === "function")
      return val;
    if (val === true) {
      return function() {
        return true;
      };
    }
    if (typeof val === "number") {
      return function(a, i) {
        return i < val;
      };
    }
    if (typeof val === "string") {
      val = val.split(/ *, */);
    }
    return proxyaddr.compile(val || []);
  };
  exports.setCharset = function setCharset(type, charset) {
    if (!type || !charset) {
      return type;
    }
    var parsed = contentType.parse(type);
    parsed.parameters.charset = charset;
    return contentType.format(parsed);
  };
  function createETagGenerator(options) {
    return function generateETag(body, encoding) {
      var buf = !Buffer2.isBuffer(body) ? Buffer2.from(body, encoding) : body;
      return etag(buf, options);
    };
  }
  function parseExtendedQueryString(str) {
    return qs.parse(str, {
      allowPrototypes: true
    });
  }
  function newObject() {
    return {};
  }
});

// node_modules/express/lib/application.js
var require_application = __commonJS((exports, module) => {
  /*!
   * express
   * Copyright(c) 2009-2013 TJ Holowaychuk
   * Copyright(c) 2013 Roman Shtylman
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  var finalhandler = require_finalhandler();
  var Router = require_router();
  var methods = require_methods();
  var middleware = require_init();
  var query = require_query();
  var debug = require_src3()("express:application");
  var View = require_view();
  var http = __require("http");
  var compileETag = require_utils2().compileETag;
  var compileQueryParser = require_utils2().compileQueryParser;
  var compileTrust = require_utils2().compileTrust;
  var deprecate2 = require_depd()("express");
  var flatten = require_array_flatten();
  var merge = require_utils_merge();
  var resolve = __require("path").resolve;
  var setPrototypeOf = require_setprototypeof();
  var slice = Array.prototype.slice;
  var app = exports = module.exports = {};
  var trustProxyDefaultSymbol = "@@symbol:trust_proxy_default";
  app.init = function init() {
    this.cache = {};
    this.engines = {};
    this.settings = {};
    this.defaultConfiguration();
  };
  app.defaultConfiguration = function defaultConfiguration() {
    var env = "development";
    this.enable("x-powered-by");
    this.set("etag", "weak");
    this.set("env", env);
    this.set("query parser", "extended");
    this.set("subdomain offset", 2);
    this.set("trust proxy", false);
    Object.defineProperty(this.settings, trustProxyDefaultSymbol, {
      configurable: true,
      value: true
    });
    debug("booting in %s mode", env);
    this.on("mount", function onmount(parent) {
      if (this.settings[trustProxyDefaultSymbol] === true && typeof parent.settings["trust proxy fn"] === "function") {
        delete this.settings["trust proxy"];
        delete this.settings["trust proxy fn"];
      }
      setPrototypeOf(this.request, parent.request);
      setPrototypeOf(this.response, parent.response);
      setPrototypeOf(this.engines, parent.engines);
      setPrototypeOf(this.settings, parent.settings);
    });
    this.locals = Object.create(null);
    this.mountpath = "/";
    this.locals.settings = this.settings;
    this.set("view", View);
    this.set("views", resolve("views"));
    this.set("jsonp callback name", "callback");
    if (env === "production") {
      this.enable("view cache");
    }
    Object.defineProperty(this, "router", {
      get: function() {
        throw new Error(`'app.router' is deprecated!
Please see the 3.x to 4.x migration guide for details on how to update your app.`);
      }
    });
  };
  app.lazyrouter = function lazyrouter() {
    if (!this._router) {
      this._router = new Router({
        caseSensitive: this.enabled("case sensitive routing"),
        strict: this.enabled("strict routing")
      });
      this._router.use(query(this.get("query parser fn")));
      this._router.use(middleware.init(this));
    }
  };
  app.handle = function handle(req, res, callback) {
    var router = this._router;
    var done = callback || finalhandler(req, res, {
      env: this.get("env"),
      onerror: logerror.bind(this)
    });
    if (!router) {
      debug("no routes defined on app");
      done();
      return;
    }
    router.handle(req, res, done);
  };
  app.use = function use(fn2) {
    var offset = 0;
    var path = "/";
    if (typeof fn2 !== "function") {
      var arg = fn2;
      while (Array.isArray(arg) && arg.length !== 0) {
        arg = arg[0];
      }
      if (typeof arg !== "function") {
        offset = 1;
        path = fn2;
      }
    }
    var fns = flatten(slice.call(arguments, offset));
    if (fns.length === 0) {
      throw new TypeError("app.use() requires a middleware function");
    }
    this.lazyrouter();
    var router = this._router;
    fns.forEach(function(fn3) {
      if (!fn3 || !fn3.handle || !fn3.set) {
        return router.use(path, fn3);
      }
      debug(".use app under %s", path);
      fn3.mountpath = path;
      fn3.parent = this;
      router.use(path, function mounted_app(req, res, next) {
        var orig = req.app;
        fn3.handle(req, res, function(err) {
          setPrototypeOf(req, orig.request);
          setPrototypeOf(res, orig.response);
          next(err);
        });
      });
      fn3.emit("mount", this);
    }, this);
    return this;
  };
  app.route = function route(path) {
    this.lazyrouter();
    return this._router.route(path);
  };
  app.engine = function engine(ext, fn2) {
    if (typeof fn2 !== "function") {
      throw new Error("callback function required");
    }
    var extension = ext[0] !== "." ? "." + ext : ext;
    this.engines[extension] = fn2;
    return this;
  };
  app.param = function param(name, fn2) {
    this.lazyrouter();
    if (Array.isArray(name)) {
      for (var i = 0;i < name.length; i++) {
        this.param(name[i], fn2);
      }
      return this;
    }
    this._router.param(name, fn2);
    return this;
  };
  app.set = function set(setting, val) {
    if (arguments.length === 1) {
      return this.settings[setting];
    }
    debug('set "%s" to %o', setting, val);
    this.settings[setting] = val;
    switch (setting) {
      case "etag":
        this.set("etag fn", compileETag(val));
        break;
      case "query parser":
        this.set("query parser fn", compileQueryParser(val));
        break;
      case "trust proxy":
        this.set("trust proxy fn", compileTrust(val));
        Object.defineProperty(this.settings, trustProxyDefaultSymbol, {
          configurable: true,
          value: false
        });
        break;
    }
    return this;
  };
  app.path = function path() {
    return this.parent ? this.parent.path() + this.mountpath : "";
  };
  app.enabled = function enabled(setting) {
    return Boolean(this.set(setting));
  };
  app.disabled = function disabled(setting) {
    return !this.set(setting);
  };
  app.enable = function enable(setting) {
    return this.set(setting, true);
  };
  app.disable = function disable(setting) {
    return this.set(setting, false);
  };
  methods.forEach(function(method) {
    app[method] = function(path) {
      if (method === "get" && arguments.length === 1) {
        return this.set(path);
      }
      this.lazyrouter();
      var route = this._router.route(path);
      route[method].apply(route, slice.call(arguments, 1));
      return this;
    };
  });
  app.all = function all(path) {
    this.lazyrouter();
    var route = this._router.route(path);
    var args2 = slice.call(arguments, 1);
    for (var i = 0;i < methods.length; i++) {
      route[methods[i]].apply(route, args2);
    }
    return this;
  };
  app.del = deprecate2.function(app.delete, "app.del: Use app.delete instead");
  app.render = function render(name, options, callback) {
    var cache = this.cache;
    var done = callback;
    var engines = this.engines;
    var opts = options;
    var renderOptions = {};
    var view;
    if (typeof options === "function") {
      done = options;
      opts = {};
    }
    merge(renderOptions, this.locals);
    if (opts._locals) {
      merge(renderOptions, opts._locals);
    }
    merge(renderOptions, opts);
    if (renderOptions.cache == null) {
      renderOptions.cache = this.enabled("view cache");
    }
    if (renderOptions.cache) {
      view = cache[name];
    }
    if (!view) {
      var View2 = this.get("view");
      view = new View2(name, {
        defaultEngine: this.get("view engine"),
        root: this.get("views"),
        engines
      });
      if (!view.path) {
        var dirs = Array.isArray(view.root) && view.root.length > 1 ? 'directories "' + view.root.slice(0, -1).join('", "') + '" or "' + view.root[view.root.length - 1] + '"' : 'directory "' + view.root + '"';
        var err = new Error('Failed to lookup view "' + name + '" in views ' + dirs);
        err.view = view;
        return done(err);
      }
      if (renderOptions.cache) {
        cache[name] = view;
      }
    }
    tryRender(view, renderOptions, done);
  };
  app.listen = function listen() {
    var server = http.createServer(this);
    return server.listen.apply(server, arguments);
  };
  function logerror(err) {
    if (this.get("env") !== "test")
      console.error(err.stack || err.toString());
  }
  function tryRender(view, options, callback) {
    try {
      view.render(options, callback);
    } catch (err) {
      callback(err);
    }
  }
});

// node_modules/negotiator/lib/charset.js
var require_charset = __commonJS((exports, module) => {
  module.exports = preferredCharsets;
  module.exports.preferredCharsets = preferredCharsets;
  var simpleCharsetRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
  function parseAcceptCharset(accept) {
    var accepts = accept.split(",");
    for (var i = 0, j = 0;i < accepts.length; i++) {
      var charset = parseCharset(accepts[i].trim(), i);
      if (charset) {
        accepts[j++] = charset;
      }
    }
    accepts.length = j;
    return accepts;
  }
  function parseCharset(str, i) {
    var match = simpleCharsetRegExp.exec(str);
    if (!match)
      return null;
    var charset = match[1];
    var q = 1;
    if (match[2]) {
      var params = match[2].split(";");
      for (var j = 0;j < params.length; j++) {
        var p = params[j].trim().split("=");
        if (p[0] === "q") {
          q = parseFloat(p[1]);
          break;
        }
      }
    }
    return {
      charset,
      q,
      i
    };
  }
  function getCharsetPriority(charset, accepted, index) {
    var priority = { o: -1, q: 0, s: 0 };
    for (var i = 0;i < accepted.length; i++) {
      var spec = specify(charset, accepted[i], index);
      if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
        priority = spec;
      }
    }
    return priority;
  }
  function specify(charset, spec, index) {
    var s = 0;
    if (spec.charset.toLowerCase() === charset.toLowerCase()) {
      s |= 1;
    } else if (spec.charset !== "*") {
      return null;
    }
    return {
      i: index,
      o: spec.i,
      q: spec.q,
      s
    };
  }
  function preferredCharsets(accept, provided) {
    var accepts = parseAcceptCharset(accept === undefined ? "*" : accept || "");
    if (!provided) {
      return accepts.filter(isQuality).sort(compareSpecs).map(getFullCharset);
    }
    var priorities = provided.map(function getPriority(type, index) {
      return getCharsetPriority(type, accepts, index);
    });
    return priorities.filter(isQuality).sort(compareSpecs).map(function getCharset(priority) {
      return provided[priorities.indexOf(priority)];
    });
  }
  function compareSpecs(a, b) {
    return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
  }
  function getFullCharset(spec) {
    return spec.charset;
  }
  function isQuality(spec) {
    return spec.q > 0;
  }
});

// node_modules/negotiator/lib/encoding.js
var require_encoding = __commonJS((exports, module) => {
  module.exports = preferredEncodings;
  module.exports.preferredEncodings = preferredEncodings;
  var simpleEncodingRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
  function parseAcceptEncoding(accept) {
    var accepts = accept.split(",");
    var hasIdentity = false;
    var minQuality = 1;
    for (var i = 0, j = 0;i < accepts.length; i++) {
      var encoding = parseEncoding(accepts[i].trim(), i);
      if (encoding) {
        accepts[j++] = encoding;
        hasIdentity = hasIdentity || specify("identity", encoding);
        minQuality = Math.min(minQuality, encoding.q || 1);
      }
    }
    if (!hasIdentity) {
      accepts[j++] = {
        encoding: "identity",
        q: minQuality,
        i
      };
    }
    accepts.length = j;
    return accepts;
  }
  function parseEncoding(str, i) {
    var match = simpleEncodingRegExp.exec(str);
    if (!match)
      return null;
    var encoding = match[1];
    var q = 1;
    if (match[2]) {
      var params = match[2].split(";");
      for (var j = 0;j < params.length; j++) {
        var p = params[j].trim().split("=");
        if (p[0] === "q") {
          q = parseFloat(p[1]);
          break;
        }
      }
    }
    return {
      encoding,
      q,
      i
    };
  }
  function getEncodingPriority(encoding, accepted, index) {
    var priority = { o: -1, q: 0, s: 0 };
    for (var i = 0;i < accepted.length; i++) {
      var spec = specify(encoding, accepted[i], index);
      if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
        priority = spec;
      }
    }
    return priority;
  }
  function specify(encoding, spec, index) {
    var s = 0;
    if (spec.encoding.toLowerCase() === encoding.toLowerCase()) {
      s |= 1;
    } else if (spec.encoding !== "*") {
      return null;
    }
    return {
      i: index,
      o: spec.i,
      q: spec.q,
      s
    };
  }
  function preferredEncodings(accept, provided) {
    var accepts = parseAcceptEncoding(accept || "");
    if (!provided) {
      return accepts.filter(isQuality).sort(compareSpecs).map(getFullEncoding);
    }
    var priorities = provided.map(function getPriority(type, index) {
      return getEncodingPriority(type, accepts, index);
    });
    return priorities.filter(isQuality).sort(compareSpecs).map(function getEncoding(priority) {
      return provided[priorities.indexOf(priority)];
    });
  }
  function compareSpecs(a, b) {
    return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
  }
  function getFullEncoding(spec) {
    return spec.encoding;
  }
  function isQuality(spec) {
    return spec.q > 0;
  }
});

// node_modules/negotiator/lib/language.js
var require_language = __commonJS((exports, module) => {
  module.exports = preferredLanguages;
  module.exports.preferredLanguages = preferredLanguages;
  var simpleLanguageRegExp = /^\s*([^\s\-;]+)(?:-([^\s;]+))?\s*(?:;(.*))?$/;
  function parseAcceptLanguage(accept) {
    var accepts = accept.split(",");
    for (var i = 0, j = 0;i < accepts.length; i++) {
      var language = parseLanguage(accepts[i].trim(), i);
      if (language) {
        accepts[j++] = language;
      }
    }
    accepts.length = j;
    return accepts;
  }
  function parseLanguage(str, i) {
    var match = simpleLanguageRegExp.exec(str);
    if (!match)
      return null;
    var prefix = match[1], suffix = match[2], full = prefix;
    if (suffix)
      full += "-" + suffix;
    var q = 1;
    if (match[3]) {
      var params = match[3].split(";");
      for (var j = 0;j < params.length; j++) {
        var p = params[j].split("=");
        if (p[0] === "q")
          q = parseFloat(p[1]);
      }
    }
    return {
      prefix,
      suffix,
      q,
      i,
      full
    };
  }
  function getLanguagePriority(language, accepted, index) {
    var priority = { o: -1, q: 0, s: 0 };
    for (var i = 0;i < accepted.length; i++) {
      var spec = specify(language, accepted[i], index);
      if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
        priority = spec;
      }
    }
    return priority;
  }
  function specify(language, spec, index) {
    var p = parseLanguage(language);
    if (!p)
      return null;
    var s = 0;
    if (spec.full.toLowerCase() === p.full.toLowerCase()) {
      s |= 4;
    } else if (spec.prefix.toLowerCase() === p.full.toLowerCase()) {
      s |= 2;
    } else if (spec.full.toLowerCase() === p.prefix.toLowerCase()) {
      s |= 1;
    } else if (spec.full !== "*") {
      return null;
    }
    return {
      i: index,
      o: spec.i,
      q: spec.q,
      s
    };
  }
  function preferredLanguages(accept, provided) {
    var accepts = parseAcceptLanguage(accept === undefined ? "*" : accept || "");
    if (!provided) {
      return accepts.filter(isQuality).sort(compareSpecs).map(getFullLanguage);
    }
    var priorities = provided.map(function getPriority(type, index) {
      return getLanguagePriority(type, accepts, index);
    });
    return priorities.filter(isQuality).sort(compareSpecs).map(function getLanguage(priority) {
      return provided[priorities.indexOf(priority)];
    });
  }
  function compareSpecs(a, b) {
    return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
  }
  function getFullLanguage(spec) {
    return spec.full;
  }
  function isQuality(spec) {
    return spec.q > 0;
  }
});

// node_modules/negotiator/lib/mediaType.js
var require_mediaType = __commonJS((exports, module) => {
  module.exports = preferredMediaTypes;
  module.exports.preferredMediaTypes = preferredMediaTypes;
  var simpleMediaTypeRegExp = /^\s*([^\s\/;]+)\/([^;\s]+)\s*(?:;(.*))?$/;
  function parseAccept(accept) {
    var accepts = splitMediaTypes(accept);
    for (var i = 0, j = 0;i < accepts.length; i++) {
      var mediaType = parseMediaType(accepts[i].trim(), i);
      if (mediaType) {
        accepts[j++] = mediaType;
      }
    }
    accepts.length = j;
    return accepts;
  }
  function parseMediaType(str, i) {
    var match = simpleMediaTypeRegExp.exec(str);
    if (!match)
      return null;
    var params = Object.create(null);
    var q = 1;
    var subtype = match[2];
    var type = match[1];
    if (match[3]) {
      var kvps = splitParameters(match[3]).map(splitKeyValuePair);
      for (var j = 0;j < kvps.length; j++) {
        var pair = kvps[j];
        var key = pair[0].toLowerCase();
        var val = pair[1];
        var value = val && val[0] === '"' && val[val.length - 1] === '"' ? val.substr(1, val.length - 2) : val;
        if (key === "q") {
          q = parseFloat(value);
          break;
        }
        params[key] = value;
      }
    }
    return {
      type,
      subtype,
      params,
      q,
      i
    };
  }
  function getMediaTypePriority(type, accepted, index) {
    var priority = { o: -1, q: 0, s: 0 };
    for (var i = 0;i < accepted.length; i++) {
      var spec = specify(type, accepted[i], index);
      if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
        priority = spec;
      }
    }
    return priority;
  }
  function specify(type, spec, index) {
    var p = parseMediaType(type);
    var s = 0;
    if (!p) {
      return null;
    }
    if (spec.type.toLowerCase() == p.type.toLowerCase()) {
      s |= 4;
    } else if (spec.type != "*") {
      return null;
    }
    if (spec.subtype.toLowerCase() == p.subtype.toLowerCase()) {
      s |= 2;
    } else if (spec.subtype != "*") {
      return null;
    }
    var keys = Object.keys(spec.params);
    if (keys.length > 0) {
      if (keys.every(function(k) {
        return spec.params[k] == "*" || (spec.params[k] || "").toLowerCase() == (p.params[k] || "").toLowerCase();
      })) {
        s |= 1;
      } else {
        return null;
      }
    }
    return {
      i: index,
      o: spec.i,
      q: spec.q,
      s
    };
  }
  function preferredMediaTypes(accept, provided) {
    var accepts = parseAccept(accept === undefined ? "*/*" : accept || "");
    if (!provided) {
      return accepts.filter(isQuality).sort(compareSpecs).map(getFullType);
    }
    var priorities = provided.map(function getPriority(type, index) {
      return getMediaTypePriority(type, accepts, index);
    });
    return priorities.filter(isQuality).sort(compareSpecs).map(function getType(priority) {
      return provided[priorities.indexOf(priority)];
    });
  }
  function compareSpecs(a, b) {
    return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
  }
  function getFullType(spec) {
    return spec.type + "/" + spec.subtype;
  }
  function isQuality(spec) {
    return spec.q > 0;
  }
  function quoteCount(string) {
    var count = 0;
    var index = 0;
    while ((index = string.indexOf('"', index)) !== -1) {
      count++;
      index++;
    }
    return count;
  }
  function splitKeyValuePair(str) {
    var index = str.indexOf("=");
    var key;
    var val;
    if (index === -1) {
      key = str;
    } else {
      key = str.substr(0, index);
      val = str.substr(index + 1);
    }
    return [key, val];
  }
  function splitMediaTypes(accept) {
    var accepts = accept.split(",");
    for (var i = 1, j = 0;i < accepts.length; i++) {
      if (quoteCount(accepts[j]) % 2 == 0) {
        accepts[++j] = accepts[i];
      } else {
        accepts[j] += "," + accepts[i];
      }
    }
    accepts.length = j + 1;
    return accepts;
  }
  function splitParameters(str) {
    var parameters = str.split(";");
    for (var i = 1, j = 0;i < parameters.length; i++) {
      if (quoteCount(parameters[j]) % 2 == 0) {
        parameters[++j] = parameters[i];
      } else {
        parameters[j] += ";" + parameters[i];
      }
    }
    parameters.length = j + 1;
    for (var i = 0;i < parameters.length; i++) {
      parameters[i] = parameters[i].trim();
    }
    return parameters;
  }
});

// node_modules/negotiator/index.js
var require_negotiator = __commonJS((exports, module) => {
  /*!
   * negotiator
   * Copyright(c) 2012 Federico Romero
   * Copyright(c) 2012-2014 Isaac Z. Schlueter
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  var modules = Object.create(null);
  module.exports = Negotiator;
  module.exports.Negotiator = Negotiator;
  function Negotiator(request) {
    if (!(this instanceof Negotiator)) {
      return new Negotiator(request);
    }
    this.request = request;
  }
  Negotiator.prototype.charset = function charset(available) {
    var set = this.charsets(available);
    return set && set[0];
  };
  Negotiator.prototype.charsets = function charsets(available) {
    var preferredCharsets = loadModule("charset").preferredCharsets;
    return preferredCharsets(this.request.headers["accept-charset"], available);
  };
  Negotiator.prototype.encoding = function encoding(available) {
    var set = this.encodings(available);
    return set && set[0];
  };
  Negotiator.prototype.encodings = function encodings(available) {
    var preferredEncodings = loadModule("encoding").preferredEncodings;
    return preferredEncodings(this.request.headers["accept-encoding"], available);
  };
  Negotiator.prototype.language = function language(available) {
    var set = this.languages(available);
    return set && set[0];
  };
  Negotiator.prototype.languages = function languages(available) {
    var preferredLanguages = loadModule("language").preferredLanguages;
    return preferredLanguages(this.request.headers["accept-language"], available);
  };
  Negotiator.prototype.mediaType = function mediaType(available) {
    var set = this.mediaTypes(available);
    return set && set[0];
  };
  Negotiator.prototype.mediaTypes = function mediaTypes(available) {
    var preferredMediaTypes = loadModule("mediaType").preferredMediaTypes;
    return preferredMediaTypes(this.request.headers.accept, available);
  };
  Negotiator.prototype.preferredCharset = Negotiator.prototype.charset;
  Negotiator.prototype.preferredCharsets = Negotiator.prototype.charsets;
  Negotiator.prototype.preferredEncoding = Negotiator.prototype.encoding;
  Negotiator.prototype.preferredEncodings = Negotiator.prototype.encodings;
  Negotiator.prototype.preferredLanguage = Negotiator.prototype.language;
  Negotiator.prototype.preferredLanguages = Negotiator.prototype.languages;
  Negotiator.prototype.preferredMediaType = Negotiator.prototype.mediaType;
  Negotiator.prototype.preferredMediaTypes = Negotiator.prototype.mediaTypes;
  function loadModule(moduleName2) {
    var module2 = modules[moduleName2];
    if (module2 !== undefined) {
      return module2;
    }
    switch (moduleName2) {
      case "charset":
        module2 = require_charset();
        break;
      case "encoding":
        module2 = require_encoding();
        break;
      case "language":
        module2 = require_language();
        break;
      case "mediaType":
        module2 = require_mediaType();
        break;
      default:
        throw new Error("Cannot find module '" + moduleName2 + "'");
    }
    modules[moduleName2] = module2;
    return module2;
  }
});

// node_modules/accepts/index.js
var require_accepts = __commonJS((exports, module) => {
  /*!
   * accepts
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  var Negotiator = require_negotiator();
  var mime = require_mime_types();
  module.exports = Accepts;
  function Accepts(req) {
    if (!(this instanceof Accepts)) {
      return new Accepts(req);
    }
    this.headers = req.headers;
    this.negotiator = new Negotiator(req);
  }
  Accepts.prototype.type = Accepts.prototype.types = function(types_) {
    var types = types_;
    if (types && !Array.isArray(types)) {
      types = new Array(arguments.length);
      for (var i = 0;i < types.length; i++) {
        types[i] = arguments[i];
      }
    }
    if (!types || types.length === 0) {
      return this.negotiator.mediaTypes();
    }
    if (!this.headers.accept) {
      return types[0];
    }
    var mimes = types.map(extToMime);
    var accepts = this.negotiator.mediaTypes(mimes.filter(validMime));
    var first = accepts[0];
    return first ? types[mimes.indexOf(first)] : false;
  };
  Accepts.prototype.encoding = Accepts.prototype.encodings = function(encodings_) {
    var encodings = encodings_;
    if (encodings && !Array.isArray(encodings)) {
      encodings = new Array(arguments.length);
      for (var i = 0;i < encodings.length; i++) {
        encodings[i] = arguments[i];
      }
    }
    if (!encodings || encodings.length === 0) {
      return this.negotiator.encodings();
    }
    return this.negotiator.encodings(encodings)[0] || false;
  };
  Accepts.prototype.charset = Accepts.prototype.charsets = function(charsets_) {
    var charsets = charsets_;
    if (charsets && !Array.isArray(charsets)) {
      charsets = new Array(arguments.length);
      for (var i = 0;i < charsets.length; i++) {
        charsets[i] = arguments[i];
      }
    }
    if (!charsets || charsets.length === 0) {
      return this.negotiator.charsets();
    }
    return this.negotiator.charsets(charsets)[0] || false;
  };
  Accepts.prototype.lang = Accepts.prototype.langs = Accepts.prototype.language = Accepts.prototype.languages = function(languages_) {
    var languages = languages_;
    if (languages && !Array.isArray(languages)) {
      languages = new Array(arguments.length);
      for (var i = 0;i < languages.length; i++) {
        languages[i] = arguments[i];
      }
    }
    if (!languages || languages.length === 0) {
      return this.negotiator.languages();
    }
    return this.negotiator.languages(languages)[0] || false;
  };
  function extToMime(type) {
    return type.indexOf("/") === -1 ? mime.lookup(type) : type;
  }
  function validMime(type) {
    return typeof type === "string";
  }
});

// node_modules/express/lib/request.js
var require_request = __commonJS((exports, module) => {
  /*!
   * express
   * Copyright(c) 2009-2013 TJ Holowaychuk
   * Copyright(c) 2013 Roman Shtylman
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  var accepts = require_accepts();
  var deprecate2 = require_depd()("express");
  var isIP = __require("net").isIP;
  var typeis = require_type_is();
  var http = __require("http");
  var fresh = require_fresh();
  var parseRange = require_range_parser();
  var parse = require_parseurl();
  var proxyaddr = require_proxy_addr();
  var req = Object.create(http.IncomingMessage.prototype);
  module.exports = req;
  req.get = req.header = function header(name) {
    if (!name) {
      throw new TypeError("name argument is required to req.get");
    }
    if (typeof name !== "string") {
      throw new TypeError("name must be a string to req.get");
    }
    var lc = name.toLowerCase();
    switch (lc) {
      case "referer":
      case "referrer":
        return this.headers.referrer || this.headers.referer;
      default:
        return this.headers[lc];
    }
  };
  req.accepts = function() {
    var accept = accepts(this);
    return accept.types.apply(accept, arguments);
  };
  req.acceptsEncodings = function() {
    var accept = accepts(this);
    return accept.encodings.apply(accept, arguments);
  };
  req.acceptsEncoding = deprecate2.function(req.acceptsEncodings, "req.acceptsEncoding: Use acceptsEncodings instead");
  req.acceptsCharsets = function() {
    var accept = accepts(this);
    return accept.charsets.apply(accept, arguments);
  };
  req.acceptsCharset = deprecate2.function(req.acceptsCharsets, "req.acceptsCharset: Use acceptsCharsets instead");
  req.acceptsLanguages = function() {
    var accept = accepts(this);
    return accept.languages.apply(accept, arguments);
  };
  req.acceptsLanguage = deprecate2.function(req.acceptsLanguages, "req.acceptsLanguage: Use acceptsLanguages instead");
  req.range = function range(size, options) {
    var range = this.get("Range");
    if (!range)
      return;
    return parseRange(size, range, options);
  };
  req.param = function param(name, defaultValue) {
    var params = this.params || {};
    var body = this.body || {};
    var query = this.query || {};
    var args2 = arguments.length === 1 ? "name" : "name, default";
    deprecate2("req.param(" + args2 + "): Use req.params, req.body, or req.query instead");
    if (params[name] != null && params.hasOwnProperty(name))
      return params[name];
    if (body[name] != null)
      return body[name];
    if (query[name] != null)
      return query[name];
    return defaultValue;
  };
  req.is = function is(types) {
    var arr = types;
    if (!Array.isArray(types)) {
      arr = new Array(arguments.length);
      for (var i = 0;i < arr.length; i++) {
        arr[i] = arguments[i];
      }
    }
    return typeis(this, arr);
  };
  defineGetter(req, "protocol", function protocol() {
    var proto = this.connection.encrypted ? "https" : "http";
    var trust = this.app.get("trust proxy fn");
    if (!trust(this.connection.remoteAddress, 0)) {
      return proto;
    }
    var header = this.get("X-Forwarded-Proto") || proto;
    var index = header.indexOf(",");
    return index !== -1 ? header.substring(0, index).trim() : header.trim();
  });
  defineGetter(req, "secure", function secure() {
    return this.protocol === "https";
  });
  defineGetter(req, "ip", function ip() {
    var trust = this.app.get("trust proxy fn");
    return proxyaddr(this, trust);
  });
  defineGetter(req, "ips", function ips() {
    var trust = this.app.get("trust proxy fn");
    var addrs = proxyaddr.all(this, trust);
    addrs.reverse().pop();
    return addrs;
  });
  defineGetter(req, "subdomains", function subdomains() {
    var hostname = this.hostname;
    if (!hostname)
      return [];
    var offset = this.app.get("subdomain offset");
    var subdomains = !isIP(hostname) ? hostname.split(".").reverse() : [hostname];
    return subdomains.slice(offset);
  });
  defineGetter(req, "path", function path() {
    return parse(this).pathname;
  });
  defineGetter(req, "hostname", function hostname() {
    var trust = this.app.get("trust proxy fn");
    var host = this.get("X-Forwarded-Host");
    if (!host || !trust(this.connection.remoteAddress, 0)) {
      host = this.get("Host");
    } else if (host.indexOf(",") !== -1) {
      host = host.substring(0, host.indexOf(",")).trimRight();
    }
    if (!host)
      return;
    var offset = host[0] === "[" ? host.indexOf("]") + 1 : 0;
    var index = host.indexOf(":", offset);
    return index !== -1 ? host.substring(0, index) : host;
  });
  defineGetter(req, "host", deprecate2.function(function host() {
    return this.hostname;
  }, "req.host: Use req.hostname instead"));
  defineGetter(req, "fresh", function() {
    var method = this.method;
    var res = this.res;
    var status = res.statusCode;
    if (method !== "GET" && method !== "HEAD")
      return false;
    if (status >= 200 && status < 300 || status === 304) {
      return fresh(this.headers, {
        etag: res.get("ETag"),
        "last-modified": res.get("Last-Modified")
      });
    }
    return false;
  });
  defineGetter(req, "stale", function stale() {
    return !this.fresh;
  });
  defineGetter(req, "xhr", function xhr() {
    var val = this.get("X-Requested-With") || "";
    return val.toLowerCase() === "xmlhttprequest";
  });
  function defineGetter(obj, name, getter) {
    Object.defineProperty(obj, name, {
      configurable: true,
      enumerable: true,
      get: getter
    });
  }
});

// node_modules/cookie-signature/index.js
var require_cookie_signature = __commonJS((exports) => {
  var crypto = __require("crypto");
  exports.sign = function(val, secret) {
    if (typeof val != "string")
      throw new TypeError("Cookie value must be provided as a string.");
    if (typeof secret != "string")
      throw new TypeError("Secret string must be provided.");
    return val + "." + crypto.createHmac("sha256", secret).update(val).digest("base64").replace(/\=+$/, "");
  };
  exports.unsign = function(val, secret) {
    if (typeof val != "string")
      throw new TypeError("Signed cookie string must be provided.");
    if (typeof secret != "string")
      throw new TypeError("Secret string must be provided.");
    var str = val.slice(0, val.lastIndexOf(".")), mac = exports.sign(str, secret);
    return sha1(mac) == sha1(val) ? str : false;
  };
  function sha1(str) {
    return crypto.createHash("sha1").update(str).digest("hex");
  }
});

// node_modules/cookie/index.js
var require_cookie = __commonJS((exports) => {
  /*!
   * cookie
   * Copyright(c) 2012-2014 Roman Shtylman
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  exports.parse = parse;
  exports.serialize = serialize;
  var decode = decodeURIComponent;
  var encode = encodeURIComponent;
  var pairSplitRegExp = /; */;
  var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
  function parse(str, options) {
    if (typeof str !== "string") {
      throw new TypeError("argument str must be a string");
    }
    var obj = {};
    var opt = options || {};
    var pairs = str.split(pairSplitRegExp);
    var dec = opt.decode || decode;
    for (var i = 0;i < pairs.length; i++) {
      var pair = pairs[i];
      var eq_idx = pair.indexOf("=");
      if (eq_idx < 0) {
        continue;
      }
      var key = pair.substr(0, eq_idx).trim();
      var val = pair.substr(++eq_idx, pair.length).trim();
      if (val[0] == '"') {
        val = val.slice(1, -1);
      }
      if (obj[key] == undefined) {
        obj[key] = tryDecode(val, dec);
      }
    }
    return obj;
  }
  function serialize(name, val, options) {
    var opt = options || {};
    var enc = opt.encode || encode;
    if (typeof enc !== "function") {
      throw new TypeError("option encode is invalid");
    }
    if (!fieldContentRegExp.test(name)) {
      throw new TypeError("argument name is invalid");
    }
    var value = enc(val);
    if (value && !fieldContentRegExp.test(value)) {
      throw new TypeError("argument val is invalid");
    }
    var str = name + "=" + value;
    if (opt.maxAge != null) {
      var maxAge = opt.maxAge - 0;
      if (isNaN(maxAge))
        throw new Error("maxAge should be a Number");
      str += "; Max-Age=" + Math.floor(maxAge);
    }
    if (opt.domain) {
      if (!fieldContentRegExp.test(opt.domain)) {
        throw new TypeError("option domain is invalid");
      }
      str += "; Domain=" + opt.domain;
    }
    if (opt.path) {
      if (!fieldContentRegExp.test(opt.path)) {
        throw new TypeError("option path is invalid");
      }
      str += "; Path=" + opt.path;
    }
    if (opt.expires) {
      if (typeof opt.expires.toUTCString !== "function") {
        throw new TypeError("option expires is invalid");
      }
      str += "; Expires=" + opt.expires.toUTCString();
    }
    if (opt.httpOnly) {
      str += "; HttpOnly";
    }
    if (opt.secure) {
      str += "; Secure";
    }
    if (opt.sameSite) {
      var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
      switch (sameSite) {
        case true:
          str += "; SameSite=Strict";
          break;
        case "lax":
          str += "; SameSite=Lax";
          break;
        case "strict":
          str += "; SameSite=Strict";
          break;
        case "none":
          str += "; SameSite=None";
          break;
        default:
          throw new TypeError("option sameSite is invalid");
      }
    }
    return str;
  }
  function tryDecode(str, decode2) {
    try {
      return decode2(str);
    } catch (e) {
      return str;
    }
  }
});

// node_modules/vary/index.js
var require_vary = __commonJS((exports, module) => {
  /*!
   * vary
   * Copyright(c) 2014-2017 Douglas Christopher Wilson
   * MIT Licensed
   */
  module.exports = vary;
  module.exports.append = append;
  var FIELD_NAME_REGEXP = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;
  function append(header, field) {
    if (typeof header !== "string") {
      throw new TypeError("header argument is required");
    }
    if (!field) {
      throw new TypeError("field argument is required");
    }
    var fields = !Array.isArray(field) ? parse(String(field)) : field;
    for (var j = 0;j < fields.length; j++) {
      if (!FIELD_NAME_REGEXP.test(fields[j])) {
        throw new TypeError("field argument contains an invalid header name");
      }
    }
    if (header === "*") {
      return header;
    }
    var val = header;
    var vals = parse(header.toLowerCase());
    if (fields.indexOf("*") !== -1 || vals.indexOf("*") !== -1) {
      return "*";
    }
    for (var i = 0;i < fields.length; i++) {
      var fld = fields[i].toLowerCase();
      if (vals.indexOf(fld) === -1) {
        vals.push(fld);
        val = val ? val + ", " + fields[i] : fields[i];
      }
    }
    return val;
  }
  function parse(header) {
    var end = 0;
    var list = [];
    var start = 0;
    for (var i = 0, len = header.length;i < len; i++) {
      switch (header.charCodeAt(i)) {
        case 32:
          if (start === end) {
            start = end = i + 1;
          }
          break;
        case 44:
          list.push(header.substring(start, end));
          start = end = i + 1;
          break;
        default:
          end = i + 1;
          break;
      }
    }
    list.push(header.substring(start, end));
    return list;
  }
  function vary(res, field) {
    if (!res || !res.getHeader || !res.setHeader) {
      throw new TypeError("res argument is required");
    }
    var val = res.getHeader("Vary") || "";
    var header = Array.isArray(val) ? val.join(", ") : String(val);
    if (val = append(header, field)) {
      res.setHeader("Vary", val);
    }
  }
});

// node_modules/express/lib/response.js
var require_response = __commonJS((exports, module) => {
  /*!
   * express
   * Copyright(c) 2009-2013 TJ Holowaychuk
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  var Buffer2 = require_safe_buffer().Buffer;
  var contentDisposition = require_content_disposition();
  var deprecate2 = require_depd()("express");
  var encodeUrl = require_encodeurl();
  var escapeHtml = require_escape_html();
  var http = __require("http");
  var isAbsolute = require_utils2().isAbsolute;
  var onFinished = require_on_finished();
  var path = __require("path");
  var statuses = require_statuses();
  var merge = require_utils_merge();
  var sign = require_cookie_signature().sign;
  var normalizeType = require_utils2().normalizeType;
  var normalizeTypes = require_utils2().normalizeTypes;
  var setCharset = require_utils2().setCharset;
  var cookie = require_cookie();
  var send = require_send();
  var extname = path.extname;
  var mime = send.mime;
  var resolve = path.resolve;
  var vary = require_vary();
  var res = Object.create(http.ServerResponse.prototype);
  module.exports = res;
  var charsetRegExp = /;\s*charset\s*=/;
  res.status = function status(code) {
    this.statusCode = code;
    return this;
  };
  res.links = function(links) {
    var link = this.get("Link") || "";
    if (link)
      link += ", ";
    return this.set("Link", link + Object.keys(links).map(function(rel) {
      return "<" + links[rel] + '>; rel="' + rel + '"';
    }).join(", "));
  };
  res.send = function send(body) {
    var chunk = body;
    var encoding;
    var req = this.req;
    var type;
    var app = this.app;
    if (arguments.length === 2) {
      if (typeof arguments[0] !== "number" && typeof arguments[1] === "number") {
        deprecate2("res.send(body, status): Use res.status(status).send(body) instead");
        this.statusCode = arguments[1];
      } else {
        deprecate2("res.send(status, body): Use res.status(status).send(body) instead");
        this.statusCode = arguments[0];
        chunk = arguments[1];
      }
    }
    if (typeof chunk === "number" && arguments.length === 1) {
      if (!this.get("Content-Type")) {
        this.type("txt");
      }
      deprecate2("res.send(status): Use res.sendStatus(status) instead");
      this.statusCode = chunk;
      chunk = statuses[chunk];
    }
    switch (typeof chunk) {
      case "string":
        if (!this.get("Content-Type")) {
          this.type("html");
        }
        break;
      case "boolean":
      case "number":
      case "object":
        if (chunk === null) {
          chunk = "";
        } else if (Buffer2.isBuffer(chunk)) {
          if (!this.get("Content-Type")) {
            this.type("bin");
          }
        } else {
          return this.json(chunk);
        }
        break;
    }
    if (typeof chunk === "string") {
      encoding = "utf8";
      type = this.get("Content-Type");
      if (typeof type === "string") {
        this.set("Content-Type", setCharset(type, "utf-8"));
      }
    }
    var etagFn = app.get("etag fn");
    var generateETag = !this.get("ETag") && typeof etagFn === "function";
    var len;
    if (chunk !== undefined) {
      if (Buffer2.isBuffer(chunk)) {
        len = chunk.length;
      } else if (!generateETag && chunk.length < 1000) {
        len = Buffer2.byteLength(chunk, encoding);
      } else {
        chunk = Buffer2.from(chunk, encoding);
        encoding = undefined;
        len = chunk.length;
      }
      this.set("Content-Length", len);
    }
    var etag;
    if (generateETag && len !== undefined) {
      if (etag = etagFn(chunk, encoding)) {
        this.set("ETag", etag);
      }
    }
    if (req.fresh)
      this.statusCode = 304;
    if (this.statusCode === 204 || this.statusCode === 304) {
      this.removeHeader("Content-Type");
      this.removeHeader("Content-Length");
      this.removeHeader("Transfer-Encoding");
      chunk = "";
    }
    if (req.method === "HEAD") {
      this.end();
    } else {
      this.end(chunk, encoding);
    }
    return this;
  };
  res.json = function json(obj) {
    var val = obj;
    if (arguments.length === 2) {
      if (typeof arguments[1] === "number") {
        deprecate2("res.json(obj, status): Use res.status(status).json(obj) instead");
        this.statusCode = arguments[1];
      } else {
        deprecate2("res.json(status, obj): Use res.status(status).json(obj) instead");
        this.statusCode = arguments[0];
        val = arguments[1];
      }
    }
    var app = this.app;
    var escape2 = app.get("json escape");
    var replacer = app.get("json replacer");
    var spaces = app.get("json spaces");
    var body = stringify(val, replacer, spaces, escape2);
    if (!this.get("Content-Type")) {
      this.set("Content-Type", "application/json");
    }
    return this.send(body);
  };
  res.jsonp = function jsonp(obj) {
    var val = obj;
    if (arguments.length === 2) {
      if (typeof arguments[1] === "number") {
        deprecate2("res.jsonp(obj, status): Use res.status(status).json(obj) instead");
        this.statusCode = arguments[1];
      } else {
        deprecate2("res.jsonp(status, obj): Use res.status(status).jsonp(obj) instead");
        this.statusCode = arguments[0];
        val = arguments[1];
      }
    }
    var app = this.app;
    var escape2 = app.get("json escape");
    var replacer = app.get("json replacer");
    var spaces = app.get("json spaces");
    var body = stringify(val, replacer, spaces, escape2);
    var callback = this.req.query[app.get("jsonp callback name")];
    if (!this.get("Content-Type")) {
      this.set("X-Content-Type-Options", "nosniff");
      this.set("Content-Type", "application/json");
    }
    if (Array.isArray(callback)) {
      callback = callback[0];
    }
    if (typeof callback === "string" && callback.length !== 0) {
      this.set("X-Content-Type-Options", "nosniff");
      this.set("Content-Type", "text/javascript");
      callback = callback.replace(/[^\[\]\w$.]/g, "");
      body = body.replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
      body = "/**/ typeof " + callback + " === 'function' && " + callback + "(" + body + ");";
    }
    return this.send(body);
  };
  res.sendStatus = function sendStatus(statusCode) {
    var body = statuses[statusCode] || String(statusCode);
    this.statusCode = statusCode;
    this.type("txt");
    return this.send(body);
  };
  res.sendFile = function sendFile(path2, options, callback) {
    var done = callback;
    var req = this.req;
    var res2 = this;
    var next = req.next;
    var opts = options || {};
    if (!path2) {
      throw new TypeError("path argument is required to res.sendFile");
    }
    if (typeof path2 !== "string") {
      throw new TypeError("path must be a string to res.sendFile");
    }
    if (typeof options === "function") {
      done = options;
      opts = {};
    }
    if (!opts.root && !isAbsolute(path2)) {
      throw new TypeError("path must be absolute or specify root to res.sendFile");
    }
    var pathname = encodeURI(path2);
    var file = send(req, pathname, opts);
    sendfile(res2, file, opts, function(err) {
      if (done)
        return done(err);
      if (err && err.code === "EISDIR")
        return next();
      if (err && err.code !== "ECONNABORTED" && err.syscall !== "write") {
        next(err);
      }
    });
  };
  res.sendfile = function(path2, options, callback) {
    var done = callback;
    var req = this.req;
    var res2 = this;
    var next = req.next;
    var opts = options || {};
    if (typeof options === "function") {
      done = options;
      opts = {};
    }
    var file = send(req, path2, opts);
    sendfile(res2, file, opts, function(err) {
      if (done)
        return done(err);
      if (err && err.code === "EISDIR")
        return next();
      if (err && err.code !== "ECONNABORTED" && err.syscall !== "write") {
        next(err);
      }
    });
  };
  res.sendfile = deprecate2.function(res.sendfile, "res.sendfile: Use res.sendFile instead");
  res.download = function download(path2, filename, options, callback) {
    var done = callback;
    var name = filename;
    var opts = options || null;
    if (typeof filename === "function") {
      done = filename;
      name = null;
      opts = null;
    } else if (typeof options === "function") {
      done = options;
      opts = null;
    }
    var headers = {
      "Content-Disposition": contentDisposition(name || path2)
    };
    if (opts && opts.headers) {
      var keys = Object.keys(opts.headers);
      for (var i = 0;i < keys.length; i++) {
        var key = keys[i];
        if (key.toLowerCase() !== "content-disposition") {
          headers[key] = opts.headers[key];
        }
      }
    }
    opts = Object.create(opts);
    opts.headers = headers;
    var fullPath = resolve(path2);
    return this.sendFile(fullPath, opts, done);
  };
  res.contentType = res.type = function contentType(type) {
    var ct = type.indexOf("/") === -1 ? mime.lookup(type) : type;
    return this.set("Content-Type", ct);
  };
  res.format = function(obj) {
    var req = this.req;
    var next = req.next;
    var fn2 = obj.default;
    if (fn2)
      delete obj.default;
    var keys = Object.keys(obj);
    var key = keys.length > 0 ? req.accepts(keys) : false;
    this.vary("Accept");
    if (key) {
      this.set("Content-Type", normalizeType(key).value);
      obj[key](req, this, next);
    } else if (fn2) {
      fn2();
    } else {
      var err = new Error("Not Acceptable");
      err.status = err.statusCode = 406;
      err.types = normalizeTypes(keys).map(function(o) {
        return o.value;
      });
      next(err);
    }
    return this;
  };
  res.attachment = function attachment(filename) {
    if (filename) {
      this.type(extname(filename));
    }
    this.set("Content-Disposition", contentDisposition(filename));
    return this;
  };
  res.append = function append(field, val) {
    var prev = this.get(field);
    var value = val;
    if (prev) {
      value = Array.isArray(prev) ? prev.concat(val) : Array.isArray(val) ? [prev].concat(val) : [prev, val];
    }
    return this.set(field, value);
  };
  res.set = res.header = function header(field, val) {
    if (arguments.length === 2) {
      var value = Array.isArray(val) ? val.map(String) : String(val);
      if (field.toLowerCase() === "content-type") {
        if (Array.isArray(value)) {
          throw new TypeError("Content-Type cannot be set to an Array");
        }
        if (!charsetRegExp.test(value)) {
          var charset = mime.charsets.lookup(value.split(";")[0]);
          if (charset)
            value += "; charset=" + charset.toLowerCase();
        }
      }
      this.setHeader(field, value);
    } else {
      for (var key in field) {
        this.set(key, field[key]);
      }
    }
    return this;
  };
  res.get = function(field) {
    return this.getHeader(field);
  };
  res.clearCookie = function clearCookie(name, options) {
    var opts = merge({ expires: new Date(1), path: "/" }, options);
    return this.cookie(name, "", opts);
  };
  res.cookie = function(name, value, options) {
    var opts = merge({}, options);
    var secret = this.req.secret;
    var signed = opts.signed;
    if (signed && !secret) {
      throw new Error('cookieParser("secret") required for signed cookies');
    }
    var val = typeof value === "object" ? "j:" + JSON.stringify(value) : String(value);
    if (signed) {
      val = "s:" + sign(val, secret);
    }
    if ("maxAge" in opts) {
      opts.expires = new Date(Date.now() + opts.maxAge);
      opts.maxAge /= 1000;
    }
    if (opts.path == null) {
      opts.path = "/";
    }
    this.append("Set-Cookie", cookie.serialize(name, String(val), opts));
    return this;
  };
  res.location = function location(url) {
    var loc = url;
    if (url === "back") {
      loc = this.req.get("Referrer") || "/";
    }
    return this.set("Location", encodeUrl(loc));
  };
  res.redirect = function redirect(url) {
    var address = url;
    var body;
    var status = 302;
    if (arguments.length === 2) {
      if (typeof arguments[0] === "number") {
        status = arguments[0];
        address = arguments[1];
      } else {
        deprecate2("res.redirect(url, status): Use res.redirect(status, url) instead");
        status = arguments[1];
      }
    }
    address = this.location(address).get("Location");
    this.format({
      text: function() {
        body = statuses[status] + ". Redirecting to " + address;
      },
      html: function() {
        var u = escapeHtml(address);
        body = "<p>" + statuses[status] + '. Redirecting to <a href="' + u + '">' + u + "</a></p>";
      },
      default: function() {
        body = "";
      }
    });
    this.statusCode = status;
    this.set("Content-Length", Buffer2.byteLength(body));
    if (this.req.method === "HEAD") {
      this.end();
    } else {
      this.end(body);
    }
  };
  res.vary = function(field) {
    if (!field || Array.isArray(field) && !field.length) {
      deprecate2("res.vary(): Provide a field name");
      return this;
    }
    vary(this, field);
    return this;
  };
  res.render = function render(view, options, callback) {
    var app = this.req.app;
    var done = callback;
    var opts = options || {};
    var req = this.req;
    var self2 = this;
    if (typeof options === "function") {
      done = options;
      opts = {};
    }
    opts._locals = self2.locals;
    done = done || function(err, str) {
      if (err)
        return req.next(err);
      self2.send(str);
    };
    app.render(view, opts, done);
  };
  function sendfile(res2, file, options, callback) {
    var done = false;
    var streaming;
    function onaborted() {
      if (done)
        return;
      done = true;
      var err = new Error("Request aborted");
      err.code = "ECONNABORTED";
      callback(err);
    }
    function ondirectory() {
      if (done)
        return;
      done = true;
      var err = new Error("EISDIR, read");
      err.code = "EISDIR";
      callback(err);
    }
    function onerror(err) {
      if (done)
        return;
      done = true;
      callback(err);
    }
    function onend() {
      if (done)
        return;
      done = true;
      callback();
    }
    function onfile() {
      streaming = false;
    }
    function onfinish(err) {
      if (err && err.code === "ECONNRESET")
        return onaborted();
      if (err)
        return onerror(err);
      if (done)
        return;
      setImmediate(function() {
        if (streaming !== false && !done) {
          onaborted();
          return;
        }
        if (done)
          return;
        done = true;
        callback();
      });
    }
    function onstream() {
      streaming = true;
    }
    file.on("directory", ondirectory);
    file.on("end", onend);
    file.on("error", onerror);
    file.on("file", onfile);
    file.on("stream", onstream);
    onFinished(res2, onfinish);
    if (options.headers) {
      file.on("headers", function headers(res3) {
        var obj = options.headers;
        var keys = Object.keys(obj);
        for (var i = 0;i < keys.length; i++) {
          var k = keys[i];
          res3.setHeader(k, obj[k]);
        }
      });
    }
    file.pipe(res2);
  }
  function stringify(value, replacer, spaces, escape2) {
    var json = replacer || spaces ? JSON.stringify(value, replacer, spaces) : JSON.stringify(value);
    if (escape2) {
      json = json.replace(/[<>&]/g, function(c) {
        switch (c.charCodeAt(0)) {
          case 60:
            return "\\u003c";
          case 62:
            return "\\u003e";
          case 38:
            return "\\u0026";
          default:
            return c;
        }
      });
    }
    return json;
  }
});

// node_modules/serve-static/index.js
var require_serve_static = __commonJS((exports, module) => {
  /*!
   * serve-static
   * Copyright(c) 2010 Sencha Inc.
   * Copyright(c) 2011 TJ Holowaychuk
   * Copyright(c) 2014-2016 Douglas Christopher Wilson
   * MIT Licensed
   */
  var encodeUrl = require_encodeurl();
  var escapeHtml = require_escape_html();
  var parseUrl = require_parseurl();
  var resolve = __require("path").resolve;
  var send = require_send();
  var url = __require("url");
  module.exports = serveStatic;
  module.exports.mime = send.mime;
  function serveStatic(root, options) {
    if (!root) {
      throw new TypeError("root path required");
    }
    if (typeof root !== "string") {
      throw new TypeError("root path must be a string");
    }
    var opts = Object.create(options || null);
    var fallthrough = opts.fallthrough !== false;
    var redirect = opts.redirect !== false;
    var setHeaders = opts.setHeaders;
    if (setHeaders && typeof setHeaders !== "function") {
      throw new TypeError("option setHeaders must be function");
    }
    opts.maxage = opts.maxage || opts.maxAge || 0;
    opts.root = resolve(root);
    var onDirectory = redirect ? createRedirectDirectoryListener() : createNotFoundDirectoryListener();
    return function serveStatic(req, res, next) {
      if (req.method !== "GET" && req.method !== "HEAD") {
        if (fallthrough) {
          return next();
        }
        res.statusCode = 405;
        res.setHeader("Allow", "GET, HEAD");
        res.setHeader("Content-Length", "0");
        res.end();
        return;
      }
      var forwardError = !fallthrough;
      var originalUrl = parseUrl.original(req);
      var path = parseUrl(req).pathname;
      if (path === "/" && originalUrl.pathname.substr(-1) !== "/") {
        path = "";
      }
      var stream = send(req, path, opts);
      stream.on("directory", onDirectory);
      if (setHeaders) {
        stream.on("headers", setHeaders);
      }
      if (fallthrough) {
        stream.on("file", function onFile() {
          forwardError = true;
        });
      }
      stream.on("error", function error(err) {
        if (forwardError || !(err.statusCode < 500)) {
          next(err);
          return;
        }
        next();
      });
      stream.pipe(res);
    };
  }
  function collapseLeadingSlashes(str) {
    for (var i = 0;i < str.length; i++) {
      if (str.charCodeAt(i) !== 47) {
        break;
      }
    }
    return i > 1 ? "/" + str.substr(i) : str;
  }
  function createHtmlDocument(title, body) {
    return `<!DOCTYPE html>
` + `<html lang="en">
` + `<head>
` + `<meta charset="utf-8">
` + "<title>" + title + `</title>
` + `</head>
` + `<body>
` + "<pre>" + body + `</pre>
` + `</body>
` + `</html>
`;
  }
  function createNotFoundDirectoryListener() {
    return function notFound() {
      this.error(404);
    };
  }
  function createRedirectDirectoryListener() {
    return function redirect(res) {
      if (this.hasTrailingSlash()) {
        this.error(404);
        return;
      }
      var originalUrl = parseUrl.original(this.req);
      originalUrl.path = null;
      originalUrl.pathname = collapseLeadingSlashes(originalUrl.pathname + "/");
      var loc = encodeUrl(url.format(originalUrl));
      var doc = createHtmlDocument("Redirecting", 'Redirecting to <a href="' + escapeHtml(loc) + '">' + escapeHtml(loc) + "</a>");
      res.statusCode = 301;
      res.setHeader("Content-Type", "text/html; charset=UTF-8");
      res.setHeader("Content-Length", Buffer.byteLength(doc));
      res.setHeader("Content-Security-Policy", "default-src 'none'");
      res.setHeader("X-Content-Type-Options", "nosniff");
      res.setHeader("Location", loc);
      res.end(doc);
    };
  }
});

// node_modules/express/lib/express.js
var require_express = __commonJS((exports, module) => {
  /*!
   * express
   * Copyright(c) 2009-2013 TJ Holowaychuk
   * Copyright(c) 2013 Roman Shtylman
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  var bodyParser = require_body_parser();
  var EventEmitter = __require("events").EventEmitter;
  var mixin = require_merge_descriptors();
  var proto = require_application();
  var Route = require_route();
  var Router = require_router();
  var req = require_request();
  var res = require_response();
  exports = module.exports = createApplication;
  function createApplication() {
    var app = function(req2, res2, next) {
      app.handle(req2, res2, next);
    };
    mixin(app, EventEmitter.prototype, false);
    mixin(app, proto, false);
    app.request = Object.create(req, {
      app: { configurable: true, enumerable: true, writable: true, value: app }
    });
    app.response = Object.create(res, {
      app: { configurable: true, enumerable: true, writable: true, value: app }
    });
    app.init();
    return app;
  }
  exports.application = proto;
  exports.request = req;
  exports.response = res;
  exports.Route = Route;
  exports.Router = Router;
  exports.json = bodyParser.json;
  exports.query = require_query();
  exports.raw = bodyParser.raw;
  exports.static = require_serve_static();
  exports.text = bodyParser.text;
  exports.urlencoded = bodyParser.urlencoded;
  var removedMiddlewares = [
    "bodyParser",
    "compress",
    "cookieSession",
    "session",
    "logger",
    "cookieParser",
    "favicon",
    "responseTime",
    "errorHandler",
    "timeout",
    "methodOverride",
    "vhost",
    "csrf",
    "directory",
    "limit",
    "multipart",
    "staticCache"
  ];
  removedMiddlewares.forEach(function(name) {
    Object.defineProperty(exports, name, {
      get: function() {
        throw new Error("Most middleware (like " + name + ") is no longer bundled with Express and must be installed separately. Please see https://github.com/senchalabs/connect#middleware.");
      },
      configurable: true
    });
  });
});

// node_modules/express/index.js
var require_express2 = __commonJS((exports, module) => {
  /*!
   * express
   * Copyright(c) 2009-2013 TJ Holowaychuk
   * Copyright(c) 2013 Roman Shtylman
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  module.exports = require_express();
});

// node_modules/webidl-conversions/lib/index.js
var require_lib3 = __commonJS((exports, module) => {
  var conversions = {};
  module.exports = conversions;
  function sign(x) {
    return x < 0 ? -1 : 1;
  }
  function evenRound(x) {
    if (x % 1 === 0.5 && (x & 1) === 0) {
      return Math.floor(x);
    } else {
      return Math.round(x);
    }
  }
  function createNumberConversion(bitLength, typeOpts) {
    if (!typeOpts.unsigned) {
      --bitLength;
    }
    const lowerBound = typeOpts.unsigned ? 0 : -Math.pow(2, bitLength);
    const upperBound = Math.pow(2, bitLength) - 1;
    const moduloVal = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength) : Math.pow(2, bitLength);
    const moduloBound = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength - 1) : Math.pow(2, bitLength - 1);
    return function(V, opts) {
      if (!opts)
        opts = {};
      let x = +V;
      if (opts.enforceRange) {
        if (!Number.isFinite(x)) {
          throw new TypeError("Argument is not a finite number");
        }
        x = sign(x) * Math.floor(Math.abs(x));
        if (x < lowerBound || x > upperBound) {
          throw new TypeError("Argument is not in byte range");
        }
        return x;
      }
      if (!isNaN(x) && opts.clamp) {
        x = evenRound(x);
        if (x < lowerBound)
          x = lowerBound;
        if (x > upperBound)
          x = upperBound;
        return x;
      }
      if (!Number.isFinite(x) || x === 0) {
        return 0;
      }
      x = sign(x) * Math.floor(Math.abs(x));
      x = x % moduloVal;
      if (!typeOpts.unsigned && x >= moduloBound) {
        return x - moduloVal;
      } else if (typeOpts.unsigned) {
        if (x < 0) {
          x += moduloVal;
        } else if (x === -0) {
          return 0;
        }
      }
      return x;
    };
  }
  conversions["void"] = function() {
    return;
  };
  conversions["boolean"] = function(val) {
    return !!val;
  };
  conversions["byte"] = createNumberConversion(8, { unsigned: false });
  conversions["octet"] = createNumberConversion(8, { unsigned: true });
  conversions["short"] = createNumberConversion(16, { unsigned: false });
  conversions["unsigned short"] = createNumberConversion(16, { unsigned: true });
  conversions["long"] = createNumberConversion(32, { unsigned: false });
  conversions["unsigned long"] = createNumberConversion(32, { unsigned: true });
  conversions["long long"] = createNumberConversion(32, { unsigned: false, moduloBitLength: 64 });
  conversions["unsigned long long"] = createNumberConversion(32, { unsigned: true, moduloBitLength: 64 });
  conversions["double"] = function(V) {
    const x = +V;
    if (!Number.isFinite(x)) {
      throw new TypeError("Argument is not a finite floating-point value");
    }
    return x;
  };
  conversions["unrestricted double"] = function(V) {
    const x = +V;
    if (isNaN(x)) {
      throw new TypeError("Argument is NaN");
    }
    return x;
  };
  conversions["float"] = conversions["double"];
  conversions["unrestricted float"] = conversions["unrestricted double"];
  conversions["DOMString"] = function(V, opts) {
    if (!opts)
      opts = {};
    if (opts.treatNullAsEmptyString && V === null) {
      return "";
    }
    return String(V);
  };
  conversions["ByteString"] = function(V, opts) {
    const x = String(V);
    let c = undefined;
    for (let i = 0;(c = x.codePointAt(i)) !== undefined; ++i) {
      if (c > 255) {
        throw new TypeError("Argument is not a valid bytestring");
      }
    }
    return x;
  };
  conversions["USVString"] = function(V) {
    const S = String(V);
    const n = S.length;
    const U = [];
    for (let i = 0;i < n; ++i) {
      const c = S.charCodeAt(i);
      if (c < 55296 || c > 57343) {
        U.push(String.fromCodePoint(c));
      } else if (56320 <= c && c <= 57343) {
        U.push(String.fromCodePoint(65533));
      } else {
        if (i === n - 1) {
          U.push(String.fromCodePoint(65533));
        } else {
          const d = S.charCodeAt(i + 1);
          if (56320 <= d && d <= 57343) {
            const a = c & 1023;
            const b = d & 1023;
            U.push(String.fromCodePoint((2 << 15) + (2 << 9) * a + b));
            ++i;
          } else {
            U.push(String.fromCodePoint(65533));
          }
        }
      }
    }
    return U.join("");
  };
  conversions["Date"] = function(V, opts) {
    if (!(V instanceof Date)) {
      throw new TypeError("Argument is not a Date object");
    }
    if (isNaN(V)) {
      return;
    }
    return V;
  };
  conversions["RegExp"] = function(V, opts) {
    if (!(V instanceof RegExp)) {
      V = new RegExp(V);
    }
    return V;
  };
});

// node_modules/whatwg-url/lib/utils.js
var require_utils3 = __commonJS((exports, module) => {
  exports.mixin = function mixin(target, source) {
    const keys = Object.getOwnPropertyNames(source);
    for (let i = 0;i < keys.length; ++i) {
      Object.defineProperty(target, keys[i], Object.getOwnPropertyDescriptor(source, keys[i]));
    }
  };
  exports.wrapperSymbol = Symbol("wrapper");
  exports.implSymbol = Symbol("impl");
  exports.wrapperForImpl = function(impl) {
    return impl[exports.wrapperSymbol];
  };
  exports.implForWrapper = function(wrapper) {
    return wrapper[exports.implSymbol];
  };
});

// node_modules/tr46/lib/mappingTable.json
var require_mappingTable = __commonJS((exports, module) => {
  module.exports = [[[0, 44], "disallowed_STD3_valid"], [[45, 46], "valid"], [[47, 47], "disallowed_STD3_valid"], [[48, 57], "valid"], [[58, 64], "disallowed_STD3_valid"], [[65, 65], "mapped", [97]], [[66, 66], "mapped", [98]], [[67, 67], "mapped", [99]], [[68, 68], "mapped", [100]], [[69, 69], "mapped", [101]], [[70, 70], "mapped", [102]], [[71, 71], "mapped", [103]], [[72, 72], "mapped", [104]], [[73, 73], "mapped", [105]], [[74, 74], "mapped", [106]], [[75, 75], "mapped", [107]], [[76, 76], "mapped", [108]], [[77, 77], "mapped", [109]], [[78, 78], "mapped", [110]], [[79, 79], "mapped", [111]], [[80, 80], "mapped", [112]], [[81, 81], "mapped", [113]], [[82, 82], "mapped", [114]], [[83, 83], "mapped", [115]], [[84, 84], "mapped", [116]], [[85, 85], "mapped", [117]], [[86, 86], "mapped", [118]], [[87, 87], "mapped", [119]], [[88, 88], "mapped", [120]], [[89, 89], "mapped", [121]], [[90, 90], "mapped", [122]], [[91, 96], "disallowed_STD3_valid"], [[97, 122], "valid"], [[123, 127], "disallowed_STD3_valid"], [[128, 159], "disallowed"], [[160, 160], "disallowed_STD3_mapped", [32]], [[161, 167], "valid", [], "NV8"], [[168, 168], "disallowed_STD3_mapped", [32, 776]], [[169, 169], "valid", [], "NV8"], [[170, 170], "mapped", [97]], [[171, 172], "valid", [], "NV8"], [[173, 173], "ignored"], [[174, 174], "valid", [], "NV8"], [[175, 175], "disallowed_STD3_mapped", [32, 772]], [[176, 177], "valid", [], "NV8"], [[178, 178], "mapped", [50]], [[179, 179], "mapped", [51]], [[180, 180], "disallowed_STD3_mapped", [32, 769]], [[181, 181], "mapped", [956]], [[182, 182], "valid", [], "NV8"], [[183, 183], "valid"], [[184, 184], "disallowed_STD3_mapped", [32, 807]], [[185, 185], "mapped", [49]], [[186, 186], "mapped", [111]], [[187, 187], "valid", [], "NV8"], [[188, 188], "mapped", [49, 8260, 52]], [[189, 189], "mapped", [49, 8260, 50]], [[190, 190], "mapped", [51, 8260, 52]], [[191, 191], "valid", [], "NV8"], [[192, 192], "mapped", [224]], [[193, 193], "mapped", [225]], [[194, 194], "mapped", [226]], [[195, 195], "mapped", [227]], [[196, 196], "mapped", [228]], [[197, 197], "mapped", [229]], [[198, 198], "mapped", [230]], [[199, 199], "mapped", [231]], [[200, 200], "mapped", [232]], [[201, 201], "mapped", [233]], [[202, 202], "mapped", [234]], [[203, 203], "mapped", [235]], [[204, 204], "mapped", [236]], [[205, 205], "mapped", [237]], [[206, 206], "mapped", [238]], [[207, 207], "mapped", [239]], [[208, 208], "mapped", [240]], [[209, 209], "mapped", [241]], [[210, 210], "mapped", [242]], [[211, 211], "mapped", [243]], [[212, 212], "mapped", [244]], [[213, 213], "mapped", [245]], [[214, 214], "mapped", [246]], [[215, 215], "valid", [], "NV8"], [[216, 216], "mapped", [248]], [[217, 217], "mapped", [249]], [[218, 218], "mapped", [250]], [[219, 219], "mapped", [251]], [[220, 220], "mapped", [252]], [[221, 221], "mapped", [253]], [[222, 222], "mapped", [254]], [[223, 223], "deviation", [115, 115]], [[224, 246], "valid"], [[247, 247], "valid", [], "NV8"], [[248, 255], "valid"], [[256, 256], "mapped", [257]], [[257, 257], "valid"], [[258, 258], "mapped", [259]], [[259, 259], "valid"], [[260, 260], "mapped", [261]], [[261, 261], "valid"], [[262, 262], "mapped", [263]], [[263, 263], "valid"], [[264, 264], "mapped", [265]], [[265, 265], "valid"], [[266, 266], "mapped", [267]], [[267, 267], "valid"], [[268, 268], "mapped", [269]], [[269, 269], "valid"], [[270, 270], "mapped", [271]], [[271, 271], "valid"], [[272, 272], "mapped", [273]], [[273, 273], "valid"], [[274, 274], "mapped", [275]], [[275, 275], "valid"], [[276, 276], "mapped", [277]], [[277, 277], "valid"], [[278, 278], "mapped", [279]], [[279, 279], "valid"], [[280, 280], "mapped", [281]], [[281, 281], "valid"], [[282, 282], "mapped", [283]], [[283, 283], "valid"], [[284, 284], "mapped", [285]], [[285, 285], "valid"], [[286, 286], "mapped", [287]], [[287, 287], "valid"], [[288, 288], "mapped", [289]], [[289, 289], "valid"], [[290, 290], "mapped", [291]], [[291, 291], "valid"], [[292, 292], "mapped", [293]], [[293, 293], "valid"], [[294, 294], "mapped", [295]], [[295, 295], "valid"], [[296, 296], "mapped", [297]], [[297, 297], "valid"], [[298, 298], "mapped", [299]], [[299, 299], "valid"], [[300, 300], "mapped", [301]], [[301, 301], "valid"], [[302, 302], "mapped", [303]], [[303, 303], "valid"], [[304, 304], "mapped", [105, 775]], [[305, 305], "valid"], [[306, 307], "mapped", [105, 106]], [[308, 308], "mapped", [309]], [[309, 309], "valid"], [[310, 310], "mapped", [311]], [[311, 312], "valid"], [[313, 313], "mapped", [314]], [[314, 314], "valid"], [[315, 315], "mapped", [316]], [[316, 316], "valid"], [[317, 317], "mapped", [318]], [[318, 318], "valid"], [[319, 320], "mapped", [108, 183]], [[321, 321], "mapped", [322]], [[322, 322], "valid"], [[323, 323], "mapped", [324]], [[324, 324], "valid"], [[325, 325], "mapped", [326]], [[326, 326], "valid"], [[327, 327], "mapped", [328]], [[328, 328], "valid"], [[329, 329], "mapped", [700, 110]], [[330, 330], "mapped", [331]], [[331, 331], "valid"], [[332, 332], "mapped", [333]], [[333, 333], "valid"], [[334, 334], "mapped", [335]], [[335, 335], "valid"], [[336, 336], "mapped", [337]], [[337, 337], "valid"], [[338, 338], "mapped", [339]], [[339, 339], "valid"], [[340, 340], "mapped", [341]], [[341, 341], "valid"], [[342, 342], "mapped", [343]], [[343, 343], "valid"], [[344, 344], "mapped", [345]], [[345, 345], "valid"], [[346, 346], "mapped", [347]], [[347, 347], "valid"], [[348, 348], "mapped", [349]], [[349, 349], "valid"], [[350, 350], "mapped", [351]], [[351, 351], "valid"], [[352, 352], "mapped", [353]], [[353, 353], "valid"], [[354, 354], "mapped", [355]], [[355, 355], "valid"], [[356, 356], "mapped", [357]], [[357, 357], "valid"], [[358, 358], "mapped", [359]], [[359, 359], "valid"], [[360, 360], "mapped", [361]], [[361, 361], "valid"], [[362, 362], "mapped", [363]], [[363, 363], "valid"], [[364, 364], "mapped", [365]], [[365, 365], "valid"], [[366, 366], "mapped", [367]], [[367, 367], "valid"], [[368, 368], "mapped", [369]], [[369, 369], "valid"], [[370, 370], "mapped", [371]], [[371, 371], "valid"], [[372, 372], "mapped", [373]], [[373, 373], "valid"], [[374, 374], "mapped", [375]], [[375, 375], "valid"], [[376, 376], "mapped", [255]], [[377, 377], "mapped", [378]], [[378, 378], "valid"], [[379, 379], "mapped", [380]], [[380, 380], "valid"], [[381, 381], "mapped", [382]], [[382, 382], "valid"], [[383, 383], "mapped", [115]], [[384, 384], "valid"], [[385, 385], "mapped", [595]], [[386, 386], "mapped", [387]], [[387, 387], "valid"], [[388, 388], "mapped", [389]], [[389, 389], "valid"], [[390, 390], "mapped", [596]], [[391, 391], "mapped", [392]], [[392, 392], "valid"], [[393, 393], "mapped", [598]], [[394, 394], "mapped", [599]], [[395, 395], "mapped", [396]], [[396, 397], "valid"], [[398, 398], "mapped", [477]], [[399, 399], "mapped", [601]], [[400, 400], "mapped", [603]], [[401, 401], "mapped", [402]], [[402, 402], "valid"], [[403, 403], "mapped", [608]], [[404, 404], "mapped", [611]], [[405, 405], "valid"], [[406, 406], "mapped", [617]], [[407, 407], "mapped", [616]], [[408, 408], "mapped", [409]], [[409, 411], "valid"], [[412, 412], "mapped", [623]], [[413, 413], "mapped", [626]], [[414, 414], "valid"], [[415, 415], "mapped", [629]], [[416, 416], "mapped", [417]], [[417, 417], "valid"], [[418, 418], "mapped", [419]], [[419, 419], "valid"], [[420, 420], "mapped", [421]], [[421, 421], "valid"], [[422, 422], "mapped", [640]], [[423, 423], "mapped", [424]], [[424, 424], "valid"], [[425, 425], "mapped", [643]], [[426, 427], "valid"], [[428, 428], "mapped", [429]], [[429, 429], "valid"], [[430, 430], "mapped", [648]], [[431, 431], "mapped", [432]], [[432, 432], "valid"], [[433, 433], "mapped", [650]], [[434, 434], "mapped", [651]], [[435, 435], "mapped", [436]], [[436, 436], "valid"], [[437, 437], "mapped", [438]], [[438, 438], "valid"], [[439, 439], "mapped", [658]], [[440, 440], "mapped", [441]], [[441, 443], "valid"], [[444, 444], "mapped", [445]], [[445, 451], "valid"], [[452, 454], "mapped", [100, 382]], [[455, 457], "mapped", [108, 106]], [[458, 460], "mapped", [110, 106]], [[461, 461], "mapped", [462]], [[462, 462], "valid"], [[463, 463], "mapped", [464]], [[464, 464], "valid"], [[465, 465], "mapped", [466]], [[466, 466], "valid"], [[467, 467], "mapped", [468]], [[468, 468], "valid"], [[469, 469], "mapped", [470]], [[470, 470], "valid"], [[471, 471], "mapped", [472]], [[472, 472], "valid"], [[473, 473], "mapped", [474]], [[474, 474], "valid"], [[475, 475], "mapped", [476]], [[476, 477], "valid"], [[478, 478], "mapped", [479]], [[479, 479], "valid"], [[480, 480], "mapped", [481]], [[481, 481], "valid"], [[482, 482], "mapped", [483]], [[483, 483], "valid"], [[484, 484], "mapped", [485]], [[485, 485], "valid"], [[486, 486], "mapped", [487]], [[487, 487], "valid"], [[488, 488], "mapped", [489]], [[489, 489], "valid"], [[490, 490], "mapped", [491]], [[491, 491], "valid"], [[492, 492], "mapped", [493]], [[493, 493], "valid"], [[494, 494], "mapped", [495]], [[495, 496], "valid"], [[497, 499], "mapped", [100, 122]], [[500, 500], "mapped", [501]], [[501, 501], "valid"], [[502, 502], "mapped", [405]], [[503, 503], "mapped", [447]], [[504, 504], "mapped", [505]], [[505, 505], "valid"], [[506, 506], "mapped", [507]], [[507, 507], "valid"], [[508, 508], "mapped", [509]], [[509, 509], "valid"], [[510, 510], "mapped", [511]], [[511, 511], "valid"], [[512, 512], "mapped", [513]], [[513, 513], "valid"], [[514, 514], "mapped", [515]], [[515, 515], "valid"], [[516, 516], "mapped", [517]], [[517, 517], "valid"], [[518, 518], "mapped", [519]], [[519, 519], "valid"], [[520, 520], "mapped", [521]], [[521, 521], "valid"], [[522, 522], "mapped", [523]], [[523, 523], "valid"], [[524, 524], "mapped", [525]], [[525, 525], "valid"], [[526, 526], "mapped", [527]], [[527, 527], "valid"], [[528, 528], "mapped", [529]], [[529, 529], "valid"], [[530, 530], "mapped", [531]], [[531, 531], "valid"], [[532, 532], "mapped", [533]], [[533, 533], "valid"], [[534, 534], "mapped", [535]], [[535, 535], "valid"], [[536, 536], "mapped", [537]], [[537, 537], "valid"], [[538, 538], "mapped", [539]], [[539, 539], "valid"], [[540, 540], "mapped", [541]], [[541, 541], "valid"], [[542, 542], "mapped", [543]], [[543, 543], "valid"], [[544, 544], "mapped", [414]], [[545, 545], "valid"], [[546, 546], "mapped", [547]], [[547, 547], "valid"], [[548, 548], "mapped", [549]], [[549, 549], "valid"], [[550, 550], "mapped", [551]], [[551, 551], "valid"], [[552, 552], "mapped", [553]], [[553, 553], "valid"], [[554, 554], "mapped", [555]], [[555, 555], "valid"], [[556, 556], "mapped", [557]], [[557, 557], "valid"], [[558, 558], "mapped", [559]], [[559, 559], "valid"], [[560, 560], "mapped", [561]], [[561, 561], "valid"], [[562, 562], "mapped", [563]], [[563, 563], "valid"], [[564, 566], "valid"], [[567, 569], "valid"], [[570, 570], "mapped", [11365]], [[571, 571], "mapped", [572]], [[572, 572], "valid"], [[573, 573], "mapped", [410]], [[574, 574], "mapped", [11366]], [[575, 576], "valid"], [[577, 577], "mapped", [578]], [[578, 578], "valid"], [[579, 579], "mapped", [384]], [[580, 580], "mapped", [649]], [[581, 581], "mapped", [652]], [[582, 582], "mapped", [583]], [[583, 583], "valid"], [[584, 584], "mapped", [585]], [[585, 585], "valid"], [[586, 586], "mapped", [587]], [[587, 587], "valid"], [[588, 588], "mapped", [589]], [[589, 589], "valid"], [[590, 590], "mapped", [591]], [[591, 591], "valid"], [[592, 680], "valid"], [[681, 685], "valid"], [[686, 687], "valid"], [[688, 688], "mapped", [104]], [[689, 689], "mapped", [614]], [[690, 690], "mapped", [106]], [[691, 691], "mapped", [114]], [[692, 692], "mapped", [633]], [[693, 693], "mapped", [635]], [[694, 694], "mapped", [641]], [[695, 695], "mapped", [119]], [[696, 696], "mapped", [121]], [[697, 705], "valid"], [[706, 709], "valid", [], "NV8"], [[710, 721], "valid"], [[722, 727], "valid", [], "NV8"], [[728, 728], "disallowed_STD3_mapped", [32, 774]], [[729, 729], "disallowed_STD3_mapped", [32, 775]], [[730, 730], "disallowed_STD3_mapped", [32, 778]], [[731, 731], "disallowed_STD3_mapped", [32, 808]], [[732, 732], "disallowed_STD3_mapped", [32, 771]], [[733, 733], "disallowed_STD3_mapped", [32, 779]], [[734, 734], "valid", [], "NV8"], [[735, 735], "valid", [], "NV8"], [[736, 736], "mapped", [611]], [[737, 737], "mapped", [108]], [[738, 738], "mapped", [115]], [[739, 739], "mapped", [120]], [[740, 740], "mapped", [661]], [[741, 745], "valid", [], "NV8"], [[746, 747], "valid", [], "NV8"], [[748, 748], "valid"], [[749, 749], "valid", [], "NV8"], [[750, 750], "valid"], [[751, 767], "valid", [], "NV8"], [[768, 831], "valid"], [[832, 832], "mapped", [768]], [[833, 833], "mapped", [769]], [[834, 834], "valid"], [[835, 835], "mapped", [787]], [[836, 836], "mapped", [776, 769]], [[837, 837], "mapped", [953]], [[838, 846], "valid"], [[847, 847], "ignored"], [[848, 855], "valid"], [[856, 860], "valid"], [[861, 863], "valid"], [[864, 865], "valid"], [[866, 866], "valid"], [[867, 879], "valid"], [[880, 880], "mapped", [881]], [[881, 881], "valid"], [[882, 882], "mapped", [883]], [[883, 883], "valid"], [[884, 884], "mapped", [697]], [[885, 885], "valid"], [[886, 886], "mapped", [887]], [[887, 887], "valid"], [[888, 889], "disallowed"], [[890, 890], "disallowed_STD3_mapped", [32, 953]], [[891, 893], "valid"], [[894, 894], "disallowed_STD3_mapped", [59]], [[895, 895], "mapped", [1011]], [[896, 899], "disallowed"], [[900, 900], "disallowed_STD3_mapped", [32, 769]], [[901, 901], "disallowed_STD3_mapped", [32, 776, 769]], [[902, 902], "mapped", [940]], [[903, 903], "mapped", [183]], [[904, 904], "mapped", [941]], [[905, 905], "mapped", [942]], [[906, 906], "mapped", [943]], [[907, 907], "disallowed"], [[908, 908], "mapped", [972]], [[909, 909], "disallowed"], [[910, 910], "mapped", [973]], [[911, 911], "mapped", [974]], [[912, 912], "valid"], [[913, 913], "mapped", [945]], [[914, 914], "mapped", [946]], [[915, 915], "mapped", [947]], [[916, 916], "mapped", [948]], [[917, 917], "mapped", [949]], [[918, 918], "mapped", [950]], [[919, 919], "mapped", [951]], [[920, 920], "mapped", [952]], [[921, 921], "mapped", [953]], [[922, 922], "mapped", [954]], [[923, 923], "mapped", [955]], [[924, 924], "mapped", [956]], [[925, 925], "mapped", [957]], [[926, 926], "mapped", [958]], [[927, 927], "mapped", [959]], [[928, 928], "mapped", [960]], [[929, 929], "mapped", [961]], [[930, 930], "disallowed"], [[931, 931], "mapped", [963]], [[932, 932], "mapped", [964]], [[933, 933], "mapped", [965]], [[934, 934], "mapped", [966]], [[935, 935], "mapped", [967]], [[936, 936], "mapped", [968]], [[937, 937], "mapped", [969]], [[938, 938], "mapped", [970]], [[939, 939], "mapped", [971]], [[940, 961], "valid"], [[962, 962], "deviation", [963]], [[963, 974], "valid"], [[975, 975], "mapped", [983]], [[976, 976], "mapped", [946]], [[977, 977], "mapped", [952]], [[978, 978], "mapped", [965]], [[979, 979], "mapped", [973]], [[980, 980], "mapped", [971]], [[981, 981], "mapped", [966]], [[982, 982], "mapped", [960]], [[983, 983], "valid"], [[984, 984], "mapped", [985]], [[985, 985], "valid"], [[986, 986], "mapped", [987]], [[987, 987], "valid"], [[988, 988], "mapped", [989]], [[989, 989], "valid"], [[990, 990], "mapped", [991]], [[991, 991], "valid"], [[992, 992], "mapped", [993]], [[993, 993], "valid"], [[994, 994], "mapped", [995]], [[995, 995], "valid"], [[996, 996], "mapped", [997]], [[997, 997], "valid"], [[998, 998], "mapped", [999]], [[999, 999], "valid"], [[1000, 1000], "mapped", [1001]], [[1001, 1001], "valid"], [[1002, 1002], "mapped", [1003]], [[1003, 1003], "valid"], [[1004, 1004], "mapped", [1005]], [[1005, 1005], "valid"], [[1006, 1006], "mapped", [1007]], [[1007, 1007], "valid"], [[1008, 1008], "mapped", [954]], [[1009, 1009], "mapped", [961]], [[1010, 1010], "mapped", [963]], [[1011, 1011], "valid"], [[1012, 1012], "mapped", [952]], [[1013, 1013], "mapped", [949]], [[1014, 1014], "valid", [], "NV8"], [[1015, 1015], "mapped", [1016]], [[1016, 1016], "valid"], [[1017, 1017], "mapped", [963]], [[1018, 1018], "mapped", [1019]], [[1019, 1019], "valid"], [[1020, 1020], "valid"], [[1021, 1021], "mapped", [891]], [[1022, 1022], "mapped", [892]], [[1023, 1023], "mapped", [893]], [[1024, 1024], "mapped", [1104]], [[1025, 1025], "mapped", [1105]], [[1026, 1026], "mapped", [1106]], [[1027, 1027], "mapped", [1107]], [[1028, 1028], "mapped", [1108]], [[1029, 1029], "mapped", [1109]], [[1030, 1030], "mapped", [1110]], [[1031, 1031], "mapped", [1111]], [[1032, 1032], "mapped", [1112]], [[1033, 1033], "mapped", [1113]], [[1034, 1034], "mapped", [1114]], [[1035, 1035], "mapped", [1115]], [[1036, 1036], "mapped", [1116]], [[1037, 1037], "mapped", [1117]], [[1038, 1038], "mapped", [1118]], [[1039, 1039], "mapped", [1119]], [[1040, 1040], "mapped", [1072]], [[1041, 1041], "mapped", [1073]], [[1042, 1042], "mapped", [1074]], [[1043, 1043], "mapped", [1075]], [[1044, 1044], "mapped", [1076]], [[1045, 1045], "mapped", [1077]], [[1046, 1046], "mapped", [1078]], [[1047, 1047], "mapped", [1079]], [[1048, 1048], "mapped", [1080]], [[1049, 1049], "mapped", [1081]], [[1050, 1050], "mapped", [1082]], [[1051, 1051], "mapped", [1083]], [[1052, 1052], "mapped", [1084]], [[1053, 1053], "mapped", [1085]], [[1054, 1054], "mapped", [1086]], [[1055, 1055], "mapped", [1087]], [[1056, 1056], "mapped", [1088]], [[1057, 1057], "mapped", [1089]], [[1058, 1058], "mapped", [1090]], [[1059, 1059], "mapped", [1091]], [[1060, 1060], "mapped", [1092]], [[1061, 1061], "mapped", [1093]], [[1062, 1062], "mapped", [1094]], [[1063, 1063], "mapped", [1095]], [[1064, 1064], "mapped", [1096]], [[1065, 1065], "mapped", [1097]], [[1066, 1066], "mapped", [1098]], [[1067, 1067], "mapped", [1099]], [[1068, 1068], "mapped", [1100]], [[1069, 1069], "mapped", [1101]], [[1070, 1070], "mapped", [1102]], [[1071, 1071], "mapped", [1103]], [[1072, 1103], "valid"], [[1104, 1104], "valid"], [[1105, 1116], "valid"], [[1117, 1117], "valid"], [[1118, 1119], "valid"], [[1120, 1120], "mapped", [1121]], [[1121, 1121], "valid"], [[1122, 1122], "mapped", [1123]], [[1123, 1123], "valid"], [[1124, 1124], "mapped", [1125]], [[1125, 1125], "valid"], [[1126, 1126], "mapped", [1127]], [[1127, 1127], "valid"], [[1128, 1128], "mapped", [1129]], [[1129, 1129], "valid"], [[1130, 1130], "mapped", [1131]], [[1131, 1131], "valid"], [[1132, 1132], "mapped", [1133]], [[1133, 1133], "valid"], [[1134, 1134], "mapped", [1135]], [[1135, 1135], "valid"], [[1136, 1136], "mapped", [1137]], [[1137, 1137], "valid"], [[1138, 1138], "mapped", [1139]], [[1139, 1139], "valid"], [[1140, 1140], "mapped", [1141]], [[1141, 1141], "valid"], [[1142, 1142], "mapped", [1143]], [[1143, 1143], "valid"], [[1144, 1144], "mapped", [1145]], [[1145, 1145], "valid"], [[1146, 1146], "mapped", [1147]], [[1147, 1147], "valid"], [[1148, 1148], "mapped", [1149]], [[1149, 1149], "valid"], [[1150, 1150], "mapped", [1151]], [[1151, 1151], "valid"], [[1152, 1152], "mapped", [1153]], [[1153, 1153], "valid"], [[1154, 1154], "valid", [], "NV8"], [[1155, 1158], "valid"], [[1159, 1159], "valid"], [[1160, 1161], "valid", [], "NV8"], [[1162, 1162], "mapped", [1163]], [[1163, 1163], "valid"], [[1164, 1164], "mapped", [1165]], [[1165, 1165], "valid"], [[1166, 1166], "mapped", [1167]], [[1167, 1167], "valid"], [[1168, 1168], "mapped", [1169]], [[1169, 1169], "valid"], [[1170, 1170], "mapped", [1171]], [[1171, 1171], "valid"], [[1172, 1172], "mapped", [1173]], [[1173, 1173], "valid"], [[1174, 1174], "mapped", [1175]], [[1175, 1175], "valid"], [[1176, 1176], "mapped", [1177]], [[1177, 1177], "valid"], [[1178, 1178], "mapped", [1179]], [[1179, 1179], "valid"], [[1180, 1180], "mapped", [1181]], [[1181, 1181], "valid"], [[1182, 1182], "mapped", [1183]], [[1183, 1183], "valid"], [[1184, 1184], "mapped", [1185]], [[1185, 1185], "valid"], [[1186, 1186], "mapped", [1187]], [[1187, 1187], "valid"], [[1188, 1188], "mapped", [1189]], [[1189, 1189], "valid"], [[1190, 1190], "mapped", [1191]], [[1191, 1191], "valid"], [[1192, 1192], "mapped", [1193]], [[1193, 1193], "valid"], [[1194, 1194], "mapped", [1195]], [[1195, 1195], "valid"], [[1196, 1196], "mapped", [1197]], [[1197, 1197], "valid"], [[1198, 1198], "mapped", [1199]], [[1199, 1199], "valid"], [[1200, 1200], "mapped", [1201]], [[1201, 1201], "valid"], [[1202, 1202], "mapped", [1203]], [[1203, 1203], "valid"], [[1204, 1204], "mapped", [1205]], [[1205, 1205], "valid"], [[1206, 1206], "mapped", [1207]], [[1207, 1207], "valid"], [[1208, 1208], "mapped", [1209]], [[1209, 1209], "valid"], [[1210, 1210], "mapped", [1211]], [[1211, 1211], "valid"], [[1212, 1212], "mapped", [1213]], [[1213, 1213], "valid"], [[1214, 1214], "mapped", [1215]], [[1215, 1215], "valid"], [[1216, 1216], "disallowed"], [[1217, 1217], "mapped", [1218]], [[1218, 1218], "valid"], [[1219, 1219], "mapped", [1220]], [[1220, 1220], "valid"], [[1221, 1221], "mapped", [1222]], [[1222, 1222], "valid"], [[1223, 1223], "mapped", [1224]], [[1224, 1224], "valid"], [[1225, 1225], "mapped", [1226]], [[1226, 1226], "valid"], [[1227, 1227], "mapped", [1228]], [[1228, 1228], "valid"], [[1229, 1229], "mapped", [1230]], [[1230, 1230], "valid"], [[1231, 1231], "valid"], [[1232, 1232], "mapped", [1233]], [[1233, 1233], "valid"], [[1234, 1234], "mapped", [1235]], [[1235, 1235], "valid"], [[1236, 1236], "mapped", [1237]], [[1237, 1237], "valid"], [[1238, 1238], "mapped", [1239]], [[1239, 1239], "valid"], [[1240, 1240], "mapped", [1241]], [[1241, 1241], "valid"], [[1242, 1242], "mapped", [1243]], [[1243, 1243], "valid"], [[1244, 1244], "mapped", [1245]], [[1245, 1245], "valid"], [[1246, 1246], "mapped", [1247]], [[1247, 1247], "valid"], [[1248, 1248], "mapped", [1249]], [[1249, 1249], "valid"], [[1250, 1250], "mapped", [1251]], [[1251, 1251], "valid"], [[1252, 1252], "mapped", [1253]], [[1253, 1253], "valid"], [[1254, 1254], "mapped", [1255]], [[1255, 1255], "valid"], [[1256, 1256], "mapped", [1257]], [[1257, 1257], "valid"], [[1258, 1258], "mapped", [1259]], [[1259, 1259], "valid"], [[1260, 1260], "mapped", [1261]], [[1261, 1261], "valid"], [[1262, 1262], "mapped", [1263]], [[1263, 1263], "valid"], [[1264, 1264], "mapped", [1265]], [[1265, 1265], "valid"], [[1266, 1266], "mapped", [1267]], [[1267, 1267], "valid"], [[1268, 1268], "mapped", [1269]], [[1269, 1269], "valid"], [[1270, 1270], "mapped", [1271]], [[1271, 1271], "valid"], [[1272, 1272], "mapped", [1273]], [[1273, 1273], "valid"], [[1274, 1274], "mapped", [1275]], [[1275, 1275], "valid"], [[1276, 1276], "mapped", [1277]], [[1277, 1277], "valid"], [[1278, 1278], "mapped", [1279]], [[1279, 1279], "valid"], [[1280, 1280], "mapped", [1281]], [[1281, 1281], "valid"], [[1282, 1282], "mapped", [1283]], [[1283, 1283], "valid"], [[1284, 1284], "mapped", [1285]], [[1285, 1285], "valid"], [[1286, 1286], "mapped", [1287]], [[1287, 1287], "valid"], [[1288, 1288], "mapped", [1289]], [[1289, 1289], "valid"], [[1290, 1290], "mapped", [1291]], [[1291, 1291], "valid"], [[1292, 1292], "mapped", [1293]], [[1293, 1293], "valid"], [[1294, 1294], "mapped", [1295]], [[1295, 1295], "valid"], [[1296, 1296], "mapped", [1297]], [[1297, 1297], "valid"], [[1298, 1298], "mapped", [1299]], [[1299, 1299], "valid"], [[1300, 1300], "mapped", [1301]], [[1301, 1301], "valid"], [[1302, 1302], "mapped", [1303]], [[1303, 1303], "valid"], [[1304, 1304], "mapped", [1305]], [[1305, 1305], "valid"], [[1306, 1306], "mapped", [1307]], [[1307, 1307], "valid"], [[1308, 1308], "mapped", [1309]], [[1309, 1309], "valid"], [[1310, 1310], "mapped", [1311]], [[1311, 1311], "valid"], [[1312, 1312], "mapped", [1313]], [[1313, 1313], "valid"], [[1314, 1314], "mapped", [1315]], [[1315, 1315], "valid"], [[1316, 1316], "mapped", [1317]], [[1317, 1317], "valid"], [[1318, 1318], "mapped", [1319]], [[1319, 1319], "valid"], [[1320, 1320], "mapped", [1321]], [[1321, 1321], "valid"], [[1322, 1322], "mapped", [1323]], [[1323, 1323], "valid"], [[1324, 1324], "mapped", [1325]], [[1325, 1325], "valid"], [[1326, 1326], "mapped", [1327]], [[1327, 1327], "valid"], [[1328, 1328], "disallowed"], [[1329, 1329], "mapped", [1377]], [[1330, 1330], "mapped", [1378]], [[1331, 1331], "mapped", [1379]], [[1332, 1332], "mapped", [1380]], [[1333, 1333], "mapped", [1381]], [[1334, 1334], "mapped", [1382]], [[1335, 1335], "mapped", [1383]], [[1336, 1336], "mapped", [1384]], [[1337, 1337], "mapped", [1385]], [[1338, 1338], "mapped", [1386]], [[1339, 1339], "mapped", [1387]], [[1340, 1340], "mapped", [1388]], [[1341, 1341], "mapped", [1389]], [[1342, 1342], "mapped", [1390]], [[1343, 1343], "mapped", [1391]], [[1344, 1344], "mapped", [1392]], [[1345, 1345], "mapped", [1393]], [[1346, 1346], "mapped", [1394]], [[1347, 1347], "mapped", [1395]], [[1348, 1348], "mapped", [1396]], [[1349, 1349], "mapped", [1397]], [[1350, 1350], "mapped", [1398]], [[1351, 1351], "mapped", [1399]], [[1352, 1352], "mapped", [1400]], [[1353, 1353], "mapped", [1401]], [[1354, 1354], "mapped", [1402]], [[1355, 1355], "mapped", [1403]], [[1356, 1356], "mapped", [1404]], [[1357, 1357], "mapped", [1405]], [[1358, 1358], "mapped", [1406]], [[1359, 1359], "mapped", [1407]], [[1360, 1360], "mapped", [1408]], [[1361, 1361], "mapped", [1409]], [[1362, 1362], "mapped", [1410]], [[1363, 1363], "mapped", [1411]], [[1364, 1364], "mapped", [1412]], [[1365, 1365], "mapped", [1413]], [[1366, 1366], "mapped", [1414]], [[1367, 1368], "disallowed"], [[1369, 1369], "valid"], [[1370, 1375], "valid", [], "NV8"], [[1376, 1376], "disallowed"], [[1377, 1414], "valid"], [[1415, 1415], "mapped", [1381, 1410]], [[1416, 1416], "disallowed"], [[1417, 1417], "valid", [], "NV8"], [[1418, 1418], "valid", [], "NV8"], [[1419, 1420], "disallowed"], [[1421, 1422], "valid", [], "NV8"], [[1423, 1423], "valid", [], "NV8"], [[1424, 1424], "disallowed"], [[1425, 1441], "valid"], [[1442, 1442], "valid"], [[1443, 1455], "valid"], [[1456, 1465], "valid"], [[1466, 1466], "valid"], [[1467, 1469], "valid"], [[1470, 1470], "valid", [], "NV8"], [[1471, 1471], "valid"], [[1472, 1472], "valid", [], "NV8"], [[1473, 1474], "valid"], [[1475, 1475], "valid", [], "NV8"], [[1476, 1476], "valid"], [[1477, 1477], "valid"], [[1478, 1478], "valid", [], "NV8"], [[1479, 1479], "valid"], [[1480, 1487], "disallowed"], [[1488, 1514], "valid"], [[1515, 1519], "disallowed"], [[1520, 1524], "valid"], [[1525, 1535], "disallowed"], [[1536, 1539], "disallowed"], [[1540, 1540], "disallowed"], [[1541, 1541], "disallowed"], [[1542, 1546], "valid", [], "NV8"], [[1547, 1547], "valid", [], "NV8"], [[1548, 1548], "valid", [], "NV8"], [[1549, 1551], "valid", [], "NV8"], [[1552, 1557], "valid"], [[1558, 1562], "valid"], [[1563, 1563], "valid", [], "NV8"], [[1564, 1564], "disallowed"], [[1565, 1565], "disallowed"], [[1566, 1566], "valid", [], "NV8"], [[1567, 1567], "valid", [], "NV8"], [[1568, 1568], "valid"], [[1569, 1594], "valid"], [[1595, 1599], "valid"], [[1600, 1600], "valid", [], "NV8"], [[1601, 1618], "valid"], [[1619, 1621], "valid"], [[1622, 1624], "valid"], [[1625, 1630], "valid"], [[1631, 1631], "valid"], [[1632, 1641], "valid"], [[1642, 1645], "valid", [], "NV8"], [[1646, 1647], "valid"], [[1648, 1652], "valid"], [[1653, 1653], "mapped", [1575, 1652]], [[1654, 1654], "mapped", [1608, 1652]], [[1655, 1655], "mapped", [1735, 1652]], [[1656, 1656], "mapped", [1610, 1652]], [[1657, 1719], "valid"], [[1720, 1721], "valid"], [[1722, 1726], "valid"], [[1727, 1727], "valid"], [[1728, 1742], "valid"], [[1743, 1743], "valid"], [[1744, 1747], "valid"], [[1748, 1748], "valid", [], "NV8"], [[1749, 1756], "valid"], [[1757, 1757], "disallowed"], [[1758, 1758], "valid", [], "NV8"], [[1759, 1768], "valid"], [[1769, 1769], "valid", [], "NV8"], [[1770, 1773], "valid"], [[1774, 1775], "valid"], [[1776, 1785], "valid"], [[1786, 1790], "valid"], [[1791, 1791], "valid"], [[1792, 1805], "valid", [], "NV8"], [[1806, 1806], "disallowed"], [[1807, 1807], "disallowed"], [[1808, 1836], "valid"], [[1837, 1839], "valid"], [[1840, 1866], "valid"], [[1867, 1868], "disallowed"], [[1869, 1871], "valid"], [[1872, 1901], "valid"], [[1902, 1919], "valid"], [[1920, 1968], "valid"], [[1969, 1969], "valid"], [[1970, 1983], "disallowed"], [[1984, 2037], "valid"], [[2038, 2042], "valid", [], "NV8"], [[2043, 2047], "disallowed"], [[2048, 2093], "valid"], [[2094, 2095], "disallowed"], [[2096, 2110], "valid", [], "NV8"], [[2111, 2111], "disallowed"], [[2112, 2139], "valid"], [[2140, 2141], "disallowed"], [[2142, 2142], "valid", [], "NV8"], [[2143, 2207], "disallowed"], [[2208, 2208], "valid"], [[2209, 2209], "valid"], [[2210, 2220], "valid"], [[2221, 2226], "valid"], [[2227, 2228], "valid"], [[2229, 2274], "disallowed"], [[2275, 2275], "valid"], [[2276, 2302], "valid"], [[2303, 2303], "valid"], [[2304, 2304], "valid"], [[2305, 2307], "valid"], [[2308, 2308], "valid"], [[2309, 2361], "valid"], [[2362, 2363], "valid"], [[2364, 2381], "valid"], [[2382, 2382], "valid"], [[2383, 2383], "valid"], [[2384, 2388], "valid"], [[2389, 2389], "valid"], [[2390, 2391], "valid"], [[2392, 2392], "mapped", [2325, 2364]], [[2393, 2393], "mapped", [2326, 2364]], [[2394, 2394], "mapped", [2327, 2364]], [[2395, 2395], "mapped", [2332, 2364]], [[2396, 2396], "mapped", [2337, 2364]], [[2397, 2397], "mapped", [2338, 2364]], [[2398, 2398], "mapped", [2347, 2364]], [[2399, 2399], "mapped", [2351, 2364]], [[2400, 2403], "valid"], [[2404, 2405], "valid", [], "NV8"], [[2406, 2415], "valid"], [[2416, 2416], "valid", [], "NV8"], [[2417, 2418], "valid"], [[2419, 2423], "valid"], [[2424, 2424], "valid"], [[2425, 2426], "valid"], [[2427, 2428], "valid"], [[2429, 2429], "valid"], [[2430, 2431], "valid"], [[2432, 2432], "valid"], [[2433, 2435], "valid"], [[2436, 2436], "disallowed"], [[2437, 2444], "valid"], [[2445, 2446], "disallowed"], [[2447, 2448], "valid"], [[2449, 2450], "disallowed"], [[2451, 2472], "valid"], [[2473, 2473], "disallowed"], [[2474, 2480], "valid"], [[2481, 2481], "disallowed"], [[2482, 2482], "valid"], [[2483, 2485], "disallowed"], [[2486, 2489], "valid"], [[2490, 2491], "disallowed"], [[2492, 2492], "valid"], [[2493, 2493], "valid"], [[2494, 2500], "valid"], [[2501, 2502], "disallowed"], [[2503, 2504], "valid"], [[2505, 2506], "disallowed"], [[2507, 2509], "valid"], [[2510, 2510], "valid"], [[2511, 2518], "disallowed"], [[2519, 2519], "valid"], [[2520, 2523], "disallowed"], [[2524, 2524], "mapped", [2465, 2492]], [[2525, 2525], "mapped", [2466, 2492]], [[2526, 2526], "disallowed"], [[2527, 2527], "mapped", [2479, 2492]], [[2528, 2531], "valid"], [[2532, 2533], "disallowed"], [[2534, 2545], "valid"], [[2546, 2554], "valid", [], "NV8"], [[2555, 2555], "valid", [], "NV8"], [[2556, 2560], "disallowed"], [[2561, 2561], "valid"], [[2562, 2562], "valid"], [[2563, 2563], "valid"], [[2564, 2564], "disallowed"], [[2565, 2570], "valid"], [[2571, 2574], "disallowed"], [[2575, 2576], "valid"], [[2577, 2578], "disallowed"], [[2579, 2600], "valid"], [[2601, 2601], "disallowed"], [[2602, 2608], "valid"], [[2609, 2609], "disallowed"], [[2610, 2610], "valid"], [[2611, 2611], "mapped", [2610, 2620]], [[2612, 2612], "disallowed"], [[2613, 2613], "valid"], [[2614, 2614], "mapped", [2616, 2620]], [[2615, 2615], "disallowed"], [[2616, 2617], "valid"], [[2618, 2619], "disallowed"], [[2620, 2620], "valid"], [[2621, 2621], "disallowed"], [[2622, 2626], "valid"], [[2627, 2630], "disallowed"], [[2631, 2632], "valid"], [[2633, 2634], "disallowed"], [[2635, 2637], "valid"], [[2638, 2640], "disallowed"], [[2641, 2641], "valid"], [[2642, 2648], "disallowed"], [[2649, 2649], "mapped", [2582, 2620]], [[2650, 2650], "mapped", [2583, 2620]], [[2651, 2651], "mapped", [2588, 2620]], [[2652, 2652], "valid"], [[2653, 2653], "disallowed"], [[2654, 2654], "mapped", [2603, 2620]], [[2655, 2661], "disallowed"], [[2662, 2676], "valid"], [[2677, 2677], "valid"], [[2678, 2688], "disallowed"], [[2689, 2691], "valid"], [[2692, 2692], "disallowed"], [[2693, 2699], "valid"], [[2700, 2700], "valid"], [[2701, 2701], "valid"], [[2702, 2702], "disallowed"], [[2703, 2705], "valid"], [[2706, 2706], "disallowed"], [[2707, 2728], "valid"], [[2729, 2729], "disallowed"], [[2730, 2736], "valid"], [[2737, 2737], "disallowed"], [[2738, 2739], "valid"], [[2740, 2740], "disallowed"], [[2741, 2745], "valid"], [[2746, 2747], "disallowed"], [[2748, 2757], "valid"], [[2758, 2758], "disallowed"], [[2759, 2761], "valid"], [[2762, 2762], "disallowed"], [[2763, 2765], "valid"], [[2766, 2767], "disallowed"], [[2768, 2768], "valid"], [[2769, 2783], "disallowed"], [[2784, 2784], "valid"], [[2785, 2787], "valid"], [[2788, 2789], "disallowed"], [[2790, 2799], "valid"], [[2800, 2800], "valid", [], "NV8"], [[2801, 2801], "valid", [], "NV8"], [[2802, 2808], "disallowed"], [[2809, 2809], "valid"], [[2810, 2816], "disallowed"], [[2817, 2819], "valid"], [[2820, 2820], "disallowed"], [[2821, 2828], "valid"], [[2829, 2830], "disallowed"], [[2831, 2832], "valid"], [[2833, 2834], "disallowed"], [[2835, 2856], "valid"], [[2857, 2857], "disallowed"], [[2858, 2864], "valid"], [[2865, 2865], "disallowed"], [[2866, 2867], "valid"], [[2868, 2868], "disallowed"], [[2869, 2869], "valid"], [[2870, 2873], "valid"], [[2874, 2875], "disallowed"], [[2876, 2883], "valid"], [[2884, 2884], "valid"], [[2885, 2886], "disallowed"], [[2887, 2888], "valid"], [[2889, 2890], "disallowed"], [[2891, 2893], "valid"], [[2894, 2901], "disallowed"], [[2902, 2903], "valid"], [[2904, 2907], "disallowed"], [[2908, 2908], "mapped", [2849, 2876]], [[2909, 2909], "mapped", [2850, 2876]], [[2910, 2910], "disallowed"], [[2911, 2913], "valid"], [[2914, 2915], "valid"], [[2916, 2917], "disallowed"], [[2918, 2927], "valid"], [[2928, 2928], "valid", [], "NV8"], [[2929, 2929], "valid"], [[2930, 2935], "valid", [], "NV8"], [[2936, 2945], "disallowed"], [[2946, 2947], "valid"], [[2948, 2948], "disallowed"], [[2949, 2954], "valid"], [[2955, 2957], "disallowed"], [[2958, 2960], "valid"], [[2961, 2961], "disallowed"], [[2962, 2965], "valid"], [[2966, 2968], "disallowed"], [[2969, 2970], "valid"], [[2971, 2971], "disallowed"], [[2972, 2972], "valid"], [[2973, 2973], "disallowed"], [[2974, 2975], "valid"], [[2976, 2978], "disallowed"], [[2979, 2980], "valid"], [[2981, 2983], "disallowed"], [[2984, 2986], "valid"], [[2987, 2989], "disallowed"], [[2990, 2997], "valid"], [[2998, 2998], "valid"], [[2999, 3001], "valid"], [[3002, 3005], "disallowed"], [[3006, 3010], "valid"], [[3011, 3013], "disallowed"], [[3014, 3016], "valid"], [[3017, 3017], "disallowed"], [[3018, 3021], "valid"], [[3022, 3023], "disallowed"], [[3024, 3024], "valid"], [[3025, 3030], "disallowed"], [[3031, 3031], "valid"], [[3032, 3045], "disallowed"], [[3046, 3046], "valid"], [[3047, 3055], "valid"], [[3056, 3058], "valid", [], "NV8"], [[3059, 3066], "valid", [], "NV8"], [[3067, 3071], "disallowed"], [[3072, 3072], "valid"], [[3073, 3075], "valid"], [[3076, 3076], "disallowed"], [[3077, 3084], "valid"], [[3085, 3085], "disallowed"], [[3086, 3088], "valid"], [[3089, 3089], "disallowed"], [[3090, 3112], "valid"], [[3113, 3113], "disallowed"], [[3114, 3123], "valid"], [[3124, 3124], "valid"], [[3125, 3129], "valid"], [[3130, 3132], "disallowed"], [[3133, 3133], "valid"], [[3134, 3140], "valid"], [[3141, 3141], "disallowed"], [[3142, 3144], "valid"], [[3145, 3145], "disallowed"], [[3146, 3149], "valid"], [[3150, 3156], "disallowed"], [[3157, 3158], "valid"], [[3159, 3159], "disallowed"], [[3160, 3161], "valid"], [[3162, 3162], "valid"], [[3163, 3167], "disallowed"], [[3168, 3169], "valid"], [[3170, 3171], "valid"], [[3172, 3173], "disallowed"], [[3174, 3183], "valid"], [[3184, 3191], "disallowed"], [[3192, 3199], "valid", [], "NV8"], [[3200, 3200], "disallowed"], [[3201, 3201], "valid"], [[3202, 3203], "valid"], [[3204, 3204], "disallowed"], [[3205, 3212], "valid"], [[3213, 3213], "disallowed"], [[3214, 3216], "valid"], [[3217, 3217], "disallowed"], [[3218, 3240], "valid"], [[3241, 3241], "disallowed"], [[3242, 3251], "valid"], [[3252, 3252], "disallowed"], [[3253, 3257], "valid"], [[3258, 3259], "disallowed"], [[3260, 3261], "valid"], [[3262, 3268], "valid"], [[3269, 3269], "disallowed"], [[3270, 3272], "valid"], [[3273, 3273], "disallowed"], [[3274, 3277], "valid"], [[3278, 3284], "disallowed"], [[3285, 3286], "valid"], [[3287, 3293], "disallowed"], [[3294, 3294], "valid"], [[3295, 3295], "disallowed"], [[3296, 3297], "valid"], [[3298, 3299], "valid"], [[3300, 3301], "disallowed"], [[3302, 3311], "valid"], [[3312, 3312], "disallowed"], [[3313, 3314], "valid"], [[3315, 3328], "disallowed"], [[3329, 3329], "valid"], [[3330, 3331], "valid"], [[3332, 3332], "disallowed"], [[3333, 3340], "valid"], [[3341, 3341], "disallowed"], [[3342, 3344], "valid"], [[3345, 3345], "disallowed"], [[3346, 3368], "valid"], [[3369, 3369], "valid"], [[3370, 3385], "valid"], [[3386, 3386], "valid"], [[3387, 3388], "disallowed"], [[3389, 3389], "valid"], [[3390, 3395], "valid"], [[3396, 3396], "valid"], [[3397, 3397], "disallowed"], [[3398, 3400], "valid"], [[3401, 3401], "disallowed"], [[3402, 3405], "valid"], [[3406, 3406], "valid"], [[3407, 3414], "disallowed"], [[3415, 3415], "valid"], [[3416, 3422], "disallowed"], [[3423, 3423], "valid"], [[3424, 3425], "valid"], [[3426, 3427], "valid"], [[3428, 3429], "disallowed"], [[3430, 3439], "valid"], [[3440, 3445], "valid", [], "NV8"], [[3446, 3448], "disallowed"], [[3449, 3449], "valid", [], "NV8"], [[3450, 3455], "valid"], [[3456, 3457], "disallowed"], [[3458, 3459], "valid"], [[3460, 3460], "disallowed"], [[3461, 3478], "valid"], [[3479, 3481], "disallowed"], [[3482, 3505], "valid"], [[3506, 3506], "disallowed"], [[3507, 3515], "valid"], [[3516, 3516], "disallowed"], [[3517, 3517], "valid"], [[3518, 3519], "disallowed"], [[3520, 3526], "valid"], [[3527, 3529], "disallowed"], [[3530, 3530], "valid"], [[3531, 3534], "disallowed"], [[3535, 3540], "valid"], [[3541, 3541], "disallowed"], [[3542, 3542], "valid"], [[3543, 3543], "disallowed"], [[3544, 3551], "valid"], [[3552, 3557], "disallowed"], [[3558, 3567], "valid"], [[3568, 3569], "disallowed"], [[3570, 3571], "valid"], [[3572, 3572], "valid", [], "NV8"], [[3573, 3584], "disallowed"], [[3585, 3634], "valid"], [[3635, 3635], "mapped", [3661, 3634]], [[3636, 3642], "valid"], [[3643, 3646], "disallowed"], [[3647, 3647], "valid", [], "NV8"], [[3648, 3662], "valid"], [[3663, 3663], "valid", [], "NV8"], [[3664, 3673], "valid"], [[3674, 3675], "valid", [], "NV8"], [[3676, 3712], "disallowed"], [[3713, 3714], "valid"], [[3715, 3715], "disallowed"], [[3716, 3716], "valid"], [[3717, 3718], "disallowed"], [[3719, 3720], "valid"], [[3721, 3721], "disallowed"], [[3722, 3722], "valid"], [[3723, 3724], "disallowed"], [[3725, 3725], "valid"], [[3726, 3731], "disallowed"], [[3732, 3735], "valid"], [[3736, 3736], "disallowed"], [[3737, 3743], "valid"], [[3744, 3744], "disallowed"], [[3745, 3747], "valid"], [[3748, 3748], "disallowed"], [[3749, 3749], "valid"], [[3750, 3750], "disallowed"], [[3751, 3751], "valid"], [[3752, 3753], "disallowed"], [[3754, 3755], "valid"], [[3756, 3756], "disallowed"], [[3757, 3762], "valid"], [[3763, 3763], "mapped", [3789, 3762]], [[3764, 3769], "valid"], [[3770, 3770], "disallowed"], [[3771, 3773], "valid"], [[3774, 3775], "disallowed"], [[3776, 3780], "valid"], [[3781, 3781], "disallowed"], [[3782, 3782], "valid"], [[3783, 3783], "disallowed"], [[3784, 3789], "valid"], [[3790, 3791], "disallowed"], [[3792, 3801], "valid"], [[3802, 3803], "disallowed"], [[3804, 3804], "mapped", [3755, 3737]], [[3805, 3805], "mapped", [3755, 3745]], [[3806, 3807], "valid"], [[3808, 3839], "disallowed"], [[3840, 3840], "valid"], [[3841, 3850], "valid", [], "NV8"], [[3851, 3851], "valid"], [[3852, 3852], "mapped", [3851]], [[3853, 3863], "valid", [], "NV8"], [[3864, 3865], "valid"], [[3866, 3871], "valid", [], "NV8"], [[3872, 3881], "valid"], [[3882, 3892], "valid", [], "NV8"], [[3893, 3893], "valid"], [[3894, 3894], "valid", [], "NV8"], [[3895, 3895], "valid"], [[3896, 3896], "valid", [], "NV8"], [[3897, 3897], "valid"], [[3898, 3901], "valid", [], "NV8"], [[3902, 3906], "valid"], [[3907, 3907], "mapped", [3906, 4023]], [[3908, 3911], "valid"], [[3912, 3912], "disallowed"], [[3913, 3916], "valid"], [[3917, 3917], "mapped", [3916, 4023]], [[3918, 3921], "valid"], [[3922, 3922], "mapped", [3921, 4023]], [[3923, 3926], "valid"], [[3927, 3927], "mapped", [3926, 4023]], [[3928, 3931], "valid"], [[3932, 3932], "mapped", [3931, 4023]], [[3933, 3944], "valid"], [[3945, 3945], "mapped", [3904, 4021]], [[3946, 3946], "valid"], [[3947, 3948], "valid"], [[3949, 3952], "disallowed"], [[3953, 3954], "valid"], [[3955, 3955], "mapped", [3953, 3954]], [[3956, 3956], "valid"], [[3957, 3957], "mapped", [3953, 3956]], [[3958, 3958], "mapped", [4018, 3968]], [[3959, 3959], "mapped", [4018, 3953, 3968]], [[3960, 3960], "mapped", [4019, 3968]], [[3961, 3961], "mapped", [4019, 3953, 3968]], [[3962, 3968], "valid"], [[3969, 3969], "mapped", [3953, 3968]], [[3970, 3972], "valid"], [[3973, 3973], "valid", [], "NV8"], [[3974, 3979], "valid"], [[3980, 3983], "valid"], [[3984, 3986], "valid"], [[3987, 3987], "mapped", [3986, 4023]], [[3988, 3989], "valid"], [[3990, 3990], "valid"], [[3991, 3991], "valid"], [[3992, 3992], "disallowed"], [[3993, 3996], "valid"], [[3997, 3997], "mapped", [3996, 4023]], [[3998, 4001], "valid"], [[4002, 4002], "mapped", [4001, 4023]], [[4003, 4006], "valid"], [[4007, 4007], "mapped", [4006, 4023]], [[4008, 4011], "valid"], [[4012, 4012], "mapped", [4011, 4023]], [[4013, 4013], "valid"], [[4014, 4016], "valid"], [[4017, 4023], "valid"], [[4024, 4024], "valid"], [[4025, 4025], "mapped", [3984, 4021]], [[4026, 4028], "valid"], [[4029, 4029], "disallowed"], [[4030, 4037], "valid", [], "NV8"], [[4038, 4038], "valid"], [[4039, 4044], "valid", [], "NV8"], [[4045, 4045], "disallowed"], [[4046, 4046], "valid", [], "NV8"], [[4047, 4047], "valid", [], "NV8"], [[4048, 4049], "valid", [], "NV8"], [[4050, 4052], "valid", [], "NV8"], [[4053, 4056], "valid", [], "NV8"], [[4057, 4058], "valid", [], "NV8"], [[4059, 4095], "disallowed"], [[4096, 4129], "valid"], [[4130, 4130], "valid"], [[4131, 4135], "valid"], [[4136, 4136], "valid"], [[4137, 4138], "valid"], [[4139, 4139], "valid"], [[4140, 4146], "valid"], [[4147, 4149], "valid"], [[4150, 4153], "valid"], [[4154, 4159], "valid"], [[4160, 4169], "valid"], [[4170, 4175], "valid", [], "NV8"], [[4176, 4185], "valid"], [[4186, 4249], "valid"], [[4250, 4253], "valid"], [[4254, 4255], "valid", [], "NV8"], [[4256, 4293], "disallowed"], [[4294, 4294], "disallowed"], [[4295, 4295], "mapped", [11559]], [[4296, 4300], "disallowed"], [[4301, 4301], "mapped", [11565]], [[4302, 4303], "disallowed"], [[4304, 4342], "valid"], [[4343, 4344], "valid"], [[4345, 4346], "valid"], [[4347, 4347], "valid", [], "NV8"], [[4348, 4348], "mapped", [4316]], [[4349, 4351], "valid"], [[4352, 4441], "valid", [], "NV8"], [[4442, 4446], "valid", [], "NV8"], [[4447, 4448], "disallowed"], [[4449, 4514], "valid", [], "NV8"], [[4515, 4519], "valid", [], "NV8"], [[4520, 4601], "valid", [], "NV8"], [[4602, 4607], "valid", [], "NV8"], [[4608, 4614], "valid"], [[4615, 4615], "valid"], [[4616, 4678], "valid"], [[4679, 4679], "valid"], [[4680, 4680], "valid"], [[4681, 4681], "disallowed"], [[4682, 4685], "valid"], [[4686, 4687], "disallowed"], [[4688, 4694], "valid"], [[4695, 4695], "disallowed"], [[4696, 4696], "valid"], [[4697, 4697], "disallowed"], [[4698, 4701], "valid"], [[4702, 4703], "disallowed"], [[4704, 4742], "valid"], [[4743, 4743], "valid"], [[4744, 4744], "valid"], [[4745, 4745], "disallowed"], [[4746, 4749], "valid"], [[4750, 4751], "disallowed"], [[4752, 4782], "valid"], [[4783, 4783], "valid"], [[4784, 4784], "valid"], [[4785, 4785], "disallowed"], [[4786, 4789], "valid"], [[4790, 4791], "disallowed"], [[4792, 4798], "valid"], [[4799, 4799], "disallowed"], [[4800, 4800], "valid"], [[4801, 4801], "disallowed"], [[4802, 4805], "valid"], [[4806, 4807], "disallowed"], [[4808, 4814], "valid"], [[4815, 4815], "valid"], [[4816, 4822], "valid"], [[4823, 4823], "disallowed"], [[4824, 4846], "valid"], [[4847, 4847], "valid"], [[4848, 4878], "valid"], [[4879, 4879], "valid"], [[4880, 4880], "valid"], [[4881, 4881], "disallowed"], [[4882, 4885], "valid"], [[4886, 4887], "disallowed"], [[4888, 4894], "valid"], [[4895, 4895], "valid"], [[4896, 4934], "valid"], [[4935, 4935], "valid"], [[4936, 4954], "valid"], [[4955, 4956], "disallowed"], [[4957, 4958], "valid"], [[4959, 4959], "valid"], [[4960, 4960], "valid", [], "NV8"], [[4961, 4988], "valid", [], "NV8"], [[4989, 4991], "disallowed"], [[4992, 5007], "valid"], [[5008, 5017], "valid", [], "NV8"], [[5018, 5023], "disallowed"], [[5024, 5108], "valid"], [[5109, 5109], "valid"], [[5110, 5111], "disallowed"], [[5112, 5112], "mapped", [5104]], [[5113, 5113], "mapped", [5105]], [[5114, 5114], "mapped", [5106]], [[5115, 5115], "mapped", [5107]], [[5116, 5116], "mapped", [5108]], [[5117, 5117], "mapped", [5109]], [[5118, 5119], "disallowed"], [[5120, 5120], "valid", [], "NV8"], [[5121, 5740], "valid"], [[5741, 5742], "valid", [], "NV8"], [[5743, 5750], "valid"], [[5751, 5759], "valid"], [[5760, 5760], "disallowed"], [[5761, 5786], "valid"], [[5787, 5788], "valid", [], "NV8"], [[5789, 5791], "disallowed"], [[5792, 5866], "valid"], [[5867, 5872], "valid", [], "NV8"], [[5873, 5880], "valid"], [[5881, 5887], "disallowed"], [[5888, 5900], "valid"], [[5901, 5901], "disallowed"], [[5902, 5908], "valid"], [[5909, 5919], "disallowed"], [[5920, 5940], "valid"], [[5941, 5942], "valid", [], "NV8"], [[5943, 5951], "disallowed"], [[5952, 5971], "valid"], [[5972, 5983], "disallowed"], [[5984, 5996], "valid"], [[5997, 5997], "disallowed"], [[5998, 6000], "valid"], [[6001, 6001], "disallowed"], [[6002, 6003], "valid"], [[6004, 6015], "disallowed"], [[6016, 6067], "valid"], [[6068, 6069], "disallowed"], [[6070, 6099], "valid"], [[6100, 6102], "valid", [], "NV8"], [[6103, 6103], "valid"], [[6104, 6107], "valid", [], "NV8"], [[6108, 6108], "valid"], [[6109, 6109], "valid"], [[6110, 6111], "disallowed"], [[6112, 6121], "valid"], [[6122, 6127], "disallowed"], [[6128, 6137], "valid", [], "NV8"], [[6138, 6143], "disallowed"], [[6144, 6149], "valid", [], "NV8"], [[6150, 6150], "disallowed"], [[6151, 6154], "valid", [], "NV8"], [[6155, 6157], "ignored"], [[6158, 6158], "disallowed"], [[6159, 6159], "disallowed"], [[6160, 6169], "valid"], [[6170, 6175], "disallowed"], [[6176, 6263], "valid"], [[6264, 6271], "disallowed"], [[6272, 6313], "valid"], [[6314, 6314], "valid"], [[6315, 6319], "disallowed"], [[6320, 6389], "valid"], [[6390, 6399], "disallowed"], [[6400, 6428], "valid"], [[6429, 6430], "valid"], [[6431, 6431], "disallowed"], [[6432, 6443], "valid"], [[6444, 6447], "disallowed"], [[6448, 6459], "valid"], [[6460, 6463], "disallowed"], [[6464, 6464], "valid", [], "NV8"], [[6465, 6467], "disallowed"], [[6468, 6469], "valid", [], "NV8"], [[6470, 6509], "valid"], [[6510, 6511], "disallowed"], [[6512, 6516], "valid"], [[6517, 6527], "disallowed"], [[6528, 6569], "valid"], [[6570, 6571], "valid"], [[6572, 6575], "disallowed"], [[6576, 6601], "valid"], [[6602, 6607], "disallowed"], [[6608, 6617], "valid"], [[6618, 6618], "valid", [], "XV8"], [[6619, 6621], "disallowed"], [[6622, 6623], "valid", [], "NV8"], [[6624, 6655], "valid", [], "NV8"], [[6656, 6683], "valid"], [[6684, 6685], "disallowed"], [[6686, 6687], "valid", [], "NV8"], [[6688, 6750], "valid"], [[6751, 6751], "disallowed"], [[6752, 6780], "valid"], [[6781, 6782], "disallowed"], [[6783, 6793], "valid"], [[6794, 6799], "disallowed"], [[6800, 6809], "valid"], [[6810, 6815], "disallowed"], [[6816, 6822], "valid", [], "NV8"], [[6823, 6823], "valid"], [[6824, 6829], "valid", [], "NV8"], [[6830, 6831], "disallowed"], [[6832, 6845], "valid"], [[6846, 6846], "valid", [], "NV8"], [[6847, 6911], "disallowed"], [[6912, 6987], "valid"], [[6988, 6991], "disallowed"], [[6992, 7001], "valid"], [[7002, 7018], "valid", [], "NV8"], [[7019, 7027], "valid"], [[7028, 7036], "valid", [], "NV8"], [[7037, 7039], "disallowed"], [[7040, 7082], "valid"], [[7083, 7085], "valid"], [[7086, 7097], "valid"], [[7098, 7103], "valid"], [[7104, 7155], "valid"], [[7156, 7163], "disallowed"], [[7164, 7167], "valid", [], "NV8"], [[7168, 7223], "valid"], [[7224, 7226], "disallowed"], [[7227, 7231], "valid", [], "NV8"], [[7232, 7241], "valid"], [[7242, 7244], "disallowed"], [[7245, 7293], "valid"], [[7294, 7295], "valid", [], "NV8"], [[7296, 7359], "disallowed"], [[7360, 7367], "valid", [], "NV8"], [[7368, 7375], "disallowed"], [[7376, 7378], "valid"], [[7379, 7379], "valid", [], "NV8"], [[7380, 7410], "valid"], [[7411, 7414], "valid"], [[7415, 7415], "disallowed"], [[7416, 7417], "valid"], [[7418, 7423], "disallowed"], [[7424, 7467], "valid"], [[7468, 7468], "mapped", [97]], [[7469, 7469], "mapped", [230]], [[7470, 7470], "mapped", [98]], [[7471, 7471], "valid"], [[7472, 7472], "mapped", [100]], [[7473, 7473], "mapped", [101]], [[7474, 7474], "mapped", [477]], [[7475, 7475], "mapped", [103]], [[7476, 7476], "mapped", [104]], [[7477, 7477], "mapped", [105]], [[7478, 7478], "mapped", [106]], [[7479, 7479], "mapped", [107]], [[7480, 7480], "mapped", [108]], [[7481, 7481], "mapped", [109]], [[7482, 7482], "mapped", [110]], [[7483, 7483], "valid"], [[7484, 7484], "mapped", [111]], [[7485, 7485], "mapped", [547]], [[7486, 7486], "mapped", [112]], [[7487, 7487], "mapped", [114]], [[7488, 7488], "mapped", [116]], [[7489, 7489], "mapped", [117]], [[7490, 7490], "mapped", [119]], [[7491, 7491], "mapped", [97]], [[7492, 7492], "mapped", [592]], [[7493, 7493], "mapped", [593]], [[7494, 7494], "mapped", [7426]], [[7495, 7495], "mapped", [98]], [[7496, 7496], "mapped", [100]], [[7497, 7497], "mapped", [101]], [[7498, 7498], "mapped", [601]], [[7499, 7499], "mapped", [603]], [[7500, 7500], "mapped", [604]], [[7501, 7501], "mapped", [103]], [[7502, 7502], "valid"], [[7503, 7503], "mapped", [107]], [[7504, 7504], "mapped", [109]], [[7505, 7505], "mapped", [331]], [[7506, 7506], "mapped", [111]], [[7507, 7507], "mapped", [596]], [[7508, 7508], "mapped", [7446]], [[7509, 7509], "mapped", [7447]], [[7510, 7510], "mapped", [112]], [[7511, 7511], "mapped", [116]], [[7512, 7512], "mapped", [117]], [[7513, 7513], "mapped", [7453]], [[7514, 7514], "mapped", [623]], [[7515, 7515], "mapped", [118]], [[7516, 7516], "mapped", [7461]], [[7517, 7517], "mapped", [946]], [[7518, 7518], "mapped", [947]], [[7519, 7519], "mapped", [948]], [[7520, 7520], "mapped", [966]], [[7521, 7521], "mapped", [967]], [[7522, 7522], "mapped", [105]], [[7523, 7523], "mapped", [114]], [[7524, 7524], "mapped", [117]], [[7525, 7525], "mapped", [118]], [[7526, 7526], "mapped", [946]], [[7527, 7527], "mapped", [947]], [[7528, 7528], "mapped", [961]], [[7529, 7529], "mapped", [966]], [[7530, 7530], "mapped", [967]], [[7531, 7531], "valid"], [[7532, 7543], "valid"], [[7544, 7544], "mapped", [1085]], [[7545, 7578], "valid"], [[7579, 7579], "mapped", [594]], [[7580, 7580], "mapped", [99]], [[7581, 7581], "mapped", [597]], [[7582, 7582], "mapped", [240]], [[7583, 7583], "mapped", [604]], [[7584, 7584], "mapped", [102]], [[7585, 7585], "mapped", [607]], [[7586, 7586], "mapped", [609]], [[7587, 7587], "mapped", [613]], [[7588, 7588], "mapped", [616]], [[7589, 7589], "mapped", [617]], [[7590, 7590], "mapped", [618]], [[7591, 7591], "mapped", [7547]], [[7592, 7592], "mapped", [669]], [[7593, 7593], "mapped", [621]], [[7594, 7594], "mapped", [7557]], [[7595, 7595], "mapped", [671]], [[7596, 7596], "mapped", [625]], [[7597, 7597], "mapped", [624]], [[7598, 7598], "mapped", [626]], [[7599, 7599], "mapped", [627]], [[7600, 7600], "mapped", [628]], [[7601, 7601], "mapped", [629]], [[7602, 7602], "mapped", [632]], [[7603, 7603], "mapped", [642]], [[7604, 7604], "mapped", [643]], [[7605, 7605], "mapped", [427]], [[7606, 7606], "mapped", [649]], [[7607, 7607], "mapped", [650]], [[7608, 7608], "mapped", [7452]], [[7609, 7609], "mapped", [651]], [[7610, 7610], "mapped", [652]], [[7611, 7611], "mapped", [122]], [[7612, 7612], "mapped", [656]], [[7613, 7613], "mapped", [657]], [[7614, 7614], "mapped", [658]], [[7615, 7615], "mapped", [952]], [[7616, 7619], "valid"], [[7620, 7626], "valid"], [[7627, 7654], "valid"], [[7655, 7669], "valid"], [[7670, 7675], "disallowed"], [[7676, 7676], "valid"], [[7677, 7677], "valid"], [[7678, 7679], "valid"], [[7680, 7680], "mapped", [7681]], [[7681, 7681], "valid"], [[7682, 7682], "mapped", [7683]], [[7683, 7683], "valid"], [[7684, 7684], "mapped", [7685]], [[7685, 7685], "valid"], [[7686, 7686], "mapped", [7687]], [[7687, 7687], "valid"], [[7688, 7688], "mapped", [7689]], [[7689, 7689], "valid"], [[7690, 7690], "mapped", [7691]], [[7691, 7691], "valid"], [[7692, 7692], "mapped", [7693]], [[7693, 7693], "valid"], [[7694, 7694], "mapped", [7695]], [[7695, 7695], "valid"], [[7696, 7696], "mapped", [7697]], [[7697, 7697], "valid"], [[7698, 7698], "mapped", [7699]], [[7699, 7699], "valid"], [[7700, 7700], "mapped", [7701]], [[7701, 7701], "valid"], [[7702, 7702], "mapped", [7703]], [[7703, 7703], "valid"], [[7704, 7704], "mapped", [7705]], [[7705, 7705], "valid"], [[7706, 7706], "mapped", [7707]], [[7707, 7707], "valid"], [[7708, 7708], "mapped", [7709]], [[7709, 7709], "valid"], [[7710, 7710], "mapped", [7711]], [[7711, 7711], "valid"], [[7712, 7712], "mapped", [7713]], [[7713, 7713], "valid"], [[7714, 7714], "mapped", [7715]], [[7715, 7715], "valid"], [[7716, 7716], "mapped", [7717]], [[7717, 7717], "valid"], [[7718, 7718], "mapped", [7719]], [[7719, 7719], "valid"], [[7720, 7720], "mapped", [7721]], [[7721, 7721], "valid"], [[7722, 7722], "mapped", [7723]], [[7723, 7723], "valid"], [[7724, 7724], "mapped", [7725]], [[7725, 7725], "valid"], [[7726, 7726], "mapped", [7727]], [[7727, 7727], "valid"], [[7728, 7728], "mapped", [7729]], [[7729, 7729], "valid"], [[7730, 7730], "mapped", [7731]], [[7731, 7731], "valid"], [[7732, 7732], "mapped", [7733]], [[7733, 7733], "valid"], [[7734, 7734], "mapped", [7735]], [[7735, 7735], "valid"], [[7736, 7736], "mapped", [7737]], [[7737, 7737], "valid"], [[7738, 7738], "mapped", [7739]], [[7739, 7739], "valid"], [[7740, 7740], "mapped", [7741]], [[7741, 7741], "valid"], [[7742, 7742], "mapped", [7743]], [[7743, 7743], "valid"], [[7744, 7744], "mapped", [7745]], [[7745, 7745], "valid"], [[7746, 7746], "mapped", [7747]], [[7747, 7747], "valid"], [[7748, 7748], "mapped", [7749]], [[7749, 7749], "valid"], [[7750, 7750], "mapped", [7751]], [[7751, 7751], "valid"], [[7752, 7752], "mapped", [7753]], [[7753, 7753], "valid"], [[7754, 7754], "mapped", [7755]], [[7755, 7755], "valid"], [[7756, 7756], "mapped", [7757]], [[7757, 7757], "valid"], [[7758, 7758], "mapped", [7759]], [[7759, 7759], "valid"], [[7760, 7760], "mapped", [7761]], [[7761, 7761], "valid"], [[7762, 7762], "mapped", [7763]], [[7763, 7763], "valid"], [[7764, 7764], "mapped", [7765]], [[7765, 7765], "valid"], [[7766, 7766], "mapped", [7767]], [[7767, 7767], "valid"], [[7768, 7768], "mapped", [7769]], [[7769, 7769], "valid"], [[7770, 7770], "mapped", [7771]], [[7771, 7771], "valid"], [[7772, 7772], "mapped", [7773]], [[7773, 7773], "valid"], [[7774, 7774], "mapped", [7775]], [[7775, 7775], "valid"], [[7776, 7776], "mapped", [7777]], [[7777, 7777], "valid"], [[7778, 7778], "mapped", [7779]], [[7779, 7779], "valid"], [[7780, 7780], "mapped", [7781]], [[7781, 7781], "valid"], [[7782, 7782], "mapped", [7783]], [[7783, 7783], "valid"], [[7784, 7784], "mapped", [7785]], [[7785, 7785], "valid"], [[7786, 7786], "mapped", [7787]], [[7787, 7787], "valid"], [[7788, 7788], "mapped", [7789]], [[7789, 7789], "valid"], [[7790, 7790], "mapped", [7791]], [[7791, 7791], "valid"], [[7792, 7792], "mapped", [7793]], [[7793, 7793], "valid"], [[7794, 7794], "mapped", [7795]], [[7795, 7795], "valid"], [[7796, 7796], "mapped", [7797]], [[7797, 7797], "valid"], [[7798, 7798], "mapped", [7799]], [[7799, 7799], "valid"], [[7800, 7800], "mapped", [7801]], [[7801, 7801], "valid"], [[7802, 7802], "mapped", [7803]], [[7803, 7803], "valid"], [[7804, 7804], "mapped", [7805]], [[7805, 7805], "valid"], [[7806, 7806], "mapped", [7807]], [[7807, 7807], "valid"], [[7808, 7808], "mapped", [7809]], [[7809, 7809], "valid"], [[7810, 7810], "mapped", [7811]], [[7811, 7811], "valid"], [[7812, 7812], "mapped", [7813]], [[7813, 7813], "valid"], [[7814, 7814], "mapped", [7815]], [[7815, 7815], "valid"], [[7816, 7816], "mapped", [7817]], [[7817, 7817], "valid"], [[7818, 7818], "mapped", [7819]], [[7819, 7819], "valid"], [[7820, 7820], "mapped", [7821]], [[7821, 7821], "valid"], [[7822, 7822], "mapped", [7823]], [[7823, 7823], "valid"], [[7824, 7824], "mapped", [7825]], [[7825, 7825], "valid"], [[7826, 7826], "mapped", [7827]], [[7827, 7827], "valid"], [[7828, 7828], "mapped", [7829]], [[7829, 7833], "valid"], [[7834, 7834], "mapped", [97, 702]], [[7835, 7835], "mapped", [7777]], [[7836, 7837], "valid"], [[7838, 7838], "mapped", [115, 115]], [[7839, 7839], "valid"], [[7840, 7840], "mapped", [7841]], [[7841, 7841], "valid"], [[7842, 7842], "mapped", [7843]], [[7843, 7843], "valid"], [[7844, 7844], "mapped", [7845]], [[7845, 7845], "valid"], [[7846, 7846], "mapped", [7847]], [[7847, 7847], "valid"], [[7848, 7848], "mapped", [7849]], [[7849, 7849], "valid"], [[7850, 7850], "mapped", [7851]], [[7851, 7851], "valid"], [[7852, 7852], "mapped", [7853]], [[7853, 7853], "valid"], [[7854, 7854], "mapped", [7855]], [[7855, 7855], "valid"], [[7856, 7856], "mapped", [7857]], [[7857, 7857], "valid"], [[7858, 7858], "mapped", [7859]], [[7859, 7859], "valid"], [[7860, 7860], "mapped", [7861]], [[7861, 7861], "valid"], [[7862, 7862], "mapped", [7863]], [[7863, 7863], "valid"], [[7864, 7864], "mapped", [7865]], [[7865, 7865], "valid"], [[7866, 7866], "mapped", [7867]], [[7867, 7867], "valid"], [[7868, 7868], "mapped", [7869]], [[7869, 7869], "valid"], [[7870, 7870], "mapped", [7871]], [[7871, 7871], "valid"], [[7872, 7872], "mapped", [7873]], [[7873, 7873], "valid"], [[7874, 7874], "mapped", [7875]], [[7875, 7875], "valid"], [[7876, 7876], "mapped", [7877]], [[7877, 7877], "valid"], [[7878, 7878], "mapped", [7879]], [[7879, 7879], "valid"], [[7880, 7880], "mapped", [7881]], [[7881, 7881], "valid"], [[7882, 7882], "mapped", [7883]], [[7883, 7883], "valid"], [[7884, 7884], "mapped", [7885]], [[7885, 7885], "valid"], [[7886, 7886], "mapped", [7887]], [[7887, 7887], "valid"], [[7888, 7888], "mapped", [7889]], [[7889, 7889], "valid"], [[7890, 7890], "mapped", [7891]], [[7891, 7891], "valid"], [[7892, 7892], "mapped", [7893]], [[7893, 7893], "valid"], [[7894, 7894], "mapped", [7895]], [[7895, 7895], "valid"], [[7896, 7896], "mapped", [7897]], [[7897, 7897], "valid"], [[7898, 7898], "mapped", [7899]], [[7899, 7899], "valid"], [[7900, 7900], "mapped", [7901]], [[7901, 7901], "valid"], [[7902, 7902], "mapped", [7903]], [[7903, 7903], "valid"], [[7904, 7904], "mapped", [7905]], [[7905, 7905], "valid"], [[7906, 7906], "mapped", [7907]], [[7907, 7907], "valid"], [[7908, 7908], "mapped", [7909]], [[7909, 7909], "valid"], [[7910, 7910], "mapped", [7911]], [[7911, 7911], "valid"], [[7912, 7912], "mapped", [7913]], [[7913, 7913], "valid"], [[7914, 7914], "mapped", [7915]], [[7915, 7915], "valid"], [[7916, 7916], "mapped", [7917]], [[7917, 7917], "valid"], [[7918, 7918], "mapped", [7919]], [[7919, 7919], "valid"], [[7920, 7920], "mapped", [7921]], [[7921, 7921], "valid"], [[7922, 7922], "mapped", [7923]], [[7923, 7923], "valid"], [[7924, 7924], "mapped", [7925]], [[7925, 7925], "valid"], [[7926, 7926], "mapped", [7927]], [[7927, 7927], "valid"], [[7928, 7928], "mapped", [7929]], [[7929, 7929], "valid"], [[7930, 7930], "mapped", [7931]], [[7931, 7931], "valid"], [[7932, 7932], "mapped", [7933]], [[7933, 7933], "valid"], [[7934, 7934], "mapped", [7935]], [[7935, 7935], "valid"], [[7936, 7943], "valid"], [[7944, 7944], "mapped", [7936]], [[7945, 7945], "mapped", [7937]], [[7946, 7946], "mapped", [7938]], [[7947, 7947], "mapped", [7939]], [[7948, 7948], "mapped", [7940]], [[7949, 7949], "mapped", [7941]], [[7950, 7950], "mapped", [7942]], [[7951, 7951], "mapped", [7943]], [[7952, 7957], "valid"], [[7958, 7959], "disallowed"], [[7960, 7960], "mapped", [7952]], [[7961, 7961], "mapped", [7953]], [[7962, 7962], "mapped", [7954]], [[7963, 7963], "mapped", [7955]], [[7964, 7964], "mapped", [7956]], [[7965, 7965], "mapped", [7957]], [[7966, 7967], "disallowed"], [[7968, 7975], "valid"], [[7976, 7976], "mapped", [7968]], [[7977, 7977], "mapped", [7969]], [[7978, 7978], "mapped", [7970]], [[7979, 7979], "mapped", [7971]], [[7980, 7980], "mapped", [7972]], [[7981, 7981], "mapped", [7973]], [[7982, 7982], "mapped", [7974]], [[7983, 7983], "mapped", [7975]], [[7984, 7991], "valid"], [[7992, 7992], "mapped", [7984]], [[7993, 7993], "mapped", [7985]], [[7994, 7994], "mapped", [7986]], [[7995, 7995], "mapped", [7987]], [[7996, 7996], "mapped", [7988]], [[7997, 7997], "mapped", [7989]], [[7998, 7998], "mapped", [7990]], [[7999, 7999], "mapped", [7991]], [[8000, 8005], "valid"], [[8006, 8007], "disallowed"], [[8008, 8008], "mapped", [8000]], [[8009, 8009], "mapped", [8001]], [[8010, 8010], "mapped", [8002]], [[8011, 8011], "mapped", [8003]], [[8012, 8012], "mapped", [8004]], [[8013, 8013], "mapped", [8005]], [[8014, 8015], "disallowed"], [[8016, 8023], "valid"], [[8024, 8024], "disallowed"], [[8025, 8025], "mapped", [8017]], [[8026, 8026], "disallowed"], [[8027, 8027], "mapped", [8019]], [[8028, 8028], "disallowed"], [[8029, 8029], "mapped", [8021]], [[8030, 8030], "disallowed"], [[8031, 8031], "mapped", [8023]], [[8032, 8039], "valid"], [[8040, 8040], "mapped", [8032]], [[8041, 8041], "mapped", [8033]], [[8042, 8042], "mapped", [8034]], [[8043, 8043], "mapped", [8035]], [[8044, 8044], "mapped", [8036]], [[8045, 8045], "mapped", [8037]], [[8046, 8046], "mapped", [8038]], [[8047, 8047], "mapped", [8039]], [[8048, 8048], "valid"], [[8049, 8049], "mapped", [940]], [[8050, 8050], "valid"], [[8051, 8051], "mapped", [941]], [[8052, 8052], "valid"], [[8053, 8053], "mapped", [942]], [[8054, 8054], "valid"], [[8055, 8055], "mapped", [943]], [[8056, 8056], "valid"], [[8057, 8057], "mapped", [972]], [[8058, 8058], "valid"], [[8059, 8059], "mapped", [973]], [[8060, 8060], "valid"], [[8061, 8061], "mapped", [974]], [[8062, 8063], "disallowed"], [[8064, 8064], "mapped", [7936, 953]], [[8065, 8065], "mapped", [7937, 953]], [[8066, 8066], "mapped", [7938, 953]], [[8067, 8067], "mapped", [7939, 953]], [[8068, 8068], "mapped", [7940, 953]], [[8069, 8069], "mapped", [7941, 953]], [[8070, 8070], "mapped", [7942, 953]], [[8071, 8071], "mapped", [7943, 953]], [[8072, 8072], "mapped", [7936, 953]], [[8073, 8073], "mapped", [7937, 953]], [[8074, 8074], "mapped", [7938, 953]], [[8075, 8075], "mapped", [7939, 953]], [[8076, 8076], "mapped", [7940, 953]], [[8077, 8077], "mapped", [7941, 953]], [[8078, 8078], "mapped", [7942, 953]], [[8079, 8079], "mapped", [7943, 953]], [[8080, 8080], "mapped", [7968, 953]], [[8081, 8081], "mapped", [7969, 953]], [[8082, 8082], "mapped", [7970, 953]], [[8083, 8083], "mapped", [7971, 953]], [[8084, 8084], "mapped", [7972, 953]], [[8085, 8085], "mapped", [7973, 953]], [[8086, 8086], "mapped", [7974, 953]], [[8087, 8087], "mapped", [7975, 953]], [[8088, 8088], "mapped", [7968, 953]], [[8089, 8089], "mapped", [7969, 953]], [[8090, 8090], "mapped", [7970, 953]], [[8091, 8091], "mapped", [7971, 953]], [[8092, 8092], "mapped", [7972, 953]], [[8093, 8093], "mapped", [7973, 953]], [[8094, 8094], "mapped", [7974, 953]], [[8095, 8095], "mapped", [7975, 953]], [[8096, 8096], "mapped", [8032, 953]], [[8097, 8097], "mapped", [8033, 953]], [[8098, 8098], "mapped", [8034, 953]], [[8099, 8099], "mapped", [8035, 953]], [[8100, 8100], "mapped", [8036, 953]], [[8101, 8101], "mapped", [8037, 953]], [[8102, 8102], "mapped", [8038, 953]], [[8103, 8103], "mapped", [8039, 953]], [[8104, 8104], "mapped", [8032, 953]], [[8105, 8105], "mapped", [8033, 953]], [[8106, 8106], "mapped", [8034, 953]], [[8107, 8107], "mapped", [8035, 953]], [[8108, 8108], "mapped", [8036, 953]], [[8109, 8109], "mapped", [8037, 953]], [[8110, 8110], "mapped", [8038, 953]], [[8111, 8111], "mapped", [8039, 953]], [[8112, 8113], "valid"], [[8114, 8114], "mapped", [8048, 953]], [[8115, 8115], "mapped", [945, 953]], [[8116, 8116], "mapped", [940, 953]], [[8117, 8117], "disallowed"], [[8118, 8118], "valid"], [[8119, 8119], "mapped", [8118, 953]], [[8120, 8120], "mapped", [8112]], [[8121, 8121], "mapped", [8113]], [[8122, 8122], "mapped", [8048]], [[8123, 8123], "mapped", [940]], [[8124, 8124], "mapped", [945, 953]], [[8125, 8125], "disallowed_STD3_mapped", [32, 787]], [[8126, 8126], "mapped", [953]], [[8127, 8127], "disallowed_STD3_mapped", [32, 787]], [[8128, 8128], "disallowed_STD3_mapped", [32, 834]], [[8129, 8129], "disallowed_STD3_mapped", [32, 776, 834]], [[8130, 8130], "mapped", [8052, 953]], [[8131, 8131], "mapped", [951, 953]], [[8132, 8132], "mapped", [942, 953]], [[8133, 8133], "disallowed"], [[8134, 8134], "valid"], [[8135, 8135], "mapped", [8134, 953]], [[8136, 8136], "mapped", [8050]], [[8137, 8137], "mapped", [941]], [[8138, 8138], "mapped", [8052]], [[8139, 8139], "mapped", [942]], [[8140, 8140], "mapped", [951, 953]], [[8141, 8141], "disallowed_STD3_mapped", [32, 787, 768]], [[8142, 8142], "disallowed_STD3_mapped", [32, 787, 769]], [[8143, 8143], "disallowed_STD3_mapped", [32, 787, 834]], [[8144, 8146], "valid"], [[8147, 8147], "mapped", [912]], [[8148, 8149], "disallowed"], [[8150, 8151], "valid"], [[8152, 8152], "mapped", [8144]], [[8153, 8153], "mapped", [8145]], [[8154, 8154], "mapped", [8054]], [[8155, 8155], "mapped", [943]], [[8156, 8156], "disallowed"], [[8157, 8157], "disallowed_STD3_mapped", [32, 788, 768]], [[8158, 8158], "disallowed_STD3_mapped", [32, 788, 769]], [[8159, 8159], "disallowed_STD3_mapped", [32, 788, 834]], [[8160, 8162], "valid"], [[8163, 8163], "mapped", [944]], [[8164, 8167], "valid"], [[8168, 8168], "mapped", [8160]], [[8169, 8169], "mapped", [8161]], [[8170, 8170], "mapped", [8058]], [[8171, 8171], "mapped", [973]], [[8172, 8172], "mapped", [8165]], [[8173, 8173], "disallowed_STD3_mapped", [32, 776, 768]], [[8174, 8174], "disallowed_STD3_mapped", [32, 776, 769]], [[8175, 8175], "disallowed_STD3_mapped", [96]], [[8176, 8177], "disallowed"], [[8178, 8178], "mapped", [8060, 953]], [[8179, 8179], "mapped", [969, 953]], [[8180, 8180], "mapped", [974, 953]], [[8181, 8181], "disallowed"], [[8182, 8182], "valid"], [[8183, 8183], "mapped", [8182, 953]], [[8184, 8184], "mapped", [8056]], [[8185, 8185], "mapped", [972]], [[8186, 8186], "mapped", [8060]], [[8187, 8187], "mapped", [974]], [[8188, 8188], "mapped", [969, 953]], [[8189, 8189], "disallowed_STD3_mapped", [32, 769]], [[8190, 8190], "disallowed_STD3_mapped", [32, 788]], [[8191, 8191], "disallowed"], [[8192, 8202], "disallowed_STD3_mapped", [32]], [[8203, 8203], "ignored"], [[8204, 8205], "deviation", []], [[8206, 8207], "disallowed"], [[8208, 8208], "valid", [], "NV8"], [[8209, 8209], "mapped", [8208]], [[8210, 8214], "valid", [], "NV8"], [[8215, 8215], "disallowed_STD3_mapped", [32, 819]], [[8216, 8227], "valid", [], "NV8"], [[8228, 8230], "disallowed"], [[8231, 8231], "valid", [], "NV8"], [[8232, 8238], "disallowed"], [[8239, 8239], "disallowed_STD3_mapped", [32]], [[8240, 8242], "valid", [], "NV8"], [[8243, 8243], "mapped", [8242, 8242]], [[8244, 8244], "mapped", [8242, 8242, 8242]], [[8245, 8245], "valid", [], "NV8"], [[8246, 8246], "mapped", [8245, 8245]], [[8247, 8247], "mapped", [8245, 8245, 8245]], [[8248, 8251], "valid", [], "NV8"], [[8252, 8252], "disallowed_STD3_mapped", [33, 33]], [[8253, 8253], "valid", [], "NV8"], [[8254, 8254], "disallowed_STD3_mapped", [32, 773]], [[8255, 8262], "valid", [], "NV8"], [[8263, 8263], "disallowed_STD3_mapped", [63, 63]], [[8264, 8264], "disallowed_STD3_mapped", [63, 33]], [[8265, 8265], "disallowed_STD3_mapped", [33, 63]], [[8266, 8269], "valid", [], "NV8"], [[8270, 8274], "valid", [], "NV8"], [[8275, 8276], "valid", [], "NV8"], [[8277, 8278], "valid", [], "NV8"], [[8279, 8279], "mapped", [8242, 8242, 8242, 8242]], [[8280, 8286], "valid", [], "NV8"], [[8287, 8287], "disallowed_STD3_mapped", [32]], [[8288, 8288], "ignored"], [[8289, 8291], "disallowed"], [[8292, 8292], "ignored"], [[8293, 8293], "disallowed"], [[8294, 8297], "disallowed"], [[8298, 8303], "disallowed"], [[8304, 8304], "mapped", [48]], [[8305, 8305], "mapped", [105]], [[8306, 8307], "disallowed"], [[8308, 8308], "mapped", [52]], [[8309, 8309], "mapped", [53]], [[8310, 8310], "mapped", [54]], [[8311, 8311], "mapped", [55]], [[8312, 8312], "mapped", [56]], [[8313, 8313], "mapped", [57]], [[8314, 8314], "disallowed_STD3_mapped", [43]], [[8315, 8315], "mapped", [8722]], [[8316, 8316], "disallowed_STD3_mapped", [61]], [[8317, 8317], "disallowed_STD3_mapped", [40]], [[8318, 8318], "disallowed_STD3_mapped", [41]], [[8319, 8319], "mapped", [110]], [[8320, 8320], "mapped", [48]], [[8321, 8321], "mapped", [49]], [[8322, 8322], "mapped", [50]], [[8323, 8323], "mapped", [51]], [[8324, 8324], "mapped", [52]], [[8325, 8325], "mapped", [53]], [[8326, 8326], "mapped", [54]], [[8327, 8327], "mapped", [55]], [[8328, 8328], "mapped", [56]], [[8329, 8329], "mapped", [57]], [[8330, 8330], "disallowed_STD3_mapped", [43]], [[8331, 8331], "mapped", [8722]], [[8332, 8332], "disallowed_STD3_mapped", [61]], [[8333, 8333], "disallowed_STD3_mapped", [40]], [[8334, 8334], "disallowed_STD3_mapped", [41]], [[8335, 8335], "disallowed"], [[8336, 8336], "mapped", [97]], [[8337, 8337], "mapped", [101]], [[8338, 8338], "mapped", [111]], [[8339, 8339], "mapped", [120]], [[8340, 8340], "mapped", [601]], [[8341, 8341], "mapped", [104]], [[8342, 8342], "mapped", [107]], [[8343, 8343], "mapped", [108]], [[8344, 8344], "mapped", [109]], [[8345, 8345], "mapped", [110]], [[8346, 8346], "mapped", [112]], [[8347, 8347], "mapped", [115]], [[8348, 8348], "mapped", [116]], [[8349, 8351], "disallowed"], [[8352, 8359], "valid", [], "NV8"], [[8360, 8360], "mapped", [114, 115]], [[8361, 8362], "valid", [], "NV8"], [[8363, 8363], "valid", [], "NV8"], [[8364, 8364], "valid", [], "NV8"], [[8365, 8367], "valid", [], "NV8"], [[8368, 8369], "valid", [], "NV8"], [[8370, 8373], "valid", [], "NV8"], [[8374, 8376], "valid", [], "NV8"], [[8377, 8377], "valid", [], "NV8"], [[8378, 8378], "valid", [], "NV8"], [[8379, 8381], "valid", [], "NV8"], [[8382, 8382], "valid", [], "NV8"], [[8383, 8399], "disallowed"], [[8400, 8417], "valid", [], "NV8"], [[8418, 8419], "valid", [], "NV8"], [[8420, 8426], "valid", [], "NV8"], [[8427, 8427], "valid", [], "NV8"], [[8428, 8431], "valid", [], "NV8"], [[8432, 8432], "valid", [], "NV8"], [[8433, 8447], "disallowed"], [[8448, 8448], "disallowed_STD3_mapped", [97, 47, 99]], [[8449, 8449], "disallowed_STD3_mapped", [97, 47, 115]], [[8450, 8450], "mapped", [99]], [[8451, 8451], "mapped", [176, 99]], [[8452, 8452], "valid", [], "NV8"], [[8453, 8453], "disallowed_STD3_mapped", [99, 47, 111]], [[8454, 8454], "disallowed_STD3_mapped", [99, 47, 117]], [[8455, 8455], "mapped", [603]], [[8456, 8456], "valid", [], "NV8"], [[8457, 8457], "mapped", [176, 102]], [[8458, 8458], "mapped", [103]], [[8459, 8462], "mapped", [104]], [[8463, 8463], "mapped", [295]], [[8464, 8465], "mapped", [105]], [[8466, 8467], "mapped", [108]], [[8468, 8468], "valid", [], "NV8"], [[8469, 8469], "mapped", [110]], [[8470, 8470], "mapped", [110, 111]], [[8471, 8472], "valid", [], "NV8"], [[8473, 8473], "mapped", [112]], [[8474, 8474], "mapped", [113]], [[8475, 8477], "mapped", [114]], [[8478, 8479], "valid", [], "NV8"], [[8480, 8480], "mapped", [115, 109]], [[8481, 8481], "mapped", [116, 101, 108]], [[8482, 8482], "mapped", [116, 109]], [[8483, 8483], "valid", [], "NV8"], [[8484, 8484], "mapped", [122]], [[8485, 8485], "valid", [], "NV8"], [[8486, 8486], "mapped", [969]], [[8487, 8487], "valid", [], "NV8"], [[8488, 8488], "mapped", [122]], [[8489, 8489], "valid", [], "NV8"], [[8490, 8490], "mapped", [107]], [[8491, 8491], "mapped", [229]], [[8492, 8492], "mapped", [98]], [[8493, 8493], "mapped", [99]], [[8494, 8494], "valid", [], "NV8"], [[8495, 8496], "mapped", [101]], [[8497, 8497], "mapped", [102]], [[8498, 8498], "disallowed"], [[8499, 8499], "mapped", [109]], [[8500, 8500], "mapped", [111]], [[8501, 8501], "mapped", [1488]], [[8502, 8502], "mapped", [1489]], [[8503, 8503], "mapped", [1490]], [[8504, 8504], "mapped", [1491]], [[8505, 8505], "mapped", [105]], [[8506, 8506], "valid", [], "NV8"], [[8507, 8507], "mapped", [102, 97, 120]], [[8508, 8508], "mapped", [960]], [[8509, 8510], "mapped", [947]], [[8511, 8511], "mapped", [960]], [[8512, 8512], "mapped", [8721]], [[8513, 8516], "valid", [], "NV8"], [[8517, 8518], "mapped", [100]], [[8519, 8519], "mapped", [101]], [[8520, 8520], "mapped", [105]], [[8521, 8521], "mapped", [106]], [[8522, 8523], "valid", [], "NV8"], [[8524, 8524], "valid", [], "NV8"], [[8525, 8525], "valid", [], "NV8"], [[8526, 8526], "valid"], [[8527, 8527], "valid", [], "NV8"], [[8528, 8528], "mapped", [49, 8260, 55]], [[8529, 8529], "mapped", [49, 8260, 57]], [[8530, 8530], "mapped", [49, 8260, 49, 48]], [[8531, 8531], "mapped", [49, 8260, 51]], [[8532, 8532], "mapped", [50, 8260, 51]], [[8533, 8533], "mapped", [49, 8260, 53]], [[8534, 8534], "mapped", [50, 8260, 53]], [[8535, 8535], "mapped", [51, 8260, 53]], [[8536, 8536], "mapped", [52, 8260, 53]], [[8537, 8537], "mapped", [49, 8260, 54]], [[8538, 8538], "mapped", [53, 8260, 54]], [[8539, 8539], "mapped", [49, 8260, 56]], [[8540, 8540], "mapped", [51, 8260, 56]], [[8541, 8541], "mapped", [53, 8260, 56]], [[8542, 8542], "mapped", [55, 8260, 56]], [[8543, 8543], "mapped", [49, 8260]], [[8544, 8544], "mapped", [105]], [[8545, 8545], "mapped", [105, 105]], [[8546, 8546], "mapped", [105, 105, 105]], [[8547, 8547], "mapped", [105, 118]], [[8548, 8548], "mapped", [118]], [[8549, 8549], "mapped", [118, 105]], [[8550, 8550], "mapped", [118, 105, 105]], [[8551, 8551], "mapped", [118, 105, 105, 105]], [[8552, 8552], "mapped", [105, 120]], [[8553, 8553], "mapped", [120]], [[8554, 8554], "mapped", [120, 105]], [[8555, 8555], "mapped", [120, 105, 105]], [[8556, 8556], "mapped", [108]], [[8557, 8557], "mapped", [99]], [[8558, 8558], "mapped", [100]], [[8559, 8559], "mapped", [109]], [[8560, 8560], "mapped", [105]], [[8561, 8561], "mapped", [105, 105]], [[8562, 8562], "mapped", [105, 105, 105]], [[8563, 8563], "mapped", [105, 118]], [[8564, 8564], "mapped", [118]], [[8565, 8565], "mapped", [118, 105]], [[8566, 8566], "mapped", [118, 105, 105]], [[8567, 8567], "mapped", [118, 105, 105, 105]], [[8568, 8568], "mapped", [105, 120]], [[8569, 8569], "mapped", [120]], [[8570, 8570], "mapped", [120, 105]], [[8571, 8571], "mapped", [120, 105, 105]], [[8572, 8572], "mapped", [108]], [[8573, 8573], "mapped", [99]], [[8574, 8574], "mapped", [100]], [[8575, 8575], "mapped", [109]], [[8576, 8578], "valid", [], "NV8"], [[8579, 8579], "disallowed"], [[8580, 8580], "valid"], [[8581, 8584], "valid", [], "NV8"], [[8585, 8585], "mapped", [48, 8260, 51]], [[8586, 8587], "valid", [], "NV8"], [[8588, 8591], "disallowed"], [[8592, 8682], "valid", [], "NV8"], [[8683, 8691], "valid", [], "NV8"], [[8692, 8703], "valid", [], "NV8"], [[8704, 8747], "valid", [], "NV8"], [[8748, 8748], "mapped", [8747, 8747]], [[8749, 8749], "mapped", [8747, 8747, 8747]], [[8750, 8750], "valid", [], "NV8"], [[8751, 8751], "mapped", [8750, 8750]], [[8752, 8752], "mapped", [8750, 8750, 8750]], [[8753, 8799], "valid", [], "NV8"], [[8800, 8800], "disallowed_STD3_valid"], [[8801, 8813], "valid", [], "NV8"], [[8814, 8815], "disallowed_STD3_valid"], [[8816, 8945], "valid", [], "NV8"], [[8946, 8959], "valid", [], "NV8"], [[8960, 8960], "valid", [], "NV8"], [[8961, 8961], "valid", [], "NV8"], [[8962, 9000], "valid", [], "NV8"], [[9001, 9001], "mapped", [12296]], [[9002, 9002], "mapped", [12297]], [[9003, 9082], "valid", [], "NV8"], [[9083, 9083], "valid", [], "NV8"], [[9084, 9084], "valid", [], "NV8"], [[9085, 9114], "valid", [], "NV8"], [[9115, 9166], "valid", [], "NV8"], [[9167, 9168], "valid", [], "NV8"], [[9169, 9179], "valid", [], "NV8"], [[9180, 9191], "valid", [], "NV8"], [[9192, 9192], "valid", [], "NV8"], [[9193, 9203], "valid", [], "NV8"], [[9204, 9210], "valid", [], "NV8"], [[9211, 9215], "disallowed"], [[9216, 9252], "valid", [], "NV8"], [[9253, 9254], "valid", [], "NV8"], [[9255, 9279], "disallowed"], [[9280, 9290], "valid", [], "NV8"], [[9291, 9311], "disallowed"], [[9312, 9312], "mapped", [49]], [[9313, 9313], "mapped", [50]], [[9314, 9314], "mapped", [51]], [[9315, 9315], "mapped", [52]], [[9316, 9316], "mapped", [53]], [[9317, 9317], "mapped", [54]], [[9318, 9318], "mapped", [55]], [[9319, 9319], "mapped", [56]], [[9320, 9320], "mapped", [57]], [[9321, 9321], "mapped", [49, 48]], [[9322, 9322], "mapped", [49, 49]], [[9323, 9323], "mapped", [49, 50]], [[9324, 9324], "mapped", [49, 51]], [[9325, 9325], "mapped", [49, 52]], [[9326, 9326], "mapped", [49, 53]], [[9327, 9327], "mapped", [49, 54]], [[9328, 9328], "mapped", [49, 55]], [[9329, 9329], "mapped", [49, 56]], [[9330, 9330], "mapped", [49, 57]], [[9331, 9331], "mapped", [50, 48]], [[9332, 9332], "disallowed_STD3_mapped", [40, 49, 41]], [[9333, 9333], "disallowed_STD3_mapped", [40, 50, 41]], [[9334, 9334], "disallowed_STD3_mapped", [40, 51, 41]], [[9335, 9335], "disallowed_STD3_mapped", [40, 52, 41]], [[9336, 9336], "disallowed_STD3_mapped", [40, 53, 41]], [[9337, 9337], "disallowed_STD3_mapped", [40, 54, 41]], [[9338, 9338], "disallowed_STD3_mapped", [40, 55, 41]], [[9339, 9339], "disallowed_STD3_mapped", [40, 56, 41]], [[9340, 9340], "disallowed_STD3_mapped", [40, 57, 41]], [[9341, 9341], "disallowed_STD3_mapped", [40, 49, 48, 41]], [[9342, 9342], "disallowed_STD3_mapped", [40, 49, 49, 41]], [[9343, 9343], "disallowed_STD3_mapped", [40, 49, 50, 41]], [[9344, 9344], "disallowed_STD3_mapped", [40, 49, 51, 41]], [[9345, 9345], "disallowed_STD3_mapped", [40, 49, 52, 41]], [[9346, 9346], "disallowed_STD3_mapped", [40, 49, 53, 41]], [[9347, 9347], "disallowed_STD3_mapped", [40, 49, 54, 41]], [[9348, 9348], "disallowed_STD3_mapped", [40, 49, 55, 41]], [[9349, 9349], "disallowed_STD3_mapped", [40, 49, 56, 41]], [[9350, 9350], "disallowed_STD3_mapped", [40, 49, 57, 41]], [[9351, 9351], "disallowed_STD3_mapped", [40, 50, 48, 41]], [[9352, 9371], "disallowed"], [[9372, 9372], "disallowed_STD3_mapped", [40, 97, 41]], [[9373, 9373], "disallowed_STD3_mapped", [40, 98, 41]], [[9374, 9374], "disallowed_STD3_mapped", [40, 99, 41]], [[9375, 9375], "disallowed_STD3_mapped", [40, 100, 41]], [[9376, 9376], "disallowed_STD3_mapped", [40, 101, 41]], [[9377, 9377], "disallowed_STD3_mapped", [40, 102, 41]], [[9378, 9378], "disallowed_STD3_mapped", [40, 103, 41]], [[9379, 9379], "disallowed_STD3_mapped", [40, 104, 41]], [[9380, 9380], "disallowed_STD3_mapped", [40, 105, 41]], [[9381, 9381], "disallowed_STD3_mapped", [40, 106, 41]], [[9382, 9382], "disallowed_STD3_mapped", [40, 107, 41]], [[9383, 9383], "disallowed_STD3_mapped", [40, 108, 41]], [[9384, 9384], "disallowed_STD3_mapped", [40, 109, 41]], [[9385, 9385], "disallowed_STD3_mapped", [40, 110, 41]], [[9386, 9386], "disallowed_STD3_mapped", [40, 111, 41]], [[9387, 9387], "disallowed_STD3_mapped", [40, 112, 41]], [[9388, 9388], "disallowed_STD3_mapped", [40, 113, 41]], [[9389, 9389], "disallowed_STD3_mapped", [40, 114, 41]], [[9390, 9390], "disallowed_STD3_mapped", [40, 115, 41]], [[9391, 9391], "disallowed_STD3_mapped", [40, 116, 41]], [[9392, 9392], "disallowed_STD3_mapped", [40, 117, 41]], [[9393, 9393], "disallowed_STD3_mapped", [40, 118, 41]], [[9394, 9394], "disallowed_STD3_mapped", [40, 119, 41]], [[9395, 9395], "disallowed_STD3_mapped", [40, 120, 41]], [[9396, 9396], "disallowed_STD3_mapped", [40, 121, 41]], [[9397, 9397], "disallowed_STD3_mapped", [40, 122, 41]], [[9398, 9398], "mapped", [97]], [[9399, 9399], "mapped", [98]], [[9400, 9400], "mapped", [99]], [[9401, 9401], "mapped", [100]], [[9402, 9402], "mapped", [101]], [[9403, 9403], "mapped", [102]], [[9404, 9404], "mapped", [103]], [[9405, 9405], "mapped", [104]], [[9406, 9406], "mapped", [105]], [[9407, 9407], "mapped", [106]], [[9408, 9408], "mapped", [107]], [[9409, 9409], "mapped", [108]], [[9410, 9410], "mapped", [109]], [[9411, 9411], "mapped", [110]], [[9412, 9412], "mapped", [111]], [[9413, 9413], "mapped", [112]], [[9414, 9414], "mapped", [113]], [[9415, 9415], "mapped", [114]], [[9416, 9416], "mapped", [115]], [[9417, 9417], "mapped", [116]], [[9418, 9418], "mapped", [117]], [[9419, 9419], "mapped", [118]], [[9420, 9420], "mapped", [119]], [[9421, 9421], "mapped", [120]], [[9422, 9422], "mapped", [121]], [[9423, 9423], "mapped", [122]], [[9424, 9424], "mapped", [97]], [[9425, 9425], "mapped", [98]], [[9426, 9426], "mapped", [99]], [[9427, 9427], "mapped", [100]], [[9428, 9428], "mapped", [101]], [[9429, 9429], "mapped", [102]], [[9430, 9430], "mapped", [103]], [[9431, 9431], "mapped", [104]], [[9432, 9432], "mapped", [105]], [[9433, 9433], "mapped", [106]], [[9434, 9434], "mapped", [107]], [[9435, 9435], "mapped", [108]], [[9436, 9436], "mapped", [109]], [[9437, 9437], "mapped", [110]], [[9438, 9438], "mapped", [111]], [[9439, 9439], "mapped", [112]], [[9440, 9440], "mapped", [113]], [[9441, 9441], "mapped", [114]], [[9442, 9442], "mapped", [115]], [[9443, 9443], "mapped", [116]], [[9444, 9444], "mapped", [117]], [[9445, 9445], "mapped", [118]], [[9446, 9446], "mapped", [119]], [[9447, 9447], "mapped", [120]], [[9448, 9448], "mapped", [121]], [[9449, 9449], "mapped", [122]], [[9450, 9450], "mapped", [48]], [[9451, 9470], "valid", [], "NV8"], [[9471, 9471], "valid", [], "NV8"], [[9472, 9621], "valid", [], "NV8"], [[9622, 9631], "valid", [], "NV8"], [[9632, 9711], "valid", [], "NV8"], [[9712, 9719], "valid", [], "NV8"], [[9720, 9727], "valid", [], "NV8"], [[9728, 9747], "valid", [], "NV8"], [[9748, 9749], "valid", [], "NV8"], [[9750, 9751], "valid", [], "NV8"], [[9752, 9752], "valid", [], "NV8"], [[9753, 9753], "valid", [], "NV8"], [[9754, 9839], "valid", [], "NV8"], [[9840, 9841], "valid", [], "NV8"], [[9842, 9853], "valid", [], "NV8"], [[9854, 9855], "valid", [], "NV8"], [[9856, 9865], "valid", [], "NV8"], [[9866, 9873], "valid", [], "NV8"], [[9874, 9884], "valid", [], "NV8"], [[9885, 9885], "valid", [], "NV8"], [[9886, 9887], "valid", [], "NV8"], [[9888, 9889], "valid", [], "NV8"], [[9890, 9905], "valid", [], "NV8"], [[9906, 9906], "valid", [], "NV8"], [[9907, 9916], "valid", [], "NV8"], [[9917, 9919], "valid", [], "NV8"], [[9920, 9923], "valid", [], "NV8"], [[9924, 9933], "valid", [], "NV8"], [[9934, 9934], "valid", [], "NV8"], [[9935, 9953], "valid", [], "NV8"], [[9954, 9954], "valid", [], "NV8"], [[9955, 9955], "valid", [], "NV8"], [[9956, 9959], "valid", [], "NV8"], [[9960, 9983], "valid", [], "NV8"], [[9984, 9984], "valid", [], "NV8"], [[9985, 9988], "valid", [], "NV8"], [[9989, 9989], "valid", [], "NV8"], [[9990, 9993], "valid", [], "NV8"], [[9994, 9995], "valid", [], "NV8"], [[9996, 10023], "valid", [], "NV8"], [[10024, 10024], "valid", [], "NV8"], [[10025, 10059], "valid", [], "NV8"], [[10060, 10060], "valid", [], "NV8"], [[10061, 10061], "valid", [], "NV8"], [[10062, 10062], "valid", [], "NV8"], [[10063, 10066], "valid", [], "NV8"], [[10067, 10069], "valid", [], "NV8"], [[10070, 10070], "valid", [], "NV8"], [[10071, 10071], "valid", [], "NV8"], [[10072, 10078], "valid", [], "NV8"], [[10079, 10080], "valid", [], "NV8"], [[10081, 10087], "valid", [], "NV8"], [[10088, 10101], "valid", [], "NV8"], [[10102, 10132], "valid", [], "NV8"], [[10133, 10135], "valid", [], "NV8"], [[10136, 10159], "valid", [], "NV8"], [[10160, 10160], "valid", [], "NV8"], [[10161, 10174], "valid", [], "NV8"], [[10175, 10175], "valid", [], "NV8"], [[10176, 10182], "valid", [], "NV8"], [[10183, 10186], "valid", [], "NV8"], [[10187, 10187], "valid", [], "NV8"], [[10188, 10188], "valid", [], "NV8"], [[10189, 10189], "valid", [], "NV8"], [[10190, 10191], "valid", [], "NV8"], [[10192, 10219], "valid", [], "NV8"], [[10220, 10223], "valid", [], "NV8"], [[10224, 10239], "valid", [], "NV8"], [[10240, 10495], "valid", [], "NV8"], [[10496, 10763], "valid", [], "NV8"], [[10764, 10764], "mapped", [8747, 8747, 8747, 8747]], [[10765, 10867], "valid", [], "NV8"], [[10868, 10868], "disallowed_STD3_mapped", [58, 58, 61]], [[10869, 10869], "disallowed_STD3_mapped", [61, 61]], [[10870, 10870], "disallowed_STD3_mapped", [61, 61, 61]], [[10871, 10971], "valid", [], "NV8"], [[10972, 10972], "mapped", [10973, 824]], [[10973, 11007], "valid", [], "NV8"], [[11008, 11021], "valid", [], "NV8"], [[11022, 11027], "valid", [], "NV8"], [[11028, 11034], "valid", [], "NV8"], [[11035, 11039], "valid", [], "NV8"], [[11040, 11043], "valid", [], "NV8"], [[11044, 11084], "valid", [], "NV8"], [[11085, 11087], "valid", [], "NV8"], [[11088, 11092], "valid", [], "NV8"], [[11093, 11097], "valid", [], "NV8"], [[11098, 11123], "valid", [], "NV8"], [[11124, 11125], "disallowed"], [[11126, 11157], "valid", [], "NV8"], [[11158, 11159], "disallowed"], [[11160, 11193], "valid", [], "NV8"], [[11194, 11196], "disallowed"], [[11197, 11208], "valid", [], "NV8"], [[11209, 11209], "disallowed"], [[11210, 11217], "valid", [], "NV8"], [[11218, 11243], "disallowed"], [[11244, 11247], "valid", [], "NV8"], [[11248, 11263], "disallowed"], [[11264, 11264], "mapped", [11312]], [[11265, 11265], "mapped", [11313]], [[11266, 11266], "mapped", [11314]], [[11267, 11267], "mapped", [11315]], [[11268, 11268], "mapped", [11316]], [[11269, 11269], "mapped", [11317]], [[11270, 11270], "mapped", [11318]], [[11271, 11271], "mapped", [11319]], [[11272, 11272], "mapped", [11320]], [[11273, 11273], "mapped", [11321]], [[11274, 11274], "mapped", [11322]], [[11275, 11275], "mapped", [11323]], [[11276, 11276], "mapped", [11324]], [[11277, 11277], "mapped", [11325]], [[11278, 11278], "mapped", [11326]], [[11279, 11279], "mapped", [11327]], [[11280, 11280], "mapped", [11328]], [[11281, 11281], "mapped", [11329]], [[11282, 11282], "mapped", [11330]], [[11283, 11283], "mapped", [11331]], [[11284, 11284], "mapped", [11332]], [[11285, 11285], "mapped", [11333]], [[11286, 11286], "mapped", [11334]], [[11287, 11287], "mapped", [11335]], [[11288, 11288], "mapped", [11336]], [[11289, 11289], "mapped", [11337]], [[11290, 11290], "mapped", [11338]], [[11291, 11291], "mapped", [11339]], [[11292, 11292], "mapped", [11340]], [[11293, 11293], "mapped", [11341]], [[11294, 11294], "mapped", [11342]], [[11295, 11295], "mapped", [11343]], [[11296, 11296], "mapped", [11344]], [[11297, 11297], "mapped", [11345]], [[11298, 11298], "mapped", [11346]], [[11299, 11299], "mapped", [11347]], [[11300, 11300], "mapped", [11348]], [[11301, 11301], "mapped", [11349]], [[11302, 11302], "mapped", [11350]], [[11303, 11303], "mapped", [11351]], [[11304, 11304], "mapped", [11352]], [[11305, 11305], "mapped", [11353]], [[11306, 11306], "mapped", [11354]], [[11307, 11307], "mapped", [11355]], [[11308, 11308], "mapped", [11356]], [[11309, 11309], "mapped", [11357]], [[11310, 11310], "mapped", [11358]], [[11311, 11311], "disallowed"], [[11312, 11358], "valid"], [[11359, 11359], "disallowed"], [[11360, 11360], "mapped", [11361]], [[11361, 11361], "valid"], [[11362, 11362], "mapped", [619]], [[11363, 11363], "mapped", [7549]], [[11364, 11364], "mapped", [637]], [[11365, 11366], "valid"], [[11367, 11367], "mapped", [11368]], [[11368, 11368], "valid"], [[11369, 11369], "mapped", [11370]], [[11370, 11370], "valid"], [[11371, 11371], "mapped", [11372]], [[11372, 11372], "valid"], [[11373, 11373], "mapped", [593]], [[11374, 11374], "mapped", [625]], [[11375, 11375], "mapped", [592]], [[11376, 11376], "mapped", [594]], [[11377, 11377], "valid"], [[11378, 11378], "mapped", [11379]], [[11379, 11379], "valid"], [[11380, 11380], "valid"], [[11381, 11381], "mapped", [11382]], [[11382, 11383], "valid"], [[11384, 11387], "valid"], [[11388, 11388], "mapped", [106]], [[11389, 11389], "mapped", [118]], [[11390, 11390], "mapped", [575]], [[11391, 11391], "mapped", [576]], [[11392, 11392], "mapped", [11393]], [[11393, 11393], "valid"], [[11394, 11394], "mapped", [11395]], [[11395, 11395], "valid"], [[11396, 11396], "mapped", [11397]], [[11397, 11397], "valid"], [[11398, 11398], "mapped", [11399]], [[11399, 11399], "valid"], [[11400, 11400], "mapped", [11401]], [[11401, 11401], "valid"], [[11402, 11402], "mapped", [11403]], [[11403, 11403], "valid"], [[11404, 11404], "mapped", [11405]], [[11405, 11405], "valid"], [[11406, 11406], "mapped", [11407]], [[11407, 11407], "valid"], [[11408, 11408], "mapped", [11409]], [[11409, 11409], "valid"], [[11410, 11410], "mapped", [11411]], [[11411, 11411], "valid"], [[11412, 11412], "mapped", [11413]], [[11413, 11413], "valid"], [[11414, 11414], "mapped", [11415]], [[11415, 11415], "valid"], [[11416, 11416], "mapped", [11417]], [[11417, 11417], "valid"], [[11418, 11418], "mapped", [11419]], [[11419, 11419], "valid"], [[11420, 11420], "mapped", [11421]], [[11421, 11421], "valid"], [[11422, 11422], "mapped", [11423]], [[11423, 11423], "valid"], [[11424, 11424], "mapped", [11425]], [[11425, 11425], "valid"], [[11426, 11426], "mapped", [11427]], [[11427, 11427], "valid"], [[11428, 11428], "mapped", [11429]], [[11429, 11429], "valid"], [[11430, 11430], "mapped", [11431]], [[11431, 11431], "valid"], [[11432, 11432], "mapped", [11433]], [[11433, 11433], "valid"], [[11434, 11434], "mapped", [11435]], [[11435, 11435], "valid"], [[11436, 11436], "mapped", [11437]], [[11437, 11437], "valid"], [[11438, 11438], "mapped", [11439]], [[11439, 11439], "valid"], [[11440, 11440], "mapped", [11441]], [[11441, 11441], "valid"], [[11442, 11442], "mapped", [11443]], [[11443, 11443], "valid"], [[11444, 11444], "mapped", [11445]], [[11445, 11445], "valid"], [[11446, 11446], "mapped", [11447]], [[11447, 11447], "valid"], [[11448, 11448], "mapped", [11449]], [[11449, 11449], "valid"], [[11450, 11450], "mapped", [11451]], [[11451, 11451], "valid"], [[11452, 11452], "mapped", [11453]], [[11453, 11453], "valid"], [[11454, 11454], "mapped", [11455]], [[11455, 11455], "valid"], [[11456, 11456], "mapped", [11457]], [[11457, 11457], "valid"], [[11458, 11458], "mapped", [11459]], [[11459, 11459], "valid"], [[11460, 11460], "mapped", [11461]], [[11461, 11461], "valid"], [[11462, 11462], "mapped", [11463]], [[11463, 11463], "valid"], [[11464, 11464], "mapped", [11465]], [[11465, 11465], "valid"], [[11466, 11466], "mapped", [11467]], [[11467, 11467], "valid"], [[11468, 11468], "mapped", [11469]], [[11469, 11469], "valid"], [[11470, 11470], "mapped", [11471]], [[11471, 11471], "valid"], [[11472, 11472], "mapped", [11473]], [[11473, 11473], "valid"], [[11474, 11474], "mapped", [11475]], [[11475, 11475], "valid"], [[11476, 11476], "mapped", [11477]], [[11477, 11477], "valid"], [[11478, 11478], "mapped", [11479]], [[11479, 11479], "valid"], [[11480, 11480], "mapped", [11481]], [[11481, 11481], "valid"], [[11482, 11482], "mapped", [11483]], [[11483, 11483], "valid"], [[11484, 11484], "mapped", [11485]], [[11485, 11485], "valid"], [[11486, 11486], "mapped", [11487]], [[11487, 11487], "valid"], [[11488, 11488], "mapped", [11489]], [[11489, 11489], "valid"], [[11490, 11490], "mapped", [11491]], [[11491, 11492], "valid"], [[11493, 11498], "valid", [], "NV8"], [[11499, 11499], "mapped", [11500]], [[11500, 11500], "valid"], [[11501, 11501], "mapped", [11502]], [[11502, 11505], "valid"], [[11506, 11506], "mapped", [11507]], [[11507, 11507], "valid"], [[11508, 11512], "disallowed"], [[11513, 11519], "valid", [], "NV8"], [[11520, 11557], "valid"], [[11558, 11558], "disallowed"], [[11559, 11559], "valid"], [[11560, 11564], "disallowed"], [[11565, 11565], "valid"], [[11566, 11567], "disallowed"], [[11568, 11621], "valid"], [[11622, 11623], "valid"], [[11624, 11630], "disallowed"], [[11631, 11631], "mapped", [11617]], [[11632, 11632], "valid", [], "NV8"], [[11633, 11646], "disallowed"], [[11647, 11647], "valid"], [[11648, 11670], "valid"], [[11671, 11679], "disallowed"], [[11680, 11686], "valid"], [[11687, 11687], "disallowed"], [[11688, 11694], "valid"], [[11695, 11695], "disallowed"], [[11696, 11702], "valid"], [[11703, 11703], "disallowed"], [[11704, 11710], "valid"], [[11711, 11711], "disallowed"], [[11712, 11718], "valid"], [[11719, 11719], "disallowed"], [[11720, 11726], "valid"], [[11727, 11727], "disallowed"], [[11728, 11734], "valid"], [[11735, 11735], "disallowed"], [[11736, 11742], "valid"], [[11743, 11743], "disallowed"], [[11744, 11775], "valid"], [[11776, 11799], "valid", [], "NV8"], [[11800, 11803], "valid", [], "NV8"], [[11804, 11805], "valid", [], "NV8"], [[11806, 11822], "valid", [], "NV8"], [[11823, 11823], "valid"], [[11824, 11824], "valid", [], "NV8"], [[11825, 11825], "valid", [], "NV8"], [[11826, 11835], "valid", [], "NV8"], [[11836, 11842], "valid", [], "NV8"], [[11843, 11903], "disallowed"], [[11904, 11929], "valid", [], "NV8"], [[11930, 11930], "disallowed"], [[11931, 11934], "valid", [], "NV8"], [[11935, 11935], "mapped", [27597]], [[11936, 12018], "valid", [], "NV8"], [[12019, 12019], "mapped", [40863]], [[12020, 12031], "disallowed"], [[12032, 12032], "mapped", [19968]], [[12033, 12033], "mapped", [20008]], [[12034, 12034], "mapped", [20022]], [[12035, 12035], "mapped", [20031]], [[12036, 12036], "mapped", [20057]], [[12037, 12037], "mapped", [20101]], [[12038, 12038], "mapped", [20108]], [[12039, 12039], "mapped", [20128]], [[12040, 12040], "mapped", [20154]], [[12041, 12041], "mapped", [20799]], [[12042, 12042], "mapped", [20837]], [[12043, 12043], "mapped", [20843]], [[12044, 12044], "mapped", [20866]], [[12045, 12045], "mapped", [20886]], [[12046, 12046], "mapped", [20907]], [[12047, 12047], "mapped", [20960]], [[12048, 12048], "mapped", [20981]], [[12049, 12049], "mapped", [20992]], [[12050, 12050], "mapped", [21147]], [[12051, 12051], "mapped", [21241]], [[12052, 12052], "mapped", [21269]], [[12053, 12053], "mapped", [21274]], [[12054, 12054], "mapped", [21304]], [[12055, 12055], "mapped", [21313]], [[12056, 12056], "mapped", [21340]], [[12057, 12057], "mapped", [21353]], [[12058, 12058], "mapped", [21378]], [[12059, 12059], "mapped", [21430]], [[12060, 12060], "mapped", [21448]], [[12061, 12061], "mapped", [21475]], [[12062, 12062], "mapped", [22231]], [[12063, 12063], "mapped", [22303]], [[12064, 12064], "mapped", [22763]], [[12065, 12065], "mapped", [22786]], [[12066, 12066], "mapped", [22794]], [[12067, 12067], "mapped", [22805]], [[12068, 12068], "mapped", [22823]], [[12069, 12069], "mapped", [22899]], [[12070, 12070], "mapped", [23376]], [[12071, 12071], "mapped", [23424]], [[12072, 12072], "mapped", [23544]], [[12073, 12073], "mapped", [23567]], [[12074, 12074], "mapped", [23586]], [[12075, 12075], "mapped", [23608]], [[12076, 12076], "mapped", [23662]], [[12077, 12077], "mapped", [23665]], [[12078, 12078], "mapped", [24027]], [[12079, 12079], "mapped", [24037]], [[12080, 12080], "mapped", [24049]], [[12081, 12081], "mapped", [24062]], [[12082, 12082], "mapped", [24178]], [[12083, 12083], "mapped", [24186]], [[12084, 12084], "mapped", [24191]], [[12085, 12085], "mapped", [24308]], [[12086, 12086], "mapped", [24318]], [[12087, 12087], "mapped", [24331]], [[12088, 12088], "mapped", [24339]], [[12089, 12089], "mapped", [24400]], [[12090, 12090], "mapped", [24417]], [[12091, 12091], "mapped", [24435]], [[12092, 12092], "mapped", [24515]], [[12093, 12093], "mapped", [25096]], [[12094, 12094], "mapped", [25142]], [[12095, 12095], "mapped", [25163]], [[12096, 12096], "mapped", [25903]], [[12097, 12097], "mapped", [25908]], [[12098, 12098], "mapped", [25991]], [[12099, 12099], "mapped", [26007]], [[12100, 12100], "mapped", [26020]], [[12101, 12101], "mapped", [26041]], [[12102, 12102], "mapped", [26080]], [[12103, 12103], "mapped", [26085]], [[12104, 12104], "mapped", [26352]], [[12105, 12105], "mapped", [26376]], [[12106, 12106], "mapped", [26408]], [[12107, 12107], "mapped", [27424]], [[12108, 12108], "mapped", [27490]], [[12109, 12109], "mapped", [27513]], [[12110, 12110], "mapped", [27571]], [[12111, 12111], "mapped", [27595]], [[12112, 12112], "mapped", [27604]], [[12113, 12113], "mapped", [27611]], [[12114, 12114], "mapped", [27663]], [[12115, 12115], "mapped", [27668]], [[12116, 12116], "mapped", [27700]], [[12117, 12117], "mapped", [28779]], [[12118, 12118], "mapped", [29226]], [[12119, 12119], "mapped", [29238]], [[12120, 12120], "mapped", [29243]], [[12121, 12121], "mapped", [29247]], [[12122, 12122], "mapped", [29255]], [[12123, 12123], "mapped", [29273]], [[12124, 12124], "mapped", [29275]], [[12125, 12125], "mapped", [29356]], [[12126, 12126], "mapped", [29572]], [[12127, 12127], "mapped", [29577]], [[12128, 12128], "mapped", [29916]], [[12129, 12129], "mapped", [29926]], [[12130, 12130], "mapped", [29976]], [[12131, 12131], "mapped", [29983]], [[12132, 12132], "mapped", [29992]], [[12133, 12133], "mapped", [30000]], [[12134, 12134], "mapped", [30091]], [[12135, 12135], "mapped", [30098]], [[12136, 12136], "mapped", [30326]], [[12137, 12137], "mapped", [30333]], [[12138, 12138], "mapped", [30382]], [[12139, 12139], "mapped", [30399]], [[12140, 12140], "mapped", [30446]], [[12141, 12141], "mapped", [30683]], [[12142, 12142], "mapped", [30690]], [[12143, 12143], "mapped", [30707]], [[12144, 12144], "mapped", [31034]], [[12145, 12145], "mapped", [31160]], [[12146, 12146], "mapped", [31166]], [[12147, 12147], "mapped", [31348]], [[12148, 12148], "mapped", [31435]], [[12149, 12149], "mapped", [31481]], [[12150, 12150], "mapped", [31859]], [[12151, 12151], "mapped", [31992]], [[12152, 12152], "mapped", [32566]], [[12153, 12153], "mapped", [32593]], [[12154, 12154], "mapped", [32650]], [[12155, 12155], "mapped", [32701]], [[12156, 12156], "mapped", [32769]], [[12157, 12157], "mapped", [32780]], [[12158, 12158], "mapped", [32786]], [[12159, 12159], "mapped", [32819]], [[12160, 12160], "mapped", [32895]], [[12161, 12161], "mapped", [32905]], [[12162, 12162], "mapped", [33251]], [[12163, 12163], "mapped", [33258]], [[12164, 12164], "mapped", [33267]], [[12165, 12165], "mapped", [33276]], [[12166, 12166], "mapped", [33292]], [[12167, 12167], "mapped", [33307]], [[12168, 12168], "mapped", [33311]], [[12169, 12169], "mapped", [33390]], [[12170, 12170], "mapped", [33394]], [[12171, 12171], "mapped", [33400]], [[12172, 12172], "mapped", [34381]], [[12173, 12173], "mapped", [34411]], [[12174, 12174], "mapped", [34880]], [[12175, 12175], "mapped", [34892]], [[12176, 12176], "mapped", [34915]], [[12177, 12177], "mapped", [35198]], [[12178, 12178], "mapped", [35211]], [[12179, 12179], "mapped", [35282]], [[12180, 12180], "mapped", [35328]], [[12181, 12181], "mapped", [35895]], [[12182, 12182], "mapped", [35910]], [[12183, 12183], "mapped", [35925]], [[12184, 12184], "mapped", [35960]], [[12185, 12185], "mapped", [35997]], [[12186, 12186], "mapped", [36196]], [[12187, 12187], "mapped", [36208]], [[12188, 12188], "mapped", [36275]], [[12189, 12189], "mapped", [36523]], [[12190, 12190], "mapped", [36554]], [[12191, 12191], "mapped", [36763]], [[12192, 12192], "mapped", [36784]], [[12193, 12193], "mapped", [36789]], [[12194, 12194], "mapped", [37009]], [[12195, 12195], "mapped", [37193]], [[12196, 12196], "mapped", [37318]], [[12197, 12197], "mapped", [37324]], [[12198, 12198], "mapped", [37329]], [[12199, 12199], "mapped", [38263]], [[12200, 12200], "mapped", [38272]], [[12201, 12201], "mapped", [38428]], [[12202, 12202], "mapped", [38582]], [[12203, 12203], "mapped", [38585]], [[12204, 12204], "mapped", [38632]], [[12205, 12205], "mapped", [38737]], [[12206, 12206], "mapped", [38750]], [[12207, 12207], "mapped", [38754]], [[12208, 12208], "mapped", [38761]], [[12209, 12209], "mapped", [38859]], [[12210, 12210], "mapped", [38893]], [[12211, 12211], "mapped", [38899]], [[12212, 12212], "mapped", [38913]], [[12213, 12213], "mapped", [39080]], [[12214, 12214], "mapped", [39131]], [[12215, 12215], "mapped", [39135]], [[12216, 12216], "mapped", [39318]], [[12217, 12217], "mapped", [39321]], [[12218, 12218], "mapped", [39340]], [[12219, 12219], "mapped", [39592]], [[12220, 12220], "mapped", [39640]], [[12221, 12221], "mapped", [39647]], [[12222, 12222], "mapped", [39717]], [[12223, 12223], "mapped", [39727]], [[12224, 12224], "mapped", [39730]], [[12225, 12225], "mapped", [39740]], [[12226, 12226], "mapped", [39770]], [[12227, 12227], "mapped", [40165]], [[12228, 12228], "mapped", [40565]], [[12229, 12229], "mapped", [40575]], [[12230, 12230], "mapped", [40613]], [[12231, 12231], "mapped", [40635]], [[12232, 12232], "mapped", [40643]], [[12233, 12233], "mapped", [40653]], [[12234, 12234], "mapped", [40657]], [[12235, 12235], "mapped", [40697]], [[12236, 12236], "mapped", [40701]], [[12237, 12237], "mapped", [40718]], [[12238, 12238], "mapped", [40723]], [[12239, 12239], "mapped", [40736]], [[12240, 12240], "mapped", [40763]], [[12241, 12241], "mapped", [40778]], [[12242, 12242], "mapped", [40786]], [[12243, 12243], "mapped", [40845]], [[12244, 12244], "mapped", [40860]], [[12245, 12245], "mapped", [40864]], [[12246, 12271], "disallowed"], [[12272, 12283], "disallowed"], [[12284, 12287], "disallowed"], [[12288, 12288], "disallowed_STD3_mapped", [32]], [[12289, 12289], "valid", [], "NV8"], [[12290, 12290], "mapped", [46]], [[12291, 12292], "valid", [], "NV8"], [[12293, 12295], "valid"], [[12296, 12329], "valid", [], "NV8"], [[12330, 12333], "valid"], [[12334, 12341], "valid", [], "NV8"], [[12342, 12342], "mapped", [12306]], [[12343, 12343], "valid", [], "NV8"], [[12344, 12344], "mapped", [21313]], [[12345, 12345], "mapped", [21316]], [[12346, 12346], "mapped", [21317]], [[12347, 12347], "valid", [], "NV8"], [[12348, 12348], "valid"], [[12349, 12349], "valid", [], "NV8"], [[12350, 12350], "valid", [], "NV8"], [[12351, 12351], "valid", [], "NV8"], [[12352, 12352], "disallowed"], [[12353, 12436], "valid"], [[12437, 12438], "valid"], [[12439, 12440], "disallowed"], [[12441, 12442], "valid"], [[12443, 12443], "disallowed_STD3_mapped", [32, 12441]], [[12444, 12444], "disallowed_STD3_mapped", [32, 12442]], [[12445, 12446], "valid"], [[12447, 12447], "mapped", [12424, 12426]], [[12448, 12448], "valid", [], "NV8"], [[12449, 12542], "valid"], [[12543, 12543], "mapped", [12467, 12488]], [[12544, 12548], "disallowed"], [[12549, 12588], "valid"], [[12589, 12589], "valid"], [[12590, 12592], "disallowed"], [[12593, 12593], "mapped", [4352]], [[12594, 12594], "mapped", [4353]], [[12595, 12595], "mapped", [4522]], [[12596, 12596], "mapped", [4354]], [[12597, 12597], "mapped", [4524]], [[12598, 12598], "mapped", [4525]], [[12599, 12599], "mapped", [4355]], [[12600, 12600], "mapped", [4356]], [[12601, 12601], "mapped", [4357]], [[12602, 12602], "mapped", [4528]], [[12603, 12603], "mapped", [4529]], [[12604, 12604], "mapped", [4530]], [[12605, 12605], "mapped", [4531]], [[12606, 12606], "mapped", [4532]], [[12607, 12607], "mapped", [4533]], [[12608, 12608], "mapped", [4378]], [[12609, 12609], "mapped", [4358]], [[12610, 12610], "mapped", [4359]], [[12611, 12611], "mapped", [4360]], [[12612, 12612], "mapped", [4385]], [[12613, 12613], "mapped", [4361]], [[12614, 12614], "mapped", [4362]], [[12615, 12615], "mapped", [4363]], [[12616, 12616], "mapped", [4364]], [[12617, 12617], "mapped", [4365]], [[12618, 12618], "mapped", [4366]], [[12619, 12619], "mapped", [4367]], [[12620, 12620], "mapped", [4368]], [[12621, 12621], "mapped", [4369]], [[12622, 12622], "mapped", [4370]], [[12623, 12623], "mapped", [4449]], [[12624, 12624], "mapped", [4450]], [[12625, 12625], "mapped", [4451]], [[12626, 12626], "mapped", [4452]], [[12627, 12627], "mapped", [4453]], [[12628, 12628], "mapped", [4454]], [[12629, 12629], "mapped", [4455]], [[12630, 12630], "mapped", [4456]], [[12631, 12631], "mapped", [4457]], [[12632, 12632], "mapped", [4458]], [[12633, 12633], "mapped", [4459]], [[12634, 12634], "mapped", [4460]], [[12635, 12635], "mapped", [4461]], [[12636, 12636], "mapped", [4462]], [[12637, 12637], "mapped", [4463]], [[12638, 12638], "mapped", [4464]], [[12639, 12639], "mapped", [4465]], [[12640, 12640], "mapped", [4466]], [[12641, 12641], "mapped", [4467]], [[12642, 12642], "mapped", [4468]], [[12643, 12643], "mapped", [4469]], [[12644, 12644], "disallowed"], [[12645, 12645], "mapped", [4372]], [[12646, 12646], "mapped", [4373]], [[12647, 12647], "mapped", [4551]], [[12648, 12648], "mapped", [4552]], [[12649, 12649], "mapped", [4556]], [[12650, 12650], "mapped", [4558]], [[12651, 12651], "mapped", [4563]], [[12652, 12652], "mapped", [4567]], [[12653, 12653], "mapped", [4569]], [[12654, 12654], "mapped", [4380]], [[12655, 12655], "mapped", [4573]], [[12656, 12656], "mapped", [4575]], [[12657, 12657], "mapped", [4381]], [[12658, 12658], "mapped", [4382]], [[12659, 12659], "mapped", [4384]], [[12660, 12660], "mapped", [4386]], [[12661, 12661], "mapped", [4387]], [[12662, 12662], "mapped", [4391]], [[12663, 12663], "mapped", [4393]], [[12664, 12664], "mapped", [4395]], [[12665, 12665], "mapped", [4396]], [[12666, 12666], "mapped", [4397]], [[12667, 12667], "mapped", [4398]], [[12668, 12668], "mapped", [4399]], [[12669, 12669], "mapped", [4402]], [[12670, 12670], "mapped", [4406]], [[12671, 12671], "mapped", [4416]], [[12672, 12672], "mapped", [4423]], [[12673, 12673], "mapped", [4428]], [[12674, 12674], "mapped", [4593]], [[12675, 12675], "mapped", [4594]], [[12676, 12676], "mapped", [4439]], [[12677, 12677], "mapped", [4440]], [[12678, 12678], "mapped", [4441]], [[12679, 12679], "mapped", [4484]], [[12680, 12680], "mapped", [4485]], [[12681, 12681], "mapped", [4488]], [[12682, 12682], "mapped", [4497]], [[12683, 12683], "mapped", [4498]], [[12684, 12684], "mapped", [4500]], [[12685, 12685], "mapped", [4510]], [[12686, 12686], "mapped", [4513]], [[12687, 12687], "disallowed"], [[12688, 12689], "valid", [], "NV8"], [[12690, 12690], "mapped", [19968]], [[12691, 12691], "mapped", [20108]], [[12692, 12692], "mapped", [19977]], [[12693, 12693], "mapped", [22235]], [[12694, 12694], "mapped", [19978]], [[12695, 12695], "mapped", [20013]], [[12696, 12696], "mapped", [19979]], [[12697, 12697], "mapped", [30002]], [[12698, 12698], "mapped", [20057]], [[12699, 12699], "mapped", [19993]], [[12700, 12700], "mapped", [19969]], [[12701, 12701], "mapped", [22825]], [[12702, 12702], "mapped", [22320]], [[12703, 12703], "mapped", [20154]], [[12704, 12727], "valid"], [[12728, 12730], "valid"], [[12731, 12735], "disallowed"], [[12736, 12751], "valid", [], "NV8"], [[12752, 12771], "valid", [], "NV8"], [[12772, 12783], "disallowed"], [[12784, 12799], "valid"], [[12800, 12800], "disallowed_STD3_mapped", [40, 4352, 41]], [[12801, 12801], "disallowed_STD3_mapped", [40, 4354, 41]], [[12802, 12802], "disallowed_STD3_mapped", [40, 4355, 41]], [[12803, 12803], "disallowed_STD3_mapped", [40, 4357, 41]], [[12804, 12804], "disallowed_STD3_mapped", [40, 4358, 41]], [[12805, 12805], "disallowed_STD3_mapped", [40, 4359, 41]], [[12806, 12806], "disallowed_STD3_mapped", [40, 4361, 41]], [[12807, 12807], "disallowed_STD3_mapped", [40, 4363, 41]], [[12808, 12808], "disallowed_STD3_mapped", [40, 4364, 41]], [[12809, 12809], "disallowed_STD3_mapped", [40, 4366, 41]], [[12810, 12810], "disallowed_STD3_mapped", [40, 4367, 41]], [[12811, 12811], "disallowed_STD3_mapped", [40, 4368, 41]], [[12812, 12812], "disallowed_STD3_mapped", [40, 4369, 41]], [[12813, 12813], "disallowed_STD3_mapped", [40, 4370, 41]], [[12814, 12814], "disallowed_STD3_mapped", [40, 44032, 41]], [[12815, 12815], "disallowed_STD3_mapped", [40, 45208, 41]], [[12816, 12816], "disallowed_STD3_mapped", [40, 45796, 41]], [[12817, 12817], "disallowed_STD3_mapped", [40, 46972, 41]], [[12818, 12818], "disallowed_STD3_mapped", [40, 47560, 41]], [[12819, 12819], "disallowed_STD3_mapped", [40, 48148, 41]], [[12820, 12820], "disallowed_STD3_mapped", [40, 49324, 41]], [[12821, 12821], "disallowed_STD3_mapped", [40, 50500, 41]], [[12822, 12822], "disallowed_STD3_mapped", [40, 51088, 41]], [[12823, 12823], "disallowed_STD3_mapped", [40, 52264, 41]], [[12824, 12824], "disallowed_STD3_mapped", [40, 52852, 41]], [[12825, 12825], "disallowed_STD3_mapped", [40, 53440, 41]], [[12826, 12826], "disallowed_STD3_mapped", [40, 54028, 41]], [[12827, 12827], "disallowed_STD3_mapped", [40, 54616, 41]], [[12828, 12828], "disallowed_STD3_mapped", [40, 51452, 41]], [[12829, 12829], "disallowed_STD3_mapped", [40, 50724, 51204, 41]], [[12830, 12830], "disallowed_STD3_mapped", [40, 50724, 54980, 41]], [[12831, 12831], "disallowed"], [[12832, 12832], "disallowed_STD3_mapped", [40, 19968, 41]], [[12833, 12833], "disallowed_STD3_mapped", [40, 20108, 41]], [[12834, 12834], "disallowed_STD3_mapped", [40, 19977, 41]], [[12835, 12835], "disallowed_STD3_mapped", [40, 22235, 41]], [[12836, 12836], "disallowed_STD3_mapped", [40, 20116, 41]], [[12837, 12837], "disallowed_STD3_mapped", [40, 20845, 41]], [[12838, 12838], "disallowed_STD3_mapped", [40, 19971, 41]], [[12839, 12839], "disallowed_STD3_mapped", [40, 20843, 41]], [[12840, 12840], "disallowed_STD3_mapped", [40, 20061, 41]], [[12841, 12841], "disallowed_STD3_mapped", [40, 21313, 41]], [[12842, 12842], "disallowed_STD3_mapped", [40, 26376, 41]], [[12843, 12843], "disallowed_STD3_mapped", [40, 28779, 41]], [[12844, 12844], "disallowed_STD3_mapped", [40, 27700, 41]], [[12845, 12845], "disallowed_STD3_mapped", [40, 26408, 41]], [[12846, 12846], "disallowed_STD3_mapped", [40, 37329, 41]], [[12847, 12847], "disallowed_STD3_mapped", [40, 22303, 41]], [[12848, 12848], "disallowed_STD3_mapped", [40, 26085, 41]], [[12849, 12849], "disallowed_STD3_mapped", [40, 26666, 41]], [[12850, 12850], "disallowed_STD3_mapped", [40, 26377, 41]], [[12851, 12851], "disallowed_STD3_mapped", [40, 31038, 41]], [[12852, 12852], "disallowed_STD3_mapped", [40, 21517, 41]], [[12853, 12853], "disallowed_STD3_mapped", [40, 29305, 41]], [[12854, 12854], "disallowed_STD3_mapped", [40, 36001, 41]], [[12855, 12855], "disallowed_STD3_mapped", [40, 31069, 41]], [[12856, 12856], "disallowed_STD3_mapped", [40, 21172, 41]], [[12857, 12857], "disallowed_STD3_mapped", [40, 20195, 41]], [[12858, 12858], "disallowed_STD3_mapped", [40, 21628, 41]], [[12859, 12859], "disallowed_STD3_mapped", [40, 23398, 41]], [[12860, 12860], "disallowed_STD3_mapped", [40, 30435, 41]], [[12861, 12861], "disallowed_STD3_mapped", [40, 20225, 41]], [[12862, 12862], "disallowed_STD3_mapped", [40, 36039, 41]], [[12863, 12863], "disallowed_STD3_mapped", [40, 21332, 41]], [[12864, 12864], "disallowed_STD3_mapped", [40, 31085, 41]], [[12865, 12865], "disallowed_STD3_mapped", [40, 20241, 41]], [[12866, 12866], "disallowed_STD3_mapped", [40, 33258, 41]], [[12867, 12867], "disallowed_STD3_mapped", [40, 33267, 41]], [[12868, 12868], "mapped", [21839]], [[12869, 12869], "mapped", [24188]], [[12870, 12870], "mapped", [25991]], [[12871, 12871], "mapped", [31631]], [[12872, 12879], "valid", [], "NV8"], [[12880, 12880], "mapped", [112, 116, 101]], [[12881, 12881], "mapped", [50, 49]], [[12882, 12882], "mapped", [50, 50]], [[12883, 12883], "mapped", [50, 51]], [[12884, 12884], "mapped", [50, 52]], [[12885, 12885], "mapped", [50, 53]], [[12886, 12886], "mapped", [50, 54]], [[12887, 12887], "mapped", [50, 55]], [[12888, 12888], "mapped", [50, 56]], [[12889, 12889], "mapped", [50, 57]], [[12890, 12890], "mapped", [51, 48]], [[12891, 12891], "mapped", [51, 49]], [[12892, 12892], "mapped", [51, 50]], [[12893, 12893], "mapped", [51, 51]], [[12894, 12894], "mapped", [51, 52]], [[12895, 12895], "mapped", [51, 53]], [[12896, 12896], "mapped", [4352]], [[12897, 12897], "mapped", [4354]], [[12898, 12898], "mapped", [4355]], [[12899, 12899], "mapped", [4357]], [[12900, 12900], "mapped", [4358]], [[12901, 12901], "mapped", [4359]], [[12902, 12902], "mapped", [4361]], [[12903, 12903], "mapped", [4363]], [[12904, 12904], "mapped", [4364]], [[12905, 12905], "mapped", [4366]], [[12906, 12906], "mapped", [4367]], [[12907, 12907], "mapped", [4368]], [[12908, 12908], "mapped", [4369]], [[12909, 12909], "mapped", [4370]], [[12910, 12910], "mapped", [44032]], [[12911, 12911], "mapped", [45208]], [[12912, 12912], "mapped", [45796]], [[12913, 12913], "mapped", [46972]], [[12914, 12914], "mapped", [47560]], [[12915, 12915], "mapped", [48148]], [[12916, 12916], "mapped", [49324]], [[12917, 12917], "mapped", [50500]], [[12918, 12918], "mapped", [51088]], [[12919, 12919], "mapped", [52264]], [[12920, 12920], "mapped", [52852]], [[12921, 12921], "mapped", [53440]], [[12922, 12922], "mapped", [54028]], [[12923, 12923], "mapped", [54616]], [[12924, 12924], "mapped", [52280, 44256]], [[12925, 12925], "mapped", [51452, 51032]], [[12926, 12926], "mapped", [50864]], [[12927, 12927], "valid", [], "NV8"], [[12928, 12928], "mapped", [19968]], [[12929, 12929], "mapped", [20108]], [[12930, 12930], "mapped", [19977]], [[12931, 12931], "mapped", [22235]], [[12932, 12932], "mapped", [20116]], [[12933, 12933], "mapped", [20845]], [[12934, 12934], "mapped", [19971]], [[12935, 12935], "mapped", [20843]], [[12936, 12936], "mapped", [20061]], [[12937, 12937], "mapped", [21313]], [[12938, 12938], "mapped", [26376]], [[12939, 12939], "mapped", [28779]], [[12940, 12940], "mapped", [27700]], [[12941, 12941], "mapped", [26408]], [[12942, 12942], "mapped", [37329]], [[12943, 12943], "mapped", [22303]], [[12944, 12944], "mapped", [26085]], [[12945, 12945], "mapped", [26666]], [[12946, 12946], "mapped", [26377]], [[12947, 12947], "mapped", [31038]], [[12948, 12948], "mapped", [21517]], [[12949, 12949], "mapped", [29305]], [[12950, 12950], "mapped", [36001]], [[12951, 12951], "mapped", [31069]], [[12952, 12952], "mapped", [21172]], [[12953, 12953], "mapped", [31192]], [[12954, 12954], "mapped", [30007]], [[12955, 12955], "mapped", [22899]], [[12956, 12956], "mapped", [36969]], [[12957, 12957], "mapped", [20778]], [[12958, 12958], "mapped", [21360]], [[12959, 12959], "mapped", [27880]], [[12960, 12960], "mapped", [38917]], [[12961, 12961], "mapped", [20241]], [[12962, 12962], "mapped", [20889]], [[12963, 12963], "mapped", [27491]], [[12964, 12964], "mapped", [19978]], [[12965, 12965], "mapped", [20013]], [[12966, 12966], "mapped", [19979]], [[12967, 12967], "mapped", [24038]], [[12968, 12968], "mapped", [21491]], [[12969, 12969], "mapped", [21307]], [[12970, 12970], "mapped", [23447]], [[12971, 12971], "mapped", [23398]], [[12972, 12972], "mapped", [30435]], [[12973, 12973], "mapped", [20225]], [[12974, 12974], "mapped", [36039]], [[12975, 12975], "mapped", [21332]], [[12976, 12976], "mapped", [22812]], [[12977, 12977], "mapped", [51, 54]], [[12978, 12978], "mapped", [51, 55]], [[12979, 12979], "mapped", [51, 56]], [[12980, 12980], "mapped", [51, 57]], [[12981, 12981], "mapped", [52, 48]], [[12982, 12982], "mapped", [52, 49]], [[12983, 12983], "mapped", [52, 50]], [[12984, 12984], "mapped", [52, 51]], [[12985, 12985], "mapped", [52, 52]], [[12986, 12986], "mapped", [52, 53]], [[12987, 12987], "mapped", [52, 54]], [[12988, 12988], "mapped", [52, 55]], [[12989, 12989], "mapped", [52, 56]], [[12990, 12990], "mapped", [52, 57]], [[12991, 12991], "mapped", [53, 48]], [[12992, 12992], "mapped", [49, 26376]], [[12993, 12993], "mapped", [50, 26376]], [[12994, 12994], "mapped", [51, 26376]], [[12995, 12995], "mapped", [52, 26376]], [[12996, 12996], "mapped", [53, 26376]], [[12997, 12997], "mapped", [54, 26376]], [[12998, 12998], "mapped", [55, 26376]], [[12999, 12999], "mapped", [56, 26376]], [[13000, 13000], "mapped", [57, 26376]], [[13001, 13001], "mapped", [49, 48, 26376]], [[13002, 13002], "mapped", [49, 49, 26376]], [[13003, 13003], "mapped", [49, 50, 26376]], [[13004, 13004], "mapped", [104, 103]], [[13005, 13005], "mapped", [101, 114, 103]], [[13006, 13006], "mapped", [101, 118]], [[13007, 13007], "mapped", [108, 116, 100]], [[13008, 13008], "mapped", [12450]], [[13009, 13009], "mapped", [12452]], [[13010, 13010], "mapped", [12454]], [[13011, 13011], "mapped", [12456]], [[13012, 13012], "mapped", [12458]], [[13013, 13013], "mapped", [12459]], [[13014, 13014], "mapped", [12461]], [[13015, 13015], "mapped", [12463]], [[13016, 13016], "mapped", [12465]], [[13017, 13017], "mapped", [12467]], [[13018, 13018], "mapped", [12469]], [[13019, 13019], "mapped", [12471]], [[13020, 13020], "mapped", [12473]], [[13021, 13021], "mapped", [12475]], [[13022, 13022], "mapped", [12477]], [[13023, 13023], "mapped", [12479]], [[13024, 13024], "mapped", [12481]], [[13025, 13025], "mapped", [12484]], [[13026, 13026], "mapped", [12486]], [[13027, 13027], "mapped", [12488]], [[13028, 13028], "mapped", [12490]], [[13029, 13029], "mapped", [12491]], [[13030, 13030], "mapped", [12492]], [[13031, 13031], "mapped", [12493]], [[13032, 13032], "mapped", [12494]], [[13033, 13033], "mapped", [12495]], [[13034, 13034], "mapped", [12498]], [[13035, 13035], "mapped", [12501]], [[13036, 13036], "mapped", [12504]], [[13037, 13037], "mapped", [12507]], [[13038, 13038], "mapped", [12510]], [[13039, 13039], "mapped", [12511]], [[13040, 13040], "mapped", [12512]], [[13041, 13041], "mapped", [12513]], [[13042, 13042], "mapped", [12514]], [[13043, 13043], "mapped", [12516]], [[13044, 13044], "mapped", [12518]], [[13045, 13045], "mapped", [12520]], [[13046, 13046], "mapped", [12521]], [[13047, 13047], "mapped", [12522]], [[13048, 13048], "mapped", [12523]], [[13049, 13049], "mapped", [12524]], [[13050, 13050], "mapped", [12525]], [[13051, 13051], "mapped", [12527]], [[13052, 13052], "mapped", [12528]], [[13053, 13053], "mapped", [12529]], [[13054, 13054], "mapped", [12530]], [[13055, 13055], "disallowed"], [[13056, 13056], "mapped", [12450, 12497, 12540, 12488]], [[13057, 13057], "mapped", [12450, 12523, 12501, 12449]], [[13058, 13058], "mapped", [12450, 12531, 12506, 12450]], [[13059, 13059], "mapped", [12450, 12540, 12523]], [[13060, 13060], "mapped", [12452, 12491, 12531, 12464]], [[13061, 13061], "mapped", [12452, 12531, 12481]], [[13062, 13062], "mapped", [12454, 12457, 12531]], [[13063, 13063], "mapped", [12456, 12473, 12463, 12540, 12489]], [[13064, 13064], "mapped", [12456, 12540, 12459, 12540]], [[13065, 13065], "mapped", [12458, 12531, 12473]], [[13066, 13066], "mapped", [12458, 12540, 12512]], [[13067, 13067], "mapped", [12459, 12452, 12522]], [[13068, 13068], "mapped", [12459, 12521, 12483, 12488]], [[13069, 13069], "mapped", [12459, 12525, 12522, 12540]], [[13070, 13070], "mapped", [12460, 12525, 12531]], [[13071, 13071], "mapped", [12460, 12531, 12510]], [[13072, 13072], "mapped", [12462, 12460]], [[13073, 13073], "mapped", [12462, 12491, 12540]], [[13074, 13074], "mapped", [12461, 12517, 12522, 12540]], [[13075, 13075], "mapped", [12462, 12523, 12480, 12540]], [[13076, 13076], "mapped", [12461, 12525]], [[13077, 13077], "mapped", [12461, 12525, 12464, 12521, 12512]], [[13078, 13078], "mapped", [12461, 12525, 12513, 12540, 12488, 12523]], [[13079, 13079], "mapped", [12461, 12525, 12527, 12483, 12488]], [[13080, 13080], "mapped", [12464, 12521, 12512]], [[13081, 13081], "mapped", [12464, 12521, 12512, 12488, 12531]], [[13082, 13082], "mapped", [12463, 12523, 12476, 12452, 12525]], [[13083, 13083], "mapped", [12463, 12525, 12540, 12493]], [[13084, 13084], "mapped", [12465, 12540, 12473]], [[13085, 13085], "mapped", [12467, 12523, 12490]], [[13086, 13086], "mapped", [12467, 12540, 12509]], [[13087, 13087], "mapped", [12469, 12452, 12463, 12523]], [[13088, 13088], "mapped", [12469, 12531, 12481, 12540, 12512]], [[13089, 13089], "mapped", [12471, 12522, 12531, 12464]], [[13090, 13090], "mapped", [12475, 12531, 12481]], [[13091, 13091], "mapped", [12475, 12531, 12488]], [[13092, 13092], "mapped", [12480, 12540, 12473]], [[13093, 13093], "mapped", [12487, 12471]], [[13094, 13094], "mapped", [12489, 12523]], [[13095, 13095], "mapped", [12488, 12531]], [[13096, 13096], "mapped", [12490, 12494]], [[13097, 13097], "mapped", [12494, 12483, 12488]], [[13098, 13098], "mapped", [12495, 12452, 12484]], [[13099, 13099], "mapped", [12497, 12540, 12475, 12531, 12488]], [[13100, 13100], "mapped", [12497, 12540, 12484]], [[13101, 13101], "mapped", [12496, 12540, 12524, 12523]], [[13102, 13102], "mapped", [12500, 12450, 12473, 12488, 12523]], [[13103, 13103], "mapped", [12500, 12463, 12523]], [[13104, 13104], "mapped", [12500, 12467]], [[13105, 13105], "mapped", [12499, 12523]], [[13106, 13106], "mapped", [12501, 12449, 12521, 12483, 12489]], [[13107, 13107], "mapped", [12501, 12451, 12540, 12488]], [[13108, 13108], "mapped", [12502, 12483, 12471, 12455, 12523]], [[13109, 13109], "mapped", [12501, 12521, 12531]], [[13110, 13110], "mapped", [12504, 12463, 12479, 12540, 12523]], [[13111, 13111], "mapped", [12506, 12477]], [[13112, 13112], "mapped", [12506, 12491, 12498]], [[13113, 13113], "mapped", [12504, 12523, 12484]], [[13114, 13114], "mapped", [12506, 12531, 12473]], [[13115, 13115], "mapped", [12506, 12540, 12472]], [[13116, 13116], "mapped", [12505, 12540, 12479]], [[13117, 13117], "mapped", [12509, 12452, 12531, 12488]], [[13118, 13118], "mapped", [12508, 12523, 12488]], [[13119, 13119], "mapped", [12507, 12531]], [[13120, 13120], "mapped", [12509, 12531, 12489]], [[13121, 13121], "mapped", [12507, 12540, 12523]], [[13122, 13122], "mapped", [12507, 12540, 12531]], [[13123, 13123], "mapped", [12510, 12452, 12463, 12525]], [[13124, 13124], "mapped", [12510, 12452, 12523]], [[13125, 13125], "mapped", [12510, 12483, 12495]], [[13126, 13126], "mapped", [12510, 12523, 12463]], [[13127, 13127], "mapped", [12510, 12531, 12471, 12519, 12531]], [[13128, 13128], "mapped", [12511, 12463, 12525, 12531]], [[13129, 13129], "mapped", [12511, 12522]], [[13130, 13130], "mapped", [12511, 12522, 12496, 12540, 12523]], [[13131, 13131], "mapped", [12513, 12460]], [[13132, 13132], "mapped", [12513, 12460, 12488, 12531]], [[13133, 13133], "mapped", [12513, 12540, 12488, 12523]], [[13134, 13134], "mapped", [12516, 12540, 12489]], [[13135, 13135], "mapped", [12516, 12540, 12523]], [[13136, 13136], "mapped", [12518, 12450, 12531]], [[13137, 13137], "mapped", [12522, 12483, 12488, 12523]], [[13138, 13138], "mapped", [12522, 12521]], [[13139, 13139], "mapped", [12523, 12500, 12540]], [[13140, 13140], "mapped", [12523, 12540, 12502, 12523]], [[13141, 13141], "mapped", [12524, 12512]], [[13142, 13142], "mapped", [12524, 12531, 12488, 12466, 12531]], [[13143, 13143], "mapped", [12527, 12483, 12488]], [[13144, 13144], "mapped", [48, 28857]], [[13145, 13145], "mapped", [49, 28857]], [[13146, 13146], "mapped", [50, 28857]], [[13147, 13147], "mapped", [51, 28857]], [[13148, 13148], "mapped", [52, 28857]], [[13149, 13149], "mapped", [53, 28857]], [[13150, 13150], "mapped", [54, 28857]], [[13151, 13151], "mapped", [55, 28857]], [[13152, 13152], "mapped", [56, 28857]], [[13153, 13153], "mapped", [57, 28857]], [[13154, 13154], "mapped", [49, 48, 28857]], [[13155, 13155], "mapped", [49, 49, 28857]], [[13156, 13156], "mapped", [49, 50, 28857]], [[13157, 13157], "mapped", [49, 51, 28857]], [[13158, 13158], "mapped", [49, 52, 28857]], [[13159, 13159], "mapped", [49, 53, 28857]], [[13160, 13160], "mapped", [49, 54, 28857]], [[13161, 13161], "mapped", [49, 55, 28857]], [[13162, 13162], "mapped", [49, 56, 28857]], [[13163, 13163], "mapped", [49, 57, 28857]], [[13164, 13164], "mapped", [50, 48, 28857]], [[13165, 13165], "mapped", [50, 49, 28857]], [[13166, 13166], "mapped", [50, 50, 28857]], [[13167, 13167], "mapped", [50, 51, 28857]], [[13168, 13168], "mapped", [50, 52, 28857]], [[13169, 13169], "mapped", [104, 112, 97]], [[13170, 13170], "mapped", [100, 97]], [[13171, 13171], "mapped", [97, 117]], [[13172, 13172], "mapped", [98, 97, 114]], [[13173, 13173], "mapped", [111, 118]], [[13174, 13174], "mapped", [112, 99]], [[13175, 13175], "mapped", [100, 109]], [[13176, 13176], "mapped", [100, 109, 50]], [[13177, 13177], "mapped", [100, 109, 51]], [[13178, 13178], "mapped", [105, 117]], [[13179, 13179], "mapped", [24179, 25104]], [[13180, 13180], "mapped", [26157, 21644]], [[13181, 13181], "mapped", [22823, 27491]], [[13182, 13182], "mapped", [26126, 27835]], [[13183, 13183], "mapped", [26666, 24335, 20250, 31038]], [[13184, 13184], "mapped", [112, 97]], [[13185, 13185], "mapped", [110, 97]], [[13186, 13186], "mapped", [956, 97]], [[13187, 13187], "mapped", [109, 97]], [[13188, 13188], "mapped", [107, 97]], [[13189, 13189], "mapped", [107, 98]], [[13190, 13190], "mapped", [109, 98]], [[13191, 13191], "mapped", [103, 98]], [[13192, 13192], "mapped", [99, 97, 108]], [[13193, 13193], "mapped", [107, 99, 97, 108]], [[13194, 13194], "mapped", [112, 102]], [[13195, 13195], "mapped", [110, 102]], [[13196, 13196], "mapped", [956, 102]], [[13197, 13197], "mapped", [956, 103]], [[13198, 13198], "mapped", [109, 103]], [[13199, 13199], "mapped", [107, 103]], [[13200, 13200], "mapped", [104, 122]], [[13201, 13201], "mapped", [107, 104, 122]], [[13202, 13202], "mapped", [109, 104, 122]], [[13203, 13203], "mapped", [103, 104, 122]], [[13204, 13204], "mapped", [116, 104, 122]], [[13205, 13205], "mapped", [956, 108]], [[13206, 13206], "mapped", [109, 108]], [[13207, 13207], "mapped", [100, 108]], [[13208, 13208], "mapped", [107, 108]], [[13209, 13209], "mapped", [102, 109]], [[13210, 13210], "mapped", [110, 109]], [[13211, 13211], "mapped", [956, 109]], [[13212, 13212], "mapped", [109, 109]], [[13213, 13213], "mapped", [99, 109]], [[13214, 13214], "mapped", [107, 109]], [[13215, 13215], "mapped", [109, 109, 50]], [[13216, 13216], "mapped", [99, 109, 50]], [[13217, 13217], "mapped", [109, 50]], [[13218, 13218], "mapped", [107, 109, 50]], [[13219, 13219], "mapped", [109, 109, 51]], [[13220, 13220], "mapped", [99, 109, 51]], [[13221, 13221], "mapped", [109, 51]], [[13222, 13222], "mapped", [107, 109, 51]], [[13223, 13223], "mapped", [109, 8725, 115]], [[13224, 13224], "mapped", [109, 8725, 115, 50]], [[13225, 13225], "mapped", [112, 97]], [[13226, 13226], "mapped", [107, 112, 97]], [[13227, 13227], "mapped", [109, 112, 97]], [[13228, 13228], "mapped", [103, 112, 97]], [[13229, 13229], "mapped", [114, 97, 100]], [[13230, 13230], "mapped", [114, 97, 100, 8725, 115]], [[13231, 13231], "mapped", [114, 97, 100, 8725, 115, 50]], [[13232, 13232], "mapped", [112, 115]], [[13233, 13233], "mapped", [110, 115]], [[13234, 13234], "mapped", [956, 115]], [[13235, 13235], "mapped", [109, 115]], [[13236, 13236], "mapped", [112, 118]], [[13237, 13237], "mapped", [110, 118]], [[13238, 13238], "mapped", [956, 118]], [[13239, 13239], "mapped", [109, 118]], [[13240, 13240], "mapped", [107, 118]], [[13241, 13241], "mapped", [109, 118]], [[13242, 13242], "mapped", [112, 119]], [[13243, 13243], "mapped", [110, 119]], [[13244, 13244], "mapped", [956, 119]], [[13245, 13245], "mapped", [109, 119]], [[13246, 13246], "mapped", [107, 119]], [[13247, 13247], "mapped", [109, 119]], [[13248, 13248], "mapped", [107, 969]], [[13249, 13249], "mapped", [109, 969]], [[13250, 13250], "disallowed"], [[13251, 13251], "mapped", [98, 113]], [[13252, 13252], "mapped", [99, 99]], [[13253, 13253], "mapped", [99, 100]], [[13254, 13254], "mapped", [99, 8725, 107, 103]], [[13255, 13255], "disallowed"], [[13256, 13256], "mapped", [100, 98]], [[13257, 13257], "mapped", [103, 121]], [[13258, 13258], "mapped", [104, 97]], [[13259, 13259], "mapped", [104, 112]], [[13260, 13260], "mapped", [105, 110]], [[13261, 13261], "mapped", [107, 107]], [[13262, 13262], "mapped", [107, 109]], [[13263, 13263], "mapped", [107, 116]], [[13264, 13264], "mapped", [108, 109]], [[13265, 13265], "mapped", [108, 110]], [[13266, 13266], "mapped", [108, 111, 103]], [[13267, 13267], "mapped", [108, 120]], [[13268, 13268], "mapped", [109, 98]], [[13269, 13269], "mapped", [109, 105, 108]], [[13270, 13270], "mapped", [109, 111, 108]], [[13271, 13271], "mapped", [112, 104]], [[13272, 13272], "disallowed"], [[13273, 13273], "mapped", [112, 112, 109]], [[13274, 13274], "mapped", [112, 114]], [[13275, 13275], "mapped", [115, 114]], [[13276, 13276], "mapped", [115, 118]], [[13277, 13277], "mapped", [119, 98]], [[13278, 13278], "mapped", [118, 8725, 109]], [[13279, 13279], "mapped", [97, 8725, 109]], [[13280, 13280], "mapped", [49, 26085]], [[13281, 13281], "mapped", [50, 26085]], [[13282, 13282], "mapped", [51, 26085]], [[13283, 13283], "mapped", [52, 26085]], [[13284, 13284], "mapped", [53, 26085]], [[13285, 13285], "mapped", [54, 26085]], [[13286, 13286], "mapped", [55, 26085]], [[13287, 13287], "mapped", [56, 26085]], [[13288, 13288], "mapped", [57, 26085]], [[13289, 13289], "mapped", [49, 48, 26085]], [[13290, 13290], "mapped", [49, 49, 26085]], [[13291, 13291], "mapped", [49, 50, 26085]], [[13292, 13292], "mapped", [49, 51, 26085]], [[13293, 13293], "mapped", [49, 52, 26085]], [[13294, 13294], "mapped", [49, 53, 26085]], [[13295, 13295], "mapped", [49, 54, 26085]], [[13296, 13296], "mapped", [49, 55, 26085]], [[13297, 13297], "mapped", [49, 56, 26085]], [[13298, 13298], "mapped", [49, 57, 26085]], [[13299, 13299], "mapped", [50, 48, 26085]], [[13300, 13300], "mapped", [50, 49, 26085]], [[13301, 13301], "mapped", [50, 50, 26085]], [[13302, 13302], "mapped", [50, 51, 26085]], [[13303, 13303], "mapped", [50, 52, 26085]], [[13304, 13304], "mapped", [50, 53, 26085]], [[13305, 13305], "mapped", [50, 54, 26085]], [[13306, 13306], "mapped", [50, 55, 26085]], [[13307, 13307], "mapped", [50, 56, 26085]], [[13308, 13308], "mapped", [50, 57, 26085]], [[13309, 13309], "mapped", [51, 48, 26085]], [[13310, 13310], "mapped", [51, 49, 26085]], [[13311, 13311], "mapped", [103, 97, 108]], [[13312, 19893], "valid"], [[19894, 19903], "disallowed"], [[19904, 19967], "valid", [], "NV8"], [[19968, 40869], "valid"], [[40870, 40891], "valid"], [[40892, 40899], "valid"], [[40900, 40907], "valid"], [[40908, 40908], "valid"], [[40909, 40917], "valid"], [[40918, 40959], "disallowed"], [[40960, 42124], "valid"], [[42125, 42127], "disallowed"], [[42128, 42145], "valid", [], "NV8"], [[42146, 42147], "valid", [], "NV8"], [[42148, 42163], "valid", [], "NV8"], [[42164, 42164], "valid", [], "NV8"], [[42165, 42176], "valid", [], "NV8"], [[42177, 42177], "valid", [], "NV8"], [[42178, 42180], "valid", [], "NV8"], [[42181, 42181], "valid", [], "NV8"], [[42182, 42182], "valid", [], "NV8"], [[42183, 42191], "disallowed"], [[42192, 42237], "valid"], [[42238, 42239], "valid", [], "NV8"], [[42240, 42508], "valid"], [[42509, 42511], "valid", [], "NV8"], [[42512, 42539], "valid"], [[42540, 42559], "disallowed"], [[42560, 42560], "mapped", [42561]], [[42561, 42561], "valid"], [[42562, 42562], "mapped", [42563]], [[42563, 42563], "valid"], [[42564, 42564], "mapped", [42565]], [[42565, 42565], "valid"], [[42566, 42566], "mapped", [42567]], [[42567, 42567], "valid"], [[42568, 42568], "mapped", [42569]], [[42569, 42569], "valid"], [[42570, 42570], "mapped", [42571]], [[42571, 42571], "valid"], [[42572, 42572], "mapped", [42573]], [[42573, 42573], "valid"], [[42574, 42574], "mapped", [42575]], [[42575, 42575], "valid"], [[42576, 42576], "mapped", [42577]], [[42577, 42577], "valid"], [[42578, 42578], "mapped", [42579]], [[42579, 42579], "valid"], [[42580, 42580], "mapped", [42581]], [[42581, 42581], "valid"], [[42582, 42582], "mapped", [42583]], [[42583, 42583], "valid"], [[42584, 42584], "mapped", [42585]], [[42585, 42585], "valid"], [[42586, 42586], "mapped", [42587]], [[42587, 42587], "valid"], [[42588, 42588], "mapped", [42589]], [[42589, 42589], "valid"], [[42590, 42590], "mapped", [42591]], [[42591, 42591], "valid"], [[42592, 42592], "mapped", [42593]], [[42593, 42593], "valid"], [[42594, 42594], "mapped", [42595]], [[42595, 42595], "valid"], [[42596, 42596], "mapped", [42597]], [[42597, 42597], "valid"], [[42598, 42598], "mapped", [42599]], [[42599, 42599], "valid"], [[42600, 42600], "mapped", [42601]], [[42601, 42601], "valid"], [[42602, 42602], "mapped", [42603]], [[42603, 42603], "valid"], [[42604, 42604], "mapped", [42605]], [[42605, 42607], "valid"], [[42608, 42611], "valid", [], "NV8"], [[42612, 42619], "valid"], [[42620, 42621], "valid"], [[42622, 42622], "valid", [], "NV8"], [[42623, 42623], "valid"], [[42624, 42624], "mapped", [42625]], [[42625, 42625], "valid"], [[42626, 42626], "mapped", [42627]], [[42627, 42627], "valid"], [[42628, 42628], "mapped", [42629]], [[42629, 42629], "valid"], [[42630, 42630], "mapped", [42631]], [[42631, 42631], "valid"], [[42632, 42632], "mapped", [42633]], [[42633, 42633], "valid"], [[42634, 42634], "mapped", [42635]], [[42635, 42635], "valid"], [[42636, 42636], "mapped", [42637]], [[42637, 42637], "valid"], [[42638, 42638], "mapped", [42639]], [[42639, 42639], "valid"], [[42640, 42640], "mapped", [42641]], [[42641, 42641], "valid"], [[42642, 42642], "mapped", [42643]], [[42643, 42643], "valid"], [[42644, 42644], "mapped", [42645]], [[42645, 42645], "valid"], [[42646, 42646], "mapped", [42647]], [[42647, 42647], "valid"], [[42648, 42648], "mapped", [42649]], [[42649, 42649], "valid"], [[42650, 42650], "mapped", [42651]], [[42651, 42651], "valid"], [[42652, 42652], "mapped", [1098]], [[42653, 42653], "mapped", [1100]], [[42654, 42654], "valid"], [[42655, 42655], "valid"], [[42656, 42725], "valid"], [[42726, 42735], "valid", [], "NV8"], [[42736, 42737], "valid"], [[42738, 42743], "valid", [], "NV8"], [[42744, 42751], "disallowed"], [[42752, 42774], "valid", [], "NV8"], [[42775, 42778], "valid"], [[42779, 42783], "valid"], [[42784, 42785], "valid", [], "NV8"], [[42786, 42786], "mapped", [42787]], [[42787, 42787], "valid"], [[42788, 42788], "mapped", [42789]], [[42789, 42789], "valid"], [[42790, 42790], "mapped", [42791]], [[42791, 42791], "valid"], [[42792, 42792], "mapped", [42793]], [[42793, 42793], "valid"], [[42794, 42794], "mapped", [42795]], [[42795, 42795], "valid"], [[42796, 42796], "mapped", [42797]], [[42797, 42797], "valid"], [[42798, 42798], "mapped", [42799]], [[42799, 42801], "valid"], [[42802, 42802], "mapped", [42803]], [[42803, 42803], "valid"], [[42804, 42804], "mapped", [42805]], [[42805, 42805], "valid"], [[42806, 42806], "mapped", [42807]], [[42807, 42807], "valid"], [[42808, 42808], "mapped", [42809]], [[42809, 42809], "valid"], [[42810, 42810], "mapped", [42811]], [[42811, 42811], "valid"], [[42812, 42812], "mapped", [42813]], [[42813, 42813], "valid"], [[42814, 42814], "mapped", [42815]], [[42815, 42815], "valid"], [[42816, 42816], "mapped", [42817]], [[42817, 42817], "valid"], [[42818, 42818], "mapped", [42819]], [[42819, 42819], "valid"], [[42820, 42820], "mapped", [42821]], [[42821, 42821], "valid"], [[42822, 42822], "mapped", [42823]], [[42823, 42823], "valid"], [[42824, 42824], "mapped", [42825]], [[42825, 42825], "valid"], [[42826, 42826], "mapped", [42827]], [[42827, 42827], "valid"], [[42828, 42828], "mapped", [42829]], [[42829, 42829], "valid"], [[42830, 42830], "mapped", [42831]], [[42831, 42831], "valid"], [[42832, 42832], "mapped", [42833]], [[42833, 42833], "valid"], [[42834, 42834], "mapped", [42835]], [[42835, 42835], "valid"], [[42836, 42836], "mapped", [42837]], [[42837, 42837], "valid"], [[42838, 42838], "mapped", [42839]], [[42839, 42839], "valid"], [[42840, 42840], "mapped", [42841]], [[42841, 42841], "valid"], [[42842, 42842], "mapped", [42843]], [[42843, 42843], "valid"], [[42844, 42844], "mapped", [42845]], [[42845, 42845], "valid"], [[42846, 42846], "mapped", [42847]], [[42847, 42847], "valid"], [[42848, 42848], "mapped", [42849]], [[42849, 42849], "valid"], [[42850, 42850], "mapped", [42851]], [[42851, 42851], "valid"], [[42852, 42852], "mapped", [42853]], [[42853, 42853], "valid"], [[42854, 42854], "mapped", [42855]], [[42855, 42855], "valid"], [[42856, 42856], "mapped", [42857]], [[42857, 42857], "valid"], [[42858, 42858], "mapped", [42859]], [[42859, 42859], "valid"], [[42860, 42860], "mapped", [42861]], [[42861, 42861], "valid"], [[42862, 42862], "mapped", [42863]], [[42863, 42863], "valid"], [[42864, 42864], "mapped", [42863]], [[42865, 42872], "valid"], [[42873, 42873], "mapped", [42874]], [[42874, 42874], "valid"], [[42875, 42875], "mapped", [42876]], [[42876, 42876], "valid"], [[42877, 42877], "mapped", [7545]], [[42878, 42878], "mapped", [42879]], [[42879, 42879], "valid"], [[42880, 42880], "mapped", [42881]], [[42881, 42881], "valid"], [[42882, 42882], "mapped", [42883]], [[42883, 42883], "valid"], [[42884, 42884], "mapped", [42885]], [[42885, 42885], "valid"], [[42886, 42886], "mapped", [42887]], [[42887, 42888], "valid"], [[42889, 42890], "valid", [], "NV8"], [[42891, 42891], "mapped", [42892]], [[42892, 42892], "valid"], [[42893, 42893], "mapped", [613]], [[42894, 42894], "valid"], [[42895, 42895], "valid"], [[42896, 42896], "mapped", [42897]], [[42897, 42897], "valid"], [[42898, 42898], "mapped", [42899]], [[42899, 42899], "valid"], [[42900, 42901], "valid"], [[42902, 42902], "mapped", [42903]], [[42903, 42903], "valid"], [[42904, 42904], "mapped", [42905]], [[42905, 42905], "valid"], [[42906, 42906], "mapped", [42907]], [[42907, 42907], "valid"], [[42908, 42908], "mapped", [42909]], [[42909, 42909], "valid"], [[42910, 42910], "mapped", [42911]], [[42911, 42911], "valid"], [[42912, 42912], "mapped", [42913]], [[42913, 42913], "valid"], [[42914, 42914], "mapped", [42915]], [[42915, 42915], "valid"], [[42916, 42916], "mapped", [42917]], [[42917, 42917], "valid"], [[42918, 42918], "mapped", [42919]], [[42919, 42919], "valid"], [[42920, 42920], "mapped", [42921]], [[42921, 42921], "valid"], [[42922, 42922], "mapped", [614]], [[42923, 42923], "mapped", [604]], [[42924, 42924], "mapped", [609]], [[42925, 42925], "mapped", [620]], [[42926, 42927], "disallowed"], [[42928, 42928], "mapped", [670]], [[42929, 42929], "mapped", [647]], [[42930, 42930], "mapped", [669]], [[42931, 42931], "mapped", [43859]], [[42932, 42932], "mapped", [42933]], [[42933, 42933], "valid"], [[42934, 42934], "mapped", [42935]], [[42935, 42935], "valid"], [[42936, 42998], "disallowed"], [[42999, 42999], "valid"], [[43000, 43000], "mapped", [295]], [[43001, 43001], "mapped", [339]], [[43002, 43002], "valid"], [[43003, 43007], "valid"], [[43008, 43047], "valid"], [[43048, 43051], "valid", [], "NV8"], [[43052, 43055], "disallowed"], [[43056, 43065], "valid", [], "NV8"], [[43066, 43071], "disallowed"], [[43072, 43123], "valid"], [[43124, 43127], "valid", [], "NV8"], [[43128, 43135], "disallowed"], [[43136, 43204], "valid"], [[43205, 43213], "disallowed"], [[43214, 43215], "valid", [], "NV8"], [[43216, 43225], "valid"], [[43226, 43231], "disallowed"], [[43232, 43255], "valid"], [[43256, 43258], "valid", [], "NV8"], [[43259, 43259], "valid"], [[43260, 43260], "valid", [], "NV8"], [[43261, 43261], "valid"], [[43262, 43263], "disallowed"], [[43264, 43309], "valid"], [[43310, 43311], "valid", [], "NV8"], [[43312, 43347], "valid"], [[43348, 43358], "disallowed"], [[43359, 43359], "valid", [], "NV8"], [[43360, 43388], "valid", [], "NV8"], [[43389, 43391], "disallowed"], [[43392, 43456], "valid"], [[43457, 43469], "valid", [], "NV8"], [[43470, 43470], "disallowed"], [[43471, 43481], "valid"], [[43482, 43485], "disallowed"], [[43486, 43487], "valid", [], "NV8"], [[43488, 43518], "valid"], [[43519, 43519], "disallowed"], [[43520, 43574], "valid"], [[43575, 43583], "disallowed"], [[43584, 43597], "valid"], [[43598, 43599], "disallowed"], [[43600, 43609], "valid"], [[43610, 43611], "disallowed"], [[43612, 43615], "valid", [], "NV8"], [[43616, 43638], "valid"], [[43639, 43641], "valid", [], "NV8"], [[43642, 43643], "valid"], [[43644, 43647], "valid"], [[43648, 43714], "valid"], [[43715, 43738], "disallowed"], [[43739, 43741], "valid"], [[43742, 43743], "valid", [], "NV8"], [[43744, 43759], "valid"], [[43760, 43761], "valid", [], "NV8"], [[43762, 43766], "valid"], [[43767, 43776], "disallowed"], [[43777, 43782], "valid"], [[43783, 43784], "disallowed"], [[43785, 43790], "valid"], [[43791, 43792], "disallowed"], [[43793, 43798], "valid"], [[43799, 43807], "disallowed"], [[43808, 43814], "valid"], [[43815, 43815], "disallowed"], [[43816, 43822], "valid"], [[43823, 43823], "disallowed"], [[43824, 43866], "valid"], [[43867, 43867], "valid", [], "NV8"], [[43868, 43868], "mapped", [42791]], [[43869, 43869], "mapped", [43831]], [[43870, 43870], "mapped", [619]], [[43871, 43871], "mapped", [43858]], [[43872, 43875], "valid"], [[43876, 43877], "valid"], [[43878, 43887], "disallowed"], [[43888, 43888], "mapped", [5024]], [[43889, 43889], "mapped", [5025]], [[43890, 43890], "mapped", [5026]], [[43891, 43891], "mapped", [5027]], [[43892, 43892], "mapped", [5028]], [[43893, 43893], "mapped", [5029]], [[43894, 43894], "mapped", [5030]], [[43895, 43895], "mapped", [5031]], [[43896, 43896], "mapped", [5032]], [[43897, 43897], "mapped", [5033]], [[43898, 43898], "mapped", [5034]], [[43899, 43899], "mapped", [5035]], [[43900, 43900], "mapped", [5036]], [[43901, 43901], "mapped", [5037]], [[43902, 43902], "mapped", [5038]], [[43903, 43903], "mapped", [5039]], [[43904, 43904], "mapped", [5040]], [[43905, 43905], "mapped", [5041]], [[43906, 43906], "mapped", [5042]], [[43907, 43907], "mapped", [5043]], [[43908, 43908], "mapped", [5044]], [[43909, 43909], "mapped", [5045]], [[43910, 43910], "mapped", [5046]], [[43911, 43911], "mapped", [5047]], [[43912, 43912], "mapped", [5048]], [[43913, 43913], "mapped", [5049]], [[43914, 43914], "mapped", [5050]], [[43915, 43915], "mapped", [5051]], [[43916, 43916], "mapped", [5052]], [[43917, 43917], "mapped", [5053]], [[43918, 43918], "mapped", [5054]], [[43919, 43919], "mapped", [5055]], [[43920, 43920], "mapped", [5056]], [[43921, 43921], "mapped", [5057]], [[43922, 43922], "mapped", [5058]], [[43923, 43923], "mapped", [5059]], [[43924, 43924], "mapped", [5060]], [[43925, 43925], "mapped", [5061]], [[43926, 43926], "mapped", [5062]], [[43927, 43927], "mapped", [5063]], [[43928, 43928], "mapped", [5064]], [[43929, 43929], "mapped", [5065]], [[43930, 43930], "mapped", [5066]], [[43931, 43931], "mapped", [5067]], [[43932, 43932], "mapped", [5068]], [[43933, 43933], "mapped", [5069]], [[43934, 43934], "mapped", [5070]], [[43935, 43935], "mapped", [5071]], [[43936, 43936], "mapped", [5072]], [[43937, 43937], "mapped", [5073]], [[43938, 43938], "mapped", [5074]], [[43939, 43939], "mapped", [5075]], [[43940, 43940], "mapped", [5076]], [[43941, 43941], "mapped", [5077]], [[43942, 43942], "mapped", [5078]], [[43943, 43943], "mapped", [5079]], [[43944, 43944], "mapped", [5080]], [[43945, 43945], "mapped", [5081]], [[43946, 43946], "mapped", [5082]], [[43947, 43947], "mapped", [5083]], [[43948, 43948], "mapped", [5084]], [[43949, 43949], "mapped", [5085]], [[43950, 43950], "mapped", [5086]], [[43951, 43951], "mapped", [5087]], [[43952, 43952], "mapped", [5088]], [[43953, 43953], "mapped", [5089]], [[43954, 43954], "mapped", [5090]], [[43955, 43955], "mapped", [5091]], [[43956, 43956], "mapped", [5092]], [[43957, 43957], "mapped", [5093]], [[43958, 43958], "mapped", [5094]], [[43959, 43959], "mapped", [5095]], [[43960, 43960], "mapped", [5096]], [[43961, 43961], "mapped", [5097]], [[43962, 43962], "mapped", [5098]], [[43963, 43963], "mapped", [5099]], [[43964, 43964], "mapped", [5100]], [[43965, 43965], "mapped", [5101]], [[43966, 43966], "mapped", [5102]], [[43967, 43967], "mapped", [5103]], [[43968, 44010], "valid"], [[44011, 44011], "valid", [], "NV8"], [[44012, 44013], "valid"], [[44014, 44015], "disallowed"], [[44016, 44025], "valid"], [[44026, 44031], "disallowed"], [[44032, 55203], "valid"], [[55204, 55215], "disallowed"], [[55216, 55238], "valid", [], "NV8"], [[55239, 55242], "disallowed"], [[55243, 55291], "valid", [], "NV8"], [[55292, 55295], "disallowed"], [[55296, 57343], "disallowed"], [[57344, 63743], "disallowed"], [[63744, 63744], "mapped", [35912]], [[63745, 63745], "mapped", [26356]], [[63746, 63746], "mapped", [36554]], [[63747, 63747], "mapped", [36040]], [[63748, 63748], "mapped", [28369]], [[63749, 63749], "mapped", [20018]], [[63750, 63750], "mapped", [21477]], [[63751, 63752], "mapped", [40860]], [[63753, 63753], "mapped", [22865]], [[63754, 63754], "mapped", [37329]], [[63755, 63755], "mapped", [21895]], [[63756, 63756], "mapped", [22856]], [[63757, 63757], "mapped", [25078]], [[63758, 63758], "mapped", [30313]], [[63759, 63759], "mapped", [32645]], [[63760, 63760], "mapped", [34367]], [[63761, 63761], "mapped", [34746]], [[63762, 63762], "mapped", [35064]], [[63763, 63763], "mapped", [37007]], [[63764, 63764], "mapped", [27138]], [[63765, 63765], "mapped", [27931]], [[63766, 63766], "mapped", [28889]], [[63767, 63767], "mapped", [29662]], [[63768, 63768], "mapped", [33853]], [[63769, 63769], "mapped", [37226]], [[63770, 63770], "mapped", [39409]], [[63771, 63771], "mapped", [20098]], [[63772, 63772], "mapped", [21365]], [[63773, 63773], "mapped", [27396]], [[63774, 63774], "mapped", [29211]], [[63775, 63775], "mapped", [34349]], [[63776, 63776], "mapped", [40478]], [[63777, 63777], "mapped", [23888]], [[63778, 63778], "mapped", [28651]], [[63779, 63779], "mapped", [34253]], [[63780, 63780], "mapped", [35172]], [[63781, 63781], "mapped", [25289]], [[63782, 63782], "mapped", [33240]], [[63783, 63783], "mapped", [34847]], [[63784, 63784], "mapped", [24266]], [[63785, 63785], "mapped", [26391]], [[63786, 63786], "mapped", [28010]], [[63787, 63787], "mapped", [29436]], [[63788, 63788], "mapped", [37070]], [[63789, 63789], "mapped", [20358]], [[63790, 63790], "mapped", [20919]], [[63791, 63791], "mapped", [21214]], [[63792, 63792], "mapped", [25796]], [[63793, 63793], "mapped", [27347]], [[63794, 63794], "mapped", [29200]], [[63795, 63795], "mapped", [30439]], [[63796, 63796], "mapped", [32769]], [[63797, 63797], "mapped", [34310]], [[63798, 63798], "mapped", [34396]], [[63799, 63799], "mapped", [36335]], [[63800, 63800], "mapped", [38706]], [[63801, 63801], "mapped", [39791]], [[63802, 63802], "mapped", [40442]], [[63803, 63803], "mapped", [30860]], [[63804, 63804], "mapped", [31103]], [[63805, 63805], "mapped", [32160]], [[63806, 63806], "mapped", [33737]], [[63807, 63807], "mapped", [37636]], [[63808, 63808], "mapped", [40575]], [[63809, 63809], "mapped", [35542]], [[63810, 63810], "mapped", [22751]], [[63811, 63811], "mapped", [24324]], [[63812, 63812], "mapped", [31840]], [[63813, 63813], "mapped", [32894]], [[63814, 63814], "mapped", [29282]], [[63815, 63815], "mapped", [30922]], [[63816, 63816], "mapped", [36034]], [[63817, 63817], "mapped", [38647]], [[63818, 63818], "mapped", [22744]], [[63819, 63819], "mapped", [23650]], [[63820, 63820], "mapped", [27155]], [[63821, 63821], "mapped", [28122]], [[63822, 63822], "mapped", [28431]], [[63823, 63823], "mapped", [32047]], [[63824, 63824], "mapped", [32311]], [[63825, 63825], "mapped", [38475]], [[63826, 63826], "mapped", [21202]], [[63827, 63827], "mapped", [32907]], [[63828, 63828], "mapped", [20956]], [[63829, 63829], "mapped", [20940]], [[63830, 63830], "mapped", [31260]], [[63831, 63831], "mapped", [32190]], [[63832, 63832], "mapped", [33777]], [[63833, 63833], "mapped", [38517]], [[63834, 63834], "mapped", [35712]], [[63835, 63835], "mapped", [25295]], [[63836, 63836], "mapped", [27138]], [[63837, 63837], "mapped", [35582]], [[63838, 63838], "mapped", [20025]], [[63839, 63839], "mapped", [23527]], [[63840, 63840], "mapped", [24594]], [[63841, 63841], "mapped", [29575]], [[63842, 63842], "mapped", [30064]], [[63843, 63843], "mapped", [21271]], [[63844, 63844], "mapped", [30971]], [[63845, 63845], "mapped", [20415]], [[63846, 63846], "mapped", [24489]], [[63847, 63847], "mapped", [19981]], [[63848, 63848], "mapped", [27852]], [[63849, 63849], "mapped", [25976]], [[63850, 63850], "mapped", [32034]], [[63851, 63851], "mapped", [21443]], [[63852, 63852], "mapped", [22622]], [[63853, 63853], "mapped", [30465]], [[63854, 63854], "mapped", [33865]], [[63855, 63855], "mapped", [35498]], [[63856, 63856], "mapped", [27578]], [[63857, 63857], "mapped", [36784]], [[63858, 63858], "mapped", [27784]], [[63859, 63859], "mapped", [25342]], [[63860, 63860], "mapped", [33509]], [[63861, 63861], "mapped", [25504]], [[63862, 63862], "mapped", [30053]], [[63863, 63863], "mapped", [20142]], [[63864, 63864], "mapped", [20841]], [[63865, 63865], "mapped", [20937]], [[63866, 63866], "mapped", [26753]], [[63867, 63867], "mapped", [31975]], [[63868, 63868], "mapped", [33391]], [[63869, 63869], "mapped", [35538]], [[63870, 63870], "mapped", [37327]], [[63871, 63871], "mapped", [21237]], [[63872, 63872], "mapped", [21570]], [[63873, 63873], "mapped", [22899]], [[63874, 63874], "mapped", [24300]], [[63875, 63875], "mapped", [26053]], [[63876, 63876], "mapped", [28670]], [[63877, 63877], "mapped", [31018]], [[63878, 63878], "mapped", [38317]], [[63879, 63879], "mapped", [39530]], [[63880, 63880], "mapped", [40599]], [[63881, 63881], "mapped", [40654]], [[63882, 63882], "mapped", [21147]], [[63883, 63883], "mapped", [26310]], [[63884, 63884], "mapped", [27511]], [[63885, 63885], "mapped", [36706]], [[63886, 63886], "mapped", [24180]], [[63887, 63887], "mapped", [24976]], [[63888, 63888], "mapped", [25088]], [[63889, 63889], "mapped", [25754]], [[63890, 63890], "mapped", [28451]], [[63891, 63891], "mapped", [29001]], [[63892, 63892], "mapped", [29833]], [[63893, 63893], "mapped", [31178]], [[63894, 63894], "mapped", [32244]], [[63895, 63895], "mapped", [32879]], [[63896, 63896], "mapped", [36646]], [[63897, 63897], "mapped", [34030]], [[63898, 63898], "mapped", [36899]], [[63899, 63899], "mapped", [37706]], [[63900, 63900], "mapped", [21015]], [[63901, 63901], "mapped", [21155]], [[63902, 63902], "mapped", [21693]], [[63903, 63903], "mapped", [28872]], [[63904, 63904], "mapped", [35010]], [[63905, 63905], "mapped", [35498]], [[63906, 63906], "mapped", [24265]], [[63907, 63907], "mapped", [24565]], [[63908, 63908], "mapped", [25467]], [[63909, 63909], "mapped", [27566]], [[63910, 63910], "mapped", [31806]], [[63911, 63911], "mapped", [29557]], [[63912, 63912], "mapped", [20196]], [[63913, 63913], "mapped", [22265]], [[63914, 63914], "mapped", [23527]], [[63915, 63915], "mapped", [23994]], [[63916, 63916], "mapped", [24604]], [[63917, 63917], "mapped", [29618]], [[63918, 63918], "mapped", [29801]], [[63919, 63919], "mapped", [32666]], [[63920, 63920], "mapped", [32838]], [[63921, 63921], "mapped", [37428]], [[63922, 63922], "mapped", [38646]], [[63923, 63923], "mapped", [38728]], [[63924, 63924], "mapped", [38936]], [[63925, 63925], "mapped", [20363]], [[63926, 63926], "mapped", [31150]], [[63927, 63927], "mapped", [37300]], [[63928, 63928], "mapped", [38584]], [[63929, 63929], "mapped", [24801]], [[63930, 63930], "mapped", [20102]], [[63931, 63931], "mapped", [20698]], [[63932, 63932], "mapped", [23534]], [[63933, 63933], "mapped", [23615]], [[63934, 63934], "mapped", [26009]], [[63935, 63935], "mapped", [27138]], [[63936, 63936], "mapped", [29134]], [[63937, 63937], "mapped", [30274]], [[63938, 63938], "mapped", [34044]], [[63939, 63939], "mapped", [36988]], [[63940, 63940], "mapped", [40845]], [[63941, 63941], "mapped", [26248]], [[63942, 63942], "mapped", [38446]], [[63943, 63943], "mapped", [21129]], [[63944, 63944], "mapped", [26491]], [[63945, 63945], "mapped", [26611]], [[63946, 63946], "mapped", [27969]], [[63947, 63947], "mapped", [28316]], [[63948, 63948], "mapped", [29705]], [[63949, 63949], "mapped", [30041]], [[63950, 63950], "mapped", [30827]], [[63951, 63951], "mapped", [32016]], [[63952, 63952], "mapped", [39006]], [[63953, 63953], "mapped", [20845]], [[63954, 63954], "mapped", [25134]], [[63955, 63955], "mapped", [38520]], [[63956, 63956], "mapped", [20523]], [[63957, 63957], "mapped", [23833]], [[63958, 63958], "mapped", [28138]], [[63959, 63959], "mapped", [36650]], [[63960, 63960], "mapped", [24459]], [[63961, 63961], "mapped", [24900]], [[63962, 63962], "mapped", [26647]], [[63963, 63963], "mapped", [29575]], [[63964, 63964], "mapped", [38534]], [[63965, 63965], "mapped", [21033]], [[63966, 63966], "mapped", [21519]], [[63967, 63967], "mapped", [23653]], [[63968, 63968], "mapped", [26131]], [[63969, 63969], "mapped", [26446]], [[63970, 63970], "mapped", [26792]], [[63971, 63971], "mapped", [27877]], [[63972, 63972], "mapped", [29702]], [[63973, 63973], "mapped", [30178]], [[63974, 63974], "mapped", [32633]], [[63975, 63975], "mapped", [35023]], [[63976, 63976], "mapped", [35041]], [[63977, 63977], "mapped", [37324]], [[63978, 63978], "mapped", [38626]], [[63979, 63979], "mapped", [21311]], [[63980, 63980], "mapped", [28346]], [[63981, 63981], "mapped", [21533]], [[63982, 63982], "mapped", [29136]], [[63983, 63983], "mapped", [29848]], [[63984, 63984], "mapped", [34298]], [[63985, 63985], "mapped", [38563]], [[63986, 63986], "mapped", [40023]], [[63987, 63987], "mapped", [40607]], [[63988, 63988], "mapped", [26519]], [[63989, 63989], "mapped", [28107]], [[63990, 63990], "mapped", [33256]], [[63991, 63991], "mapped", [31435]], [[63992, 63992], "mapped", [31520]], [[63993, 63993], "mapped", [31890]], [[63994, 63994], "mapped", [29376]], [[63995, 63995], "mapped", [28825]], [[63996, 63996], "mapped", [35672]], [[63997, 63997], "mapped", [20160]], [[63998, 63998], "mapped", [33590]], [[63999, 63999], "mapped", [21050]], [[64000, 64000], "mapped", [20999]], [[64001, 64001], "mapped", [24230]], [[64002, 64002], "mapped", [25299]], [[64003, 64003], "mapped", [31958]], [[64004, 64004], "mapped", [23429]], [[64005, 64005], "mapped", [27934]], [[64006, 64006], "mapped", [26292]], [[64007, 64007], "mapped", [36667]], [[64008, 64008], "mapped", [34892]], [[64009, 64009], "mapped", [38477]], [[64010, 64010], "mapped", [35211]], [[64011, 64011], "mapped", [24275]], [[64012, 64012], "mapped", [20800]], [[64013, 64013], "mapped", [21952]], [[64014, 64015], "valid"], [[64016, 64016], "mapped", [22618]], [[64017, 64017], "valid"], [[64018, 64018], "mapped", [26228]], [[64019, 64020], "valid"], [[64021, 64021], "mapped", [20958]], [[64022, 64022], "mapped", [29482]], [[64023, 64023], "mapped", [30410]], [[64024, 64024], "mapped", [31036]], [[64025, 64025], "mapped", [31070]], [[64026, 64026], "mapped", [31077]], [[64027, 64027], "mapped", [31119]], [[64028, 64028], "mapped", [38742]], [[64029, 64029], "mapped", [31934]], [[64030, 64030], "mapped", [32701]], [[64031, 64031], "valid"], [[64032, 64032], "mapped", [34322]], [[64033, 64033], "valid"], [[64034, 64034], "mapped", [35576]], [[64035, 64036], "valid"], [[64037, 64037], "mapped", [36920]], [[64038, 64038], "mapped", [37117]], [[64039, 64041], "valid"], [[64042, 64042], "mapped", [39151]], [[64043, 64043], "mapped", [39164]], [[64044, 64044], "mapped", [39208]], [[64045, 64045], "mapped", [40372]], [[64046, 64046], "mapped", [37086]], [[64047, 64047], "mapped", [38583]], [[64048, 64048], "mapped", [20398]], [[64049, 64049], "mapped", [20711]], [[64050, 64050], "mapped", [20813]], [[64051, 64051], "mapped", [21193]], [[64052, 64052], "mapped", [21220]], [[64053, 64053], "mapped", [21329]], [[64054, 64054], "mapped", [21917]], [[64055, 64055], "mapped", [22022]], [[64056, 64056], "mapped", [22120]], [[64057, 64057], "mapped", [22592]], [[64058, 64058], "mapped", [22696]], [[64059, 64059], "mapped", [23652]], [[64060, 64060], "mapped", [23662]], [[64061, 64061], "mapped", [24724]], [[64062, 64062], "mapped", [24936]], [[64063, 64063], "mapped", [24974]], [[64064, 64064], "mapped", [25074]], [[64065, 64065], "mapped", [25935]], [[64066, 64066], "mapped", [26082]], [[64067, 64067], "mapped", [26257]], [[64068, 64068], "mapped", [26757]], [[64069, 64069], "mapped", [28023]], [[64070, 64070], "mapped", [28186]], [[64071, 64071], "mapped", [28450]], [[64072, 64072], "mapped", [29038]], [[64073, 64073], "mapped", [29227]], [[64074, 64074], "mapped", [29730]], [[64075, 64075], "mapped", [30865]], [[64076, 64076], "mapped", [31038]], [[64077, 64077], "mapped", [31049]], [[64078, 64078], "mapped", [31048]], [[64079, 64079], "mapped", [31056]], [[64080, 64080], "mapped", [31062]], [[64081, 64081], "mapped", [31069]], [[64082, 64082], "mapped", [31117]], [[64083, 64083], "mapped", [31118]], [[64084, 64084], "mapped", [31296]], [[64085, 64085], "mapped", [31361]], [[64086, 64086], "mapped", [31680]], [[64087, 64087], "mapped", [32244]], [[64088, 64088], "mapped", [32265]], [[64089, 64089], "mapped", [32321]], [[64090, 64090], "mapped", [32626]], [[64091, 64091], "mapped", [32773]], [[64092, 64092], "mapped", [33261]], [[64093, 64094], "mapped", [33401]], [[64095, 64095], "mapped", [33879]], [[64096, 64096], "mapped", [35088]], [[64097, 64097], "mapped", [35222]], [[64098, 64098], "mapped", [35585]], [[64099, 64099], "mapped", [35641]], [[64100, 64100], "mapped", [36051]], [[64101, 64101], "mapped", [36104]], [[64102, 64102], "mapped", [36790]], [[64103, 64103], "mapped", [36920]], [[64104, 64104], "mapped", [38627]], [[64105, 64105], "mapped", [38911]], [[64106, 64106], "mapped", [38971]], [[64107, 64107], "mapped", [24693]], [[64108, 64108], "mapped", [148206]], [[64109, 64109], "mapped", [33304]], [[64110, 64111], "disallowed"], [[64112, 64112], "mapped", [20006]], [[64113, 64113], "mapped", [20917]], [[64114, 64114], "mapped", [20840]], [[64115, 64115], "mapped", [20352]], [[64116, 64116], "mapped", [20805]], [[64117, 64117], "mapped", [20864]], [[64118, 64118], "mapped", [21191]], [[64119, 64119], "mapped", [21242]], [[64120, 64120], "mapped", [21917]], [[64121, 64121], "mapped", [21845]], [[64122, 64122], "mapped", [21913]], [[64123, 64123], "mapped", [21986]], [[64124, 64124], "mapped", [22618]], [[64125, 64125], "mapped", [22707]], [[64126, 64126], "mapped", [22852]], [[64127, 64127], "mapped", [22868]], [[64128, 64128], "mapped", [23138]], [[64129, 64129], "mapped", [23336]], [[64130, 64130], "mapped", [24274]], [[64131, 64131], "mapped", [24281]], [[64132, 64132], "mapped", [24425]], [[64133, 64133], "mapped", [24493]], [[64134, 64134], "mapped", [24792]], [[64135, 64135], "mapped", [24910]], [[64136, 64136], "mapped", [24840]], [[64137, 64137], "mapped", [24974]], [[64138, 64138], "mapped", [24928]], [[64139, 64139], "mapped", [25074]], [[64140, 64140], "mapped", [25140]], [[64141, 64141], "mapped", [25540]], [[64142, 64142], "mapped", [25628]], [[64143, 64143], "mapped", [25682]], [[64144, 64144], "mapped", [25942]], [[64145, 64145], "mapped", [26228]], [[64146, 64146], "mapped", [26391]], [[64147, 64147], "mapped", [26395]], [[64148, 64148], "mapped", [26454]], [[64149, 64149], "mapped", [27513]], [[64150, 64150], "mapped", [27578]], [[64151, 64151], "mapped", [27969]], [[64152, 64152], "mapped", [28379]], [[64153, 64153], "mapped", [28363]], [[64154, 64154], "mapped", [28450]], [[64155, 64155], "mapped", [28702]], [[64156, 64156], "mapped", [29038]], [[64157, 64157], "mapped", [30631]], [[64158, 64158], "mapped", [29237]], [[64159, 64159], "mapped", [29359]], [[64160, 64160], "mapped", [29482]], [[64161, 64161], "mapped", [29809]], [[64162, 64162], "mapped", [29958]], [[64163, 64163], "mapped", [30011]], [[64164, 64164], "mapped", [30237]], [[64165, 64165], "mapped", [30239]], [[64166, 64166], "mapped", [30410]], [[64167, 64167], "mapped", [30427]], [[64168, 64168], "mapped", [30452]], [[64169, 64169], "mapped", [30538]], [[64170, 64170], "mapped", [30528]], [[64171, 64171], "mapped", [30924]], [[64172, 64172], "mapped", [31409]], [[64173, 64173], "mapped", [31680]], [[64174, 64174], "mapped", [31867]], [[64175, 64175], "mapped", [32091]], [[64176, 64176], "mapped", [32244]], [[64177, 64177], "mapped", [32574]], [[64178, 64178], "mapped", [32773]], [[64179, 64179], "mapped", [33618]], [[64180, 64180], "mapped", [33775]], [[64181, 64181], "mapped", [34681]], [[64182, 64182], "mapped", [35137]], [[64183, 64183], "mapped", [35206]], [[64184, 64184], "mapped", [35222]], [[64185, 64185], "mapped", [35519]], [[64186, 64186], "mapped", [35576]], [[64187, 64187], "mapped", [35531]], [[64188, 64188], "mapped", [35585]], [[64189, 64189], "mapped", [35582]], [[64190, 64190], "mapped", [35565]], [[64191, 64191], "mapped", [35641]], [[64192, 64192], "mapped", [35722]], [[64193, 64193], "mapped", [36104]], [[64194, 64194], "mapped", [36664]], [[64195, 64195], "mapped", [36978]], [[64196, 64196], "mapped", [37273]], [[64197, 64197], "mapped", [37494]], [[64198, 64198], "mapped", [38524]], [[64199, 64199], "mapped", [38627]], [[64200, 64200], "mapped", [38742]], [[64201, 64201], "mapped", [38875]], [[64202, 64202], "mapped", [38911]], [[64203, 64203], "mapped", [38923]], [[64204, 64204], "mapped", [38971]], [[64205, 64205], "mapped", [39698]], [[64206, 64206], "mapped", [40860]], [[64207, 64207], "mapped", [141386]], [[64208, 64208], "mapped", [141380]], [[64209, 64209], "mapped", [144341]], [[64210, 64210], "mapped", [15261]], [[64211, 64211], "mapped", [16408]], [[64212, 64212], "mapped", [16441]], [[64213, 64213], "mapped", [152137]], [[64214, 64214], "mapped", [154832]], [[64215, 64215], "mapped", [163539]], [[64216, 64216], "mapped", [40771]], [[64217, 64217], "mapped", [40846]], [[64218, 64255], "disallowed"], [[64256, 64256], "mapped", [102, 102]], [[64257, 64257], "mapped", [102, 105]], [[64258, 64258], "mapped", [102, 108]], [[64259, 64259], "mapped", [102, 102, 105]], [[64260, 64260], "mapped", [102, 102, 108]], [[64261, 64262], "mapped", [115, 116]], [[64263, 64274], "disallowed"], [[64275, 64275], "mapped", [1396, 1398]], [[64276, 64276], "mapped", [1396, 1381]], [[64277, 64277], "mapped", [1396, 1387]], [[64278, 64278], "mapped", [1406, 1398]], [[64279, 64279], "mapped", [1396, 1389]], [[64280, 64284], "disallowed"], [[64285, 64285], "mapped", [1497, 1460]], [[64286, 64286], "valid"], [[64287, 64287], "mapped", [1522, 1463]], [[64288, 64288], "mapped", [1506]], [[64289, 64289], "mapped", [1488]], [[64290, 64290], "mapped", [1491]], [[64291, 64291], "mapped", [1492]], [[64292, 64292], "mapped", [1499]], [[64293, 64293], "mapped", [1500]], [[64294, 64294], "mapped", [1501]], [[64295, 64295], "mapped", [1512]], [[64296, 64296], "mapped", [1514]], [[64297, 64297], "disallowed_STD3_mapped", [43]], [[64298, 64298], "mapped", [1513, 1473]], [[64299, 64299], "mapped", [1513, 1474]], [[64300, 64300], "mapped", [1513, 1468, 1473]], [[64301, 64301], "mapped", [1513, 1468, 1474]], [[64302, 64302], "mapped", [1488, 1463]], [[64303, 64303], "mapped", [1488, 1464]], [[64304, 64304], "mapped", [1488, 1468]], [[64305, 64305], "mapped", [1489, 1468]], [[64306, 64306], "mapped", [1490, 1468]], [[64307, 64307], "mapped", [1491, 1468]], [[64308, 64308], "mapped", [1492, 1468]], [[64309, 64309], "mapped", [1493, 1468]], [[64310, 64310], "mapped", [1494, 1468]], [[64311, 64311], "disallowed"], [[64312, 64312], "mapped", [1496, 1468]], [[64313, 64313], "mapped", [1497, 1468]], [[64314, 64314], "mapped", [1498, 1468]], [[64315, 64315], "mapped", [1499, 1468]], [[64316, 64316], "mapped", [1500, 1468]], [[64317, 64317], "disallowed"], [[64318, 64318], "mapped", [1502, 1468]], [[64319, 64319], "disallowed"], [[64320, 64320], "mapped", [1504, 1468]], [[64321, 64321], "mapped", [1505, 1468]], [[64322, 64322], "disallowed"], [[64323, 64323], "mapped", [1507, 1468]], [[64324, 64324], "mapped", [1508, 1468]], [[64325, 64325], "disallowed"], [[64326, 64326], "mapped", [1510, 1468]], [[64327, 64327], "mapped", [1511, 1468]], [[64328, 64328], "mapped", [1512, 1468]], [[64329, 64329], "mapped", [1513, 1468]], [[64330, 64330], "mapped", [1514, 1468]], [[64331, 64331], "mapped", [1493, 1465]], [[64332, 64332], "mapped", [1489, 1471]], [[64333, 64333], "mapped", [1499, 1471]], [[64334, 64334], "mapped", [1508, 1471]], [[64335, 64335], "mapped", [1488, 1500]], [[64336, 64337], "mapped", [1649]], [[64338, 64341], "mapped", [1659]], [[64342, 64345], "mapped", [1662]], [[64346, 64349], "mapped", [1664]], [[64350, 64353], "mapped", [1658]], [[64354, 64357], "mapped", [1663]], [[64358, 64361], "mapped", [1657]], [[64362, 64365], "mapped", [1700]], [[64366, 64369], "mapped", [1702]], [[64370, 64373], "mapped", [1668]], [[64374, 64377], "mapped", [1667]], [[64378, 64381], "mapped", [1670]], [[64382, 64385], "mapped", [1671]], [[64386, 64387], "mapped", [1677]], [[64388, 64389], "mapped", [1676]], [[64390, 64391], "mapped", [1678]], [[64392, 64393], "mapped", [1672]], [[64394, 64395], "mapped", [1688]], [[64396, 64397], "mapped", [1681]], [[64398, 64401], "mapped", [1705]], [[64402, 64405], "mapped", [1711]], [[64406, 64409], "mapped", [1715]], [[64410, 64413], "mapped", [1713]], [[64414, 64415], "mapped", [1722]], [[64416, 64419], "mapped", [1723]], [[64420, 64421], "mapped", [1728]], [[64422, 64425], "mapped", [1729]], [[64426, 64429], "mapped", [1726]], [[64430, 64431], "mapped", [1746]], [[64432, 64433], "mapped", [1747]], [[64434, 64449], "valid", [], "NV8"], [[64450, 64466], "disallowed"], [[64467, 64470], "mapped", [1709]], [[64471, 64472], "mapped", [1735]], [[64473, 64474], "mapped", [1734]], [[64475, 64476], "mapped", [1736]], [[64477, 64477], "mapped", [1735, 1652]], [[64478, 64479], "mapped", [1739]], [[64480, 64481], "mapped", [1733]], [[64482, 64483], "mapped", [1737]], [[64484, 64487], "mapped", [1744]], [[64488, 64489], "mapped", [1609]], [[64490, 64491], "mapped", [1574, 1575]], [[64492, 64493], "mapped", [1574, 1749]], [[64494, 64495], "mapped", [1574, 1608]], [[64496, 64497], "mapped", [1574, 1735]], [[64498, 64499], "mapped", [1574, 1734]], [[64500, 64501], "mapped", [1574, 1736]], [[64502, 64504], "mapped", [1574, 1744]], [[64505, 64507], "mapped", [1574, 1609]], [[64508, 64511], "mapped", [1740]], [[64512, 64512], "mapped", [1574, 1580]], [[64513, 64513], "mapped", [1574, 1581]], [[64514, 64514], "mapped", [1574, 1605]], [[64515, 64515], "mapped", [1574, 1609]], [[64516, 64516], "mapped", [1574, 1610]], [[64517, 64517], "mapped", [1576, 1580]], [[64518, 64518], "mapped", [1576, 1581]], [[64519, 64519], "mapped", [1576, 1582]], [[64520, 64520], "mapped", [1576, 1605]], [[64521, 64521], "mapped", [1576, 1609]], [[64522, 64522], "mapped", [1576, 1610]], [[64523, 64523], "mapped", [1578, 1580]], [[64524, 64524], "mapped", [1578, 1581]], [[64525, 64525], "mapped", [1578, 1582]], [[64526, 64526], "mapped", [1578, 1605]], [[64527, 64527], "mapped", [1578, 1609]], [[64528, 64528], "mapped", [1578, 1610]], [[64529, 64529], "mapped", [1579, 1580]], [[64530, 64530], "mapped", [1579, 1605]], [[64531, 64531], "mapped", [1579, 1609]], [[64532, 64532], "mapped", [1579, 1610]], [[64533, 64533], "mapped", [1580, 1581]], [[64534, 64534], "mapped", [1580, 1605]], [[64535, 64535], "mapped", [1581, 1580]], [[64536, 64536], "mapped", [1581, 1605]], [[64537, 64537], "mapped", [1582, 1580]], [[64538, 64538], "mapped", [1582, 1581]], [[64539, 64539], "mapped", [1582, 1605]], [[64540, 64540], "mapped", [1587, 1580]], [[64541, 64541], "mapped", [1587, 1581]], [[64542, 64542], "mapped", [1587, 1582]], [[64543, 64543], "mapped", [1587, 1605]], [[64544, 64544], "mapped", [1589, 1581]], [[64545, 64545], "mapped", [1589, 1605]], [[64546, 64546], "mapped", [1590, 1580]], [[64547, 64547], "mapped", [1590, 1581]], [[64548, 64548], "mapped", [1590, 1582]], [[64549, 64549], "mapped", [1590, 1605]], [[64550, 64550], "mapped", [1591, 1581]], [[64551, 64551], "mapped", [1591, 1605]], [[64552, 64552], "mapped", [1592, 1605]], [[64553, 64553], "mapped", [1593, 1580]], [[64554, 64554], "mapped", [1593, 1605]], [[64555, 64555], "mapped", [1594, 1580]], [[64556, 64556], "mapped", [1594, 1605]], [[64557, 64557], "mapped", [1601, 1580]], [[64558, 64558], "mapped", [1601, 1581]], [[64559, 64559], "mapped", [1601, 1582]], [[64560, 64560], "mapped", [1601, 1605]], [[64561, 64561], "mapped", [1601, 1609]], [[64562, 64562], "mapped", [1601, 1610]], [[64563, 64563], "mapped", [1602, 1581]], [[64564, 64564], "mapped", [1602, 1605]], [[64565, 64565], "mapped", [1602, 1609]], [[64566, 64566], "mapped", [1602, 1610]], [[64567, 64567], "mapped", [1603, 1575]], [[64568, 64568], "mapped", [1603, 1580]], [[64569, 64569], "mapped", [1603, 1581]], [[64570, 64570], "mapped", [1603, 1582]], [[64571, 64571], "mapped", [1603, 1604]], [[64572, 64572], "mapped", [1603, 1605]], [[64573, 64573], "mapped", [1603, 1609]], [[64574, 64574], "mapped", [1603, 1610]], [[64575, 64575], "mapped", [1604, 1580]], [[64576, 64576], "mapped", [1604, 1581]], [[64577, 64577], "mapped", [1604, 1582]], [[64578, 64578], "mapped", [1604, 1605]], [[64579, 64579], "mapped", [1604, 1609]], [[64580, 64580], "mapped", [1604, 1610]], [[64581, 64581], "mapped", [1605, 1580]], [[64582, 64582], "mapped", [1605, 1581]], [[64583, 64583], "mapped", [1605, 1582]], [[64584, 64584], "mapped", [1605, 1605]], [[64585, 64585], "mapped", [1605, 1609]], [[64586, 64586], "mapped", [1605, 1610]], [[64587, 64587], "mapped", [1606, 1580]], [[64588, 64588], "mapped", [1606, 1581]], [[64589, 64589], "mapped", [1606, 1582]], [[64590, 64590], "mapped", [1606, 1605]], [[64591, 64591], "mapped", [1606, 1609]], [[64592, 64592], "mapped", [1606, 1610]], [[64593, 64593], "mapped", [1607, 1580]], [[64594, 64594], "mapped", [1607, 1605]], [[64595, 64595], "mapped", [1607, 1609]], [[64596, 64596], "mapped", [1607, 1610]], [[64597, 64597], "mapped", [1610, 1580]], [[64598, 64598], "mapped", [1610, 1581]], [[64599, 64599], "mapped", [1610, 1582]], [[64600, 64600], "mapped", [1610, 1605]], [[64601, 64601], "mapped", [1610, 1609]], [[64602, 64602], "mapped", [1610, 1610]], [[64603, 64603], "mapped", [1584, 1648]], [[64604, 64604], "mapped", [1585, 1648]], [[64605, 64605], "mapped", [1609, 1648]], [[64606, 64606], "disallowed_STD3_mapped", [32, 1612, 1617]], [[64607, 64607], "disallowed_STD3_mapped", [32, 1613, 1617]], [[64608, 64608], "disallowed_STD3_mapped", [32, 1614, 1617]], [[64609, 64609], "disallowed_STD3_mapped", [32, 1615, 1617]], [[64610, 64610], "disallowed_STD3_mapped", [32, 1616, 1617]], [[64611, 64611], "disallowed_STD3_mapped", [32, 1617, 1648]], [[64612, 64612], "mapped", [1574, 1585]], [[64613, 64613], "mapped", [1574, 1586]], [[64614, 64614], "mapped", [1574, 1605]], [[64615, 64615], "mapped", [1574, 1606]], [[64616, 64616], "mapped", [1574, 1609]], [[64617, 64617], "mapped", [1574, 1610]], [[64618, 64618], "mapped", [1576, 1585]], [[64619, 64619], "mapped", [1576, 1586]], [[64620, 64620], "mapped", [1576, 1605]], [[64621, 64621], "mapped", [1576, 1606]], [[64622, 64622], "mapped", [1576, 1609]], [[64623, 64623], "mapped", [1576, 1610]], [[64624, 64624], "mapped", [1578, 1585]], [[64625, 64625], "mapped", [1578, 1586]], [[64626, 64626], "mapped", [1578, 1605]], [[64627, 64627], "mapped", [1578, 1606]], [[64628, 64628], "mapped", [1578, 1609]], [[64629, 64629], "mapped", [1578, 1610]], [[64630, 64630], "mapped", [1579, 1585]], [[64631, 64631], "mapped", [1579, 1586]], [[64632, 64632], "mapped", [1579, 1605]], [[64633, 64633], "mapped", [1579, 1606]], [[64634, 64634], "mapped", [1579, 1609]], [[64635, 64635], "mapped", [1579, 1610]], [[64636, 64636], "mapped", [1601, 1609]], [[64637, 64637], "mapped", [1601, 1610]], [[64638, 64638], "mapped", [1602, 1609]], [[64639, 64639], "mapped", [1602, 1610]], [[64640, 64640], "mapped", [1603, 1575]], [[64641, 64641], "mapped", [1603, 1604]], [[64642, 64642], "mapped", [1603, 1605]], [[64643, 64643], "mapped", [1603, 1609]], [[64644, 64644], "mapped", [1603, 1610]], [[64645, 64645], "mapped", [1604, 1605]], [[64646, 64646], "mapped", [1604, 1609]], [[64647, 64647], "mapped", [1604, 1610]], [[64648, 64648], "mapped", [1605, 1575]], [[64649, 64649], "mapped", [1605, 1605]], [[64650, 64650], "mapped", [1606, 1585]], [[64651, 64651], "mapped", [1606, 1586]], [[64652, 64652], "mapped", [1606, 1605]], [[64653, 64653], "mapped", [1606, 1606]], [[64654, 64654], "mapped", [1606, 1609]], [[64655, 64655], "mapped", [1606, 1610]], [[64656, 64656], "mapped", [1609, 1648]], [[64657, 64657], "mapped", [1610, 1585]], [[64658, 64658], "mapped", [1610, 1586]], [[64659, 64659], "mapped", [1610, 1605]], [[64660, 64660], "mapped", [1610, 1606]], [[64661, 64661], "mapped", [1610, 1609]], [[64662, 64662], "mapped", [1610, 1610]], [[64663, 64663], "mapped", [1574, 1580]], [[64664, 64664], "mapped", [1574, 1581]], [[64665, 64665], "mapped", [1574, 1582]], [[64666, 64666], "mapped", [1574, 1605]], [[64667, 64667], "mapped", [1574, 1607]], [[64668, 64668], "mapped", [1576, 1580]], [[64669, 64669], "mapped", [1576, 1581]], [[64670, 64670], "mapped", [1576, 1582]], [[64671, 64671], "mapped", [1576, 1605]], [[64672, 64672], "mapped", [1576, 1607]], [[64673, 64673], "mapped", [1578, 1580]], [[64674, 64674], "mapped", [1578, 1581]], [[64675, 64675], "mapped", [1578, 1582]], [[64676, 64676], "mapped", [1578, 1605]], [[64677, 64677], "mapped", [1578, 1607]], [[64678, 64678], "mapped", [1579, 1605]], [[64679, 64679], "mapped", [1580, 1581]], [[64680, 64680], "mapped", [1580, 1605]], [[64681, 64681], "mapped", [1581, 1580]], [[64682, 64682], "mapped", [1581, 1605]], [[64683, 64683], "mapped", [1582, 1580]], [[64684, 64684], "mapped", [1582, 1605]], [[64685, 64685], "mapped", [1587, 1580]], [[64686, 64686], "mapped", [1587, 1581]], [[64687, 64687], "mapped", [1587, 1582]], [[64688, 64688], "mapped", [1587, 1605]], [[64689, 64689], "mapped", [1589, 1581]], [[64690, 64690], "mapped", [1589, 1582]], [[64691, 64691], "mapped", [1589, 1605]], [[64692, 64692], "mapped", [1590, 1580]], [[64693, 64693], "mapped", [1590, 1581]], [[64694, 64694], "mapped", [1590, 1582]], [[64695, 64695], "mapped", [1590, 1605]], [[64696, 64696], "mapped", [1591, 1581]], [[64697, 64697], "mapped", [1592, 1605]], [[64698, 64698], "mapped", [1593, 1580]], [[64699, 64699], "mapped", [1593, 1605]], [[64700, 64700], "mapped", [1594, 1580]], [[64701, 64701], "mapped", [1594, 1605]], [[64702, 64702], "mapped", [1601, 1580]], [[64703, 64703], "mapped", [1601, 1581]], [[64704, 64704], "mapped", [1601, 1582]], [[64705, 64705], "mapped", [1601, 1605]], [[64706, 64706], "mapped", [1602, 1581]], [[64707, 64707], "mapped", [1602, 1605]], [[64708, 64708], "mapped", [1603, 1580]], [[64709, 64709], "mapped", [1603, 1581]], [[64710, 64710], "mapped", [1603, 1582]], [[64711, 64711], "mapped", [1603, 1604]], [[64712, 64712], "mapped", [1603, 1605]], [[64713, 64713], "mapped", [1604, 1580]], [[64714, 64714], "mapped", [1604, 1581]], [[64715, 64715], "mapped", [1604, 1582]], [[64716, 64716], "mapped", [1604, 1605]], [[64717, 64717], "mapped", [1604, 1607]], [[64718, 64718], "mapped", [1605, 1580]], [[64719, 64719], "mapped", [1605, 1581]], [[64720, 64720], "mapped", [1605, 1582]], [[64721, 64721], "mapped", [1605, 1605]], [[64722, 64722], "mapped", [1606, 1580]], [[64723, 64723], "mapped", [1606, 1581]], [[64724, 64724], "mapped", [1606, 1582]], [[64725, 64725], "mapped", [1606, 1605]], [[64726, 64726], "mapped", [1606, 1607]], [[64727, 64727], "mapped", [1607, 1580]], [[64728, 64728], "mapped", [1607, 1605]], [[64729, 64729], "mapped", [1607, 1648]], [[64730, 64730], "mapped", [1610, 1580]], [[64731, 64731], "mapped", [1610, 1581]], [[64732, 64732], "mapped", [1610, 1582]], [[64733, 64733], "mapped", [1610, 1605]], [[64734, 64734], "mapped", [1610, 1607]], [[64735, 64735], "mapped", [1574, 1605]], [[64736, 64736], "mapped", [1574, 1607]], [[64737, 64737], "mapped", [1576, 1605]], [[64738, 64738], "mapped", [1576, 1607]], [[64739, 64739], "mapped", [1578, 1605]], [[64740, 64740], "mapped", [1578, 1607]], [[64741, 64741], "mapped", [1579, 1605]], [[64742, 64742], "mapped", [1579, 1607]], [[64743, 64743], "mapped", [1587, 1605]], [[64744, 64744], "mapped", [1587, 1607]], [[64745, 64745], "mapped", [1588, 1605]], [[64746, 64746], "mapped", [1588, 1607]], [[64747, 64747], "mapped", [1603, 1604]], [[64748, 64748], "mapped", [1603, 1605]], [[64749, 64749], "mapped", [1604, 1605]], [[64750, 64750], "mapped", [1606, 1605]], [[64751, 64751], "mapped", [1606, 1607]], [[64752, 64752], "mapped", [1610, 1605]], [[64753, 64753], "mapped", [1610, 1607]], [[64754, 64754], "mapped", [1600, 1614, 1617]], [[64755, 64755], "mapped", [1600, 1615, 1617]], [[64756, 64756], "mapped", [1600, 1616, 1617]], [[64757, 64757], "mapped", [1591, 1609]], [[64758, 64758], "mapped", [1591, 1610]], [[64759, 64759], "mapped", [1593, 1609]], [[64760, 64760], "mapped", [1593, 1610]], [[64761, 64761], "mapped", [1594, 1609]], [[64762, 64762], "mapped", [1594, 1610]], [[64763, 64763], "mapped", [1587, 1609]], [[64764, 64764], "mapped", [1587, 1610]], [[64765, 64765], "mapped", [1588, 1609]], [[64766, 64766], "mapped", [1588, 1610]], [[64767, 64767], "mapped", [1581, 1609]], [[64768, 64768], "mapped", [1581, 1610]], [[64769, 64769], "mapped", [1580, 1609]], [[64770, 64770], "mapped", [1580, 1610]], [[64771, 64771], "mapped", [1582, 1609]], [[64772, 64772], "mapped", [1582, 1610]], [[64773, 64773], "mapped", [1589, 1609]], [[64774, 64774], "mapped", [1589, 1610]], [[64775, 64775], "mapped", [1590, 1609]], [[64776, 64776], "mapped", [1590, 1610]], [[64777, 64777], "mapped", [1588, 1580]], [[64778, 64778], "mapped", [1588, 1581]], [[64779, 64779], "mapped", [1588, 1582]], [[64780, 64780], "mapped", [1588, 1605]], [[64781, 64781], "mapped", [1588, 1585]], [[64782, 64782], "mapped", [1587, 1585]], [[64783, 64783], "mapped", [1589, 1585]], [[64784, 64784], "mapped", [1590, 1585]], [[64785, 64785], "mapped", [1591, 1609]], [[64786, 64786], "mapped", [1591, 1610]], [[64787, 64787], "mapped", [1593, 1609]], [[64788, 64788], "mapped", [1593, 1610]], [[64789, 64789], "mapped", [1594, 1609]], [[64790, 64790], "mapped", [1594, 1610]], [[64791, 64791], "mapped", [1587, 1609]], [[64792, 64792], "mapped", [1587, 1610]], [[64793, 64793], "mapped", [1588, 1609]], [[64794, 64794], "mapped", [1588, 1610]], [[64795, 64795], "mapped", [1581, 1609]], [[64796, 64796], "mapped", [1581, 1610]], [[64797, 64797], "mapped", [1580, 1609]], [[64798, 64798], "mapped", [1580, 1610]], [[64799, 64799], "mapped", [1582, 1609]], [[64800, 64800], "mapped", [1582, 1610]], [[64801, 64801], "mapped", [1589, 1609]], [[64802, 64802], "mapped", [1589, 1610]], [[64803, 64803], "mapped", [1590, 1609]], [[64804, 64804], "mapped", [1590, 1610]], [[64805, 64805], "mapped", [1588, 1580]], [[64806, 64806], "mapped", [1588, 1581]], [[64807, 64807], "mapped", [1588, 1582]], [[64808, 64808], "mapped", [1588, 1605]], [[64809, 64809], "mapped", [1588, 1585]], [[64810, 64810], "mapped", [1587, 1585]], [[64811, 64811], "mapped", [1589, 1585]], [[64812, 64812], "mapped", [1590, 1585]], [[64813, 64813], "mapped", [1588, 1580]], [[64814, 64814], "mapped", [1588, 1581]], [[64815, 64815], "mapped", [1588, 1582]], [[64816, 64816], "mapped", [1588, 1605]], [[64817, 64817], "mapped", [1587, 1607]], [[64818, 64818], "mapped", [1588, 1607]], [[64819, 64819], "mapped", [1591, 1605]], [[64820, 64820], "mapped", [1587, 1580]], [[64821, 64821], "mapped", [1587, 1581]], [[64822, 64822], "mapped", [1587, 1582]], [[64823, 64823], "mapped", [1588, 1580]], [[64824, 64824], "mapped", [1588, 1581]], [[64825, 64825], "mapped", [1588, 1582]], [[64826, 64826], "mapped", [1591, 1605]], [[64827, 64827], "mapped", [1592, 1605]], [[64828, 64829], "mapped", [1575, 1611]], [[64830, 64831], "valid", [], "NV8"], [[64832, 64847], "disallowed"], [[64848, 64848], "mapped", [1578, 1580, 1605]], [[64849, 64850], "mapped", [1578, 1581, 1580]], [[64851, 64851], "mapped", [1578, 1581, 1605]], [[64852, 64852], "mapped", [1578, 1582, 1605]], [[64853, 64853], "mapped", [1578, 1605, 1580]], [[64854, 64854], "mapped", [1578, 1605, 1581]], [[64855, 64855], "mapped", [1578, 1605, 1582]], [[64856, 64857], "mapped", [1580, 1605, 1581]], [[64858, 64858], "mapped", [1581, 1605, 1610]], [[64859, 64859], "mapped", [1581, 1605, 1609]], [[64860, 64860], "mapped", [1587, 1581, 1580]], [[64861, 64861], "mapped", [1587, 1580, 1581]], [[64862, 64862], "mapped", [1587, 1580, 1609]], [[64863, 64864], "mapped", [1587, 1605, 1581]], [[64865, 64865], "mapped", [1587, 1605, 1580]], [[64866, 64867], "mapped", [1587, 1605, 1605]], [[64868, 64869], "mapped", [1589, 1581, 1581]], [[64870, 64870], "mapped", [1589, 1605, 1605]], [[64871, 64872], "mapped", [1588, 1581, 1605]], [[64873, 64873], "mapped", [1588, 1580, 1610]], [[64874, 64875], "mapped", [1588, 1605, 1582]], [[64876, 64877], "mapped", [1588, 1605, 1605]], [[64878, 64878], "mapped", [1590, 1581, 1609]], [[64879, 64880], "mapped", [1590, 1582, 1605]], [[64881, 64882], "mapped", [1591, 1605, 1581]], [[64883, 64883], "mapped", [1591, 1605, 1605]], [[64884, 64884], "mapped", [1591, 1605, 1610]], [[64885, 64885], "mapped", [1593, 1580, 1605]], [[64886, 64887], "mapped", [1593, 1605, 1605]], [[64888, 64888], "mapped", [1593, 1605, 1609]], [[64889, 64889], "mapped", [1594, 1605, 1605]], [[64890, 64890], "mapped", [1594, 1605, 1610]], [[64891, 64891], "mapped", [1594, 1605, 1609]], [[64892, 64893], "mapped", [1601, 1582, 1605]], [[64894, 64894], "mapped", [1602, 1605, 1581]], [[64895, 64895], "mapped", [1602, 1605, 1605]], [[64896, 64896], "mapped", [1604, 1581, 1605]], [[64897, 64897], "mapped", [1604, 1581, 1610]], [[64898, 64898], "mapped", [1604, 1581, 1609]], [[64899, 64900], "mapped", [1604, 1580, 1580]], [[64901, 64902], "mapped", [1604, 1582, 1605]], [[64903, 64904], "mapped", [1604, 1605, 1581]], [[64905, 64905], "mapped", [1605, 1581, 1580]], [[64906, 64906], "mapped", [1605, 1581, 1605]], [[64907, 64907], "mapped", [1605, 1581, 1610]], [[64908, 64908], "mapped", [1605, 1580, 1581]], [[64909, 64909], "mapped", [1605, 1580, 1605]], [[64910, 64910], "mapped", [1605, 1582, 1580]], [[64911, 64911], "mapped", [1605, 1582, 1605]], [[64912, 64913], "disallowed"], [[64914, 64914], "mapped", [1605, 1580, 1582]], [[64915, 64915], "mapped", [1607, 1605, 1580]], [[64916, 64916], "mapped", [1607, 1605, 1605]], [[64917, 64917], "mapped", [1606, 1581, 1605]], [[64918, 64918], "mapped", [1606, 1581, 1609]], [[64919, 64920], "mapped", [1606, 1580, 1605]], [[64921, 64921], "mapped", [1606, 1580, 1609]], [[64922, 64922], "mapped", [1606, 1605, 1610]], [[64923, 64923], "mapped", [1606, 1605, 1609]], [[64924, 64925], "mapped", [1610, 1605, 1605]], [[64926, 64926], "mapped", [1576, 1582, 1610]], [[64927, 64927], "mapped", [1578, 1580, 1610]], [[64928, 64928], "mapped", [1578, 1580, 1609]], [[64929, 64929], "mapped", [1578, 1582, 1610]], [[64930, 64930], "mapped", [1578, 1582, 1609]], [[64931, 64931], "mapped", [1578, 1605, 1610]], [[64932, 64932], "mapped", [1578, 1605, 1609]], [[64933, 64933], "mapped", [1580, 1605, 1610]], [[64934, 64934], "mapped", [1580, 1581, 1609]], [[64935, 64935], "mapped", [1580, 1605, 1609]], [[64936, 64936], "mapped", [1587, 1582, 1609]], [[64937, 64937], "mapped", [1589, 1581, 1610]], [[64938, 64938], "mapped", [1588, 1581, 1610]], [[64939, 64939], "mapped", [1590, 1581, 1610]], [[64940, 64940], "mapped", [1604, 1580, 1610]], [[64941, 64941], "mapped", [1604, 1605, 1610]], [[64942, 64942], "mapped", [1610, 1581, 1610]], [[64943, 64943], "mapped", [1610, 1580, 1610]], [[64944, 64944], "mapped", [1610, 1605, 1610]], [[64945, 64945], "mapped", [1605, 1605, 1610]], [[64946, 64946], "mapped", [1602, 1605, 1610]], [[64947, 64947], "mapped", [1606, 1581, 1610]], [[64948, 64948], "mapped", [1602, 1605, 1581]], [[64949, 64949], "mapped", [1604, 1581, 1605]], [[64950, 64950], "mapped", [1593, 1605, 1610]], [[64951, 64951], "mapped", [1603, 1605, 1610]], [[64952, 64952], "mapped", [1606, 1580, 1581]], [[64953, 64953], "mapped", [1605, 1582, 1610]], [[64954, 64954], "mapped", [1604, 1580, 1605]], [[64955, 64955], "mapped", [1603, 1605, 1605]], [[64956, 64956], "mapped", [1604, 1580, 1605]], [[64957, 64957], "mapped", [1606, 1580, 1581]], [[64958, 64958], "mapped", [1580, 1581, 1610]], [[64959, 64959], "mapped", [1581, 1580, 1610]], [[64960, 64960], "mapped", [1605, 1580, 1610]], [[64961, 64961], "mapped", [1601, 1605, 1610]], [[64962, 64962], "mapped", [1576, 1581, 1610]], [[64963, 64963], "mapped", [1603, 1605, 1605]], [[64964, 64964], "mapped", [1593, 1580, 1605]], [[64965, 64965], "mapped", [1589, 1605, 1605]], [[64966, 64966], "mapped", [1587, 1582, 1610]], [[64967, 64967], "mapped", [1606, 1580, 1610]], [[64968, 64975], "disallowed"], [[64976, 65007], "disallowed"], [[65008, 65008], "mapped", [1589, 1604, 1746]], [[65009, 65009], "mapped", [1602, 1604, 1746]], [[65010, 65010], "mapped", [1575, 1604, 1604, 1607]], [[65011, 65011], "mapped", [1575, 1603, 1576, 1585]], [[65012, 65012], "mapped", [1605, 1581, 1605, 1583]], [[65013, 65013], "mapped", [1589, 1604, 1593, 1605]], [[65014, 65014], "mapped", [1585, 1587, 1608, 1604]], [[65015, 65015], "mapped", [1593, 1604, 1610, 1607]], [[65016, 65016], "mapped", [1608, 1587, 1604, 1605]], [[65017, 65017], "mapped", [1589, 1604, 1609]], [[65018, 65018], "disallowed_STD3_mapped", [1589, 1604, 1609, 32, 1575, 1604, 1604, 1607, 32, 1593, 1604, 1610, 1607, 32, 1608, 1587, 1604, 1605]], [[65019, 65019], "disallowed_STD3_mapped", [1580, 1604, 32, 1580, 1604, 1575, 1604, 1607]], [[65020, 65020], "mapped", [1585, 1740, 1575, 1604]], [[65021, 65021], "valid", [], "NV8"], [[65022, 65023], "disallowed"], [[65024, 65039], "ignored"], [[65040, 65040], "disallowed_STD3_mapped", [44]], [[65041, 65041], "mapped", [12289]], [[65042, 65042], "disallowed"], [[65043, 65043], "disallowed_STD3_mapped", [58]], [[65044, 65044], "disallowed_STD3_mapped", [59]], [[65045, 65045], "disallowed_STD3_mapped", [33]], [[65046, 65046], "disallowed_STD3_mapped", [63]], [[65047, 65047], "mapped", [12310]], [[65048, 65048], "mapped", [12311]], [[65049, 65049], "disallowed"], [[65050, 65055], "disallowed"], [[65056, 65059], "valid"], [[65060, 65062], "valid"], [[65063, 65069], "valid"], [[65070, 65071], "valid"], [[65072, 65072], "disallowed"], [[65073, 65073], "mapped", [8212]], [[65074, 65074], "mapped", [8211]], [[65075, 65076], "disallowed_STD3_mapped", [95]], [[65077, 65077], "disallowed_STD3_mapped", [40]], [[65078, 65078], "disallowed_STD3_mapped", [41]], [[65079, 65079], "disallowed_STD3_mapped", [123]], [[65080, 65080], "disallowed_STD3_mapped", [125]], [[65081, 65081], "mapped", [12308]], [[65082, 65082], "mapped", [12309]], [[65083, 65083], "mapped", [12304]], [[65084, 65084], "mapped", [12305]], [[65085, 65085], "mapped", [12298]], [[65086, 65086], "mapped", [12299]], [[65087, 65087], "mapped", [12296]], [[65088, 65088], "mapped", [12297]], [[65089, 65089], "mapped", [12300]], [[65090, 65090], "mapped", [12301]], [[65091, 65091], "mapped", [12302]], [[65092, 65092], "mapped", [12303]], [[65093, 65094], "valid", [], "NV8"], [[65095, 65095], "disallowed_STD3_mapped", [91]], [[65096, 65096], "disallowed_STD3_mapped", [93]], [[65097, 65100], "disallowed_STD3_mapped", [32, 773]], [[65101, 65103], "disallowed_STD3_mapped", [95]], [[65104, 65104], "disallowed_STD3_mapped", [44]], [[65105, 65105], "mapped", [12289]], [[65106, 65106], "disallowed"], [[65107, 65107], "disallowed"], [[65108, 65108], "disallowed_STD3_mapped", [59]], [[65109, 65109], "disallowed_STD3_mapped", [58]], [[65110, 65110], "disallowed_STD3_mapped", [63]], [[65111, 65111], "disallowed_STD3_mapped", [33]], [[65112, 65112], "mapped", [8212]], [[65113, 65113], "disallowed_STD3_mapped", [40]], [[65114, 65114], "disallowed_STD3_mapped", [41]], [[65115, 65115], "disallowed_STD3_mapped", [123]], [[65116, 65116], "disallowed_STD3_mapped", [125]], [[65117, 65117], "mapped", [12308]], [[65118, 65118], "mapped", [12309]], [[65119, 65119], "disallowed_STD3_mapped", [35]], [[65120, 65120], "disallowed_STD3_mapped", [38]], [[65121, 65121], "disallowed_STD3_mapped", [42]], [[65122, 65122], "disallowed_STD3_mapped", [43]], [[65123, 65123], "mapped", [45]], [[65124, 65124], "disallowed_STD3_mapped", [60]], [[65125, 65125], "disallowed_STD3_mapped", [62]], [[65126, 65126], "disallowed_STD3_mapped", [61]], [[65127, 65127], "disallowed"], [[65128, 65128], "disallowed_STD3_mapped", [92]], [[65129, 65129], "disallowed_STD3_mapped", [36]], [[65130, 65130], "disallowed_STD3_mapped", [37]], [[65131, 65131], "disallowed_STD3_mapped", [64]], [[65132, 65135], "disallowed"], [[65136, 65136], "disallowed_STD3_mapped", [32, 1611]], [[65137, 65137], "mapped", [1600, 1611]], [[65138, 65138], "disallowed_STD3_mapped", [32, 1612]], [[65139, 65139], "valid"], [[65140, 65140], "disallowed_STD3_mapped", [32, 1613]], [[65141, 65141], "disallowed"], [[65142, 65142], "disallowed_STD3_mapped", [32, 1614]], [[65143, 65143], "mapped", [1600, 1614]], [[65144, 65144], "disallowed_STD3_mapped", [32, 1615]], [[65145, 65145], "mapped", [1600, 1615]], [[65146, 65146], "disallowed_STD3_mapped", [32, 1616]], [[65147, 65147], "mapped", [1600, 1616]], [[65148, 65148], "disallowed_STD3_mapped", [32, 1617]], [[65149, 65149], "mapped", [1600, 1617]], [[65150, 65150], "disallowed_STD3_mapped", [32, 1618]], [[65151, 65151], "mapped", [1600, 1618]], [[65152, 65152], "mapped", [1569]], [[65153, 65154], "mapped", [1570]], [[65155, 65156], "mapped", [1571]], [[65157, 65158], "mapped", [1572]], [[65159, 65160], "mapped", [1573]], [[65161, 65164], "mapped", [1574]], [[65165, 65166], "mapped", [1575]], [[65167, 65170], "mapped", [1576]], [[65171, 65172], "mapped", [1577]], [[65173, 65176], "mapped", [1578]], [[65177, 65180], "mapped", [1579]], [[65181, 65184], "mapped", [1580]], [[65185, 65188], "mapped", [1581]], [[65189, 65192], "mapped", [1582]], [[65193, 65194], "mapped", [1583]], [[65195, 65196], "mapped", [1584]], [[65197, 65198], "mapped", [1585]], [[65199, 65200], "mapped", [1586]], [[65201, 65204], "mapped", [1587]], [[65205, 65208], "mapped", [1588]], [[65209, 65212], "mapped", [1589]], [[65213, 65216], "mapped", [1590]], [[65217, 65220], "mapped", [1591]], [[65221, 65224], "mapped", [1592]], [[65225, 65228], "mapped", [1593]], [[65229, 65232], "mapped", [1594]], [[65233, 65236], "mapped", [1601]], [[65237, 65240], "mapped", [1602]], [[65241, 65244], "mapped", [1603]], [[65245, 65248], "mapped", [1604]], [[65249, 65252], "mapped", [1605]], [[65253, 65256], "mapped", [1606]], [[65257, 65260], "mapped", [1607]], [[65261, 65262], "mapped", [1608]], [[65263, 65264], "mapped", [1609]], [[65265, 65268], "mapped", [1610]], [[65269, 65270], "mapped", [1604, 1570]], [[65271, 65272], "mapped", [1604, 1571]], [[65273, 65274], "mapped", [1604, 1573]], [[65275, 65276], "mapped", [1604, 1575]], [[65277, 65278], "disallowed"], [[65279, 65279], "ignored"], [[65280, 65280], "disallowed"], [[65281, 65281], "disallowed_STD3_mapped", [33]], [[65282, 65282], "disallowed_STD3_mapped", [34]], [[65283, 65283], "disallowed_STD3_mapped", [35]], [[65284, 65284], "disallowed_STD3_mapped", [36]], [[65285, 65285], "disallowed_STD3_mapped", [37]], [[65286, 65286], "disallowed_STD3_mapped", [38]], [[65287, 65287], "disallowed_STD3_mapped", [39]], [[65288, 65288], "disallowed_STD3_mapped", [40]], [[65289, 65289], "disallowed_STD3_mapped", [41]], [[65290, 65290], "disallowed_STD3_mapped", [42]], [[65291, 65291], "disallowed_STD3_mapped", [43]], [[65292, 65292], "disallowed_STD3_mapped", [44]], [[65293, 65293], "mapped", [45]], [[65294, 65294], "mapped", [46]], [[65295, 65295], "disallowed_STD3_mapped", [47]], [[65296, 65296], "mapped", [48]], [[65297, 65297], "mapped", [49]], [[65298, 65298], "mapped", [50]], [[65299, 65299], "mapped", [51]], [[65300, 65300], "mapped", [52]], [[65301, 65301], "mapped", [53]], [[65302, 65302], "mapped", [54]], [[65303, 65303], "mapped", [55]], [[65304, 65304], "mapped", [56]], [[65305, 65305], "mapped", [57]], [[65306, 65306], "disallowed_STD3_mapped", [58]], [[65307, 65307], "disallowed_STD3_mapped", [59]], [[65308, 65308], "disallowed_STD3_mapped", [60]], [[65309, 65309], "disallowed_STD3_mapped", [61]], [[65310, 65310], "disallowed_STD3_mapped", [62]], [[65311, 65311], "disallowed_STD3_mapped", [63]], [[65312, 65312], "disallowed_STD3_mapped", [64]], [[65313, 65313], "mapped", [97]], [[65314, 65314], "mapped", [98]], [[65315, 65315], "mapped", [99]], [[65316, 65316], "mapped", [100]], [[65317, 65317], "mapped", [101]], [[65318, 65318], "mapped", [102]], [[65319, 65319], "mapped", [103]], [[65320, 65320], "mapped", [104]], [[65321, 65321], "mapped", [105]], [[65322, 65322], "mapped", [106]], [[65323, 65323], "mapped", [107]], [[65324, 65324], "mapped", [108]], [[65325, 65325], "mapped", [109]], [[65326, 65326], "mapped", [110]], [[65327, 65327], "mapped", [111]], [[65328, 65328], "mapped", [112]], [[65329, 65329], "mapped", [113]], [[65330, 65330], "mapped", [114]], [[65331, 65331], "mapped", [115]], [[65332, 65332], "mapped", [116]], [[65333, 65333], "mapped", [117]], [[65334, 65334], "mapped", [118]], [[65335, 65335], "mapped", [119]], [[65336, 65336], "mapped", [120]], [[65337, 65337], "mapped", [121]], [[65338, 65338], "mapped", [122]], [[65339, 65339], "disallowed_STD3_mapped", [91]], [[65340, 65340], "disallowed_STD3_mapped", [92]], [[65341, 65341], "disallowed_STD3_mapped", [93]], [[65342, 65342], "disallowed_STD3_mapped", [94]], [[65343, 65343], "disallowed_STD3_mapped", [95]], [[65344, 65344], "disallowed_STD3_mapped", [96]], [[65345, 65345], "mapped", [97]], [[65346, 65346], "mapped", [98]], [[65347, 65347], "mapped", [99]], [[65348, 65348], "mapped", [100]], [[65349, 65349], "mapped", [101]], [[65350, 65350], "mapped", [102]], [[65351, 65351], "mapped", [103]], [[65352, 65352], "mapped", [104]], [[65353, 65353], "mapped", [105]], [[65354, 65354], "mapped", [106]], [[65355, 65355], "mapped", [107]], [[65356, 65356], "mapped", [108]], [[65357, 65357], "mapped", [109]], [[65358, 65358], "mapped", [110]], [[65359, 65359], "mapped", [111]], [[65360, 65360], "mapped", [112]], [[65361, 65361], "mapped", [113]], [[65362, 65362], "mapped", [114]], [[65363, 65363], "mapped", [115]], [[65364, 65364], "mapped", [116]], [[65365, 65365], "mapped", [117]], [[65366, 65366], "mapped", [118]], [[65367, 65367], "mapped", [119]], [[65368, 65368], "mapped", [120]], [[65369, 65369], "mapped", [121]], [[65370, 65370], "mapped", [122]], [[65371, 65371], "disallowed_STD3_mapped", [123]], [[65372, 65372], "disallowed_STD3_mapped", [124]], [[65373, 65373], "disallowed_STD3_mapped", [125]], [[65374, 65374], "disallowed_STD3_mapped", [126]], [[65375, 65375], "mapped", [10629]], [[65376, 65376], "mapped", [10630]], [[65377, 65377], "mapped", [46]], [[65378, 65378], "mapped", [12300]], [[65379, 65379], "mapped", [12301]], [[65380, 65380], "mapped", [12289]], [[65381, 65381], "mapped", [12539]], [[65382, 65382], "mapped", [12530]], [[65383, 65383], "mapped", [12449]], [[65384, 65384], "mapped", [12451]], [[65385, 65385], "mapped", [12453]], [[65386, 65386], "mapped", [12455]], [[65387, 65387], "mapped", [12457]], [[65388, 65388], "mapped", [12515]], [[65389, 65389], "mapped", [12517]], [[65390, 65390], "mapped", [12519]], [[65391, 65391], "mapped", [12483]], [[65392, 65392], "mapped", [12540]], [[65393, 65393], "mapped", [12450]], [[65394, 65394], "mapped", [12452]], [[65395, 65395], "mapped", [12454]], [[65396, 65396], "mapped", [12456]], [[65397, 65397], "mapped", [12458]], [[65398, 65398], "mapped", [12459]], [[65399, 65399], "mapped", [12461]], [[65400, 65400], "mapped", [12463]], [[65401, 65401], "mapped", [12465]], [[65402, 65402], "mapped", [12467]], [[65403, 65403], "mapped", [12469]], [[65404, 65404], "mapped", [12471]], [[65405, 65405], "mapped", [12473]], [[65406, 65406], "mapped", [12475]], [[65407, 65407], "mapped", [12477]], [[65408, 65408], "mapped", [12479]], [[65409, 65409], "mapped", [12481]], [[65410, 65410], "mapped", [12484]], [[65411, 65411], "mapped", [12486]], [[65412, 65412], "mapped", [12488]], [[65413, 65413], "mapped", [12490]], [[65414, 65414], "mapped", [12491]], [[65415, 65415], "mapped", [12492]], [[65416, 65416], "mapped", [12493]], [[65417, 65417], "mapped", [12494]], [[65418, 65418], "mapped", [12495]], [[65419, 65419], "mapped", [12498]], [[65420, 65420], "mapped", [12501]], [[65421, 65421], "mapped", [12504]], [[65422, 65422], "mapped", [12507]], [[65423, 65423], "mapped", [12510]], [[65424, 65424], "mapped", [12511]], [[65425, 65425], "mapped", [12512]], [[65426, 65426], "mapped", [12513]], [[65427, 65427], "mapped", [12514]], [[65428, 65428], "mapped", [12516]], [[65429, 65429], "mapped", [12518]], [[65430, 65430], "mapped", [12520]], [[65431, 65431], "mapped", [12521]], [[65432, 65432], "mapped", [12522]], [[65433, 65433], "mapped", [12523]], [[65434, 65434], "mapped", [12524]], [[65435, 65435], "mapped", [12525]], [[65436, 65436], "mapped", [12527]], [[65437, 65437], "mapped", [12531]], [[65438, 65438], "mapped", [12441]], [[65439, 65439], "mapped", [12442]], [[65440, 65440], "disallowed"], [[65441, 65441], "mapped", [4352]], [[65442, 65442], "mapped", [4353]], [[65443, 65443], "mapped", [4522]], [[65444, 65444], "mapped", [4354]], [[65445, 65445], "mapped", [4524]], [[65446, 65446], "mapped", [4525]], [[65447, 65447], "mapped", [4355]], [[65448, 65448], "mapped", [4356]], [[65449, 65449], "mapped", [4357]], [[65450, 65450], "mapped", [4528]], [[65451, 65451], "mapped", [4529]], [[65452, 65452], "mapped", [4530]], [[65453, 65453], "mapped", [4531]], [[65454, 65454], "mapped", [4532]], [[65455, 65455], "mapped", [4533]], [[65456, 65456], "mapped", [4378]], [[65457, 65457], "mapped", [4358]], [[65458, 65458], "mapped", [4359]], [[65459, 65459], "mapped", [4360]], [[65460, 65460], "mapped", [4385]], [[65461, 65461], "mapped", [4361]], [[65462, 65462], "mapped", [4362]], [[65463, 65463], "mapped", [4363]], [[65464, 65464], "mapped", [4364]], [[65465, 65465], "mapped", [4365]], [[65466, 65466], "mapped", [4366]], [[65467, 65467], "mapped", [4367]], [[65468, 65468], "mapped", [4368]], [[65469, 65469], "mapped", [4369]], [[65470, 65470], "mapped", [4370]], [[65471, 65473], "disallowed"], [[65474, 65474], "mapped", [4449]], [[65475, 65475], "mapped", [4450]], [[65476, 65476], "mapped", [4451]], [[65477, 65477], "mapped", [4452]], [[65478, 65478], "mapped", [4453]], [[65479, 65479], "mapped", [4454]], [[65480, 65481], "disallowed"], [[65482, 65482], "mapped", [4455]], [[65483, 65483], "mapped", [4456]], [[65484, 65484], "mapped", [4457]], [[65485, 65485], "mapped", [4458]], [[65486, 65486], "mapped", [4459]], [[65487, 65487], "mapped", [4460]], [[65488, 65489], "disallowed"], [[65490, 65490], "mapped", [4461]], [[65491, 65491], "mapped", [4462]], [[65492, 65492], "mapped", [4463]], [[65493, 65493], "mapped", [4464]], [[65494, 65494], "mapped", [4465]], [[65495, 65495], "mapped", [4466]], [[65496, 65497], "disallowed"], [[65498, 65498], "mapped", [4467]], [[65499, 65499], "mapped", [4468]], [[65500, 65500], "mapped", [4469]], [[65501, 65503], "disallowed"], [[65504, 65504], "mapped", [162]], [[65505, 65505], "mapped", [163]], [[65506, 65506], "mapped", [172]], [[65507, 65507], "disallowed_STD3_mapped", [32, 772]], [[65508, 65508], "mapped", [166]], [[65509, 65509], "mapped", [165]], [[65510, 65510], "mapped", [8361]], [[65511, 65511], "disallowed"], [[65512, 65512], "mapped", [9474]], [[65513, 65513], "mapped", [8592]], [[65514, 65514], "mapped", [8593]], [[65515, 65515], "mapped", [8594]], [[65516, 65516], "mapped", [8595]], [[65517, 65517], "mapped", [9632]], [[65518, 65518], "mapped", [9675]], [[65519, 65528], "disallowed"], [[65529, 65531], "disallowed"], [[65532, 65532], "disallowed"], [[65533, 65533], "disallowed"], [[65534, 65535], "disallowed"], [[65536, 65547], "valid"], [[65548, 65548], "disallowed"], [[65549, 65574], "valid"], [[65575, 65575], "disallowed"], [[65576, 65594], "valid"], [[65595, 65595], "disallowed"], [[65596, 65597], "valid"], [[65598, 65598], "disallowed"], [[65599, 65613], "valid"], [[65614, 65615], "disallowed"], [[65616, 65629], "valid"], [[65630, 65663], "disallowed"], [[65664, 65786], "valid"], [[65787, 65791], "disallowed"], [[65792, 65794], "valid", [], "NV8"], [[65795, 65798], "disallowed"], [[65799, 65843], "valid", [], "NV8"], [[65844, 65846], "disallowed"], [[65847, 65855], "valid", [], "NV8"], [[65856, 65930], "valid", [], "NV8"], [[65931, 65932], "valid", [], "NV8"], [[65933, 65935], "disallowed"], [[65936, 65947], "valid", [], "NV8"], [[65948, 65951], "disallowed"], [[65952, 65952], "valid", [], "NV8"], [[65953, 65999], "disallowed"], [[66000, 66044], "valid", [], "NV8"], [[66045, 66045], "valid"], [[66046, 66175], "disallowed"], [[66176, 66204], "valid"], [[66205, 66207], "disallowed"], [[66208, 66256], "valid"], [[66257, 66271], "disallowed"], [[66272, 66272], "valid"], [[66273, 66299], "valid", [], "NV8"], [[66300, 66303], "disallowed"], [[66304, 66334], "valid"], [[66335, 66335], "valid"], [[66336, 66339], "valid", [], "NV8"], [[66340, 66351], "disallowed"], [[66352, 66368], "valid"], [[66369, 66369], "valid", [], "NV8"], [[66370, 66377], "valid"], [[66378, 66378], "valid", [], "NV8"], [[66379, 66383], "disallowed"], [[66384, 66426], "valid"], [[66427, 66431], "disallowed"], [[66432, 66461], "valid"], [[66462, 66462], "disallowed"], [[66463, 66463], "valid", [], "NV8"], [[66464, 66499], "valid"], [[66500, 66503], "disallowed"], [[66504, 66511], "valid"], [[66512, 66517], "valid", [], "NV8"], [[66518, 66559], "disallowed"], [[66560, 66560], "mapped", [66600]], [[66561, 66561], "mapped", [66601]], [[66562, 66562], "mapped", [66602]], [[66563, 66563], "mapped", [66603]], [[66564, 66564], "mapped", [66604]], [[66565, 66565], "mapped", [66605]], [[66566, 66566], "mapped", [66606]], [[66567, 66567], "mapped", [66607]], [[66568, 66568], "mapped", [66608]], [[66569, 66569], "mapped", [66609]], [[66570, 66570], "mapped", [66610]], [[66571, 66571], "mapped", [66611]], [[66572, 66572], "mapped", [66612]], [[66573, 66573], "mapped", [66613]], [[66574, 66574], "mapped", [66614]], [[66575, 66575], "mapped", [66615]], [[66576, 66576], "mapped", [66616]], [[66577, 66577], "mapped", [66617]], [[66578, 66578], "mapped", [66618]], [[66579, 66579], "mapped", [66619]], [[66580, 66580], "mapped", [66620]], [[66581, 66581], "mapped", [66621]], [[66582, 66582], "mapped", [66622]], [[66583, 66583], "mapped", [66623]], [[66584, 66584], "mapped", [66624]], [[66585, 66585], "mapped", [66625]], [[66586, 66586], "mapped", [66626]], [[66587, 66587], "mapped", [66627]], [[66588, 66588], "mapped", [66628]], [[66589, 66589], "mapped", [66629]], [[66590, 66590], "mapped", [66630]], [[66591, 66591], "mapped", [66631]], [[66592, 66592], "mapped", [66632]], [[66593, 66593], "mapped", [66633]], [[66594, 66594], "mapped", [66634]], [[66595, 66595], "mapped", [66635]], [[66596, 66596], "mapped", [66636]], [[66597, 66597], "mapped", [66637]], [[66598, 66598], "mapped", [66638]], [[66599, 66599], "mapped", [66639]], [[66600, 66637], "valid"], [[66638, 66717], "valid"], [[66718, 66719], "disallowed"], [[66720, 66729], "valid"], [[66730, 66815], "disallowed"], [[66816, 66855], "valid"], [[66856, 66863], "disallowed"], [[66864, 66915], "valid"], [[66916, 66926], "disallowed"], [[66927, 66927], "valid", [], "NV8"], [[66928, 67071], "disallowed"], [[67072, 67382], "valid"], [[67383, 67391], "disallowed"], [[67392, 67413], "valid"], [[67414, 67423], "disallowed"], [[67424, 67431], "valid"], [[67432, 67583], "disallowed"], [[67584, 67589], "valid"], [[67590, 67591], "disallowed"], [[67592, 67592], "valid"], [[67593, 67593], "disallowed"], [[67594, 67637], "valid"], [[67638, 67638], "disallowed"], [[67639, 67640], "valid"], [[67641, 67643], "disallowed"], [[67644, 67644], "valid"], [[67645, 67646], "disallowed"], [[67647, 67647], "valid"], [[67648, 67669], "valid"], [[67670, 67670], "disallowed"], [[67671, 67679], "valid", [], "NV8"], [[67680, 67702], "valid"], [[67703, 67711], "valid", [], "NV8"], [[67712, 67742], "valid"], [[67743, 67750], "disallowed"], [[67751, 67759], "valid", [], "NV8"], [[67760, 67807], "disallowed"], [[67808, 67826], "valid"], [[67827, 67827], "disallowed"], [[67828, 67829], "valid"], [[67830, 67834], "disallowed"], [[67835, 67839], "valid", [], "NV8"], [[67840, 67861], "valid"], [[67862, 67865], "valid", [], "NV8"], [[67866, 67867], "valid", [], "NV8"], [[67868, 67870], "disallowed"], [[67871, 67871], "valid", [], "NV8"], [[67872, 67897], "valid"], [[67898, 67902], "disallowed"], [[67903, 67903], "valid", [], "NV8"], [[67904, 67967], "disallowed"], [[67968, 68023], "valid"], [[68024, 68027], "disallowed"], [[68028, 68029], "valid", [], "NV8"], [[68030, 68031], "valid"], [[68032, 68047], "valid", [], "NV8"], [[68048, 68049], "disallowed"], [[68050, 68095], "valid", [], "NV8"], [[68096, 68099], "valid"], [[68100, 68100], "disallowed"], [[68101, 68102], "valid"], [[68103, 68107], "disallowed"], [[68108, 68115], "valid"], [[68116, 68116], "disallowed"], [[68117, 68119], "valid"], [[68120, 68120], "disallowed"], [[68121, 68147], "valid"], [[68148, 68151], "disallowed"], [[68152, 68154], "valid"], [[68155, 68158], "disallowed"], [[68159, 68159], "valid"], [[68160, 68167], "valid", [], "NV8"], [[68168, 68175], "disallowed"], [[68176, 68184], "valid", [], "NV8"], [[68185, 68191], "disallowed"], [[68192, 68220], "valid"], [[68221, 68223], "valid", [], "NV8"], [[68224, 68252], "valid"], [[68253, 68255], "valid", [], "NV8"], [[68256, 68287], "disallowed"], [[68288, 68295], "valid"], [[68296, 68296], "valid", [], "NV8"], [[68297, 68326], "valid"], [[68327, 68330], "disallowed"], [[68331, 68342], "valid", [], "NV8"], [[68343, 68351], "disallowed"], [[68352, 68405], "valid"], [[68406, 68408], "disallowed"], [[68409, 68415], "valid", [], "NV8"], [[68416, 68437], "valid"], [[68438, 68439], "disallowed"], [[68440, 68447], "valid", [], "NV8"], [[68448, 68466], "valid"], [[68467, 68471], "disallowed"], [[68472, 68479], "valid", [], "NV8"], [[68480, 68497], "valid"], [[68498, 68504], "disallowed"], [[68505, 68508], "valid", [], "NV8"], [[68509, 68520], "disallowed"], [[68521, 68527], "valid", [], "NV8"], [[68528, 68607], "disallowed"], [[68608, 68680], "valid"], [[68681, 68735], "disallowed"], [[68736, 68736], "mapped", [68800]], [[68737, 68737], "mapped", [68801]], [[68738, 68738], "mapped", [68802]], [[68739, 68739], "mapped", [68803]], [[68740, 68740], "mapped", [68804]], [[68741, 68741], "mapped", [68805]], [[68742, 68742], "mapped", [68806]], [[68743, 68743], "mapped", [68807]], [[68744, 68744], "mapped", [68808]], [[68745, 68745], "mapped", [68809]], [[68746, 68746], "mapped", [68810]], [[68747, 68747], "mapped", [68811]], [[68748, 68748], "mapped", [68812]], [[68749, 68749], "mapped", [68813]], [[68750, 68750], "mapped", [68814]], [[68751, 68751], "mapped", [68815]], [[68752, 68752], "mapped", [68816]], [[68753, 68753], "mapped", [68817]], [[68754, 68754], "mapped", [68818]], [[68755, 68755], "mapped", [68819]], [[68756, 68756], "mapped", [68820]], [[68757, 68757], "mapped", [68821]], [[68758, 68758], "mapped", [68822]], [[68759, 68759], "mapped", [68823]], [[68760, 68760], "mapped", [68824]], [[68761, 68761], "mapped", [68825]], [[68762, 68762], "mapped", [68826]], [[68763, 68763], "mapped", [68827]], [[68764, 68764], "mapped", [68828]], [[68765, 68765], "mapped", [68829]], [[68766, 68766], "mapped", [68830]], [[68767, 68767], "mapped", [68831]], [[68768, 68768], "mapped", [68832]], [[68769, 68769], "mapped", [68833]], [[68770, 68770], "mapped", [68834]], [[68771, 68771], "mapped", [68835]], [[68772, 68772], "mapped", [68836]], [[68773, 68773], "mapped", [68837]], [[68774, 68774], "mapped", [68838]], [[68775, 68775], "mapped", [68839]], [[68776, 68776], "mapped", [68840]], [[68777, 68777], "mapped", [68841]], [[68778, 68778], "mapped", [68842]], [[68779, 68779], "mapped", [68843]], [[68780, 68780], "mapped", [68844]], [[68781, 68781], "mapped", [68845]], [[68782, 68782], "mapped", [68846]], [[68783, 68783], "mapped", [68847]], [[68784, 68784], "mapped", [68848]], [[68785, 68785], "mapped", [68849]], [[68786, 68786], "mapped", [68850]], [[68787, 68799], "disallowed"], [[68800, 68850], "valid"], [[68851, 68857], "disallowed"], [[68858, 68863], "valid", [], "NV8"], [[68864, 69215], "disallowed"], [[69216, 69246], "valid", [], "NV8"], [[69247, 69631], "disallowed"], [[69632, 69702], "valid"], [[69703, 69709], "valid", [], "NV8"], [[69710, 69713], "disallowed"], [[69714, 69733], "valid", [], "NV8"], [[69734, 69743], "valid"], [[69744, 69758], "disallowed"], [[69759, 69759], "valid"], [[69760, 69818], "valid"], [[69819, 69820], "valid", [], "NV8"], [[69821, 69821], "disallowed"], [[69822, 69825], "valid", [], "NV8"], [[69826, 69839], "disallowed"], [[69840, 69864], "valid"], [[69865, 69871], "disallowed"], [[69872, 69881], "valid"], [[69882, 69887], "disallowed"], [[69888, 69940], "valid"], [[69941, 69941], "disallowed"], [[69942, 69951], "valid"], [[69952, 69955], "valid", [], "NV8"], [[69956, 69967], "disallowed"], [[69968, 70003], "valid"], [[70004, 70005], "valid", [], "NV8"], [[70006, 70006], "valid"], [[70007, 70015], "disallowed"], [[70016, 70084], "valid"], [[70085, 70088], "valid", [], "NV8"], [[70089, 70089], "valid", [], "NV8"], [[70090, 70092], "valid"], [[70093, 70093], "valid", [], "NV8"], [[70094, 70095], "disallowed"], [[70096, 70105], "valid"], [[70106, 70106], "valid"], [[70107, 70107], "valid", [], "NV8"], [[70108, 70108], "valid"], [[70109, 70111], "valid", [], "NV8"], [[70112, 70112], "disallowed"], [[70113, 70132], "valid", [], "NV8"], [[70133, 70143], "disallowed"], [[70144, 70161], "valid"], [[70162, 70162], "disallowed"], [[70163, 70199], "valid"], [[70200, 70205], "valid", [], "NV8"], [[70206, 70271], "disallowed"], [[70272, 70278], "valid"], [[70279, 70279], "disallowed"], [[70280, 70280], "valid"], [[70281, 70281], "disallowed"], [[70282, 70285], "valid"], [[70286, 70286], "disallowed"], [[70287, 70301], "valid"], [[70302, 70302], "disallowed"], [[70303, 70312], "valid"], [[70313, 70313], "valid", [], "NV8"], [[70314, 70319], "disallowed"], [[70320, 70378], "valid"], [[70379, 70383], "disallowed"], [[70384, 70393], "valid"], [[70394, 70399], "disallowed"], [[70400, 70400], "valid"], [[70401, 70403], "valid"], [[70404, 70404], "disallowed"], [[70405, 70412], "valid"], [[70413, 70414], "disallowed"], [[70415, 70416], "valid"], [[70417, 70418], "disallowed"], [[70419, 70440], "valid"], [[70441, 70441], "disallowed"], [[70442, 70448], "valid"], [[70449, 70449], "disallowed"], [[70450, 70451], "valid"], [[70452, 70452], "disallowed"], [[70453, 70457], "valid"], [[70458, 70459], "disallowed"], [[70460, 70468], "valid"], [[70469, 70470], "disallowed"], [[70471, 70472], "valid"], [[70473, 70474], "disallowed"], [[70475, 70477], "valid"], [[70478, 70479], "disallowed"], [[70480, 70480], "valid"], [[70481, 70486], "disallowed"], [[70487, 70487], "valid"], [[70488, 70492], "disallowed"], [[70493, 70499], "valid"], [[70500, 70501], "disallowed"], [[70502, 70508], "valid"], [[70509, 70511], "disallowed"], [[70512, 70516], "valid"], [[70517, 70783], "disallowed"], [[70784, 70853], "valid"], [[70854, 70854], "valid", [], "NV8"], [[70855, 70855], "valid"], [[70856, 70863], "disallowed"], [[70864, 70873], "valid"], [[70874, 71039], "disallowed"], [[71040, 71093], "valid"], [[71094, 71095], "disallowed"], [[71096, 71104], "valid"], [[71105, 71113], "valid", [], "NV8"], [[71114, 71127], "valid", [], "NV8"], [[71128, 71133], "valid"], [[71134, 71167], "disallowed"], [[71168, 71232], "valid"], [[71233, 71235], "valid", [], "NV8"], [[71236, 71236], "valid"], [[71237, 71247], "disallowed"], [[71248, 71257], "valid"], [[71258, 71295], "disallowed"], [[71296, 71351], "valid"], [[71352, 71359], "disallowed"], [[71360, 71369], "valid"], [[71370, 71423], "disallowed"], [[71424, 71449], "valid"], [[71450, 71452], "disallowed"], [[71453, 71467], "valid"], [[71468, 71471], "disallowed"], [[71472, 71481], "valid"], [[71482, 71487], "valid", [], "NV8"], [[71488, 71839], "disallowed"], [[71840, 71840], "mapped", [71872]], [[71841, 71841], "mapped", [71873]], [[71842, 71842], "mapped", [71874]], [[71843, 71843], "mapped", [71875]], [[71844, 71844], "mapped", [71876]], [[71845, 71845], "mapped", [71877]], [[71846, 71846], "mapped", [71878]], [[71847, 71847], "mapped", [71879]], [[71848, 71848], "mapped", [71880]], [[71849, 71849], "mapped", [71881]], [[71850, 71850], "mapped", [71882]], [[71851, 71851], "mapped", [71883]], [[71852, 71852], "mapped", [71884]], [[71853, 71853], "mapped", [71885]], [[71854, 71854], "mapped", [71886]], [[71855, 71855], "mapped", [71887]], [[71856, 71856], "mapped", [71888]], [[71857, 71857], "mapped", [71889]], [[71858, 71858], "mapped", [71890]], [[71859, 71859], "mapped", [71891]], [[71860, 71860], "mapped", [71892]], [[71861, 71861], "mapped", [71893]], [[71862, 71862], "mapped", [71894]], [[71863, 71863], "mapped", [71895]], [[71864, 71864], "mapped", [71896]], [[71865, 71865], "mapped", [71897]], [[71866, 71866], "mapped", [71898]], [[71867, 71867], "mapped", [71899]], [[71868, 71868], "mapped", [71900]], [[71869, 71869], "mapped", [71901]], [[71870, 71870], "mapped", [71902]], [[71871, 71871], "mapped", [71903]], [[71872, 71913], "valid"], [[71914, 71922], "valid", [], "NV8"], [[71923, 71934], "disallowed"], [[71935, 71935], "valid"], [[71936, 72383], "disallowed"], [[72384, 72440], "valid"], [[72441, 73727], "disallowed"], [[73728, 74606], "valid"], [[74607, 74648], "valid"], [[74649, 74649], "valid"], [[74650, 74751], "disallowed"], [[74752, 74850], "valid", [], "NV8"], [[74851, 74862], "valid", [], "NV8"], [[74863, 74863], "disallowed"], [[74864, 74867], "valid", [], "NV8"], [[74868, 74868], "valid", [], "NV8"], [[74869, 74879], "disallowed"], [[74880, 75075], "valid"], [[75076, 77823], "disallowed"], [[77824, 78894], "valid"], [[78895, 82943], "disallowed"], [[82944, 83526], "valid"], [[83527, 92159], "disallowed"], [[92160, 92728], "valid"], [[92729, 92735], "disallowed"], [[92736, 92766], "valid"], [[92767, 92767], "disallowed"], [[92768, 92777], "valid"], [[92778, 92781], "disallowed"], [[92782, 92783], "valid", [], "NV8"], [[92784, 92879], "disallowed"], [[92880, 92909], "valid"], [[92910, 92911], "disallowed"], [[92912, 92916], "valid"], [[92917, 92917], "valid", [], "NV8"], [[92918, 92927], "disallowed"], [[92928, 92982], "valid"], [[92983, 92991], "valid", [], "NV8"], [[92992, 92995], "valid"], [[92996, 92997], "valid", [], "NV8"], [[92998, 93007], "disallowed"], [[93008, 93017], "valid"], [[93018, 93018], "disallowed"], [[93019, 93025], "valid", [], "NV8"], [[93026, 93026], "disallowed"], [[93027, 93047], "valid"], [[93048, 93052], "disallowed"], [[93053, 93071], "valid"], [[93072, 93951], "disallowed"], [[93952, 94020], "valid"], [[94021, 94031], "disallowed"], [[94032, 94078], "valid"], [[94079, 94094], "disallowed"], [[94095, 94111], "valid"], [[94112, 110591], "disallowed"], [[110592, 110593], "valid"], [[110594, 113663], "disallowed"], [[113664, 113770], "valid"], [[113771, 113775], "disallowed"], [[113776, 113788], "valid"], [[113789, 113791], "disallowed"], [[113792, 113800], "valid"], [[113801, 113807], "disallowed"], [[113808, 113817], "valid"], [[113818, 113819], "disallowed"], [[113820, 113820], "valid", [], "NV8"], [[113821, 113822], "valid"], [[113823, 113823], "valid", [], "NV8"], [[113824, 113827], "ignored"], [[113828, 118783], "disallowed"], [[118784, 119029], "valid", [], "NV8"], [[119030, 119039], "disallowed"], [[119040, 119078], "valid", [], "NV8"], [[119079, 119080], "disallowed"], [[119081, 119081], "valid", [], "NV8"], [[119082, 119133], "valid", [], "NV8"], [[119134, 119134], "mapped", [119127, 119141]], [[119135, 119135], "mapped", [119128, 119141]], [[119136, 119136], "mapped", [119128, 119141, 119150]], [[119137, 119137], "mapped", [119128, 119141, 119151]], [[119138, 119138], "mapped", [119128, 119141, 119152]], [[119139, 119139], "mapped", [119128, 119141, 119153]], [[119140, 119140], "mapped", [119128, 119141, 119154]], [[119141, 119154], "valid", [], "NV8"], [[119155, 119162], "disallowed"], [[119163, 119226], "valid", [], "NV8"], [[119227, 119227], "mapped", [119225, 119141]], [[119228, 119228], "mapped", [119226, 119141]], [[119229, 119229], "mapped", [119225, 119141, 119150]], [[119230, 119230], "mapped", [119226, 119141, 119150]], [[119231, 119231], "mapped", [119225, 119141, 119151]], [[119232, 119232], "mapped", [119226, 119141, 119151]], [[119233, 119261], "valid", [], "NV8"], [[119262, 119272], "valid", [], "NV8"], [[119273, 119295], "disallowed"], [[119296, 119365], "valid", [], "NV8"], [[119366, 119551], "disallowed"], [[119552, 119638], "valid", [], "NV8"], [[119639, 119647], "disallowed"], [[119648, 119665], "valid", [], "NV8"], [[119666, 119807], "disallowed"], [[119808, 119808], "mapped", [97]], [[119809, 119809], "mapped", [98]], [[119810, 119810], "mapped", [99]], [[119811, 119811], "mapped", [100]], [[119812, 119812], "mapped", [101]], [[119813, 119813], "mapped", [102]], [[119814, 119814], "mapped", [103]], [[119815, 119815], "mapped", [104]], [[119816, 119816], "mapped", [105]], [[119817, 119817], "mapped", [106]], [[119818, 119818], "mapped", [107]], [[119819, 119819], "mapped", [108]], [[119820, 119820], "mapped", [109]], [[119821, 119821], "mapped", [110]], [[119822, 119822], "mapped", [111]], [[119823, 119823], "mapped", [112]], [[119824, 119824], "mapped", [113]], [[119825, 119825], "mapped", [114]], [[119826, 119826], "mapped", [115]], [[119827, 119827], "mapped", [116]], [[119828, 119828], "mapped", [117]], [[119829, 119829], "mapped", [118]], [[119830, 119830], "mapped", [119]], [[119831, 119831], "mapped", [120]], [[119832, 119832], "mapped", [121]], [[119833, 119833], "mapped", [122]], [[119834, 119834], "mapped", [97]], [[119835, 119835], "mapped", [98]], [[119836, 119836], "mapped", [99]], [[119837, 119837], "mapped", [100]], [[119838, 119838], "mapped", [101]], [[119839, 119839], "mapped", [102]], [[119840, 119840], "mapped", [103]], [[119841, 119841], "mapped", [104]], [[119842, 119842], "mapped", [105]], [[119843, 119843], "mapped", [106]], [[119844, 119844], "mapped", [107]], [[119845, 119845], "mapped", [108]], [[119846, 119846], "mapped", [109]], [[119847, 119847], "mapped", [110]], [[119848, 119848], "mapped", [111]], [[119849, 119849], "mapped", [112]], [[119850, 119850], "mapped", [113]], [[119851, 119851], "mapped", [114]], [[119852, 119852], "mapped", [115]], [[119853, 119853], "mapped", [116]], [[119854, 119854], "mapped", [117]], [[119855, 119855], "mapped", [118]], [[119856, 119856], "mapped", [119]], [[119857, 119857], "mapped", [120]], [[119858, 119858], "mapped", [121]], [[119859, 119859], "mapped", [122]], [[119860, 119860], "mapped", [97]], [[119861, 119861], "mapped", [98]], [[119862, 119862], "mapped", [99]], [[119863, 119863], "mapped", [100]], [[119864, 119864], "mapped", [101]], [[119865, 119865], "mapped", [102]], [[119866, 119866], "mapped", [103]], [[119867, 119867], "mapped", [104]], [[119868, 119868], "mapped", [105]], [[119869, 119869], "mapped", [106]], [[119870, 119870], "mapped", [107]], [[119871, 119871], "mapped", [108]], [[119872, 119872], "mapped", [109]], [[119873, 119873], "mapped", [110]], [[119874, 119874], "mapped", [111]], [[119875, 119875], "mapped", [112]], [[119876, 119876], "mapped", [113]], [[119877, 119877], "mapped", [114]], [[119878, 119878], "mapped", [115]], [[119879, 119879], "mapped", [116]], [[119880, 119880], "mapped", [117]], [[119881, 119881], "mapped", [118]], [[119882, 119882], "mapped", [119]], [[119883, 119883], "mapped", [120]], [[119884, 119884], "mapped", [121]], [[119885, 119885], "mapped", [122]], [[119886, 119886], "mapped", [97]], [[119887, 119887], "mapped", [98]], [[119888, 119888], "mapped", [99]], [[119889, 119889], "mapped", [100]], [[119890, 119890], "mapped", [101]], [[119891, 119891], "mapped", [102]], [[119892, 119892], "mapped", [103]], [[119893, 119893], "disallowed"], [[119894, 119894], "mapped", [105]], [[119895, 119895], "mapped", [106]], [[119896, 119896], "mapped", [107]], [[119897, 119897], "mapped", [108]], [[119898, 119898], "mapped", [109]], [[119899, 119899], "mapped", [110]], [[119900, 119900], "mapped", [111]], [[119901, 119901], "mapped", [112]], [[119902, 119902], "mapped", [113]], [[119903, 119903], "mapped", [114]], [[119904, 119904], "mapped", [115]], [[119905, 119905], "mapped", [116]], [[119906, 119906], "mapped", [117]], [[119907, 119907], "mapped", [118]], [[119908, 119908], "mapped", [119]], [[119909, 119909], "mapped", [120]], [[119910, 119910], "mapped", [121]], [[119911, 119911], "mapped", [122]], [[119912, 119912], "mapped", [97]], [[119913, 119913], "mapped", [98]], [[119914, 119914], "mapped", [99]], [[119915, 119915], "mapped", [100]], [[119916, 119916], "mapped", [101]], [[119917, 119917], "mapped", [102]], [[119918, 119918], "mapped", [103]], [[119919, 119919], "mapped", [104]], [[119920, 119920], "mapped", [105]], [[119921, 119921], "mapped", [106]], [[119922, 119922], "mapped", [107]], [[119923, 119923], "mapped", [108]], [[119924, 119924], "mapped", [109]], [[119925, 119925], "mapped", [110]], [[119926, 119926], "mapped", [111]], [[119927, 119927], "mapped", [112]], [[119928, 119928], "mapped", [113]], [[119929, 119929], "mapped", [114]], [[119930, 119930], "mapped", [115]], [[119931, 119931], "mapped", [116]], [[119932, 119932], "mapped", [117]], [[119933, 119933], "mapped", [118]], [[119934, 119934], "mapped", [119]], [[119935, 119935], "mapped", [120]], [[119936, 119936], "mapped", [121]], [[119937, 119937], "mapped", [122]], [[119938, 119938], "mapped", [97]], [[119939, 119939], "mapped", [98]], [[119940, 119940], "mapped", [99]], [[119941, 119941], "mapped", [100]], [[119942, 119942], "mapped", [101]], [[119943, 119943], "mapped", [102]], [[119944, 119944], "mapped", [103]], [[119945, 119945], "mapped", [104]], [[119946, 119946], "mapped", [105]], [[119947, 119947], "mapped", [106]], [[119948, 119948], "mapped", [107]], [[119949, 119949], "mapped", [108]], [[119950, 119950], "mapped", [109]], [[119951, 119951], "mapped", [110]], [[119952, 119952], "mapped", [111]], [[119953, 119953], "mapped", [112]], [[119954, 119954], "mapped", [113]], [[119955, 119955], "mapped", [114]], [[119956, 119956], "mapped", [115]], [[119957, 119957], "mapped", [116]], [[119958, 119958], "mapped", [117]], [[119959, 119959], "mapped", [118]], [[119960, 119960], "mapped", [119]], [[119961, 119961], "mapped", [120]], [[119962, 119962], "mapped", [121]], [[119963, 119963], "mapped", [122]], [[119964, 119964], "mapped", [97]], [[119965, 119965], "disallowed"], [[119966, 119966], "mapped", [99]], [[119967, 119967], "mapped", [100]], [[119968, 119969], "disallowed"], [[119970, 119970], "mapped", [103]], [[119971, 119972], "disallowed"], [[119973, 119973], "mapped", [106]], [[119974, 119974], "mapped", [107]], [[119975, 119976], "disallowed"], [[119977, 119977], "mapped", [110]], [[119978, 119978], "mapped", [111]], [[119979, 119979], "mapped", [112]], [[119980, 119980], "mapped", [113]], [[119981, 119981], "disallowed"], [[119982, 119982], "mapped", [115]], [[119983, 119983], "mapped", [116]], [[119984, 119984], "mapped", [117]], [[119985, 119985], "mapped", [118]], [[119986, 119986], "mapped", [119]], [[119987, 119987], "mapped", [120]], [[119988, 119988], "mapped", [121]], [[119989, 119989], "mapped", [122]], [[119990, 119990], "mapped", [97]], [[119991, 119991], "mapped", [98]], [[119992, 119992], "mapped", [99]], [[119993, 119993], "mapped", [100]], [[119994, 119994], "disallowed"], [[119995, 119995], "mapped", [102]], [[119996, 119996], "disallowed"], [[119997, 119997], "mapped", [104]], [[119998, 119998], "mapped", [105]], [[119999, 119999], "mapped", [106]], [[120000, 120000], "mapped", [107]], [[120001, 120001], "mapped", [108]], [[120002, 120002], "mapped", [109]], [[120003, 120003], "mapped", [110]], [[120004, 120004], "disallowed"], [[120005, 120005], "mapped", [112]], [[120006, 120006], "mapped", [113]], [[120007, 120007], "mapped", [114]], [[120008, 120008], "mapped", [115]], [[120009, 120009], "mapped", [116]], [[120010, 120010], "mapped", [117]], [[120011, 120011], "mapped", [118]], [[120012, 120012], "mapped", [119]], [[120013, 120013], "mapped", [120]], [[120014, 120014], "mapped", [121]], [[120015, 120015], "mapped", [122]], [[120016, 120016], "mapped", [97]], [[120017, 120017], "mapped", [98]], [[120018, 120018], "mapped", [99]], [[120019, 120019], "mapped", [100]], [[120020, 120020], "mapped", [101]], [[120021, 120021], "mapped", [102]], [[120022, 120022], "mapped", [103]], [[120023, 120023], "mapped", [104]], [[120024, 120024], "mapped", [105]], [[120025, 120025], "mapped", [106]], [[120026, 120026], "mapped", [107]], [[120027, 120027], "mapped", [108]], [[120028, 120028], "mapped", [109]], [[120029, 120029], "mapped", [110]], [[120030, 120030], "mapped", [111]], [[120031, 120031], "mapped", [112]], [[120032, 120032], "mapped", [113]], [[120033, 120033], "mapped", [114]], [[120034, 120034], "mapped", [115]], [[120035, 120035], "mapped", [116]], [[120036, 120036], "mapped", [117]], [[120037, 120037], "mapped", [118]], [[120038, 120038], "mapped", [119]], [[120039, 120039], "mapped", [120]], [[120040, 120040], "mapped", [121]], [[120041, 120041], "mapped", [122]], [[120042, 120042], "mapped", [97]], [[120043, 120043], "mapped", [98]], [[120044, 120044], "mapped", [99]], [[120045, 120045], "mapped", [100]], [[120046, 120046], "mapped", [101]], [[120047, 120047], "mapped", [102]], [[120048, 120048], "mapped", [103]], [[120049, 120049], "mapped", [104]], [[120050, 120050], "mapped", [105]], [[120051, 120051], "mapped", [106]], [[120052, 120052], "mapped", [107]], [[120053, 120053], "mapped", [108]], [[120054, 120054], "mapped", [109]], [[120055, 120055], "mapped", [110]], [[120056, 120056], "mapped", [111]], [[120057, 120057], "mapped", [112]], [[120058, 120058], "mapped", [113]], [[120059, 120059], "mapped", [114]], [[120060, 120060], "mapped", [115]], [[120061, 120061], "mapped", [116]], [[120062, 120062], "mapped", [117]], [[120063, 120063], "mapped", [118]], [[120064, 120064], "mapped", [119]], [[120065, 120065], "mapped", [120]], [[120066, 120066], "mapped", [121]], [[120067, 120067], "mapped", [122]], [[120068, 120068], "mapped", [97]], [[120069, 120069], "mapped", [98]], [[120070, 120070], "disallowed"], [[120071, 120071], "mapped", [100]], [[120072, 120072], "mapped", [101]], [[120073, 120073], "mapped", [102]], [[120074, 120074], "mapped", [103]], [[120075, 120076], "disallowed"], [[120077, 120077], "mapped", [106]], [[120078, 120078], "mapped", [107]], [[120079, 120079], "mapped", [108]], [[120080, 120080], "mapped", [109]], [[120081, 120081], "mapped", [110]], [[120082, 120082], "mapped", [111]], [[120083, 120083], "mapped", [112]], [[120084, 120084], "mapped", [113]], [[120085, 120085], "disallowed"], [[120086, 120086], "mapped", [115]], [[120087, 120087], "mapped", [116]], [[120088, 120088], "mapped", [117]], [[120089, 120089], "mapped", [118]], [[120090, 120090], "mapped", [119]], [[120091, 120091], "mapped", [120]], [[120092, 120092], "mapped", [121]], [[120093, 120093], "disallowed"], [[120094, 120094], "mapped", [97]], [[120095, 120095], "mapped", [98]], [[120096, 120096], "mapped", [99]], [[120097, 120097], "mapped", [100]], [[120098, 120098], "mapped", [101]], [[120099, 120099], "mapped", [102]], [[120100, 120100], "mapped", [103]], [[120101, 120101], "mapped", [104]], [[120102, 120102], "mapped", [105]], [[120103, 120103], "mapped", [106]], [[120104, 120104], "mapped", [107]], [[120105, 120105], "mapped", [108]], [[120106, 120106], "mapped", [109]], [[120107, 120107], "mapped", [110]], [[120108, 120108], "mapped", [111]], [[120109, 120109], "mapped", [112]], [[120110, 120110], "mapped", [113]], [[120111, 120111], "mapped", [114]], [[120112, 120112], "mapped", [115]], [[120113, 120113], "mapped", [116]], [[120114, 120114], "mapped", [117]], [[120115, 120115], "mapped", [118]], [[120116, 120116], "mapped", [119]], [[120117, 120117], "mapped", [120]], [[120118, 120118], "mapped", [121]], [[120119, 120119], "mapped", [122]], [[120120, 120120], "mapped", [97]], [[120121, 120121], "mapped", [98]], [[120122, 120122], "disallowed"], [[120123, 120123], "mapped", [100]], [[120124, 120124], "mapped", [101]], [[120125, 120125], "mapped", [102]], [[120126, 120126], "mapped", [103]], [[120127, 120127], "disallowed"], [[120128, 120128], "mapped", [105]], [[120129, 120129], "mapped", [106]], [[120130, 120130], "mapped", [107]], [[120131, 120131], "mapped", [108]], [[120132, 120132], "mapped", [109]], [[120133, 120133], "disallowed"], [[120134, 120134], "mapped", [111]], [[120135, 120137], "disallowed"], [[120138, 120138], "mapped", [115]], [[120139, 120139], "mapped", [116]], [[120140, 120140], "mapped", [117]], [[120141, 120141], "mapped", [118]], [[120142, 120142], "mapped", [119]], [[120143, 120143], "mapped", [120]], [[120144, 120144], "mapped", [121]], [[120145, 120145], "disallowed"], [[120146, 120146], "mapped", [97]], [[120147, 120147], "mapped", [98]], [[120148, 120148], "mapped", [99]], [[120149, 120149], "mapped", [100]], [[120150, 120150], "mapped", [101]], [[120151, 120151], "mapped", [102]], [[120152, 120152], "mapped", [103]], [[120153, 120153], "mapped", [104]], [[120154, 120154], "mapped", [105]], [[120155, 120155], "mapped", [106]], [[120156, 120156], "mapped", [107]], [[120157, 120157], "mapped", [108]], [[120158, 120158], "mapped", [109]], [[120159, 120159], "mapped", [110]], [[120160, 120160], "mapped", [111]], [[120161, 120161], "mapped", [112]], [[120162, 120162], "mapped", [113]], [[120163, 120163], "mapped", [114]], [[120164, 120164], "mapped", [115]], [[120165, 120165], "mapped", [116]], [[120166, 120166], "mapped", [117]], [[120167, 120167], "mapped", [118]], [[120168, 120168], "mapped", [119]], [[120169, 120169], "mapped", [120]], [[120170, 120170], "mapped", [121]], [[120171, 120171], "mapped", [122]], [[120172, 120172], "mapped", [97]], [[120173, 120173], "mapped", [98]], [[120174, 120174], "mapped", [99]], [[120175, 120175], "mapped", [100]], [[120176, 120176], "mapped", [101]], [[120177, 120177], "mapped", [102]], [[120178, 120178], "mapped", [103]], [[120179, 120179], "mapped", [104]], [[120180, 120180], "mapped", [105]], [[120181, 120181], "mapped", [106]], [[120182, 120182], "mapped", [107]], [[120183, 120183], "mapped", [108]], [[120184, 120184], "mapped", [109]], [[120185, 120185], "mapped", [110]], [[120186, 120186], "mapped", [111]], [[120187, 120187], "mapped", [112]], [[120188, 120188], "mapped", [113]], [[120189, 120189], "mapped", [114]], [[120190, 120190], "mapped", [115]], [[120191, 120191], "mapped", [116]], [[120192, 120192], "mapped", [117]], [[120193, 120193], "mapped", [118]], [[120194, 120194], "mapped", [119]], [[120195, 120195], "mapped", [120]], [[120196, 120196], "mapped", [121]], [[120197, 120197], "mapped", [122]], [[120198, 120198], "mapped", [97]], [[120199, 120199], "mapped", [98]], [[120200, 120200], "mapped", [99]], [[120201, 120201], "mapped", [100]], [[120202, 120202], "mapped", [101]], [[120203, 120203], "mapped", [102]], [[120204, 120204], "mapped", [103]], [[120205, 120205], "mapped", [104]], [[120206, 120206], "mapped", [105]], [[120207, 120207], "mapped", [106]], [[120208, 120208], "mapped", [107]], [[120209, 120209], "mapped", [108]], [[120210, 120210], "mapped", [109]], [[120211, 120211], "mapped", [110]], [[120212, 120212], "mapped", [111]], [[120213, 120213], "mapped", [112]], [[120214, 120214], "mapped", [113]], [[120215, 120215], "mapped", [114]], [[120216, 120216], "mapped", [115]], [[120217, 120217], "mapped", [116]], [[120218, 120218], "mapped", [117]], [[120219, 120219], "mapped", [118]], [[120220, 120220], "mapped", [119]], [[120221, 120221], "mapped", [120]], [[120222, 120222], "mapped", [121]], [[120223, 120223], "mapped", [122]], [[120224, 120224], "mapped", [97]], [[120225, 120225], "mapped", [98]], [[120226, 120226], "mapped", [99]], [[120227, 120227], "mapped", [100]], [[120228, 120228], "mapped", [101]], [[120229, 120229], "mapped", [102]], [[120230, 120230], "mapped", [103]], [[120231, 120231], "mapped", [104]], [[120232, 120232], "mapped", [105]], [[120233, 120233], "mapped", [106]], [[120234, 120234], "mapped", [107]], [[120235, 120235], "mapped", [108]], [[120236, 120236], "mapped", [109]], [[120237, 120237], "mapped", [110]], [[120238, 120238], "mapped", [111]], [[120239, 120239], "mapped", [112]], [[120240, 120240], "mapped", [113]], [[120241, 120241], "mapped", [114]], [[120242, 120242], "mapped", [115]], [[120243, 120243], "mapped", [116]], [[120244, 120244], "mapped", [117]], [[120245, 120245], "mapped", [118]], [[120246, 120246], "mapped", [119]], [[120247, 120247], "mapped", [120]], [[120248, 120248], "mapped", [121]], [[120249, 120249], "mapped", [122]], [[120250, 120250], "mapped", [97]], [[120251, 120251], "mapped", [98]], [[120252, 120252], "mapped", [99]], [[120253, 120253], "mapped", [100]], [[120254, 120254], "mapped", [101]], [[120255, 120255], "mapped", [102]], [[120256, 120256], "mapped", [103]], [[120257, 120257], "mapped", [104]], [[120258, 120258], "mapped", [105]], [[120259, 120259], "mapped", [106]], [[120260, 120260], "mapped", [107]], [[120261, 120261], "mapped", [108]], [[120262, 120262], "mapped", [109]], [[120263, 120263], "mapped", [110]], [[120264, 120264], "mapped", [111]], [[120265, 120265], "mapped", [112]], [[120266, 120266], "mapped", [113]], [[120267, 120267], "mapped", [114]], [[120268, 120268], "mapped", [115]], [[120269, 120269], "mapped", [116]], [[120270, 120270], "mapped", [117]], [[120271, 120271], "mapped", [118]], [[120272, 120272], "mapped", [119]], [[120273, 120273], "mapped", [120]], [[120274, 120274], "mapped", [121]], [[120275, 120275], "mapped", [122]], [[120276, 120276], "mapped", [97]], [[120277, 120277], "mapped", [98]], [[120278, 120278], "mapped", [99]], [[120279, 120279], "mapped", [100]], [[120280, 120280], "mapped", [101]], [[120281, 120281], "mapped", [102]], [[120282, 120282], "mapped", [103]], [[120283, 120283], "mapped", [104]], [[120284, 120284], "mapped", [105]], [[120285, 120285], "mapped", [106]], [[120286, 120286], "mapped", [107]], [[120287, 120287], "mapped", [108]], [[120288, 120288], "mapped", [109]], [[120289, 120289], "mapped", [110]], [[120290, 120290], "mapped", [111]], [[120291, 120291], "mapped", [112]], [[120292, 120292], "mapped", [113]], [[120293, 120293], "mapped", [114]], [[120294, 120294], "mapped", [115]], [[120295, 120295], "mapped", [116]], [[120296, 120296], "mapped", [117]], [[120297, 120297], "mapped", [118]], [[120298, 120298], "mapped", [119]], [[120299, 120299], "mapped", [120]], [[120300, 120300], "mapped", [121]], [[120301, 120301], "mapped", [122]], [[120302, 120302], "mapped", [97]], [[120303, 120303], "mapped", [98]], [[120304, 120304], "mapped", [99]], [[120305, 120305], "mapped", [100]], [[120306, 120306], "mapped", [101]], [[120307, 120307], "mapped", [102]], [[120308, 120308], "mapped", [103]], [[120309, 120309], "mapped", [104]], [[120310, 120310], "mapped", [105]], [[120311, 120311], "mapped", [106]], [[120312, 120312], "mapped", [107]], [[120313, 120313], "mapped", [108]], [[120314, 120314], "mapped", [109]], [[120315, 120315], "mapped", [110]], [[120316, 120316], "mapped", [111]], [[120317, 120317], "mapped", [112]], [[120318, 120318], "mapped", [113]], [[120319, 120319], "mapped", [114]], [[120320, 120320], "mapped", [115]], [[120321, 120321], "mapped", [116]], [[120322, 120322], "mapped", [117]], [[120323, 120323], "mapped", [118]], [[120324, 120324], "mapped", [119]], [[120325, 120325], "mapped", [120]], [[120326, 120326], "mapped", [121]], [[120327, 120327], "mapped", [122]], [[120328, 120328], "mapped", [97]], [[120329, 120329], "mapped", [98]], [[120330, 120330], "mapped", [99]], [[120331, 120331], "mapped", [100]], [[120332, 120332], "mapped", [101]], [[120333, 120333], "mapped", [102]], [[120334, 120334], "mapped", [103]], [[120335, 120335], "mapped", [104]], [[120336, 120336], "mapped", [105]], [[120337, 120337], "mapped", [106]], [[120338, 120338], "mapped", [107]], [[120339, 120339], "mapped", [108]], [[120340, 120340], "mapped", [109]], [[120341, 120341], "mapped", [110]], [[120342, 120342], "mapped", [111]], [[120343, 120343], "mapped", [112]], [[120344, 120344], "mapped", [113]], [[120345, 120345], "mapped", [114]], [[120346, 120346], "mapped", [115]], [[120347, 120347], "mapped", [116]], [[120348, 120348], "mapped", [117]], [[120349, 120349], "mapped", [118]], [[120350, 120350], "mapped", [119]], [[120351, 120351], "mapped", [120]], [[120352, 120352], "mapped", [121]], [[120353, 120353], "mapped", [122]], [[120354, 120354], "mapped", [97]], [[120355, 120355], "mapped", [98]], [[120356, 120356], "mapped", [99]], [[120357, 120357], "mapped", [100]], [[120358, 120358], "mapped", [101]], [[120359, 120359], "mapped", [102]], [[120360, 120360], "mapped", [103]], [[120361, 120361], "mapped", [104]], [[120362, 120362], "mapped", [105]], [[120363, 120363], "mapped", [106]], [[120364, 120364], "mapped", [107]], [[120365, 120365], "mapped", [108]], [[120366, 120366], "mapped", [109]], [[120367, 120367], "mapped", [110]], [[120368, 120368], "mapped", [111]], [[120369, 120369], "mapped", [112]], [[120370, 120370], "mapped", [113]], [[120371, 120371], "mapped", [114]], [[120372, 120372], "mapped", [115]], [[120373, 120373], "mapped", [116]], [[120374, 120374], "mapped", [117]], [[120375, 120375], "mapped", [118]], [[120376, 120376], "mapped", [119]], [[120377, 120377], "mapped", [120]], [[120378, 120378], "mapped", [121]], [[120379, 120379], "mapped", [122]], [[120380, 120380], "mapped", [97]], [[120381, 120381], "mapped", [98]], [[120382, 120382], "mapped", [99]], [[120383, 120383], "mapped", [100]], [[120384, 120384], "mapped", [101]], [[120385, 120385], "mapped", [102]], [[120386, 120386], "mapped", [103]], [[120387, 120387], "mapped", [104]], [[120388, 120388], "mapped", [105]], [[120389, 120389], "mapped", [106]], [[120390, 120390], "mapped", [107]], [[120391, 120391], "mapped", [108]], [[120392, 120392], "mapped", [109]], [[120393, 120393], "mapped", [110]], [[120394, 120394], "mapped", [111]], [[120395, 120395], "mapped", [112]], [[120396, 120396], "mapped", [113]], [[120397, 120397], "mapped", [114]], [[120398, 120398], "mapped", [115]], [[120399, 120399], "mapped", [116]], [[120400, 120400], "mapped", [117]], [[120401, 120401], "mapped", [118]], [[120402, 120402], "mapped", [119]], [[120403, 120403], "mapped", [120]], [[120404, 120404], "mapped", [121]], [[120405, 120405], "mapped", [122]], [[120406, 120406], "mapped", [97]], [[120407, 120407], "mapped", [98]], [[120408, 120408], "mapped", [99]], [[120409, 120409], "mapped", [100]], [[120410, 120410], "mapped", [101]], [[120411, 120411], "mapped", [102]], [[120412, 120412], "mapped", [103]], [[120413, 120413], "mapped", [104]], [[120414, 120414], "mapped", [105]], [[120415, 120415], "mapped", [106]], [[120416, 120416], "mapped", [107]], [[120417, 120417], "mapped", [108]], [[120418, 120418], "mapped", [109]], [[120419, 120419], "mapped", [110]], [[120420, 120420], "mapped", [111]], [[120421, 120421], "mapped", [112]], [[120422, 120422], "mapped", [113]], [[120423, 120423], "mapped", [114]], [[120424, 120424], "mapped", [115]], [[120425, 120425], "mapped", [116]], [[120426, 120426], "mapped", [117]], [[120427, 120427], "mapped", [118]], [[120428, 120428], "mapped", [119]], [[120429, 120429], "mapped", [120]], [[120430, 120430], "mapped", [121]], [[120431, 120431], "mapped", [122]], [[120432, 120432], "mapped", [97]], [[120433, 120433], "mapped", [98]], [[120434, 120434], "mapped", [99]], [[120435, 120435], "mapped", [100]], [[120436, 120436], "mapped", [101]], [[120437, 120437], "mapped", [102]], [[120438, 120438], "mapped", [103]], [[120439, 120439], "mapped", [104]], [[120440, 120440], "mapped", [105]], [[120441, 120441], "mapped", [106]], [[120442, 120442], "mapped", [107]], [[120443, 120443], "mapped", [108]], [[120444, 120444], "mapped", [109]], [[120445, 120445], "mapped", [110]], [[120446, 120446], "mapped", [111]], [[120447, 120447], "mapped", [112]], [[120448, 120448], "mapped", [113]], [[120449, 120449], "mapped", [114]], [[120450, 120450], "mapped", [115]], [[120451, 120451], "mapped", [116]], [[120452, 120452], "mapped", [117]], [[120453, 120453], "mapped", [118]], [[120454, 120454], "mapped", [119]], [[120455, 120455], "mapped", [120]], [[120456, 120456], "mapped", [121]], [[120457, 120457], "mapped", [122]], [[120458, 120458], "mapped", [97]], [[120459, 120459], "mapped", [98]], [[120460, 120460], "mapped", [99]], [[120461, 120461], "mapped", [100]], [[120462, 120462], "mapped", [101]], [[120463, 120463], "mapped", [102]], [[120464, 120464], "mapped", [103]], [[120465, 120465], "mapped", [104]], [[120466, 120466], "mapped", [105]], [[120467, 120467], "mapped", [106]], [[120468, 120468], "mapped", [107]], [[120469, 120469], "mapped", [108]], [[120470, 120470], "mapped", [109]], [[120471, 120471], "mapped", [110]], [[120472, 120472], "mapped", [111]], [[120473, 120473], "mapped", [112]], [[120474, 120474], "mapped", [113]], [[120475, 120475], "mapped", [114]], [[120476, 120476], "mapped", [115]], [[120477, 120477], "mapped", [116]], [[120478, 120478], "mapped", [117]], [[120479, 120479], "mapped", [118]], [[120480, 120480], "mapped", [119]], [[120481, 120481], "mapped", [120]], [[120482, 120482], "mapped", [121]], [[120483, 120483], "mapped", [122]], [[120484, 120484], "mapped", [305]], [[120485, 120485], "mapped", [567]], [[120486, 120487], "disallowed"], [[120488, 120488], "mapped", [945]], [[120489, 120489], "mapped", [946]], [[120490, 120490], "mapped", [947]], [[120491, 120491], "mapped", [948]], [[120492, 120492], "mapped", [949]], [[120493, 120493], "mapped", [950]], [[120494, 120494], "mapped", [951]], [[120495, 120495], "mapped", [952]], [[120496, 120496], "mapped", [953]], [[120497, 120497], "mapped", [954]], [[120498, 120498], "mapped", [955]], [[120499, 120499], "mapped", [956]], [[120500, 120500], "mapped", [957]], [[120501, 120501], "mapped", [958]], [[120502, 120502], "mapped", [959]], [[120503, 120503], "mapped", [960]], [[120504, 120504], "mapped", [961]], [[120505, 120505], "mapped", [952]], [[120506, 120506], "mapped", [963]], [[120507, 120507], "mapped", [964]], [[120508, 120508], "mapped", [965]], [[120509, 120509], "mapped", [966]], [[120510, 120510], "mapped", [967]], [[120511, 120511], "mapped", [968]], [[120512, 120512], "mapped", [969]], [[120513, 120513], "mapped", [8711]], [[120514, 120514], "mapped", [945]], [[120515, 120515], "mapped", [946]], [[120516, 120516], "mapped", [947]], [[120517, 120517], "mapped", [948]], [[120518, 120518], "mapped", [949]], [[120519, 120519], "mapped", [950]], [[120520, 120520], "mapped", [951]], [[120521, 120521], "mapped", [952]], [[120522, 120522], "mapped", [953]], [[120523, 120523], "mapped", [954]], [[120524, 120524], "mapped", [955]], [[120525, 120525], "mapped", [956]], [[120526, 120526], "mapped", [957]], [[120527, 120527], "mapped", [958]], [[120528, 120528], "mapped", [959]], [[120529, 120529], "mapped", [960]], [[120530, 120530], "mapped", [961]], [[120531, 120532], "mapped", [963]], [[120533, 120533], "mapped", [964]], [[120534, 120534], "mapped", [965]], [[120535, 120535], "mapped", [966]], [[120536, 120536], "mapped", [967]], [[120537, 120537], "mapped", [968]], [[120538, 120538], "mapped", [969]], [[120539, 120539], "mapped", [8706]], [[120540, 120540], "mapped", [949]], [[120541, 120541], "mapped", [952]], [[120542, 120542], "mapped", [954]], [[120543, 120543], "mapped", [966]], [[120544, 120544], "mapped", [961]], [[120545, 120545], "mapped", [960]], [[120546, 120546], "mapped", [945]], [[120547, 120547], "mapped", [946]], [[120548, 120548], "mapped", [947]], [[120549, 120549], "mapped", [948]], [[120550, 120550], "mapped", [949]], [[120551, 120551], "mapped", [950]], [[120552, 120552], "mapped", [951]], [[120553, 120553], "mapped", [952]], [[120554, 120554], "mapped", [953]], [[120555, 120555], "mapped", [954]], [[120556, 120556], "mapped", [955]], [[120557, 120557], "mapped", [956]], [[120558, 120558], "mapped", [957]], [[120559, 120559], "mapped", [958]], [[120560, 120560], "mapped", [959]], [[120561, 120561], "mapped", [960]], [[120562, 120562], "mapped", [961]], [[120563, 120563], "mapped", [952]], [[120564, 120564], "mapped", [963]], [[120565, 120565], "mapped", [964]], [[120566, 120566], "mapped", [965]], [[120567, 120567], "mapped", [966]], [[120568, 120568], "mapped", [967]], [[120569, 120569], "mapped", [968]], [[120570, 120570], "mapped", [969]], [[120571, 120571], "mapped", [8711]], [[120572, 120572], "mapped", [945]], [[120573, 120573], "mapped", [946]], [[120574, 120574], "mapped", [947]], [[120575, 120575], "mapped", [948]], [[120576, 120576], "mapped", [949]], [[120577, 120577], "mapped", [950]], [[120578, 120578], "mapped", [951]], [[120579, 120579], "mapped", [952]], [[120580, 120580], "mapped", [953]], [[120581, 120581], "mapped", [954]], [[120582, 120582], "mapped", [955]], [[120583, 120583], "mapped", [956]], [[120584, 120584], "mapped", [957]], [[120585, 120585], "mapped", [958]], [[120586, 120586], "mapped", [959]], [[120587, 120587], "mapped", [960]], [[120588, 120588], "mapped", [961]], [[120589, 120590], "mapped", [963]], [[120591, 120591], "mapped", [964]], [[120592, 120592], "mapped", [965]], [[120593, 120593], "mapped", [966]], [[120594, 120594], "mapped", [967]], [[120595, 120595], "mapped", [968]], [[120596, 120596], "mapped", [969]], [[120597, 120597], "mapped", [8706]], [[120598, 120598], "mapped", [949]], [[120599, 120599], "mapped", [952]], [[120600, 120600], "mapped", [954]], [[120601, 120601], "mapped", [966]], [[120602, 120602], "mapped", [961]], [[120603, 120603], "mapped", [960]], [[120604, 120604], "mapped", [945]], [[120605, 120605], "mapped", [946]], [[120606, 120606], "mapped", [947]], [[120607, 120607], "mapped", [948]], [[120608, 120608], "mapped", [949]], [[120609, 120609], "mapped", [950]], [[120610, 120610], "mapped", [951]], [[120611, 120611], "mapped", [952]], [[120612, 120612], "mapped", [953]], [[120613, 120613], "mapped", [954]], [[120614, 120614], "mapped", [955]], [[120615, 120615], "mapped", [956]], [[120616, 120616], "mapped", [957]], [[120617, 120617], "mapped", [958]], [[120618, 120618], "mapped", [959]], [[120619, 120619], "mapped", [960]], [[120620, 120620], "mapped", [961]], [[120621, 120621], "mapped", [952]], [[120622, 120622], "mapped", [963]], [[120623, 120623], "mapped", [964]], [[120624, 120624], "mapped", [965]], [[120625, 120625], "mapped", [966]], [[120626, 120626], "mapped", [967]], [[120627, 120627], "mapped", [968]], [[120628, 120628], "mapped", [969]], [[120629, 120629], "mapped", [8711]], [[120630, 120630], "mapped", [945]], [[120631, 120631], "mapped", [946]], [[120632, 120632], "mapped", [947]], [[120633, 120633], "mapped", [948]], [[120634, 120634], "mapped", [949]], [[120635, 120635], "mapped", [950]], [[120636, 120636], "mapped", [951]], [[120637, 120637], "mapped", [952]], [[120638, 120638], "mapped", [953]], [[120639, 120639], "mapped", [954]], [[120640, 120640], "mapped", [955]], [[120641, 120641], "mapped", [956]], [[120642, 120642], "mapped", [957]], [[120643, 120643], "mapped", [958]], [[120644, 120644], "mapped", [959]], [[120645, 120645], "mapped", [960]], [[120646, 120646], "mapped", [961]], [[120647, 120648], "mapped", [963]], [[120649, 120649], "mapped", [964]], [[120650, 120650], "mapped", [965]], [[120651, 120651], "mapped", [966]], [[120652, 120652], "mapped", [967]], [[120653, 120653], "mapped", [968]], [[120654, 120654], "mapped", [969]], [[120655, 120655], "mapped", [8706]], [[120656, 120656], "mapped", [949]], [[120657, 120657], "mapped", [952]], [[120658, 120658], "mapped", [954]], [[120659, 120659], "mapped", [966]], [[120660, 120660], "mapped", [961]], [[120661, 120661], "mapped", [960]], [[120662, 120662], "mapped", [945]], [[120663, 120663], "mapped", [946]], [[120664, 120664], "mapped", [947]], [[120665, 120665], "mapped", [948]], [[120666, 120666], "mapped", [949]], [[120667, 120667], "mapped", [950]], [[120668, 120668], "mapped", [951]], [[120669, 120669], "mapped", [952]], [[120670, 120670], "mapped", [953]], [[120671, 120671], "mapped", [954]], [[120672, 120672], "mapped", [955]], [[120673, 120673], "mapped", [956]], [[120674, 120674], "mapped", [957]], [[120675, 120675], "mapped", [958]], [[120676, 120676], "mapped", [959]], [[120677, 120677], "mapped", [960]], [[120678, 120678], "mapped", [961]], [[120679, 120679], "mapped", [952]], [[120680, 120680], "mapped", [963]], [[120681, 120681], "mapped", [964]], [[120682, 120682], "mapped", [965]], [[120683, 120683], "mapped", [966]], [[120684, 120684], "mapped", [967]], [[120685, 120685], "mapped", [968]], [[120686, 120686], "mapped", [969]], [[120687, 120687], "mapped", [8711]], [[120688, 120688], "mapped", [945]], [[120689, 120689], "mapped", [946]], [[120690, 120690], "mapped", [947]], [[120691, 120691], "mapped", [948]], [[120692, 120692], "mapped", [949]], [[120693, 120693], "mapped", [950]], [[120694, 120694], "mapped", [951]], [[120695, 120695], "mapped", [952]], [[120696, 120696], "mapped", [953]], [[120697, 120697], "mapped", [954]], [[120698, 120698], "mapped", [955]], [[120699, 120699], "mapped", [956]], [[120700, 120700], "mapped", [957]], [[120701, 120701], "mapped", [958]], [[120702, 120702], "mapped", [959]], [[120703, 120703], "mapped", [960]], [[120704, 120704], "mapped", [961]], [[120705, 120706], "mapped", [963]], [[120707, 120707], "mapped", [964]], [[120708, 120708], "mapped", [965]], [[120709, 120709], "mapped", [966]], [[120710, 120710], "mapped", [967]], [[120711, 120711], "mapped", [968]], [[120712, 120712], "mapped", [969]], [[120713, 120713], "mapped", [8706]], [[120714, 120714], "mapped", [949]], [[120715, 120715], "mapped", [952]], [[120716, 120716], "mapped", [954]], [[120717, 120717], "mapped", [966]], [[120718, 120718], "mapped", [961]], [[120719, 120719], "mapped", [960]], [[120720, 120720], "mapped", [945]], [[120721, 120721], "mapped", [946]], [[120722, 120722], "mapped", [947]], [[120723, 120723], "mapped", [948]], [[120724, 120724], "mapped", [949]], [[120725, 120725], "mapped", [950]], [[120726, 120726], "mapped", [951]], [[120727, 120727], "mapped", [952]], [[120728, 120728], "mapped", [953]], [[120729, 120729], "mapped", [954]], [[120730, 120730], "mapped", [955]], [[120731, 120731], "mapped", [956]], [[120732, 120732], "mapped", [957]], [[120733, 120733], "mapped", [958]], [[120734, 120734], "mapped", [959]], [[120735, 120735], "mapped", [960]], [[120736, 120736], "mapped", [961]], [[120737, 120737], "mapped", [952]], [[120738, 120738], "mapped", [963]], [[120739, 120739], "mapped", [964]], [[120740, 120740], "mapped", [965]], [[120741, 120741], "mapped", [966]], [[120742, 120742], "mapped", [967]], [[120743, 120743], "mapped", [968]], [[120744, 120744], "mapped", [969]], [[120745, 120745], "mapped", [8711]], [[120746, 120746], "mapped", [945]], [[120747, 120747], "mapped", [946]], [[120748, 120748], "mapped", [947]], [[120749, 120749], "mapped", [948]], [[120750, 120750], "mapped", [949]], [[120751, 120751], "mapped", [950]], [[120752, 120752], "mapped", [951]], [[120753, 120753], "mapped", [952]], [[120754, 120754], "mapped", [953]], [[120755, 120755], "mapped", [954]], [[120756, 120756], "mapped", [955]], [[120757, 120757], "mapped", [956]], [[120758, 120758], "mapped", [957]], [[120759, 120759], "mapped", [958]], [[120760, 120760], "mapped", [959]], [[120761, 120761], "mapped", [960]], [[120762, 120762], "mapped", [961]], [[120763, 120764], "mapped", [963]], [[120765, 120765], "mapped", [964]], [[120766, 120766], "mapped", [965]], [[120767, 120767], "mapped", [966]], [[120768, 120768], "mapped", [967]], [[120769, 120769], "mapped", [968]], [[120770, 120770], "mapped", [969]], [[120771, 120771], "mapped", [8706]], [[120772, 120772], "mapped", [949]], [[120773, 120773], "mapped", [952]], [[120774, 120774], "mapped", [954]], [[120775, 120775], "mapped", [966]], [[120776, 120776], "mapped", [961]], [[120777, 120777], "mapped", [960]], [[120778, 120779], "mapped", [989]], [[120780, 120781], "disallowed"], [[120782, 120782], "mapped", [48]], [[120783, 120783], "mapped", [49]], [[120784, 120784], "mapped", [50]], [[120785, 120785], "mapped", [51]], [[120786, 120786], "mapped", [52]], [[120787, 120787], "mapped", [53]], [[120788, 120788], "mapped", [54]], [[120789, 120789], "mapped", [55]], [[120790, 120790], "mapped", [56]], [[120791, 120791], "mapped", [57]], [[120792, 120792], "mapped", [48]], [[120793, 120793], "mapped", [49]], [[120794, 120794], "mapped", [50]], [[120795, 120795], "mapped", [51]], [[120796, 120796], "mapped", [52]], [[120797, 120797], "mapped", [53]], [[120798, 120798], "mapped", [54]], [[120799, 120799], "mapped", [55]], [[120800, 120800], "mapped", [56]], [[120801, 120801], "mapped", [57]], [[120802, 120802], "mapped", [48]], [[120803, 120803], "mapped", [49]], [[120804, 120804], "mapped", [50]], [[120805, 120805], "mapped", [51]], [[120806, 120806], "mapped", [52]], [[120807, 120807], "mapped", [53]], [[120808, 120808], "mapped", [54]], [[120809, 120809], "mapped", [55]], [[120810, 120810], "mapped", [56]], [[120811, 120811], "mapped", [57]], [[120812, 120812], "mapped", [48]], [[120813, 120813], "mapped", [49]], [[120814, 120814], "mapped", [50]], [[120815, 120815], "mapped", [51]], [[120816, 120816], "mapped", [52]], [[120817, 120817], "mapped", [53]], [[120818, 120818], "mapped", [54]], [[120819, 120819], "mapped", [55]], [[120820, 120820], "mapped", [56]], [[120821, 120821], "mapped", [57]], [[120822, 120822], "mapped", [48]], [[120823, 120823], "mapped", [49]], [[120824, 120824], "mapped", [50]], [[120825, 120825], "mapped", [51]], [[120826, 120826], "mapped", [52]], [[120827, 120827], "mapped", [53]], [[120828, 120828], "mapped", [54]], [[120829, 120829], "mapped", [55]], [[120830, 120830], "mapped", [56]], [[120831, 120831], "mapped", [57]], [[120832, 121343], "valid", [], "NV8"], [[121344, 121398], "valid"], [[121399, 121402], "valid", [], "NV8"], [[121403, 121452], "valid"], [[121453, 121460], "valid", [], "NV8"], [[121461, 121461], "valid"], [[121462, 121475], "valid", [], "NV8"], [[121476, 121476], "valid"], [[121477, 121483], "valid", [], "NV8"], [[121484, 121498], "disallowed"], [[121499, 121503], "valid"], [[121504, 121504], "disallowed"], [[121505, 121519], "valid"], [[121520, 124927], "disallowed"], [[124928, 125124], "valid"], [[125125, 125126], "disallowed"], [[125127, 125135], "valid", [], "NV8"], [[125136, 125142], "valid"], [[125143, 126463], "disallowed"], [[126464, 126464], "mapped", [1575]], [[126465, 126465], "mapped", [1576]], [[126466, 126466], "mapped", [1580]], [[126467, 126467], "mapped", [1583]], [[126468, 126468], "disallowed"], [[126469, 126469], "mapped", [1608]], [[126470, 126470], "mapped", [1586]], [[126471, 126471], "mapped", [1581]], [[126472, 126472], "mapped", [1591]], [[126473, 126473], "mapped", [1610]], [[126474, 126474], "mapped", [1603]], [[126475, 126475], "mapped", [1604]], [[126476, 126476], "mapped", [1605]], [[126477, 126477], "mapped", [1606]], [[126478, 126478], "mapped", [1587]], [[126479, 126479], "mapped", [1593]], [[126480, 126480], "mapped", [1601]], [[126481, 126481], "mapped", [1589]], [[126482, 126482], "mapped", [1602]], [[126483, 126483], "mapped", [1585]], [[126484, 126484], "mapped", [1588]], [[126485, 126485], "mapped", [1578]], [[126486, 126486], "mapped", [1579]], [[126487, 126487], "mapped", [1582]], [[126488, 126488], "mapped", [1584]], [[126489, 126489], "mapped", [1590]], [[126490, 126490], "mapped", [1592]], [[126491, 126491], "mapped", [1594]], [[126492, 126492], "mapped", [1646]], [[126493, 126493], "mapped", [1722]], [[126494, 126494], "mapped", [1697]], [[126495, 126495], "mapped", [1647]], [[126496, 126496], "disallowed"], [[126497, 126497], "mapped", [1576]], [[126498, 126498], "mapped", [1580]], [[126499, 126499], "disallowed"], [[126500, 126500], "mapped", [1607]], [[126501, 126502], "disallowed"], [[126503, 126503], "mapped", [1581]], [[126504, 126504], "disallowed"], [[126505, 126505], "mapped", [1610]], [[126506, 126506], "mapped", [1603]], [[126507, 126507], "mapped", [1604]], [[126508, 126508], "mapped", [1605]], [[126509, 126509], "mapped", [1606]], [[126510, 126510], "mapped", [1587]], [[126511, 126511], "mapped", [1593]], [[126512, 126512], "mapped", [1601]], [[126513, 126513], "mapped", [1589]], [[126514, 126514], "mapped", [1602]], [[126515, 126515], "disallowed"], [[126516, 126516], "mapped", [1588]], [[126517, 126517], "mapped", [1578]], [[126518, 126518], "mapped", [1579]], [[126519, 126519], "mapped", [1582]], [[126520, 126520], "disallowed"], [[126521, 126521], "mapped", [1590]], [[126522, 126522], "disallowed"], [[126523, 126523], "mapped", [1594]], [[126524, 126529], "disallowed"], [[126530, 126530], "mapped", [1580]], [[126531, 126534], "disallowed"], [[126535, 126535], "mapped", [1581]], [[126536, 126536], "disallowed"], [[126537, 126537], "mapped", [1610]], [[126538, 126538], "disallowed"], [[126539, 126539], "mapped", [1604]], [[126540, 126540], "disallowed"], [[126541, 126541], "mapped", [1606]], [[126542, 126542], "mapped", [1587]], [[126543, 126543], "mapped", [1593]], [[126544, 126544], "disallowed"], [[126545, 126545], "mapped", [1589]], [[126546, 126546], "mapped", [1602]], [[126547, 126547], "disallowed"], [[126548, 126548], "mapped", [1588]], [[126549, 126550], "disallowed"], [[126551, 126551], "mapped", [1582]], [[126552, 126552], "disallowed"], [[126553, 126553], "mapped", [1590]], [[126554, 126554], "disallowed"], [[126555, 126555], "mapped", [1594]], [[126556, 126556], "disallowed"], [[126557, 126557], "mapped", [1722]], [[126558, 126558], "disallowed"], [[126559, 126559], "mapped", [1647]], [[126560, 126560], "disallowed"], [[126561, 126561], "mapped", [1576]], [[126562, 126562], "mapped", [1580]], [[126563, 126563], "disallowed"], [[126564, 126564], "mapped", [1607]], [[126565, 126566], "disallowed"], [[126567, 126567], "mapped", [1581]], [[126568, 126568], "mapped", [1591]], [[126569, 126569], "mapped", [1610]], [[126570, 126570], "mapped", [1603]], [[126571, 126571], "disallowed"], [[126572, 126572], "mapped", [1605]], [[126573, 126573], "mapped", [1606]], [[126574, 126574], "mapped", [1587]], [[126575, 126575], "mapped", [1593]], [[126576, 126576], "mapped", [1601]], [[126577, 126577], "mapped", [1589]], [[126578, 126578], "mapped", [1602]], [[126579, 126579], "disallowed"], [[126580, 126580], "mapped", [1588]], [[126581, 126581], "mapped", [1578]], [[126582, 126582], "mapped", [1579]], [[126583, 126583], "mapped", [1582]], [[126584, 126584], "disallowed"], [[126585, 126585], "mapped", [1590]], [[126586, 126586], "mapped", [1592]], [[126587, 126587], "mapped", [1594]], [[126588, 126588], "mapped", [1646]], [[126589, 126589], "disallowed"], [[126590, 126590], "mapped", [1697]], [[126591, 126591], "disallowed"], [[126592, 126592], "mapped", [1575]], [[126593, 126593], "mapped", [1576]], [[126594, 126594], "mapped", [1580]], [[126595, 126595], "mapped", [1583]], [[126596, 126596], "mapped", [1607]], [[126597, 126597], "mapped", [1608]], [[126598, 126598], "mapped", [1586]], [[126599, 126599], "mapped", [1581]], [[126600, 126600], "mapped", [1591]], [[126601, 126601], "mapped", [1610]], [[126602, 126602], "disallowed"], [[126603, 126603], "mapped", [1604]], [[126604, 126604], "mapped", [1605]], [[126605, 126605], "mapped", [1606]], [[126606, 126606], "mapped", [1587]], [[126607, 126607], "mapped", [1593]], [[126608, 126608], "mapped", [1601]], [[126609, 126609], "mapped", [1589]], [[126610, 126610], "mapped", [1602]], [[126611, 126611], "mapped", [1585]], [[126612, 126612], "mapped", [1588]], [[126613, 126613], "mapped", [1578]], [[126614, 126614], "mapped", [1579]], [[126615, 126615], "mapped", [1582]], [[126616, 126616], "mapped", [1584]], [[126617, 126617], "mapped", [1590]], [[126618, 126618], "mapped", [1592]], [[126619, 126619], "mapped", [1594]], [[126620, 126624], "disallowed"], [[126625, 126625], "mapped", [1576]], [[126626, 126626], "mapped", [1580]], [[126627, 126627], "mapped", [1583]], [[126628, 126628], "disallowed"], [[126629, 126629], "mapped", [1608]], [[126630, 126630], "mapped", [1586]], [[126631, 126631], "mapped", [1581]], [[126632, 126632], "mapped", [1591]], [[126633, 126633], "mapped", [1610]], [[126634, 126634], "disallowed"], [[126635, 126635], "mapped", [1604]], [[126636, 126636], "mapped", [1605]], [[126637, 126637], "mapped", [1606]], [[126638, 126638], "mapped", [1587]], [[126639, 126639], "mapped", [1593]], [[126640, 126640], "mapped", [1601]], [[126641, 126641], "mapped", [1589]], [[126642, 126642], "mapped", [1602]], [[126643, 126643], "mapped", [1585]], [[126644, 126644], "mapped", [1588]], [[126645, 126645], "mapped", [1578]], [[126646, 126646], "mapped", [1579]], [[126647, 126647], "mapped", [1582]], [[126648, 126648], "mapped", [1584]], [[126649, 126649], "mapped", [1590]], [[126650, 126650], "mapped", [1592]], [[126651, 126651], "mapped", [1594]], [[126652, 126703], "disallowed"], [[126704, 126705], "valid", [], "NV8"], [[126706, 126975], "disallowed"], [[126976, 127019], "valid", [], "NV8"], [[127020, 127023], "disallowed"], [[127024, 127123], "valid", [], "NV8"], [[127124, 127135], "disallowed"], [[127136, 127150], "valid", [], "NV8"], [[127151, 127152], "disallowed"], [[127153, 127166], "valid", [], "NV8"], [[127167, 127167], "valid", [], "NV8"], [[127168, 127168], "disallowed"], [[127169, 127183], "valid", [], "NV8"], [[127184, 127184], "disallowed"], [[127185, 127199], "valid", [], "NV8"], [[127200, 127221], "valid", [], "NV8"], [[127222, 127231], "disallowed"], [[127232, 127232], "disallowed"], [[127233, 127233], "disallowed_STD3_mapped", [48, 44]], [[127234, 127234], "disallowed_STD3_mapped", [49, 44]], [[127235, 127235], "disallowed_STD3_mapped", [50, 44]], [[127236, 127236], "disallowed_STD3_mapped", [51, 44]], [[127237, 127237], "disallowed_STD3_mapped", [52, 44]], [[127238, 127238], "disallowed_STD3_mapped", [53, 44]], [[127239, 127239], "disallowed_STD3_mapped", [54, 44]], [[127240, 127240], "disallowed_STD3_mapped", [55, 44]], [[127241, 127241], "disallowed_STD3_mapped", [56, 44]], [[127242, 127242], "disallowed_STD3_mapped", [57, 44]], [[127243, 127244], "valid", [], "NV8"], [[127245, 127247], "disallowed"], [[127248, 127248], "disallowed_STD3_mapped", [40, 97, 41]], [[127249, 127249], "disallowed_STD3_mapped", [40, 98, 41]], [[127250, 127250], "disallowed_STD3_mapped", [40, 99, 41]], [[127251, 127251], "disallowed_STD3_mapped", [40, 100, 41]], [[127252, 127252], "disallowed_STD3_mapped", [40, 101, 41]], [[127253, 127253], "disallowed_STD3_mapped", [40, 102, 41]], [[127254, 127254], "disallowed_STD3_mapped", [40, 103, 41]], [[127255, 127255], "disallowed_STD3_mapped", [40, 104, 41]], [[127256, 127256], "disallowed_STD3_mapped", [40, 105, 41]], [[127257, 127257], "disallowed_STD3_mapped", [40, 106, 41]], [[127258, 127258], "disallowed_STD3_mapped", [40, 107, 41]], [[127259, 127259], "disallowed_STD3_mapped", [40, 108, 41]], [[127260, 127260], "disallowed_STD3_mapped", [40, 109, 41]], [[127261, 127261], "disallowed_STD3_mapped", [40, 110, 41]], [[127262, 127262], "disallowed_STD3_mapped", [40, 111, 41]], [[127263, 127263], "disallowed_STD3_mapped", [40, 112, 41]], [[127264, 127264], "disallowed_STD3_mapped", [40, 113, 41]], [[127265, 127265], "disallowed_STD3_mapped", [40, 114, 41]], [[127266, 127266], "disallowed_STD3_mapped", [40, 115, 41]], [[127267, 127267], "disallowed_STD3_mapped", [40, 116, 41]], [[127268, 127268], "disallowed_STD3_mapped", [40, 117, 41]], [[127269, 127269], "disallowed_STD3_mapped", [40, 118, 41]], [[127270, 127270], "disallowed_STD3_mapped", [40, 119, 41]], [[127271, 127271], "disallowed_STD3_mapped", [40, 120, 41]], [[127272, 127272], "disallowed_STD3_mapped", [40, 121, 41]], [[127273, 127273], "disallowed_STD3_mapped", [40, 122, 41]], [[127274, 127274], "mapped", [12308, 115, 12309]], [[127275, 127275], "mapped", [99]], [[127276, 127276], "mapped", [114]], [[127277, 127277], "mapped", [99, 100]], [[127278, 127278], "mapped", [119, 122]], [[127279, 127279], "disallowed"], [[127280, 127280], "mapped", [97]], [[127281, 127281], "mapped", [98]], [[127282, 127282], "mapped", [99]], [[127283, 127283], "mapped", [100]], [[127284, 127284], "mapped", [101]], [[127285, 127285], "mapped", [102]], [[127286, 127286], "mapped", [103]], [[127287, 127287], "mapped", [104]], [[127288, 127288], "mapped", [105]], [[127289, 127289], "mapped", [106]], [[127290, 127290], "mapped", [107]], [[127291, 127291], "mapped", [108]], [[127292, 127292], "mapped", [109]], [[127293, 127293], "mapped", [110]], [[127294, 127294], "mapped", [111]], [[127295, 127295], "mapped", [112]], [[127296, 127296], "mapped", [113]], [[127297, 127297], "mapped", [114]], [[127298, 127298], "mapped", [115]], [[127299, 127299], "mapped", [116]], [[127300, 127300], "mapped", [117]], [[127301, 127301], "mapped", [118]], [[127302, 127302], "mapped", [119]], [[127303, 127303], "mapped", [120]], [[127304, 127304], "mapped", [121]], [[127305, 127305], "mapped", [122]], [[127306, 127306], "mapped", [104, 118]], [[127307, 127307], "mapped", [109, 118]], [[127308, 127308], "mapped", [115, 100]], [[127309, 127309], "mapped", [115, 115]], [[127310, 127310], "mapped", [112, 112, 118]], [[127311, 127311], "mapped", [119, 99]], [[127312, 127318], "valid", [], "NV8"], [[127319, 127319], "valid", [], "NV8"], [[127320, 127326], "valid", [], "NV8"], [[127327, 127327], "valid", [], "NV8"], [[127328, 127337], "valid", [], "NV8"], [[127338, 127338], "mapped", [109, 99]], [[127339, 127339], "mapped", [109, 100]], [[127340, 127343], "disallowed"], [[127344, 127352], "valid", [], "NV8"], [[127353, 127353], "valid", [], "NV8"], [[127354, 127354], "valid", [], "NV8"], [[127355, 127356], "valid", [], "NV8"], [[127357, 127358], "valid", [], "NV8"], [[127359, 127359], "valid", [], "NV8"], [[127360, 127369], "valid", [], "NV8"], [[127370, 127373], "valid", [], "NV8"], [[127374, 127375], "valid", [], "NV8"], [[127376, 127376], "mapped", [100, 106]], [[127377, 127386], "valid", [], "NV8"], [[127387, 127461], "disallowed"], [[127462, 127487], "valid", [], "NV8"], [[127488, 127488], "mapped", [12411, 12363]], [[127489, 127489], "mapped", [12467, 12467]], [[127490, 127490], "mapped", [12469]], [[127491, 127503], "disallowed"], [[127504, 127504], "mapped", [25163]], [[127505, 127505], "mapped", [23383]], [[127506, 127506], "mapped", [21452]], [[127507, 127507], "mapped", [12487]], [[127508, 127508], "mapped", [20108]], [[127509, 127509], "mapped", [22810]], [[127510, 127510], "mapped", [35299]], [[127511, 127511], "mapped", [22825]], [[127512, 127512], "mapped", [20132]], [[127513, 127513], "mapped", [26144]], [[127514, 127514], "mapped", [28961]], [[127515, 127515], "mapped", [26009]], [[127516, 127516], "mapped", [21069]], [[127517, 127517], "mapped", [24460]], [[127518, 127518], "mapped", [20877]], [[127519, 127519], "mapped", [26032]], [[127520, 127520], "mapped", [21021]], [[127521, 127521], "mapped", [32066]], [[127522, 127522], "mapped", [29983]], [[127523, 127523], "mapped", [36009]], [[127524, 127524], "mapped", [22768]], [[127525, 127525], "mapped", [21561]], [[127526, 127526], "mapped", [28436]], [[127527, 127527], "mapped", [25237]], [[127528, 127528], "mapped", [25429]], [[127529, 127529], "mapped", [19968]], [[127530, 127530], "mapped", [19977]], [[127531, 127531], "mapped", [36938]], [[127532, 127532], "mapped", [24038]], [[127533, 127533], "mapped", [20013]], [[127534, 127534], "mapped", [21491]], [[127535, 127535], "mapped", [25351]], [[127536, 127536], "mapped", [36208]], [[127537, 127537], "mapped", [25171]], [[127538, 127538], "mapped", [31105]], [[127539, 127539], "mapped", [31354]], [[127540, 127540], "mapped", [21512]], [[127541, 127541], "mapped", [28288]], [[127542, 127542], "mapped", [26377]], [[127543, 127543], "mapped", [26376]], [[127544, 127544], "mapped", [30003]], [[127545, 127545], "mapped", [21106]], [[127546, 127546], "mapped", [21942]], [[127547, 127551], "disallowed"], [[127552, 127552], "mapped", [12308, 26412, 12309]], [[127553, 127553], "mapped", [12308, 19977, 12309]], [[127554, 127554], "mapped", [12308, 20108, 12309]], [[127555, 127555], "mapped", [12308, 23433, 12309]], [[127556, 127556], "mapped", [12308, 28857, 12309]], [[127557, 127557], "mapped", [12308, 25171, 12309]], [[127558, 127558], "mapped", [12308, 30423, 12309]], [[127559, 127559], "mapped", [12308, 21213, 12309]], [[127560, 127560], "mapped", [12308, 25943, 12309]], [[127561, 127567], "disallowed"], [[127568, 127568], "mapped", [24471]], [[127569, 127569], "mapped", [21487]], [[127570, 127743], "disallowed"], [[127744, 127776], "valid", [], "NV8"], [[127777, 127788], "valid", [], "NV8"], [[127789, 127791], "valid", [], "NV8"], [[127792, 127797], "valid", [], "NV8"], [[127798, 127798], "valid", [], "NV8"], [[127799, 127868], "valid", [], "NV8"], [[127869, 127869], "valid", [], "NV8"], [[127870, 127871], "valid", [], "NV8"], [[127872, 127891], "valid", [], "NV8"], [[127892, 127903], "valid", [], "NV8"], [[127904, 127940], "valid", [], "NV8"], [[127941, 127941], "valid", [], "NV8"], [[127942, 127946], "valid", [], "NV8"], [[127947, 127950], "valid", [], "NV8"], [[127951, 127955], "valid", [], "NV8"], [[127956, 127967], "valid", [], "NV8"], [[127968, 127984], "valid", [], "NV8"], [[127985, 127991], "valid", [], "NV8"], [[127992, 127999], "valid", [], "NV8"], [[128000, 128062], "valid", [], "NV8"], [[128063, 128063], "valid", [], "NV8"], [[128064, 128064], "valid", [], "NV8"], [[128065, 128065], "valid", [], "NV8"], [[128066, 128247], "valid", [], "NV8"], [[128248, 128248], "valid", [], "NV8"], [[128249, 128252], "valid", [], "NV8"], [[128253, 128254], "valid", [], "NV8"], [[128255, 128255], "valid", [], "NV8"], [[128256, 128317], "valid", [], "NV8"], [[128318, 128319], "valid", [], "NV8"], [[128320, 128323], "valid", [], "NV8"], [[128324, 128330], "valid", [], "NV8"], [[128331, 128335], "valid", [], "NV8"], [[128336, 128359], "valid", [], "NV8"], [[128360, 128377], "valid", [], "NV8"], [[128378, 128378], "disallowed"], [[128379, 128419], "valid", [], "NV8"], [[128420, 128420], "disallowed"], [[128421, 128506], "valid", [], "NV8"], [[128507, 128511], "valid", [], "NV8"], [[128512, 128512], "valid", [], "NV8"], [[128513, 128528], "valid", [], "NV8"], [[128529, 128529], "valid", [], "NV8"], [[128530, 128532], "valid", [], "NV8"], [[128533, 128533], "valid", [], "NV8"], [[128534, 128534], "valid", [], "NV8"], [[128535, 128535], "valid", [], "NV8"], [[128536, 128536], "valid", [], "NV8"], [[128537, 128537], "valid", [], "NV8"], [[128538, 128538], "valid", [], "NV8"], [[128539, 128539], "valid", [], "NV8"], [[128540, 128542], "valid", [], "NV8"], [[128543, 128543], "valid", [], "NV8"], [[128544, 128549], "valid", [], "NV8"], [[128550, 128551], "valid", [], "NV8"], [[128552, 128555], "valid", [], "NV8"], [[128556, 128556], "valid", [], "NV8"], [[128557, 128557], "valid", [], "NV8"], [[128558, 128559], "valid", [], "NV8"], [[128560, 128563], "valid", [], "NV8"], [[128564, 128564], "valid", [], "NV8"], [[128565, 128576], "valid", [], "NV8"], [[128577, 128578], "valid", [], "NV8"], [[128579, 128580], "valid", [], "NV8"], [[128581, 128591], "valid", [], "NV8"], [[128592, 128639], "valid", [], "NV8"], [[128640, 128709], "valid", [], "NV8"], [[128710, 128719], "valid", [], "NV8"], [[128720, 128720], "valid", [], "NV8"], [[128721, 128735], "disallowed"], [[128736, 128748], "valid", [], "NV8"], [[128749, 128751], "disallowed"], [[128752, 128755], "valid", [], "NV8"], [[128756, 128767], "disallowed"], [[128768, 128883], "valid", [], "NV8"], [[128884, 128895], "disallowed"], [[128896, 128980], "valid", [], "NV8"], [[128981, 129023], "disallowed"], [[129024, 129035], "valid", [], "NV8"], [[129036, 129039], "disallowed"], [[129040, 129095], "valid", [], "NV8"], [[129096, 129103], "disallowed"], [[129104, 129113], "valid", [], "NV8"], [[129114, 129119], "disallowed"], [[129120, 129159], "valid", [], "NV8"], [[129160, 129167], "disallowed"], [[129168, 129197], "valid", [], "NV8"], [[129198, 129295], "disallowed"], [[129296, 129304], "valid", [], "NV8"], [[129305, 129407], "disallowed"], [[129408, 129412], "valid", [], "NV8"], [[129413, 129471], "disallowed"], [[129472, 129472], "valid", [], "NV8"], [[129473, 131069], "disallowed"], [[131070, 131071], "disallowed"], [[131072, 173782], "valid"], [[173783, 173823], "disallowed"], [[173824, 177972], "valid"], [[177973, 177983], "disallowed"], [[177984, 178205], "valid"], [[178206, 178207], "disallowed"], [[178208, 183969], "valid"], [[183970, 194559], "disallowed"], [[194560, 194560], "mapped", [20029]], [[194561, 194561], "mapped", [20024]], [[194562, 194562], "mapped", [20033]], [[194563, 194563], "mapped", [131362]], [[194564, 194564], "mapped", [20320]], [[194565, 194565], "mapped", [20398]], [[194566, 194566], "mapped", [20411]], [[194567, 194567], "mapped", [20482]], [[194568, 194568], "mapped", [20602]], [[194569, 194569], "mapped", [20633]], [[194570, 194570], "mapped", [20711]], [[194571, 194571], "mapped", [20687]], [[194572, 194572], "mapped", [13470]], [[194573, 194573], "mapped", [132666]], [[194574, 194574], "mapped", [20813]], [[194575, 194575], "mapped", [20820]], [[194576, 194576], "mapped", [20836]], [[194577, 194577], "mapped", [20855]], [[194578, 194578], "mapped", [132380]], [[194579, 194579], "mapped", [13497]], [[194580, 194580], "mapped", [20839]], [[194581, 194581], "mapped", [20877]], [[194582, 194582], "mapped", [132427]], [[194583, 194583], "mapped", [20887]], [[194584, 194584], "mapped", [20900]], [[194585, 194585], "mapped", [20172]], [[194586, 194586], "mapped", [20908]], [[194587, 194587], "mapped", [20917]], [[194588, 194588], "mapped", [168415]], [[194589, 194589], "mapped", [20981]], [[194590, 194590], "mapped", [20995]], [[194591, 194591], "mapped", [13535]], [[194592, 194592], "mapped", [21051]], [[194593, 194593], "mapped", [21062]], [[194594, 194594], "mapped", [21106]], [[194595, 194595], "mapped", [21111]], [[194596, 194596], "mapped", [13589]], [[194597, 194597], "mapped", [21191]], [[194598, 194598], "mapped", [21193]], [[194599, 194599], "mapped", [21220]], [[194600, 194600], "mapped", [21242]], [[194601, 194601], "mapped", [21253]], [[194602, 194602], "mapped", [21254]], [[194603, 194603], "mapped", [21271]], [[194604, 194604], "mapped", [21321]], [[194605, 194605], "mapped", [21329]], [[194606, 194606], "mapped", [21338]], [[194607, 194607], "mapped", [21363]], [[194608, 194608], "mapped", [21373]], [[194609, 194611], "mapped", [21375]], [[194612, 194612], "mapped", [133676]], [[194613, 194613], "mapped", [28784]], [[194614, 194614], "mapped", [21450]], [[194615, 194615], "mapped", [21471]], [[194616, 194616], "mapped", [133987]], [[194617, 194617], "mapped", [21483]], [[194618, 194618], "mapped", [21489]], [[194619, 194619], "mapped", [21510]], [[194620, 194620], "mapped", [21662]], [[194621, 194621], "mapped", [21560]], [[194622, 194622], "mapped", [21576]], [[194623, 194623], "mapped", [21608]], [[194624, 194624], "mapped", [21666]], [[194625, 194625], "mapped", [21750]], [[194626, 194626], "mapped", [21776]], [[194627, 194627], "mapped", [21843]], [[194628, 194628], "mapped", [21859]], [[194629, 194630], "mapped", [21892]], [[194631, 194631], "mapped", [21913]], [[194632, 194632], "mapped", [21931]], [[194633, 194633], "mapped", [21939]], [[194634, 194634], "mapped", [21954]], [[194635, 194635], "mapped", [22294]], [[194636, 194636], "mapped", [22022]], [[194637, 194637], "mapped", [22295]], [[194638, 194638], "mapped", [22097]], [[194639, 194639], "mapped", [22132]], [[194640, 194640], "mapped", [20999]], [[194641, 194641], "mapped", [22766]], [[194642, 194642], "mapped", [22478]], [[194643, 194643], "mapped", [22516]], [[194644, 194644], "mapped", [22541]], [[194645, 194645], "mapped", [22411]], [[194646, 194646], "mapped", [22578]], [[194647, 194647], "mapped", [22577]], [[194648, 194648], "mapped", [22700]], [[194649, 194649], "mapped", [136420]], [[194650, 194650], "mapped", [22770]], [[194651, 194651], "mapped", [22775]], [[194652, 194652], "mapped", [22790]], [[194653, 194653], "mapped", [22810]], [[194654, 194654], "mapped", [22818]], [[194655, 194655], "mapped", [22882]], [[194656, 194656], "mapped", [136872]], [[194657, 194657], "mapped", [136938]], [[194658, 194658], "mapped", [23020]], [[194659, 194659], "mapped", [23067]], [[194660, 194660], "mapped", [23079]], [[194661, 194661], "mapped", [23000]], [[194662, 194662], "mapped", [23142]], [[194663, 194663], "mapped", [14062]], [[194664, 194664], "disallowed"], [[194665, 194665], "mapped", [23304]], [[194666, 194667], "mapped", [23358]], [[194668, 194668], "mapped", [137672]], [[194669, 194669], "mapped", [23491]], [[194670, 194670], "mapped", [23512]], [[194671, 194671], "mapped", [23527]], [[194672, 194672], "mapped", [23539]], [[194673, 194673], "mapped", [138008]], [[194674, 194674], "mapped", [23551]], [[194675, 194675], "mapped", [23558]], [[194676, 194676], "disallowed"], [[194677, 194677], "mapped", [23586]], [[194678, 194678], "mapped", [14209]], [[194679, 194679], "mapped", [23648]], [[194680, 194680], "mapped", [23662]], [[194681, 194681], "mapped", [23744]], [[194682, 194682], "mapped", [23693]], [[194683, 194683], "mapped", [138724]], [[194684, 194684], "mapped", [23875]], [[194685, 194685], "mapped", [138726]], [[194686, 194686], "mapped", [23918]], [[194687, 194687], "mapped", [23915]], [[194688, 194688], "mapped", [23932]], [[194689, 194689], "mapped", [24033]], [[194690, 194690], "mapped", [24034]], [[194691, 194691], "mapped", [14383]], [[194692, 194692], "mapped", [24061]], [[194693, 194693], "mapped", [24104]], [[194694, 194694], "mapped", [24125]], [[194695, 194695], "mapped", [24169]], [[194696, 194696], "mapped", [14434]], [[194697, 194697], "mapped", [139651]], [[194698, 194698], "mapped", [14460]], [[194699, 194699], "mapped", [24240]], [[194700, 194700], "mapped", [24243]], [[194701, 194701], "mapped", [24246]], [[194702, 194702], "mapped", [24266]], [[194703, 194703], "mapped", [172946]], [[194704, 194704], "mapped", [24318]], [[194705, 194706], "mapped", [140081]], [[194707, 194707], "mapped", [33281]], [[194708, 194709], "mapped", [24354]], [[194710, 194710], "mapped", [14535]], [[194711, 194711], "mapped", [144056]], [[194712, 194712], "mapped", [156122]], [[194713, 194713], "mapped", [24418]], [[194714, 194714], "mapped", [24427]], [[194715, 194715], "mapped", [14563]], [[194716, 194716], "mapped", [24474]], [[194717, 194717], "mapped", [24525]], [[194718, 194718], "mapped", [24535]], [[194719, 194719], "mapped", [24569]], [[194720, 194720], "mapped", [24705]], [[194721, 194721], "mapped", [14650]], [[194722, 194722], "mapped", [14620]], [[194723, 194723], "mapped", [24724]], [[194724, 194724], "mapped", [141012]], [[194725, 194725], "mapped", [24775]], [[194726, 194726], "mapped", [24904]], [[194727, 194727], "mapped", [24908]], [[194728, 194728], "mapped", [24910]], [[194729, 194729], "mapped", [24908]], [[194730, 194730], "mapped", [24954]], [[194731, 194731], "mapped", [24974]], [[194732, 194732], "mapped", [25010]], [[194733, 194733], "mapped", [24996]], [[194734, 194734], "mapped", [25007]], [[194735, 194735], "mapped", [25054]], [[194736, 194736], "mapped", [25074]], [[194737, 194737], "mapped", [25078]], [[194738, 194738], "mapped", [25104]], [[194739, 194739], "mapped", [25115]], [[194740, 194740], "mapped", [25181]], [[194741, 194741], "mapped", [25265]], [[194742, 194742], "mapped", [25300]], [[194743, 194743], "mapped", [25424]], [[194744, 194744], "mapped", [142092]], [[194745, 194745], "mapped", [25405]], [[194746, 194746], "mapped", [25340]], [[194747, 194747], "mapped", [25448]], [[194748, 194748], "mapped", [25475]], [[194749, 194749], "mapped", [25572]], [[194750, 194750], "mapped", [142321]], [[194751, 194751], "mapped", [25634]], [[194752, 194752], "mapped", [25541]], [[194753, 194753], "mapped", [25513]], [[194754, 194754], "mapped", [14894]], [[194755, 194755], "mapped", [25705]], [[194756, 194756], "mapped", [25726]], [[194757, 194757], "mapped", [25757]], [[194758, 194758], "mapped", [25719]], [[194759, 194759], "mapped", [14956]], [[194760, 194760], "mapped", [25935]], [[194761, 194761], "mapped", [25964]], [[194762, 194762], "mapped", [143370]], [[194763, 194763], "mapped", [26083]], [[194764, 194764], "mapped", [26360]], [[194765, 194765], "mapped", [26185]], [[194766, 194766], "mapped", [15129]], [[194767, 194767], "mapped", [26257]], [[194768, 194768], "mapped", [15112]], [[194769, 194769], "mapped", [15076]], [[194770, 194770], "mapped", [20882]], [[194771, 194771], "mapped", [20885]], [[194772, 194772], "mapped", [26368]], [[194773, 194773], "mapped", [26268]], [[194774, 194774], "mapped", [32941]], [[194775, 194775], "mapped", [17369]], [[194776, 194776], "mapped", [26391]], [[194777, 194777], "mapped", [26395]], [[194778, 194778], "mapped", [26401]], [[194779, 194779], "mapped", [26462]], [[194780, 194780], "mapped", [26451]], [[194781, 194781], "mapped", [144323]], [[194782, 194782], "mapped", [15177]], [[194783, 194783], "mapped", [26618]], [[194784, 194784], "mapped", [26501]], [[194785, 194785], "mapped", [26706]], [[194786, 194786], "mapped", [26757]], [[194787, 194787], "mapped", [144493]], [[194788, 194788], "mapped", [26766]], [[194789, 194789], "mapped", [26655]], [[194790, 194790], "mapped", [26900]], [[194791, 194791], "mapped", [15261]], [[194792, 194792], "mapped", [26946]], [[194793, 194793], "mapped", [27043]], [[194794, 194794], "mapped", [27114]], [[194795, 194795], "mapped", [27304]], [[194796, 194796], "mapped", [145059]], [[194797, 194797], "mapped", [27355]], [[194798, 194798], "mapped", [15384]], [[194799, 194799], "mapped", [27425]], [[194800, 194800], "mapped", [145575]], [[194801, 194801], "mapped", [27476]], [[194802, 194802], "mapped", [15438]], [[194803, 194803], "mapped", [27506]], [[194804, 194804], "mapped", [27551]], [[194805, 194805], "mapped", [27578]], [[194806, 194806], "mapped", [27579]], [[194807, 194807], "mapped", [146061]], [[194808, 194808], "mapped", [138507]], [[194809, 194809], "mapped", [146170]], [[194810, 194810], "mapped", [27726]], [[194811, 194811], "mapped", [146620]], [[194812, 194812], "mapped", [27839]], [[194813, 194813], "mapped", [27853]], [[194814, 194814], "mapped", [27751]], [[194815, 194815], "mapped", [27926]], [[194816, 194816], "mapped", [27966]], [[194817, 194817], "mapped", [28023]], [[194818, 194818], "mapped", [27969]], [[194819, 194819], "mapped", [28009]], [[194820, 194820], "mapped", [28024]], [[194821, 194821], "mapped", [28037]], [[194822, 194822], "mapped", [146718]], [[194823, 194823], "mapped", [27956]], [[194824, 194824], "mapped", [28207]], [[194825, 194825], "mapped", [28270]], [[194826, 194826], "mapped", [15667]], [[194827, 194827], "mapped", [28363]], [[194828, 194828], "mapped", [28359]], [[194829, 194829], "mapped", [147153]], [[194830, 194830], "mapped", [28153]], [[194831, 194831], "mapped", [28526]], [[194832, 194832], "mapped", [147294]], [[194833, 194833], "mapped", [147342]], [[194834, 194834], "mapped", [28614]], [[194835, 194835], "mapped", [28729]], [[194836, 194836], "mapped", [28702]], [[194837, 194837], "mapped", [28699]], [[194838, 194838], "mapped", [15766]], [[194839, 194839], "mapped", [28746]], [[194840, 194840], "mapped", [28797]], [[194841, 194841], "mapped", [28791]], [[194842, 194842], "mapped", [28845]], [[194843, 194843], "mapped", [132389]], [[194844, 194844], "mapped", [28997]], [[194845, 194845], "mapped", [148067]], [[194846, 194846], "mapped", [29084]], [[194847, 194847], "disallowed"], [[194848, 194848], "mapped", [29224]], [[194849, 194849], "mapped", [29237]], [[194850, 194850], "mapped", [29264]], [[194851, 194851], "mapped", [149000]], [[194852, 194852], "mapped", [29312]], [[194853, 194853], "mapped", [29333]], [[194854, 194854], "mapped", [149301]], [[194855, 194855], "mapped", [149524]], [[194856, 194856], "mapped", [29562]], [[194857, 194857], "mapped", [29579]], [[194858, 194858], "mapped", [16044]], [[194859, 194859], "mapped", [29605]], [[194860, 194861], "mapped", [16056]], [[194862, 194862], "mapped", [29767]], [[194863, 194863], "mapped", [29788]], [[194864, 194864], "mapped", [29809]], [[194865, 194865], "mapped", [29829]], [[194866, 194866], "mapped", [29898]], [[194867, 194867], "mapped", [16155]], [[194868, 194868], "mapped", [29988]], [[194869, 194869], "mapped", [150582]], [[194870, 194870], "mapped", [30014]], [[194871, 194871], "mapped", [150674]], [[194872, 194872], "mapped", [30064]], [[194873, 194873], "mapped", [139679]], [[194874, 194874], "mapped", [30224]], [[194875, 194875], "mapped", [151457]], [[194876, 194876], "mapped", [151480]], [[194877, 194877], "mapped", [151620]], [[194878, 194878], "mapped", [16380]], [[194879, 194879], "mapped", [16392]], [[194880, 194880], "mapped", [30452]], [[194881, 194881], "mapped", [151795]], [[194882, 194882], "mapped", [151794]], [[194883, 194883], "mapped", [151833]], [[194884, 194884], "mapped", [151859]], [[194885, 194885], "mapped", [30494]], [[194886, 194887], "mapped", [30495]], [[194888, 194888], "mapped", [30538]], [[194889, 194889], "mapped", [16441]], [[194890, 194890], "mapped", [30603]], [[194891, 194891], "mapped", [16454]], [[194892, 194892], "mapped", [16534]], [[194893, 194893], "mapped", [152605]], [[194894, 194894], "mapped", [30798]], [[194895, 194895], "mapped", [30860]], [[194896, 194896], "mapped", [30924]], [[194897, 194897], "mapped", [16611]], [[194898, 194898], "mapped", [153126]], [[194899, 194899], "mapped", [31062]], [[194900, 194900], "mapped", [153242]], [[194901, 194901], "mapped", [153285]], [[194902, 194902], "mapped", [31119]], [[194903, 194903], "mapped", [31211]], [[194904, 194904], "mapped", [16687]], [[194905, 194905], "mapped", [31296]], [[194906, 194906], "mapped", [31306]], [[194907, 194907], "mapped", [31311]], [[194908, 194908], "mapped", [153980]], [[194909, 194910], "mapped", [154279]], [[194911, 194911], "disallowed"], [[194912, 194912], "mapped", [16898]], [[194913, 194913], "mapped", [154539]], [[194914, 194914], "mapped", [31686]], [[194915, 194915], "mapped", [31689]], [[194916, 194916], "mapped", [16935]], [[194917, 194917], "mapped", [154752]], [[194918, 194918], "mapped", [31954]], [[194919, 194919], "mapped", [17056]], [[194920, 194920], "mapped", [31976]], [[194921, 194921], "mapped", [31971]], [[194922, 194922], "mapped", [32000]], [[194923, 194923], "mapped", [155526]], [[194924, 194924], "mapped", [32099]], [[194925, 194925], "mapped", [17153]], [[194926, 194926], "mapped", [32199]], [[194927, 194927], "mapped", [32258]], [[194928, 194928], "mapped", [32325]], [[194929, 194929], "mapped", [17204]], [[194930, 194930], "mapped", [156200]], [[194931, 194931], "mapped", [156231]], [[194932, 194932], "mapped", [17241]], [[194933, 194933], "mapped", [156377]], [[194934, 194934], "mapped", [32634]], [[194935, 194935], "mapped", [156478]], [[194936, 194936], "mapped", [32661]], [[194937, 194937], "mapped", [32762]], [[194938, 194938], "mapped", [32773]], [[194939, 194939], "mapped", [156890]], [[194940, 194940], "mapped", [156963]], [[194941, 194941], "mapped", [32864]], [[194942, 194942], "mapped", [157096]], [[194943, 194943], "mapped", [32880]], [[194944, 194944], "mapped", [144223]], [[194945, 194945], "mapped", [17365]], [[194946, 194946], "mapped", [32946]], [[194947, 194947], "mapped", [33027]], [[194948, 194948], "mapped", [17419]], [[194949, 194949], "mapped", [33086]], [[194950, 194950], "mapped", [23221]], [[194951, 194951], "mapped", [157607]], [[194952, 194952], "mapped", [157621]], [[194953, 194953], "mapped", [144275]], [[194954, 194954], "mapped", [144284]], [[194955, 194955], "mapped", [33281]], [[194956, 194956], "mapped", [33284]], [[194957, 194957], "mapped", [36766]], [[194958, 194958], "mapped", [17515]], [[194959, 194959], "mapped", [33425]], [[194960, 194960], "mapped", [33419]], [[194961, 194961], "mapped", [33437]], [[194962, 194962], "mapped", [21171]], [[194963, 194963], "mapped", [33457]], [[194964, 194964], "mapped", [33459]], [[194965, 194965], "mapped", [33469]], [[194966, 194966], "mapped", [33510]], [[194967, 194967], "mapped", [158524]], [[194968, 194968], "mapped", [33509]], [[194969, 194969], "mapped", [33565]], [[194970, 194970], "mapped", [33635]], [[194971, 194971], "mapped", [33709]], [[194972, 194972], "mapped", [33571]], [[194973, 194973], "mapped", [33725]], [[194974, 194974], "mapped", [33767]], [[194975, 194975], "mapped", [33879]], [[194976, 194976], "mapped", [33619]], [[194977, 194977], "mapped", [33738]], [[194978, 194978], "mapped", [33740]], [[194979, 194979], "mapped", [33756]], [[194980, 194980], "mapped", [158774]], [[194981, 194981], "mapped", [159083]], [[194982, 194982], "mapped", [158933]], [[194983, 194983], "mapped", [17707]], [[194984, 194984], "mapped", [34033]], [[194985, 194985], "mapped", [34035]], [[194986, 194986], "mapped", [34070]], [[194987, 194987], "mapped", [160714]], [[194988, 194988], "mapped", [34148]], [[194989, 194989], "mapped", [159532]], [[194990, 194990], "mapped", [17757]], [[194991, 194991], "mapped", [17761]], [[194992, 194992], "mapped", [159665]], [[194993, 194993], "mapped", [159954]], [[194994, 194994], "mapped", [17771]], [[194995, 194995], "mapped", [34384]], [[194996, 194996], "mapped", [34396]], [[194997, 194997], "mapped", [34407]], [[194998, 194998], "mapped", [34409]], [[194999, 194999], "mapped", [34473]], [[195000, 195000], "mapped", [34440]], [[195001, 195001], "mapped", [34574]], [[195002, 195002], "mapped", [34530]], [[195003, 195003], "mapped", [34681]], [[195004, 195004], "mapped", [34600]], [[195005, 195005], "mapped", [34667]], [[195006, 195006], "mapped", [34694]], [[195007, 195007], "disallowed"], [[195008, 195008], "mapped", [34785]], [[195009, 195009], "mapped", [34817]], [[195010, 195010], "mapped", [17913]], [[195011, 195011], "mapped", [34912]], [[195012, 195012], "mapped", [34915]], [[195013, 195013], "mapped", [161383]], [[195014, 195014], "mapped", [35031]], [[195015, 195015], "mapped", [35038]], [[195016, 195016], "mapped", [17973]], [[195017, 195017], "mapped", [35066]], [[195018, 195018], "mapped", [13499]], [[195019, 195019], "mapped", [161966]], [[195020, 195020], "mapped", [162150]], [[195021, 195021], "mapped", [18110]], [[195022, 195022], "mapped", [18119]], [[195023, 195023], "mapped", [35488]], [[195024, 195024], "mapped", [35565]], [[195025, 195025], "mapped", [35722]], [[195026, 195026], "mapped", [35925]], [[195027, 195027], "mapped", [162984]], [[195028, 195028], "mapped", [36011]], [[195029, 195029], "mapped", [36033]], [[195030, 195030], "mapped", [36123]], [[195031, 195031], "mapped", [36215]], [[195032, 195032], "mapped", [163631]], [[195033, 195033], "mapped", [133124]], [[195034, 195034], "mapped", [36299]], [[195035, 195035], "mapped", [36284]], [[195036, 195036], "mapped", [36336]], [[195037, 195037], "mapped", [133342]], [[195038, 195038], "mapped", [36564]], [[195039, 195039], "mapped", [36664]], [[195040, 195040], "mapped", [165330]], [[195041, 195041], "mapped", [165357]], [[195042, 195042], "mapped", [37012]], [[195043, 195043], "mapped", [37105]], [[195044, 195044], "mapped", [37137]], [[195045, 195045], "mapped", [165678]], [[195046, 195046], "mapped", [37147]], [[195047, 195047], "mapped", [37432]], [[195048, 195048], "mapped", [37591]], [[195049, 195049], "mapped", [37592]], [[195050, 195050], "mapped", [37500]], [[195051, 195051], "mapped", [37881]], [[195052, 195052], "mapped", [37909]], [[195053, 195053], "mapped", [166906]], [[195054, 195054], "mapped", [38283]], [[195055, 195055], "mapped", [18837]], [[195056, 195056], "mapped", [38327]], [[195057, 195057], "mapped", [167287]], [[195058, 195058], "mapped", [18918]], [[195059, 195059], "mapped", [38595]], [[195060, 195060], "mapped", [23986]], [[195061, 195061], "mapped", [38691]], [[195062, 195062], "mapped", [168261]], [[195063, 195063], "mapped", [168474]], [[195064, 195064], "mapped", [19054]], [[195065, 195065], "mapped", [19062]], [[195066, 195066], "mapped", [38880]], [[195067, 195067], "mapped", [168970]], [[195068, 195068], "mapped", [19122]], [[195069, 195069], "mapped", [169110]], [[195070, 195071], "mapped", [38923]], [[195072, 195072], "mapped", [38953]], [[195073, 195073], "mapped", [169398]], [[195074, 195074], "mapped", [39138]], [[195075, 195075], "mapped", [19251]], [[195076, 195076], "mapped", [39209]], [[195077, 195077], "mapped", [39335]], [[195078, 195078], "mapped", [39362]], [[195079, 195079], "mapped", [39422]], [[195080, 195080], "mapped", [19406]], [[195081, 195081], "mapped", [170800]], [[195082, 195082], "mapped", [39698]], [[195083, 195083], "mapped", [40000]], [[195084, 195084], "mapped", [40189]], [[195085, 195085], "mapped", [19662]], [[195086, 195086], "mapped", [19693]], [[195087, 195087], "mapped", [40295]], [[195088, 195088], "mapped", [172238]], [[195089, 195089], "mapped", [19704]], [[195090, 195090], "mapped", [172293]], [[195091, 195091], "mapped", [172558]], [[195092, 195092], "mapped", [172689]], [[195093, 195093], "mapped", [40635]], [[195094, 195094], "mapped", [19798]], [[195095, 195095], "mapped", [40697]], [[195096, 195096], "mapped", [40702]], [[195097, 195097], "mapped", [40709]], [[195098, 195098], "mapped", [40719]], [[195099, 195099], "mapped", [40726]], [[195100, 195100], "mapped", [40763]], [[195101, 195101], "mapped", [173568]], [[195102, 196605], "disallowed"], [[196606, 196607], "disallowed"], [[196608, 262141], "disallowed"], [[262142, 262143], "disallowed"], [[262144, 327677], "disallowed"], [[327678, 327679], "disallowed"], [[327680, 393213], "disallowed"], [[393214, 393215], "disallowed"], [[393216, 458749], "disallowed"], [[458750, 458751], "disallowed"], [[458752, 524285], "disallowed"], [[524286, 524287], "disallowed"], [[524288, 589821], "disallowed"], [[589822, 589823], "disallowed"], [[589824, 655357], "disallowed"], [[655358, 655359], "disallowed"], [[655360, 720893], "disallowed"], [[720894, 720895], "disallowed"], [[720896, 786429], "disallowed"], [[786430, 786431], "disallowed"], [[786432, 851965], "disallowed"], [[851966, 851967], "disallowed"], [[851968, 917501], "disallowed"], [[917502, 917503], "disallowed"], [[917504, 917504], "disallowed"], [[917505, 917505], "disallowed"], [[917506, 917535], "disallowed"], [[917536, 917631], "disallowed"], [[917632, 917759], "disallowed"], [[917760, 917999], "ignored"], [[918000, 983037], "disallowed"], [[983038, 983039], "disallowed"], [[983040, 1048573], "disallowed"], [[1048574, 1048575], "disallowed"], [[1048576, 1114109], "disallowed"], [[1114110, 1114111], "disallowed"]];
});

// node_modules/tr46/index.js
var require_tr46 = __commonJS((exports, module) => {
  var punycode = __require("punycode");
  var mappingTable = require_mappingTable();
  var PROCESSING_OPTIONS = {
    TRANSITIONAL: 0,
    NONTRANSITIONAL: 1
  };
  function normalize(str) {
    return str.split("\x00").map(function(s) {
      return s.normalize("NFC");
    }).join("\x00");
  }
  function findStatus(val) {
    var start = 0;
    var end = mappingTable.length - 1;
    while (start <= end) {
      var mid = Math.floor((start + end) / 2);
      var target = mappingTable[mid];
      if (target[0][0] <= val && target[0][1] >= val) {
        return target;
      } else if (target[0][0] > val) {
        end = mid - 1;
      } else {
        start = mid + 1;
      }
    }
    return null;
  }
  var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
  function countSymbols(string) {
    return string.replace(regexAstralSymbols, "_").length;
  }
  function mapChars(domain_name, useSTD3, processing_option) {
    var hasError = false;
    var processed = "";
    var len = countSymbols(domain_name);
    for (var i = 0;i < len; ++i) {
      var codePoint = domain_name.codePointAt(i);
      var status = findStatus(codePoint);
      switch (status[1]) {
        case "disallowed":
          hasError = true;
          processed += String.fromCodePoint(codePoint);
          break;
        case "ignored":
          break;
        case "mapped":
          processed += String.fromCodePoint.apply(String, status[2]);
          break;
        case "deviation":
          if (processing_option === PROCESSING_OPTIONS.TRANSITIONAL) {
            processed += String.fromCodePoint.apply(String, status[2]);
          } else {
            processed += String.fromCodePoint(codePoint);
          }
          break;
        case "valid":
          processed += String.fromCodePoint(codePoint);
          break;
        case "disallowed_STD3_mapped":
          if (useSTD3) {
            hasError = true;
            processed += String.fromCodePoint(codePoint);
          } else {
            processed += String.fromCodePoint.apply(String, status[2]);
          }
          break;
        case "disallowed_STD3_valid":
          if (useSTD3) {
            hasError = true;
          }
          processed += String.fromCodePoint(codePoint);
          break;
      }
    }
    return {
      string: processed,
      error: hasError
    };
  }
  var combiningMarksRegex = /[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E4-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u192B\u1930-\u193B\u19B0-\u19C0\u19C8\u19C9\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2D]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD804[\uDC00-\uDC02\uDC38-\uDC46\uDC7F-\uDC82\uDCB0-\uDCBA\uDD00-\uDD02\uDD27-\uDD34\uDD73\uDD80-\uDD82\uDDB3-\uDDC0\uDE2C-\uDE37\uDEDF-\uDEEA\uDF01-\uDF03\uDF3C\uDF3E-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDCB0-\uDCC3\uDDAF-\uDDB5\uDDB8-\uDDC0\uDE30-\uDE40\uDEAB-\uDEB7]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF51-\uDF7E\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD83A[\uDCD0-\uDCD6]|\uDB40[\uDD00-\uDDEF]/;
  function validateLabel(label, processing_option) {
    if (label.substr(0, 4) === "xn--") {
      label = punycode.toUnicode(label);
      processing_option = PROCESSING_OPTIONS.NONTRANSITIONAL;
    }
    var error = false;
    if (normalize(label) !== label || label[3] === "-" && label[4] === "-" || label[0] === "-" || label[label.length - 1] === "-" || label.indexOf(".") !== -1 || label.search(combiningMarksRegex) === 0) {
      error = true;
    }
    var len = countSymbols(label);
    for (var i = 0;i < len; ++i) {
      var status = findStatus(label.codePointAt(i));
      if (processing === PROCESSING_OPTIONS.TRANSITIONAL && status[1] !== "valid" || processing === PROCESSING_OPTIONS.NONTRANSITIONAL && status[1] !== "valid" && status[1] !== "deviation") {
        error = true;
        break;
      }
    }
    return {
      label,
      error
    };
  }
  function processing(domain_name, useSTD3, processing_option) {
    var result = mapChars(domain_name, useSTD3, processing_option);
    result.string = normalize(result.string);
    var labels = result.string.split(".");
    for (var i = 0;i < labels.length; ++i) {
      try {
        var validation = validateLabel(labels[i]);
        labels[i] = validation.label;
        result.error = result.error || validation.error;
      } catch (e) {
        result.error = true;
      }
    }
    return {
      string: labels.join("."),
      error: result.error
    };
  }
  exports.toASCII = function(domain_name, useSTD3, processing_option, verifyDnsLength) {
    var result = processing(domain_name, useSTD3, processing_option);
    var labels = result.string.split(".");
    labels = labels.map(function(l) {
      try {
        return punycode.toASCII(l);
      } catch (e) {
        result.error = true;
        return l;
      }
    });
    if (verifyDnsLength) {
      var total = labels.slice(0, labels.length - 1).join(".").length;
      if (total.length > 253 || total.length === 0) {
        result.error = true;
      }
      for (var i = 0;i < labels.length; ++i) {
        if (labels.length > 63 || labels.length === 0) {
          result.error = true;
          break;
        }
      }
    }
    if (result.error)
      return null;
    return labels.join(".");
  };
  exports.toUnicode = function(domain_name, useSTD3) {
    var result = processing(domain_name, useSTD3, PROCESSING_OPTIONS.NONTRANSITIONAL);
    return {
      domain: result.string,
      error: result.error
    };
  };
  exports.PROCESSING_OPTIONS = PROCESSING_OPTIONS;
});

// node_modules/whatwg-url/lib/url-state-machine.js
var require_url_state_machine = __commonJS((exports, module) => {
  var punycode = __require("punycode");
  var tr46 = require_tr46();
  var specialSchemes = {
    ftp: 21,
    file: null,
    gopher: 70,
    http: 80,
    https: 443,
    ws: 80,
    wss: 443
  };
  var failure = Symbol("failure");
  function countSymbols(str) {
    return punycode.ucs2.decode(str).length;
  }
  function at(input, idx) {
    const c = input[idx];
    return isNaN(c) ? undefined : String.fromCodePoint(c);
  }
  function isASCIIDigit(c) {
    return c >= 48 && c <= 57;
  }
  function isASCIIAlpha(c) {
    return c >= 65 && c <= 90 || c >= 97 && c <= 122;
  }
  function isASCIIAlphanumeric(c) {
    return isASCIIAlpha(c) || isASCIIDigit(c);
  }
  function isASCIIHex(c) {
    return isASCIIDigit(c) || c >= 65 && c <= 70 || c >= 97 && c <= 102;
  }
  function isSingleDot(buffer) {
    return buffer === "." || buffer.toLowerCase() === "%2e";
  }
  function isDoubleDot(buffer) {
    buffer = buffer.toLowerCase();
    return buffer === ".." || buffer === "%2e." || buffer === ".%2e" || buffer === "%2e%2e";
  }
  function isWindowsDriveLetterCodePoints(cp1, cp2) {
    return isASCIIAlpha(cp1) && (cp2 === 58 || cp2 === 124);
  }
  function isWindowsDriveLetterString(string) {
    return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && (string[1] === ":" || string[1] === "|");
  }
  function isNormalizedWindowsDriveLetterString(string) {
    return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && string[1] === ":";
  }
  function containsForbiddenHostCodePoint(string) {
    return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|%|\/|:|\?|@|\[|\\|\]/) !== -1;
  }
  function containsForbiddenHostCodePointExcludingPercent(string) {
    return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|\/|:|\?|@|\[|\\|\]/) !== -1;
  }
  function isSpecialScheme(scheme) {
    return specialSchemes[scheme] !== undefined;
  }
  function isSpecial(url) {
    return isSpecialScheme(url.scheme);
  }
  function defaultPort(scheme) {
    return specialSchemes[scheme];
  }
  function percentEncode(c) {
    let hex = c.toString(16).toUpperCase();
    if (hex.length === 1) {
      hex = "0" + hex;
    }
    return "%" + hex;
  }
  function utf8PercentEncode(c) {
    const buf = new Buffer(c);
    let str = "";
    for (let i = 0;i < buf.length; ++i) {
      str += percentEncode(buf[i]);
    }
    return str;
  }
  function utf8PercentDecode(str) {
    const input = new Buffer(str);
    const output = [];
    for (let i = 0;i < input.length; ++i) {
      if (input[i] !== 37) {
        output.push(input[i]);
      } else if (input[i] === 37 && isASCIIHex(input[i + 1]) && isASCIIHex(input[i + 2])) {
        output.push(parseInt(input.slice(i + 1, i + 3).toString(), 16));
        i += 2;
      } else {
        output.push(input[i]);
      }
    }
    return new Buffer(output).toString();
  }
  function isC0ControlPercentEncode(c) {
    return c <= 31 || c > 126;
  }
  var extraPathPercentEncodeSet = new Set([32, 34, 35, 60, 62, 63, 96, 123, 125]);
  function isPathPercentEncode(c) {
    return isC0ControlPercentEncode(c) || extraPathPercentEncodeSet.has(c);
  }
  var extraUserinfoPercentEncodeSet = new Set([47, 58, 59, 61, 64, 91, 92, 93, 94, 124]);
  function isUserinfoPercentEncode(c) {
    return isPathPercentEncode(c) || extraUserinfoPercentEncodeSet.has(c);
  }
  function percentEncodeChar(c, encodeSetPredicate) {
    const cStr = String.fromCodePoint(c);
    if (encodeSetPredicate(c)) {
      return utf8PercentEncode(cStr);
    }
    return cStr;
  }
  function parseIPv4Number(input) {
    let R = 10;
    if (input.length >= 2 && input.charAt(0) === "0" && input.charAt(1).toLowerCase() === "x") {
      input = input.substring(2);
      R = 16;
    } else if (input.length >= 2 && input.charAt(0) === "0") {
      input = input.substring(1);
      R = 8;
    }
    if (input === "") {
      return 0;
    }
    const regex = R === 10 ? /[^0-9]/ : R === 16 ? /[^0-9A-Fa-f]/ : /[^0-7]/;
    if (regex.test(input)) {
      return failure;
    }
    return parseInt(input, R);
  }
  function parseIPv4(input) {
    const parts = input.split(".");
    if (parts[parts.length - 1] === "") {
      if (parts.length > 1) {
        parts.pop();
      }
    }
    if (parts.length > 4) {
      return input;
    }
    const numbers = [];
    for (const part of parts) {
      if (part === "") {
        return input;
      }
      const n = parseIPv4Number(part);
      if (n === failure) {
        return input;
      }
      numbers.push(n);
    }
    for (let i = 0;i < numbers.length - 1; ++i) {
      if (numbers[i] > 255) {
        return failure;
      }
    }
    if (numbers[numbers.length - 1] >= Math.pow(256, 5 - numbers.length)) {
      return failure;
    }
    let ipv4 = numbers.pop();
    let counter = 0;
    for (const n of numbers) {
      ipv4 += n * Math.pow(256, 3 - counter);
      ++counter;
    }
    return ipv4;
  }
  function serializeIPv4(address) {
    let output = "";
    let n = address;
    for (let i = 1;i <= 4; ++i) {
      output = String(n % 256) + output;
      if (i !== 4) {
        output = "." + output;
      }
      n = Math.floor(n / 256);
    }
    return output;
  }
  function parseIPv6(input) {
    const address = [0, 0, 0, 0, 0, 0, 0, 0];
    let pieceIndex = 0;
    let compress = null;
    let pointer = 0;
    input = punycode.ucs2.decode(input);
    if (input[pointer] === 58) {
      if (input[pointer + 1] !== 58) {
        return failure;
      }
      pointer += 2;
      ++pieceIndex;
      compress = pieceIndex;
    }
    while (pointer < input.length) {
      if (pieceIndex === 8) {
        return failure;
      }
      if (input[pointer] === 58) {
        if (compress !== null) {
          return failure;
        }
        ++pointer;
        ++pieceIndex;
        compress = pieceIndex;
        continue;
      }
      let value = 0;
      let length = 0;
      while (length < 4 && isASCIIHex(input[pointer])) {
        value = value * 16 + parseInt(at(input, pointer), 16);
        ++pointer;
        ++length;
      }
      if (input[pointer] === 46) {
        if (length === 0) {
          return failure;
        }
        pointer -= length;
        if (pieceIndex > 6) {
          return failure;
        }
        let numbersSeen = 0;
        while (input[pointer] !== undefined) {
          let ipv4Piece = null;
          if (numbersSeen > 0) {
            if (input[pointer] === 46 && numbersSeen < 4) {
              ++pointer;
            } else {
              return failure;
            }
          }
          if (!isASCIIDigit(input[pointer])) {
            return failure;
          }
          while (isASCIIDigit(input[pointer])) {
            const number = parseInt(at(input, pointer));
            if (ipv4Piece === null) {
              ipv4Piece = number;
            } else if (ipv4Piece === 0) {
              return failure;
            } else {
              ipv4Piece = ipv4Piece * 10 + number;
            }
            if (ipv4Piece > 255) {
              return failure;
            }
            ++pointer;
          }
          address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
          ++numbersSeen;
          if (numbersSeen === 2 || numbersSeen === 4) {
            ++pieceIndex;
          }
        }
        if (numbersSeen !== 4) {
          return failure;
        }
        break;
      } else if (input[pointer] === 58) {
        ++pointer;
        if (input[pointer] === undefined) {
          return failure;
        }
      } else if (input[pointer] !== undefined) {
        return failure;
      }
      address[pieceIndex] = value;
      ++pieceIndex;
    }
    if (compress !== null) {
      let swaps = pieceIndex - compress;
      pieceIndex = 7;
      while (pieceIndex !== 0 && swaps > 0) {
        const temp = address[compress + swaps - 1];
        address[compress + swaps - 1] = address[pieceIndex];
        address[pieceIndex] = temp;
        --pieceIndex;
        --swaps;
      }
    } else if (compress === null && pieceIndex !== 8) {
      return failure;
    }
    return address;
  }
  function serializeIPv6(address) {
    let output = "";
    const seqResult = findLongestZeroSequence(address);
    const compress = seqResult.idx;
    let ignore0 = false;
    for (let pieceIndex = 0;pieceIndex <= 7; ++pieceIndex) {
      if (ignore0 && address[pieceIndex] === 0) {
        continue;
      } else if (ignore0) {
        ignore0 = false;
      }
      if (compress === pieceIndex) {
        const separator = pieceIndex === 0 ? "::" : ":";
        output += separator;
        ignore0 = true;
        continue;
      }
      output += address[pieceIndex].toString(16);
      if (pieceIndex !== 7) {
        output += ":";
      }
    }
    return output;
  }
  function parseHost(input, isSpecialArg) {
    if (input[0] === "[") {
      if (input[input.length - 1] !== "]") {
        return failure;
      }
      return parseIPv6(input.substring(1, input.length - 1));
    }
    if (!isSpecialArg) {
      return parseOpaqueHost(input);
    }
    const domain = utf8PercentDecode(input);
    const asciiDomain = tr46.toASCII(domain, false, tr46.PROCESSING_OPTIONS.NONTRANSITIONAL, false);
    if (asciiDomain === null) {
      return failure;
    }
    if (containsForbiddenHostCodePoint(asciiDomain)) {
      return failure;
    }
    const ipv4Host = parseIPv4(asciiDomain);
    if (typeof ipv4Host === "number" || ipv4Host === failure) {
      return ipv4Host;
    }
    return asciiDomain;
  }
  function parseOpaqueHost(input) {
    if (containsForbiddenHostCodePointExcludingPercent(input)) {
      return failure;
    }
    let output = "";
    const decoded = punycode.ucs2.decode(input);
    for (let i = 0;i < decoded.length; ++i) {
      output += percentEncodeChar(decoded[i], isC0ControlPercentEncode);
    }
    return output;
  }
  function findLongestZeroSequence(arr) {
    let maxIdx = null;
    let maxLen = 1;
    let currStart = null;
    let currLen = 0;
    for (let i = 0;i < arr.length; ++i) {
      if (arr[i] !== 0) {
        if (currLen > maxLen) {
          maxIdx = currStart;
          maxLen = currLen;
        }
        currStart = null;
        currLen = 0;
      } else {
        if (currStart === null) {
          currStart = i;
        }
        ++currLen;
      }
    }
    if (currLen > maxLen) {
      maxIdx = currStart;
      maxLen = currLen;
    }
    return {
      idx: maxIdx,
      len: maxLen
    };
  }
  function serializeHost(host) {
    if (typeof host === "number") {
      return serializeIPv4(host);
    }
    if (host instanceof Array) {
      return "[" + serializeIPv6(host) + "]";
    }
    return host;
  }
  function trimControlChars(url) {
    return url.replace(/^[\u0000-\u001F\u0020]+|[\u0000-\u001F\u0020]+$/g, "");
  }
  function trimTabAndNewline(url) {
    return url.replace(/\u0009|\u000A|\u000D/g, "");
  }
  function shortenPath(url) {
    const path = url.path;
    if (path.length === 0) {
      return;
    }
    if (url.scheme === "file" && path.length === 1 && isNormalizedWindowsDriveLetter(path[0])) {
      return;
    }
    path.pop();
  }
  function includesCredentials(url) {
    return url.username !== "" || url.password !== "";
  }
  function cannotHaveAUsernamePasswordPort(url) {
    return url.host === null || url.host === "" || url.cannotBeABaseURL || url.scheme === "file";
  }
  function isNormalizedWindowsDriveLetter(string) {
    return /^[A-Za-z]:$/.test(string);
  }
  function URLStateMachine(input, base, encodingOverride, url, stateOverride) {
    this.pointer = 0;
    this.input = input;
    this.base = base || null;
    this.encodingOverride = encodingOverride || "utf-8";
    this.stateOverride = stateOverride;
    this.url = url;
    this.failure = false;
    this.parseError = false;
    if (!this.url) {
      this.url = {
        scheme: "",
        username: "",
        password: "",
        host: null,
        port: null,
        path: [],
        query: null,
        fragment: null,
        cannotBeABaseURL: false
      };
      const res2 = trimControlChars(this.input);
      if (res2 !== this.input) {
        this.parseError = true;
      }
      this.input = res2;
    }
    const res = trimTabAndNewline(this.input);
    if (res !== this.input) {
      this.parseError = true;
    }
    this.input = res;
    this.state = stateOverride || "scheme start";
    this.buffer = "";
    this.atFlag = false;
    this.arrFlag = false;
    this.passwordTokenSeenFlag = false;
    this.input = punycode.ucs2.decode(this.input);
    for (;this.pointer <= this.input.length; ++this.pointer) {
      const c = this.input[this.pointer];
      const cStr = isNaN(c) ? undefined : String.fromCodePoint(c);
      const ret = this["parse " + this.state](c, cStr);
      if (!ret) {
        break;
      } else if (ret === failure) {
        this.failure = true;
        break;
      }
    }
  }
  URLStateMachine.prototype["parse scheme start"] = function parseSchemeStart(c, cStr) {
    if (isASCIIAlpha(c)) {
      this.buffer += cStr.toLowerCase();
      this.state = "scheme";
    } else if (!this.stateOverride) {
      this.state = "no scheme";
      --this.pointer;
    } else {
      this.parseError = true;
      return failure;
    }
    return true;
  };
  URLStateMachine.prototype["parse scheme"] = function parseScheme(c, cStr) {
    if (isASCIIAlphanumeric(c) || c === 43 || c === 45 || c === 46) {
      this.buffer += cStr.toLowerCase();
    } else if (c === 58) {
      if (this.stateOverride) {
        if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) {
          return false;
        }
        if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) {
          return false;
        }
        if ((includesCredentials(this.url) || this.url.port !== null) && this.buffer === "file") {
          return false;
        }
        if (this.url.scheme === "file" && (this.url.host === "" || this.url.host === null)) {
          return false;
        }
      }
      this.url.scheme = this.buffer;
      this.buffer = "";
      if (this.stateOverride) {
        return false;
      }
      if (this.url.scheme === "file") {
        if (this.input[this.pointer + 1] !== 47 || this.input[this.pointer + 2] !== 47) {
          this.parseError = true;
        }
        this.state = "file";
      } else if (isSpecial(this.url) && this.base !== null && this.base.scheme === this.url.scheme) {
        this.state = "special relative or authority";
      } else if (isSpecial(this.url)) {
        this.state = "special authority slashes";
      } else if (this.input[this.pointer + 1] === 47) {
        this.state = "path or authority";
        ++this.pointer;
      } else {
        this.url.cannotBeABaseURL = true;
        this.url.path.push("");
        this.state = "cannot-be-a-base-URL path";
      }
    } else if (!this.stateOverride) {
      this.buffer = "";
      this.state = "no scheme";
      this.pointer = -1;
    } else {
      this.parseError = true;
      return failure;
    }
    return true;
  };
  URLStateMachine.prototype["parse no scheme"] = function parseNoScheme(c) {
    if (this.base === null || this.base.cannotBeABaseURL && c !== 35) {
      return failure;
    } else if (this.base.cannotBeABaseURL && c === 35) {
      this.url.scheme = this.base.scheme;
      this.url.path = this.base.path.slice();
      this.url.query = this.base.query;
      this.url.fragment = "";
      this.url.cannotBeABaseURL = true;
      this.state = "fragment";
    } else if (this.base.scheme === "file") {
      this.state = "file";
      --this.pointer;
    } else {
      this.state = "relative";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse special relative or authority"] = function parseSpecialRelativeOrAuthority(c) {
    if (c === 47 && this.input[this.pointer + 1] === 47) {
      this.state = "special authority ignore slashes";
      ++this.pointer;
    } else {
      this.parseError = true;
      this.state = "relative";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse path or authority"] = function parsePathOrAuthority(c) {
    if (c === 47) {
      this.state = "authority";
    } else {
      this.state = "path";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse relative"] = function parseRelative(c) {
    this.url.scheme = this.base.scheme;
    if (isNaN(c)) {
      this.url.username = this.base.username;
      this.url.password = this.base.password;
      this.url.host = this.base.host;
      this.url.port = this.base.port;
      this.url.path = this.base.path.slice();
      this.url.query = this.base.query;
    } else if (c === 47) {
      this.state = "relative slash";
    } else if (c === 63) {
      this.url.username = this.base.username;
      this.url.password = this.base.password;
      this.url.host = this.base.host;
      this.url.port = this.base.port;
      this.url.path = this.base.path.slice();
      this.url.query = "";
      this.state = "query";
    } else if (c === 35) {
      this.url.username = this.base.username;
      this.url.password = this.base.password;
      this.url.host = this.base.host;
      this.url.port = this.base.port;
      this.url.path = this.base.path.slice();
      this.url.query = this.base.query;
      this.url.fragment = "";
      this.state = "fragment";
    } else if (isSpecial(this.url) && c === 92) {
      this.parseError = true;
      this.state = "relative slash";
    } else {
      this.url.username = this.base.username;
      this.url.password = this.base.password;
      this.url.host = this.base.host;
      this.url.port = this.base.port;
      this.url.path = this.base.path.slice(0, this.base.path.length - 1);
      this.state = "path";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse relative slash"] = function parseRelativeSlash(c) {
    if (isSpecial(this.url) && (c === 47 || c === 92)) {
      if (c === 92) {
        this.parseError = true;
      }
      this.state = "special authority ignore slashes";
    } else if (c === 47) {
      this.state = "authority";
    } else {
      this.url.username = this.base.username;
      this.url.password = this.base.password;
      this.url.host = this.base.host;
      this.url.port = this.base.port;
      this.state = "path";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse special authority slashes"] = function parseSpecialAuthoritySlashes(c) {
    if (c === 47 && this.input[this.pointer + 1] === 47) {
      this.state = "special authority ignore slashes";
      ++this.pointer;
    } else {
      this.parseError = true;
      this.state = "special authority ignore slashes";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse special authority ignore slashes"] = function parseSpecialAuthorityIgnoreSlashes(c) {
    if (c !== 47 && c !== 92) {
      this.state = "authority";
      --this.pointer;
    } else {
      this.parseError = true;
    }
    return true;
  };
  URLStateMachine.prototype["parse authority"] = function parseAuthority(c, cStr) {
    if (c === 64) {
      this.parseError = true;
      if (this.atFlag) {
        this.buffer = "%40" + this.buffer;
      }
      this.atFlag = true;
      const len = countSymbols(this.buffer);
      for (let pointer = 0;pointer < len; ++pointer) {
        const codePoint = this.buffer.codePointAt(pointer);
        if (codePoint === 58 && !this.passwordTokenSeenFlag) {
          this.passwordTokenSeenFlag = true;
          continue;
        }
        const encodedCodePoints = percentEncodeChar(codePoint, isUserinfoPercentEncode);
        if (this.passwordTokenSeenFlag) {
          this.url.password += encodedCodePoints;
        } else {
          this.url.username += encodedCodePoints;
        }
      }
      this.buffer = "";
    } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92) {
      if (this.atFlag && this.buffer === "") {
        this.parseError = true;
        return failure;
      }
      this.pointer -= countSymbols(this.buffer) + 1;
      this.buffer = "";
      this.state = "host";
    } else {
      this.buffer += cStr;
    }
    return true;
  };
  URLStateMachine.prototype["parse hostname"] = URLStateMachine.prototype["parse host"] = function parseHostName(c, cStr) {
    if (this.stateOverride && this.url.scheme === "file") {
      --this.pointer;
      this.state = "file host";
    } else if (c === 58 && !this.arrFlag) {
      if (this.buffer === "") {
        this.parseError = true;
        return failure;
      }
      const host = parseHost(this.buffer, isSpecial(this.url));
      if (host === failure) {
        return failure;
      }
      this.url.host = host;
      this.buffer = "";
      this.state = "port";
      if (this.stateOverride === "hostname") {
        return false;
      }
    } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92) {
      --this.pointer;
      if (isSpecial(this.url) && this.buffer === "") {
        this.parseError = true;
        return failure;
      } else if (this.stateOverride && this.buffer === "" && (includesCredentials(this.url) || this.url.port !== null)) {
        this.parseError = true;
        return false;
      }
      const host = parseHost(this.buffer, isSpecial(this.url));
      if (host === failure) {
        return failure;
      }
      this.url.host = host;
      this.buffer = "";
      this.state = "path start";
      if (this.stateOverride) {
        return false;
      }
    } else {
      if (c === 91) {
        this.arrFlag = true;
      } else if (c === 93) {
        this.arrFlag = false;
      }
      this.buffer += cStr;
    }
    return true;
  };
  URLStateMachine.prototype["parse port"] = function parsePort(c, cStr) {
    if (isASCIIDigit(c)) {
      this.buffer += cStr;
    } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92 || this.stateOverride) {
      if (this.buffer !== "") {
        const port = parseInt(this.buffer);
        if (port > Math.pow(2, 16) - 1) {
          this.parseError = true;
          return failure;
        }
        this.url.port = port === defaultPort(this.url.scheme) ? null : port;
        this.buffer = "";
      }
      if (this.stateOverride) {
        return false;
      }
      this.state = "path start";
      --this.pointer;
    } else {
      this.parseError = true;
      return failure;
    }
    return true;
  };
  var fileOtherwiseCodePoints = new Set([47, 92, 63, 35]);
  URLStateMachine.prototype["parse file"] = function parseFile(c) {
    this.url.scheme = "file";
    if (c === 47 || c === 92) {
      if (c === 92) {
        this.parseError = true;
      }
      this.state = "file slash";
    } else if (this.base !== null && this.base.scheme === "file") {
      if (isNaN(c)) {
        this.url.host = this.base.host;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
      } else if (c === 63) {
        this.url.host = this.base.host;
        this.url.path = this.base.path.slice();
        this.url.query = "";
        this.state = "query";
      } else if (c === 35) {
        this.url.host = this.base.host;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
        this.url.fragment = "";
        this.state = "fragment";
      } else {
        if (this.input.length - this.pointer - 1 === 0 || !isWindowsDriveLetterCodePoints(c, this.input[this.pointer + 1]) || this.input.length - this.pointer - 1 >= 2 && !fileOtherwiseCodePoints.has(this.input[this.pointer + 2])) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          shortenPath(this.url);
        } else {
          this.parseError = true;
        }
        this.state = "path";
        --this.pointer;
      }
    } else {
      this.state = "path";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse file slash"] = function parseFileSlash(c) {
    if (c === 47 || c === 92) {
      if (c === 92) {
        this.parseError = true;
      }
      this.state = "file host";
    } else {
      if (this.base !== null && this.base.scheme === "file") {
        if (isNormalizedWindowsDriveLetterString(this.base.path[0])) {
          this.url.path.push(this.base.path[0]);
        } else {
          this.url.host = this.base.host;
        }
      }
      this.state = "path";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse file host"] = function parseFileHost(c, cStr) {
    if (isNaN(c) || c === 47 || c === 92 || c === 63 || c === 35) {
      --this.pointer;
      if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {
        this.parseError = true;
        this.state = "path";
      } else if (this.buffer === "") {
        this.url.host = "";
        if (this.stateOverride) {
          return false;
        }
        this.state = "path start";
      } else {
        let host = parseHost(this.buffer, isSpecial(this.url));
        if (host === failure) {
          return failure;
        }
        if (host === "localhost") {
          host = "";
        }
        this.url.host = host;
        if (this.stateOverride) {
          return false;
        }
        this.buffer = "";
        this.state = "path start";
      }
    } else {
      this.buffer += cStr;
    }
    return true;
  };
  URLStateMachine.prototype["parse path start"] = function parsePathStart(c) {
    if (isSpecial(this.url)) {
      if (c === 92) {
        this.parseError = true;
      }
      this.state = "path";
      if (c !== 47 && c !== 92) {
        --this.pointer;
      }
    } else if (!this.stateOverride && c === 63) {
      this.url.query = "";
      this.state = "query";
    } else if (!this.stateOverride && c === 35) {
      this.url.fragment = "";
      this.state = "fragment";
    } else if (c !== undefined) {
      this.state = "path";
      if (c !== 47) {
        --this.pointer;
      }
    }
    return true;
  };
  URLStateMachine.prototype["parse path"] = function parsePath(c) {
    if (isNaN(c) || c === 47 || isSpecial(this.url) && c === 92 || !this.stateOverride && (c === 63 || c === 35)) {
      if (isSpecial(this.url) && c === 92) {
        this.parseError = true;
      }
      if (isDoubleDot(this.buffer)) {
        shortenPath(this.url);
        if (c !== 47 && !(isSpecial(this.url) && c === 92)) {
          this.url.path.push("");
        }
      } else if (isSingleDot(this.buffer) && c !== 47 && !(isSpecial(this.url) && c === 92)) {
        this.url.path.push("");
      } else if (!isSingleDot(this.buffer)) {
        if (this.url.scheme === "file" && this.url.path.length === 0 && isWindowsDriveLetterString(this.buffer)) {
          if (this.url.host !== "" && this.url.host !== null) {
            this.parseError = true;
            this.url.host = "";
          }
          this.buffer = this.buffer[0] + ":";
        }
        this.url.path.push(this.buffer);
      }
      this.buffer = "";
      if (this.url.scheme === "file" && (c === undefined || c === 63 || c === 35)) {
        while (this.url.path.length > 1 && this.url.path[0] === "") {
          this.parseError = true;
          this.url.path.shift();
        }
      }
      if (c === 63) {
        this.url.query = "";
        this.state = "query";
      }
      if (c === 35) {
        this.url.fragment = "";
        this.state = "fragment";
      }
    } else {
      if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
        this.parseError = true;
      }
      this.buffer += percentEncodeChar(c, isPathPercentEncode);
    }
    return true;
  };
  URLStateMachine.prototype["parse cannot-be-a-base-URL path"] = function parseCannotBeABaseURLPath(c) {
    if (c === 63) {
      this.url.query = "";
      this.state = "query";
    } else if (c === 35) {
      this.url.fragment = "";
      this.state = "fragment";
    } else {
      if (!isNaN(c) && c !== 37) {
        this.parseError = true;
      }
      if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
        this.parseError = true;
      }
      if (!isNaN(c)) {
        this.url.path[0] = this.url.path[0] + percentEncodeChar(c, isC0ControlPercentEncode);
      }
    }
    return true;
  };
  URLStateMachine.prototype["parse query"] = function parseQuery(c, cStr) {
    if (isNaN(c) || !this.stateOverride && c === 35) {
      if (!isSpecial(this.url) || this.url.scheme === "ws" || this.url.scheme === "wss") {
        this.encodingOverride = "utf-8";
      }
      const buffer = new Buffer(this.buffer);
      for (let i = 0;i < buffer.length; ++i) {
        if (buffer[i] < 33 || buffer[i] > 126 || buffer[i] === 34 || buffer[i] === 35 || buffer[i] === 60 || buffer[i] === 62) {
          this.url.query += percentEncode(buffer[i]);
        } else {
          this.url.query += String.fromCodePoint(buffer[i]);
        }
      }
      this.buffer = "";
      if (c === 35) {
        this.url.fragment = "";
        this.state = "fragment";
      }
    } else {
      if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
        this.parseError = true;
      }
      this.buffer += cStr;
    }
    return true;
  };
  URLStateMachine.prototype["parse fragment"] = function parseFragment(c) {
    if (isNaN(c)) {} else if (c === 0) {
      this.parseError = true;
    } else {
      if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
        this.parseError = true;
      }
      this.url.fragment += percentEncodeChar(c, isC0ControlPercentEncode);
    }
    return true;
  };
  function serializeURL(url, excludeFragment) {
    let output = url.scheme + ":";
    if (url.host !== null) {
      output += "//";
      if (url.username !== "" || url.password !== "") {
        output += url.username;
        if (url.password !== "") {
          output += ":" + url.password;
        }
        output += "@";
      }
      output += serializeHost(url.host);
      if (url.port !== null) {
        output += ":" + url.port;
      }
    } else if (url.host === null && url.scheme === "file") {
      output += "//";
    }
    if (url.cannotBeABaseURL) {
      output += url.path[0];
    } else {
      for (const string of url.path) {
        output += "/" + string;
      }
    }
    if (url.query !== null) {
      output += "?" + url.query;
    }
    if (!excludeFragment && url.fragment !== null) {
      output += "#" + url.fragment;
    }
    return output;
  }
  function serializeOrigin(tuple) {
    let result = tuple.scheme + "://";
    result += serializeHost(tuple.host);
    if (tuple.port !== null) {
      result += ":" + tuple.port;
    }
    return result;
  }
  exports.serializeURL = serializeURL;
  exports.serializeURLOrigin = function(url) {
    switch (url.scheme) {
      case "blob":
        try {
          return exports.serializeURLOrigin(exports.parseURL(url.path[0]));
        } catch (e) {
          return "null";
        }
      case "ftp":
      case "gopher":
      case "http":
      case "https":
      case "ws":
      case "wss":
        return serializeOrigin({
          scheme: url.scheme,
          host: url.host,
          port: url.port
        });
      case "file":
        return "file://";
      default:
        return "null";
    }
  };
  exports.basicURLParse = function(input, options) {
    if (options === undefined) {
      options = {};
    }
    const usm = new URLStateMachine(input, options.baseURL, options.encodingOverride, options.url, options.stateOverride);
    if (usm.failure) {
      return "failure";
    }
    return usm.url;
  };
  exports.setTheUsername = function(url, username) {
    url.username = "";
    const decoded = punycode.ucs2.decode(username);
    for (let i = 0;i < decoded.length; ++i) {
      url.username += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
    }
  };
  exports.setThePassword = function(url, password) {
    url.password = "";
    const decoded = punycode.ucs2.decode(password);
    for (let i = 0;i < decoded.length; ++i) {
      url.password += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
    }
  };
  exports.serializeHost = serializeHost;
  exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;
  exports.serializeInteger = function(integer) {
    return String(integer);
  };
  exports.parseURL = function(input, options) {
    if (options === undefined) {
      options = {};
    }
    return exports.basicURLParse(input, { baseURL: options.baseURL, encodingOverride: options.encodingOverride });
  };
});

// node_modules/whatwg-url/lib/URL-impl.js
var require_URL_impl = __commonJS((exports) => {
  var usm = require_url_state_machine();
  exports.implementation = class URLImpl {
    constructor(constructorArgs) {
      const url = constructorArgs[0];
      const base = constructorArgs[1];
      let parsedBase = null;
      if (base !== undefined) {
        parsedBase = usm.basicURLParse(base);
        if (parsedBase === "failure") {
          throw new TypeError("Invalid base URL");
        }
      }
      const parsedURL = usm.basicURLParse(url, { baseURL: parsedBase });
      if (parsedURL === "failure") {
        throw new TypeError("Invalid URL");
      }
      this._url = parsedURL;
    }
    get href() {
      return usm.serializeURL(this._url);
    }
    set href(v) {
      const parsedURL = usm.basicURLParse(v);
      if (parsedURL === "failure") {
        throw new TypeError("Invalid URL");
      }
      this._url = parsedURL;
    }
    get origin() {
      return usm.serializeURLOrigin(this._url);
    }
    get protocol() {
      return this._url.scheme + ":";
    }
    set protocol(v) {
      usm.basicURLParse(v + ":", { url: this._url, stateOverride: "scheme start" });
    }
    get username() {
      return this._url.username;
    }
    set username(v) {
      if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
        return;
      }
      usm.setTheUsername(this._url, v);
    }
    get password() {
      return this._url.password;
    }
    set password(v) {
      if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
        return;
      }
      usm.setThePassword(this._url, v);
    }
    get host() {
      const url = this._url;
      if (url.host === null) {
        return "";
      }
      if (url.port === null) {
        return usm.serializeHost(url.host);
      }
      return usm.serializeHost(url.host) + ":" + usm.serializeInteger(url.port);
    }
    set host(v) {
      if (this._url.cannotBeABaseURL) {
        return;
      }
      usm.basicURLParse(v, { url: this._url, stateOverride: "host" });
    }
    get hostname() {
      if (this._url.host === null) {
        return "";
      }
      return usm.serializeHost(this._url.host);
    }
    set hostname(v) {
      if (this._url.cannotBeABaseURL) {
        return;
      }
      usm.basicURLParse(v, { url: this._url, stateOverride: "hostname" });
    }
    get port() {
      if (this._url.port === null) {
        return "";
      }
      return usm.serializeInteger(this._url.port);
    }
    set port(v) {
      if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
        return;
      }
      if (v === "") {
        this._url.port = null;
      } else {
        usm.basicURLParse(v, { url: this._url, stateOverride: "port" });
      }
    }
    get pathname() {
      if (this._url.cannotBeABaseURL) {
        return this._url.path[0];
      }
      if (this._url.path.length === 0) {
        return "";
      }
      return "/" + this._url.path.join("/");
    }
    set pathname(v) {
      if (this._url.cannotBeABaseURL) {
        return;
      }
      this._url.path = [];
      usm.basicURLParse(v, { url: this._url, stateOverride: "path start" });
    }
    get search() {
      if (this._url.query === null || this._url.query === "") {
        return "";
      }
      return "?" + this._url.query;
    }
    set search(v) {
      const url = this._url;
      if (v === "") {
        url.query = null;
        return;
      }
      const input = v[0] === "?" ? v.substring(1) : v;
      url.query = "";
      usm.basicURLParse(input, { url, stateOverride: "query" });
    }
    get hash() {
      if (this._url.fragment === null || this._url.fragment === "") {
        return "";
      }
      return "#" + this._url.fragment;
    }
    set hash(v) {
      if (v === "") {
        this._url.fragment = null;
        return;
      }
      const input = v[0] === "#" ? v.substring(1) : v;
      this._url.fragment = "";
      usm.basicURLParse(input, { url: this._url, stateOverride: "fragment" });
    }
    toJSON() {
      return this.href;
    }
  };
});

// node_modules/whatwg-url/lib/URL.js
var require_URL = __commonJS((exports, module) => {
  var conversions = require_lib3();
  var utils = require_utils3();
  var Impl = require_URL_impl();
  var impl = utils.implSymbol;
  function URL(url) {
    if (!this || this[impl] || !(this instanceof URL)) {
      throw new TypeError("Failed to construct 'URL': Please use the 'new' operator, this DOM object constructor cannot be called as a function.");
    }
    if (arguments.length < 1) {
      throw new TypeError("Failed to construct 'URL': 1 argument required, but only " + arguments.length + " present.");
    }
    const args2 = [];
    for (let i = 0;i < arguments.length && i < 2; ++i) {
      args2[i] = arguments[i];
    }
    args2[0] = conversions["USVString"](args2[0]);
    if (args2[1] !== undefined) {
      args2[1] = conversions["USVString"](args2[1]);
    }
    module.exports.setup(this, args2);
  }
  URL.prototype.toJSON = function toJSON() {
    if (!this || !module.exports.is(this)) {
      throw new TypeError("Illegal invocation");
    }
    const args2 = [];
    for (let i = 0;i < arguments.length && i < 0; ++i) {
      args2[i] = arguments[i];
    }
    return this[impl].toJSON.apply(this[impl], args2);
  };
  Object.defineProperty(URL.prototype, "href", {
    get() {
      return this[impl].href;
    },
    set(V) {
      V = conversions["USVString"](V);
      this[impl].href = V;
    },
    enumerable: true,
    configurable: true
  });
  URL.prototype.toString = function() {
    if (!this || !module.exports.is(this)) {
      throw new TypeError("Illegal invocation");
    }
    return this.href;
  };
  Object.defineProperty(URL.prototype, "origin", {
    get() {
      return this[impl].origin;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(URL.prototype, "protocol", {
    get() {
      return this[impl].protocol;
    },
    set(V) {
      V = conversions["USVString"](V);
      this[impl].protocol = V;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(URL.prototype, "username", {
    get() {
      return this[impl].username;
    },
    set(V) {
      V = conversions["USVString"](V);
      this[impl].username = V;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(URL.prototype, "password", {
    get() {
      return this[impl].password;
    },
    set(V) {
      V = conversions["USVString"](V);
      this[impl].password = V;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(URL.prototype, "host", {
    get() {
      return this[impl].host;
    },
    set(V) {
      V = conversions["USVString"](V);
      this[impl].host = V;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(URL.prototype, "hostname", {
    get() {
      return this[impl].hostname;
    },
    set(V) {
      V = conversions["USVString"](V);
      this[impl].hostname = V;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(URL.prototype, "port", {
    get() {
      return this[impl].port;
    },
    set(V) {
      V = conversions["USVString"](V);
      this[impl].port = V;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(URL.prototype, "pathname", {
    get() {
      return this[impl].pathname;
    },
    set(V) {
      V = conversions["USVString"](V);
      this[impl].pathname = V;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(URL.prototype, "search", {
    get() {
      return this[impl].search;
    },
    set(V) {
      V = conversions["USVString"](V);
      this[impl].search = V;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(URL.prototype, "hash", {
    get() {
      return this[impl].hash;
    },
    set(V) {
      V = conversions["USVString"](V);
      this[impl].hash = V;
    },
    enumerable: true,
    configurable: true
  });
  module.exports = {
    is(obj) {
      return !!obj && obj[impl] instanceof Impl.implementation;
    },
    create(constructorArgs, privateData) {
      let obj = Object.create(URL.prototype);
      this.setup(obj, constructorArgs, privateData);
      return obj;
    },
    setup(obj, constructorArgs, privateData) {
      if (!privateData)
        privateData = {};
      privateData.wrapper = obj;
      obj[impl] = new Impl.implementation(constructorArgs, privateData);
      obj[impl][utils.wrapperSymbol] = obj;
    },
    interface: URL,
    expose: {
      Window: { URL },
      Worker: { URL }
    }
  };
});

// node_modules/whatwg-url/lib/public-api.js
var require_public_api = __commonJS((exports) => {
  exports.URL = require_URL().interface;
  exports.serializeURL = require_url_state_machine().serializeURL;
  exports.serializeURLOrigin = require_url_state_machine().serializeURLOrigin;
  exports.basicURLParse = require_url_state_machine().basicURLParse;
  exports.setTheUsername = require_url_state_machine().setTheUsername;
  exports.setThePassword = require_url_state_machine().setThePassword;
  exports.serializeHost = require_url_state_machine().serializeHost;
  exports.serializeInteger = require_url_state_machine().serializeInteger;
  exports.parseURL = require_url_state_machine().parseURL;
});

// node_modules/encoding/node_modules/iconv-lite/lib/bom-handling.js
var require_bom_handling2 = __commonJS((exports) => {
  var BOMChar = "\uFEFF";
  exports.PrependBOM = PrependBOMWrapper;
  function PrependBOMWrapper(encoder, options) {
    this.encoder = encoder;
    this.addBOM = true;
  }
  PrependBOMWrapper.prototype.write = function(str) {
    if (this.addBOM) {
      str = BOMChar + str;
      this.addBOM = false;
    }
    return this.encoder.write(str);
  };
  PrependBOMWrapper.prototype.end = function() {
    return this.encoder.end();
  };
  exports.StripBOM = StripBOMWrapper;
  function StripBOMWrapper(decoder, options) {
    this.decoder = decoder;
    this.pass = false;
    this.options = options || {};
  }
  StripBOMWrapper.prototype.write = function(buf) {
    var res = this.decoder.write(buf);
    if (this.pass || !res)
      return res;
    if (res[0] === BOMChar) {
      res = res.slice(1);
      if (typeof this.options.stripBOM === "function")
        this.options.stripBOM();
    }
    this.pass = true;
    return res;
  };
  StripBOMWrapper.prototype.end = function() {
    return this.decoder.end();
  };
});

// node_modules/encoding/node_modules/iconv-lite/encodings/internal.js
var require_internal2 = __commonJS((exports, module) => {
  var Buffer2 = require_safer().Buffer;
  module.exports = {
    utf8: { type: "_internal", bomAware: true },
    cesu8: { type: "_internal", bomAware: true },
    unicode11utf8: "utf8",
    ucs2: { type: "_internal", bomAware: true },
    utf16le: "ucs2",
    binary: { type: "_internal" },
    base64: { type: "_internal" },
    hex: { type: "_internal" },
    _internal: InternalCodec
  };
  function InternalCodec(codecOptions, iconv) {
    this.enc = codecOptions.encodingName;
    this.bomAware = codecOptions.bomAware;
    if (this.enc === "base64")
      this.encoder = InternalEncoderBase64;
    else if (this.enc === "cesu8") {
      this.enc = "utf8";
      this.encoder = InternalEncoderCesu8;
      if (Buffer2.from("eda0bdedb2a9", "hex").toString() !== "\uD83D\uDCA9") {
        this.decoder = InternalDecoderCesu8;
        this.defaultCharUnicode = iconv.defaultCharUnicode;
      }
    }
  }
  InternalCodec.prototype.encoder = InternalEncoder;
  InternalCodec.prototype.decoder = InternalDecoder;
  var StringDecoder = __require("string_decoder").StringDecoder;
  if (!StringDecoder.prototype.end)
    StringDecoder.prototype.end = function() {};
  function InternalDecoder(options, codec) {
    this.decoder = new StringDecoder(codec.enc);
  }
  InternalDecoder.prototype.write = function(buf) {
    if (!Buffer2.isBuffer(buf)) {
      buf = Buffer2.from(buf);
    }
    return this.decoder.write(buf);
  };
  InternalDecoder.prototype.end = function() {
    return this.decoder.end();
  };
  function InternalEncoder(options, codec) {
    this.enc = codec.enc;
  }
  InternalEncoder.prototype.write = function(str) {
    return Buffer2.from(str, this.enc);
  };
  InternalEncoder.prototype.end = function() {};
  function InternalEncoderBase64(options, codec) {
    this.prevStr = "";
  }
  InternalEncoderBase64.prototype.write = function(str) {
    str = this.prevStr + str;
    var completeQuads = str.length - str.length % 4;
    this.prevStr = str.slice(completeQuads);
    str = str.slice(0, completeQuads);
    return Buffer2.from(str, "base64");
  };
  InternalEncoderBase64.prototype.end = function() {
    return Buffer2.from(this.prevStr, "base64");
  };
  function InternalEncoderCesu8(options, codec) {}
  InternalEncoderCesu8.prototype.write = function(str) {
    var buf = Buffer2.alloc(str.length * 3), bufIdx = 0;
    for (var i = 0;i < str.length; i++) {
      var charCode = str.charCodeAt(i);
      if (charCode < 128)
        buf[bufIdx++] = charCode;
      else if (charCode < 2048) {
        buf[bufIdx++] = 192 + (charCode >>> 6);
        buf[bufIdx++] = 128 + (charCode & 63);
      } else {
        buf[bufIdx++] = 224 + (charCode >>> 12);
        buf[bufIdx++] = 128 + (charCode >>> 6 & 63);
        buf[bufIdx++] = 128 + (charCode & 63);
      }
    }
    return buf.slice(0, bufIdx);
  };
  InternalEncoderCesu8.prototype.end = function() {};
  function InternalDecoderCesu8(options, codec) {
    this.acc = 0;
    this.contBytes = 0;
    this.accBytes = 0;
    this.defaultCharUnicode = codec.defaultCharUnicode;
  }
  InternalDecoderCesu8.prototype.write = function(buf) {
    var acc = this.acc, contBytes = this.contBytes, accBytes = this.accBytes, res = "";
    for (var i = 0;i < buf.length; i++) {
      var curByte = buf[i];
      if ((curByte & 192) !== 128) {
        if (contBytes > 0) {
          res += this.defaultCharUnicode;
          contBytes = 0;
        }
        if (curByte < 128) {
          res += String.fromCharCode(curByte);
        } else if (curByte < 224) {
          acc = curByte & 31;
          contBytes = 1;
          accBytes = 1;
        } else if (curByte < 240) {
          acc = curByte & 15;
          contBytes = 2;
          accBytes = 1;
        } else {
          res += this.defaultCharUnicode;
        }
      } else {
        if (contBytes > 0) {
          acc = acc << 6 | curByte & 63;
          contBytes--;
          accBytes++;
          if (contBytes === 0) {
            if (accBytes === 2 && acc < 128 && acc > 0)
              res += this.defaultCharUnicode;
            else if (accBytes === 3 && acc < 2048)
              res += this.defaultCharUnicode;
            else
              res += String.fromCharCode(acc);
          }
        } else {
          res += this.defaultCharUnicode;
        }
      }
    }
    this.acc = acc;
    this.contBytes = contBytes;
    this.accBytes = accBytes;
    return res;
  };
  InternalDecoderCesu8.prototype.end = function() {
    var res = 0;
    if (this.contBytes > 0)
      res += this.defaultCharUnicode;
    return res;
  };
});

// node_modules/encoding/node_modules/iconv-lite/encodings/utf32.js
var require_utf32 = __commonJS((exports) => {
  var Buffer2 = require_safer().Buffer;
  exports._utf32 = Utf32Codec;
  function Utf32Codec(codecOptions, iconv) {
    this.iconv = iconv;
    this.bomAware = true;
    this.isLE = codecOptions.isLE;
  }
  exports.utf32le = { type: "_utf32", isLE: true };
  exports.utf32be = { type: "_utf32", isLE: false };
  exports.ucs4le = "utf32le";
  exports.ucs4be = "utf32be";
  Utf32Codec.prototype.encoder = Utf32Encoder;
  Utf32Codec.prototype.decoder = Utf32Decoder;
  function Utf32Encoder(options, codec) {
    this.isLE = codec.isLE;
    this.highSurrogate = 0;
  }
  Utf32Encoder.prototype.write = function(str) {
    var src = Buffer2.from(str, "ucs2");
    var dst = Buffer2.alloc(src.length * 2);
    var write32 = this.isLE ? dst.writeUInt32LE : dst.writeUInt32BE;
    var offset = 0;
    for (var i = 0;i < src.length; i += 2) {
      var code = src.readUInt16LE(i);
      var isHighSurrogate = 55296 <= code && code < 56320;
      var isLowSurrogate = 56320 <= code && code < 57344;
      if (this.highSurrogate) {
        if (isHighSurrogate || !isLowSurrogate) {
          write32.call(dst, this.highSurrogate, offset);
          offset += 4;
        } else {
          var codepoint = (this.highSurrogate - 55296 << 10 | code - 56320) + 65536;
          write32.call(dst, codepoint, offset);
          offset += 4;
          this.highSurrogate = 0;
          continue;
        }
      }
      if (isHighSurrogate)
        this.highSurrogate = code;
      else {
        write32.call(dst, code, offset);
        offset += 4;
        this.highSurrogate = 0;
      }
    }
    if (offset < dst.length)
      dst = dst.slice(0, offset);
    return dst;
  };
  Utf32Encoder.prototype.end = function() {
    if (!this.highSurrogate)
      return;
    var buf = Buffer2.alloc(4);
    if (this.isLE)
      buf.writeUInt32LE(this.highSurrogate, 0);
    else
      buf.writeUInt32BE(this.highSurrogate, 0);
    this.highSurrogate = 0;
    return buf;
  };
  function Utf32Decoder(options, codec) {
    this.isLE = codec.isLE;
    this.badChar = codec.iconv.defaultCharUnicode.charCodeAt(0);
    this.overflow = [];
  }
  Utf32Decoder.prototype.write = function(src) {
    if (src.length === 0)
      return "";
    var i = 0;
    var codepoint = 0;
    var dst = Buffer2.alloc(src.length + 4);
    var offset = 0;
    var isLE = this.isLE;
    var overflow = this.overflow;
    var badChar = this.badChar;
    if (overflow.length > 0) {
      for (;i < src.length && overflow.length < 4; i++)
        overflow.push(src[i]);
      if (overflow.length === 4) {
        if (isLE) {
          codepoint = overflow[i] | overflow[i + 1] << 8 | overflow[i + 2] << 16 | overflow[i + 3] << 24;
        } else {
          codepoint = overflow[i + 3] | overflow[i + 2] << 8 | overflow[i + 1] << 16 | overflow[i] << 24;
        }
        overflow.length = 0;
        offset = _writeCodepoint(dst, offset, codepoint, badChar);
      }
    }
    for (;i < src.length - 3; i += 4) {
      if (isLE) {
        codepoint = src[i] | src[i + 1] << 8 | src[i + 2] << 16 | src[i + 3] << 24;
      } else {
        codepoint = src[i + 3] | src[i + 2] << 8 | src[i + 1] << 16 | src[i] << 24;
      }
      offset = _writeCodepoint(dst, offset, codepoint, badChar);
    }
    for (;i < src.length; i++) {
      overflow.push(src[i]);
    }
    return dst.slice(0, offset).toString("ucs2");
  };
  function _writeCodepoint(dst, offset, codepoint, badChar) {
    if (codepoint < 0 || codepoint > 1114111) {
      codepoint = badChar;
    }
    if (codepoint >= 65536) {
      codepoint -= 65536;
      var high = 55296 | codepoint >> 10;
      dst[offset++] = high & 255;
      dst[offset++] = high >> 8;
      var codepoint = 56320 | codepoint & 1023;
    }
    dst[offset++] = codepoint & 255;
    dst[offset++] = codepoint >> 8;
    return offset;
  }
  Utf32Decoder.prototype.end = function() {
    this.overflow.length = 0;
  };
  exports.utf32 = Utf32AutoCodec;
  exports.ucs4 = "utf32";
  function Utf32AutoCodec(options, iconv) {
    this.iconv = iconv;
  }
  Utf32AutoCodec.prototype.encoder = Utf32AutoEncoder;
  Utf32AutoCodec.prototype.decoder = Utf32AutoDecoder;
  function Utf32AutoEncoder(options, codec) {
    options = options || {};
    if (options.addBOM === undefined)
      options.addBOM = true;
    this.encoder = codec.iconv.getEncoder(options.defaultEncoding || "utf-32le", options);
  }
  Utf32AutoEncoder.prototype.write = function(str) {
    return this.encoder.write(str);
  };
  Utf32AutoEncoder.prototype.end = function() {
    return this.encoder.end();
  };
  function Utf32AutoDecoder(options, codec) {
    this.decoder = null;
    this.initialBufs = [];
    this.initialBufsLen = 0;
    this.options = options || {};
    this.iconv = codec.iconv;
  }
  Utf32AutoDecoder.prototype.write = function(buf) {
    if (!this.decoder) {
      this.initialBufs.push(buf);
      this.initialBufsLen += buf.length;
      if (this.initialBufsLen < 32)
        return "";
      var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding, this.options);
      var resStr = "";
      for (var i = 0;i < this.initialBufs.length; i++)
        resStr += this.decoder.write(this.initialBufs[i]);
      this.initialBufs.length = this.initialBufsLen = 0;
      return resStr;
    }
    return this.decoder.write(buf);
  };
  Utf32AutoDecoder.prototype.end = function() {
    if (!this.decoder) {
      var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding, this.options);
      var resStr = "";
      for (var i = 0;i < this.initialBufs.length; i++)
        resStr += this.decoder.write(this.initialBufs[i]);
      var trail = this.decoder.end();
      if (trail)
        resStr += trail;
      this.initialBufs.length = this.initialBufsLen = 0;
      return resStr;
    }
    return this.decoder.end();
  };
  function detectEncoding(bufs, defaultEncoding) {
    var b = [];
    var charsProcessed = 0;
    var invalidLE = 0, invalidBE = 0;
    var bmpCharsLE = 0, bmpCharsBE = 0;
    outer_loop:
      for (var i = 0;i < bufs.length; i++) {
        var buf = bufs[i];
        for (var j = 0;j < buf.length; j++) {
          b.push(buf[j]);
          if (b.length === 4) {
            if (charsProcessed === 0) {
              if (b[0] === 255 && b[1] === 254 && b[2] === 0 && b[3] === 0) {
                return "utf-32le";
              }
              if (b[0] === 0 && b[1] === 0 && b[2] === 254 && b[3] === 255) {
                return "utf-32be";
              }
            }
            if (b[0] !== 0 || b[1] > 16)
              invalidBE++;
            if (b[3] !== 0 || b[2] > 16)
              invalidLE++;
            if (b[0] === 0 && b[1] === 0 && (b[2] !== 0 || b[3] !== 0))
              bmpCharsBE++;
            if ((b[0] !== 0 || b[1] !== 0) && b[2] === 0 && b[3] === 0)
              bmpCharsLE++;
            b.length = 0;
            charsProcessed++;
            if (charsProcessed >= 100) {
              break outer_loop;
            }
          }
        }
      }
    if (bmpCharsBE - invalidBE > bmpCharsLE - invalidLE)
      return "utf-32be";
    if (bmpCharsBE - invalidBE < bmpCharsLE - invalidLE)
      return "utf-32le";
    return defaultEncoding || "utf-32le";
  }
});

// node_modules/encoding/node_modules/iconv-lite/encodings/utf16.js
var require_utf162 = __commonJS((exports) => {
  var Buffer2 = require_safer().Buffer;
  exports.utf16be = Utf16BECodec;
  function Utf16BECodec() {}
  Utf16BECodec.prototype.encoder = Utf16BEEncoder;
  Utf16BECodec.prototype.decoder = Utf16BEDecoder;
  Utf16BECodec.prototype.bomAware = true;
  function Utf16BEEncoder() {}
  Utf16BEEncoder.prototype.write = function(str) {
    var buf = Buffer2.from(str, "ucs2");
    for (var i = 0;i < buf.length; i += 2) {
      var tmp = buf[i];
      buf[i] = buf[i + 1];
      buf[i + 1] = tmp;
    }
    return buf;
  };
  Utf16BEEncoder.prototype.end = function() {};
  function Utf16BEDecoder() {
    this.overflowByte = -1;
  }
  Utf16BEDecoder.prototype.write = function(buf) {
    if (buf.length == 0)
      return "";
    var buf2 = Buffer2.alloc(buf.length + 1), i = 0, j = 0;
    if (this.overflowByte !== -1) {
      buf2[0] = buf[0];
      buf2[1] = this.overflowByte;
      i = 1;
      j = 2;
    }
    for (;i < buf.length - 1; i += 2, j += 2) {
      buf2[j] = buf[i + 1];
      buf2[j + 1] = buf[i];
    }
    this.overflowByte = i == buf.length - 1 ? buf[buf.length - 1] : -1;
    return buf2.slice(0, j).toString("ucs2");
  };
  Utf16BEDecoder.prototype.end = function() {
    this.overflowByte = -1;
  };
  exports.utf16 = Utf16Codec;
  function Utf16Codec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf16Codec.prototype.encoder = Utf16Encoder;
  Utf16Codec.prototype.decoder = Utf16Decoder;
  function Utf16Encoder(options, codec) {
    options = options || {};
    if (options.addBOM === undefined)
      options.addBOM = true;
    this.encoder = codec.iconv.getEncoder("utf-16le", options);
  }
  Utf16Encoder.prototype.write = function(str) {
    return this.encoder.write(str);
  };
  Utf16Encoder.prototype.end = function() {
    return this.encoder.end();
  };
  function Utf16Decoder(options, codec) {
    this.decoder = null;
    this.initialBufs = [];
    this.initialBufsLen = 0;
    this.options = options || {};
    this.iconv = codec.iconv;
  }
  Utf16Decoder.prototype.write = function(buf) {
    if (!this.decoder) {
      this.initialBufs.push(buf);
      this.initialBufsLen += buf.length;
      if (this.initialBufsLen < 16)
        return "";
      var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding, this.options);
      var resStr = "";
      for (var i = 0;i < this.initialBufs.length; i++)
        resStr += this.decoder.write(this.initialBufs[i]);
      this.initialBufs.length = this.initialBufsLen = 0;
      return resStr;
    }
    return this.decoder.write(buf);
  };
  Utf16Decoder.prototype.end = function() {
    if (!this.decoder) {
      var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding, this.options);
      var resStr = "";
      for (var i = 0;i < this.initialBufs.length; i++)
        resStr += this.decoder.write(this.initialBufs[i]);
      var trail = this.decoder.end();
      if (trail)
        resStr += trail;
      this.initialBufs.length = this.initialBufsLen = 0;
      return resStr;
    }
    return this.decoder.end();
  };
  function detectEncoding(bufs, defaultEncoding) {
    var b = [];
    var charsProcessed = 0;
    var asciiCharsLE = 0, asciiCharsBE = 0;
    outer_loop:
      for (var i = 0;i < bufs.length; i++) {
        var buf = bufs[i];
        for (var j = 0;j < buf.length; j++) {
          b.push(buf[j]);
          if (b.length === 2) {
            if (charsProcessed === 0) {
              if (b[0] === 255 && b[1] === 254)
                return "utf-16le";
              if (b[0] === 254 && b[1] === 255)
                return "utf-16be";
            }
            if (b[0] === 0 && b[1] !== 0)
              asciiCharsBE++;
            if (b[0] !== 0 && b[1] === 0)
              asciiCharsLE++;
            b.length = 0;
            charsProcessed++;
            if (charsProcessed >= 100) {
              break outer_loop;
            }
          }
        }
      }
    if (asciiCharsBE > asciiCharsLE)
      return "utf-16be";
    if (asciiCharsBE < asciiCharsLE)
      return "utf-16le";
    return defaultEncoding || "utf-16le";
  }
});

// node_modules/encoding/node_modules/iconv-lite/encodings/utf7.js
var require_utf72 = __commonJS((exports) => {
  var Buffer2 = require_safer().Buffer;
  exports.utf7 = Utf7Codec;
  exports.unicode11utf7 = "utf7";
  function Utf7Codec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf7Codec.prototype.encoder = Utf7Encoder;
  Utf7Codec.prototype.decoder = Utf7Decoder;
  Utf7Codec.prototype.bomAware = true;
  var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;
  function Utf7Encoder(options, codec) {
    this.iconv = codec.iconv;
  }
  Utf7Encoder.prototype.write = function(str) {
    return Buffer2.from(str.replace(nonDirectChars, function(chunk) {
      return "+" + (chunk === "+" ? "" : this.iconv.encode(chunk, "utf16-be").toString("base64").replace(/=+$/, "")) + "-";
    }.bind(this)));
  };
  Utf7Encoder.prototype.end = function() {};
  function Utf7Decoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = "";
  }
  var base64Regex = /[A-Za-z0-9\/+]/;
  var base64Chars = [];
  for (i = 0;i < 256; i++)
    base64Chars[i] = base64Regex.test(String.fromCharCode(i));
  var i;
  var plusChar = 43;
  var minusChar = 45;
  var andChar = 38;
  Utf7Decoder.prototype.write = function(buf) {
    var res = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
    for (var i2 = 0;i2 < buf.length; i2++) {
      if (!inBase64) {
        if (buf[i2] == plusChar) {
          res += this.iconv.decode(buf.slice(lastI, i2), "ascii");
          lastI = i2 + 1;
          inBase64 = true;
        }
      } else {
        if (!base64Chars[buf[i2]]) {
          if (i2 == lastI && buf[i2] == minusChar) {
            res += "+";
          } else {
            var b64str = base64Accum + this.iconv.decode(buf.slice(lastI, i2), "ascii");
            res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
          }
          if (buf[i2] != minusChar)
            i2--;
          lastI = i2 + 1;
          inBase64 = false;
          base64Accum = "";
        }
      }
    }
    if (!inBase64) {
      res += this.iconv.decode(buf.slice(lastI), "ascii");
    } else {
      var b64str = base64Accum + this.iconv.decode(buf.slice(lastI), "ascii");
      var canBeDecoded = b64str.length - b64str.length % 8;
      base64Accum = b64str.slice(canBeDecoded);
      b64str = b64str.slice(0, canBeDecoded);
      res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
    }
    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;
    return res;
  };
  Utf7Decoder.prototype.end = function() {
    var res = "";
    if (this.inBase64 && this.base64Accum.length > 0)
      res = this.iconv.decode(Buffer2.from(this.base64Accum, "base64"), "utf16-be");
    this.inBase64 = false;
    this.base64Accum = "";
    return res;
  };
  exports.utf7imap = Utf7IMAPCodec;
  function Utf7IMAPCodec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
  Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
  Utf7IMAPCodec.prototype.bomAware = true;
  function Utf7IMAPEncoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = Buffer2.alloc(6);
    this.base64AccumIdx = 0;
  }
  Utf7IMAPEncoder.prototype.write = function(str) {
    var inBase64 = this.inBase64, base64Accum = this.base64Accum, base64AccumIdx = this.base64AccumIdx, buf = Buffer2.alloc(str.length * 5 + 10), bufIdx = 0;
    for (var i2 = 0;i2 < str.length; i2++) {
      var uChar = str.charCodeAt(i2);
      if (32 <= uChar && uChar <= 126) {
        if (inBase64) {
          if (base64AccumIdx > 0) {
            bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
            base64AccumIdx = 0;
          }
          buf[bufIdx++] = minusChar;
          inBase64 = false;
        }
        if (!inBase64) {
          buf[bufIdx++] = uChar;
          if (uChar === andChar)
            buf[bufIdx++] = minusChar;
        }
      } else {
        if (!inBase64) {
          buf[bufIdx++] = andChar;
          inBase64 = true;
        }
        if (inBase64) {
          base64Accum[base64AccumIdx++] = uChar >> 8;
          base64Accum[base64AccumIdx++] = uChar & 255;
          if (base64AccumIdx == base64Accum.length) {
            bufIdx += buf.write(base64Accum.toString("base64").replace(/\//g, ","), bufIdx);
            base64AccumIdx = 0;
          }
        }
      }
    }
    this.inBase64 = inBase64;
    this.base64AccumIdx = base64AccumIdx;
    return buf.slice(0, bufIdx);
  };
  Utf7IMAPEncoder.prototype.end = function() {
    var buf = Buffer2.alloc(10), bufIdx = 0;
    if (this.inBase64) {
      if (this.base64AccumIdx > 0) {
        bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
        this.base64AccumIdx = 0;
      }
      buf[bufIdx++] = minusChar;
      this.inBase64 = false;
    }
    return buf.slice(0, bufIdx);
  };
  function Utf7IMAPDecoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = "";
  }
  var base64IMAPChars = base64Chars.slice();
  base64IMAPChars[44] = true;
  Utf7IMAPDecoder.prototype.write = function(buf) {
    var res = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
    for (var i2 = 0;i2 < buf.length; i2++) {
      if (!inBase64) {
        if (buf[i2] == andChar) {
          res += this.iconv.decode(buf.slice(lastI, i2), "ascii");
          lastI = i2 + 1;
          inBase64 = true;
        }
      } else {
        if (!base64IMAPChars[buf[i2]]) {
          if (i2 == lastI && buf[i2] == minusChar) {
            res += "&";
          } else {
            var b64str = base64Accum + this.iconv.decode(buf.slice(lastI, i2), "ascii").replace(/,/g, "/");
            res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
          }
          if (buf[i2] != minusChar)
            i2--;
          lastI = i2 + 1;
          inBase64 = false;
          base64Accum = "";
        }
      }
    }
    if (!inBase64) {
      res += this.iconv.decode(buf.slice(lastI), "ascii");
    } else {
      var b64str = base64Accum + this.iconv.decode(buf.slice(lastI), "ascii").replace(/,/g, "/");
      var canBeDecoded = b64str.length - b64str.length % 8;
      base64Accum = b64str.slice(canBeDecoded);
      b64str = b64str.slice(0, canBeDecoded);
      res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
    }
    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;
    return res;
  };
  Utf7IMAPDecoder.prototype.end = function() {
    var res = "";
    if (this.inBase64 && this.base64Accum.length > 0)
      res = this.iconv.decode(Buffer2.from(this.base64Accum, "base64"), "utf16-be");
    this.inBase64 = false;
    this.base64Accum = "";
    return res;
  };
});

// node_modules/encoding/node_modules/iconv-lite/encodings/sbcs-codec.js
var require_sbcs_codec2 = __commonJS((exports) => {
  var Buffer2 = require_safer().Buffer;
  exports._sbcs = SBCSCodec;
  function SBCSCodec(codecOptions, iconv) {
    if (!codecOptions)
      throw new Error("SBCS codec is called without the data.");
    if (!codecOptions.chars || codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256)
      throw new Error("Encoding '" + codecOptions.type + "' has incorrect 'chars' (must be of len 128 or 256)");
    if (codecOptions.chars.length === 128) {
      var asciiString = "";
      for (var i = 0;i < 128; i++)
        asciiString += String.fromCharCode(i);
      codecOptions.chars = asciiString + codecOptions.chars;
    }
    this.decodeBuf = Buffer2.from(codecOptions.chars, "ucs2");
    var encodeBuf = Buffer2.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0));
    for (var i = 0;i < codecOptions.chars.length; i++)
      encodeBuf[codecOptions.chars.charCodeAt(i)] = i;
    this.encodeBuf = encodeBuf;
  }
  SBCSCodec.prototype.encoder = SBCSEncoder;
  SBCSCodec.prototype.decoder = SBCSDecoder;
  function SBCSEncoder(options, codec) {
    this.encodeBuf = codec.encodeBuf;
  }
  SBCSEncoder.prototype.write = function(str) {
    var buf = Buffer2.alloc(str.length);
    for (var i = 0;i < str.length; i++)
      buf[i] = this.encodeBuf[str.charCodeAt(i)];
    return buf;
  };
  SBCSEncoder.prototype.end = function() {};
  function SBCSDecoder(options, codec) {
    this.decodeBuf = codec.decodeBuf;
  }
  SBCSDecoder.prototype.write = function(buf) {
    var decodeBuf = this.decodeBuf;
    var newBuf = Buffer2.alloc(buf.length * 2);
    var idx1 = 0, idx2 = 0;
    for (var i = 0;i < buf.length; i++) {
      idx1 = buf[i] * 2;
      idx2 = i * 2;
      newBuf[idx2] = decodeBuf[idx1];
      newBuf[idx2 + 1] = decodeBuf[idx1 + 1];
    }
    return newBuf.toString("ucs2");
  };
  SBCSDecoder.prototype.end = function() {};
});

// node_modules/encoding/node_modules/iconv-lite/encodings/sbcs-data.js
var require_sbcs_data2 = __commonJS((exports, module) => {
  module.exports = {
    "10029": "maccenteuro",
    maccenteuro: {
      type: "_sbcs",
      chars: ""
    },
    "808": "cp808",
    ibm808: "cp808",
    cp808: {
      type: "_sbcs",
      chars: ""
    },
    mik: {
      type: "_sbcs",
      chars: ""
    },
    cp720: {
      type: "_sbcs",
      chars: ""
    },
    ascii8bit: "ascii",
    usascii: "ascii",
    ansix34: "ascii",
    ansix341968: "ascii",
    ansix341986: "ascii",
    csascii: "ascii",
    cp367: "ascii",
    ibm367: "ascii",
    isoir6: "ascii",
    iso646us: "ascii",
    iso646irv: "ascii",
    us: "ascii",
    latin1: "iso88591",
    latin2: "iso88592",
    latin3: "iso88593",
    latin4: "iso88594",
    latin5: "iso88599",
    latin6: "iso885910",
    latin7: "iso885913",
    latin8: "iso885914",
    latin9: "iso885915",
    latin10: "iso885916",
    csisolatin1: "iso88591",
    csisolatin2: "iso88592",
    csisolatin3: "iso88593",
    csisolatin4: "iso88594",
    csisolatincyrillic: "iso88595",
    csisolatinarabic: "iso88596",
    csisolatingreek: "iso88597",
    csisolatinhebrew: "iso88598",
    csisolatin5: "iso88599",
    csisolatin6: "iso885910",
    l1: "iso88591",
    l2: "iso88592",
    l3: "iso88593",
    l4: "iso88594",
    l5: "iso88599",
    l6: "iso885910",
    l7: "iso885913",
    l8: "iso885914",
    l9: "iso885915",
    l10: "iso885916",
    isoir14: "iso646jp",
    isoir57: "iso646cn",
    isoir100: "iso88591",
    isoir101: "iso88592",
    isoir109: "iso88593",
    isoir110: "iso88594",
    isoir144: "iso88595",
    isoir127: "iso88596",
    isoir126: "iso88597",
    isoir138: "iso88598",
    isoir148: "iso88599",
    isoir157: "iso885910",
    isoir166: "tis620",
    isoir179: "iso885913",
    isoir199: "iso885914",
    isoir203: "iso885915",
    isoir226: "iso885916",
    cp819: "iso88591",
    ibm819: "iso88591",
    cyrillic: "iso88595",
    arabic: "iso88596",
    arabic8: "iso88596",
    ecma114: "iso88596",
    asmo708: "iso88596",
    greek: "iso88597",
    greek8: "iso88597",
    ecma118: "iso88597",
    elot928: "iso88597",
    hebrew: "iso88598",
    hebrew8: "iso88598",
    turkish: "iso88599",
    turkish8: "iso88599",
    thai: "iso885911",
    thai8: "iso885911",
    celtic: "iso885914",
    celtic8: "iso885914",
    isoceltic: "iso885914",
    tis6200: "tis620",
    tis62025291: "tis620",
    tis62025330: "tis620",
    "10000": "macroman",
    "10006": "macgreek",
    "10007": "maccyrillic",
    "10079": "maciceland",
    "10081": "macturkish",
    cspc8codepage437: "cp437",
    cspc775baltic: "cp775",
    cspc850multilingual: "cp850",
    cspcp852: "cp852",
    cspc862latinhebrew: "cp862",
    cpgr: "cp869",
    msee: "cp1250",
    mscyrl: "cp1251",
    msansi: "cp1252",
    msgreek: "cp1253",
    msturk: "cp1254",
    mshebr: "cp1255",
    msarab: "cp1256",
    winbaltrim: "cp1257",
    cp20866: "koi8r",
    "20866": "koi8r",
    ibm878: "koi8r",
    cskoi8r: "koi8r",
    cp21866: "koi8u",
    "21866": "koi8u",
    ibm1168: "koi8u",
    strk10482002: "rk1048",
    tcvn5712: "tcvn",
    tcvn57121: "tcvn",
    gb198880: "iso646cn",
    cn: "iso646cn",
    csiso14jisc6220ro: "iso646jp",
    jisc62201969ro: "iso646jp",
    jp: "iso646jp",
    cshproman8: "hproman8",
    r8: "hproman8",
    roman8: "hproman8",
    xroman8: "hproman8",
    ibm1051: "hproman8",
    mac: "macintosh",
    csmacintosh: "macintosh"
  };
});

// node_modules/encoding/node_modules/iconv-lite/encodings/sbcs-data-generated.js
var require_sbcs_data_generated2 = __commonJS((exports, module) => {
  module.exports = {
    "437": "cp437",
    "737": "cp737",
    "775": "cp775",
    "850": "cp850",
    "852": "cp852",
    "855": "cp855",
    "856": "cp856",
    "857": "cp857",
    "858": "cp858",
    "860": "cp860",
    "861": "cp861",
    "862": "cp862",
    "863": "cp863",
    "864": "cp864",
    "865": "cp865",
    "866": "cp866",
    "869": "cp869",
    "874": "windows874",
    "922": "cp922",
    "1046": "cp1046",
    "1124": "cp1124",
    "1125": "cp1125",
    "1129": "cp1129",
    "1133": "cp1133",
    "1161": "cp1161",
    "1162": "cp1162",
    "1163": "cp1163",
    "1250": "windows1250",
    "1251": "windows1251",
    "1252": "windows1252",
    "1253": "windows1253",
    "1254": "windows1254",
    "1255": "windows1255",
    "1256": "windows1256",
    "1257": "windows1257",
    "1258": "windows1258",
    "28591": "iso88591",
    "28592": "iso88592",
    "28593": "iso88593",
    "28594": "iso88594",
    "28595": "iso88595",
    "28596": "iso88596",
    "28597": "iso88597",
    "28598": "iso88598",
    "28599": "iso88599",
    "28600": "iso885910",
    "28601": "iso885911",
    "28603": "iso885913",
    "28604": "iso885914",
    "28605": "iso885915",
    "28606": "iso885916",
    windows874: {
      type: "_sbcs",
      chars: ""
    },
    win874: "windows874",
    cp874: "windows874",
    windows1250: {
      type: "_sbcs",
      chars: ""
    },
    win1250: "windows1250",
    cp1250: "windows1250",
    windows1251: {
      type: "_sbcs",
      chars: ""
    },
    win1251: "windows1251",
    cp1251: "windows1251",
    windows1252: {
      type: "_sbcs",
      chars: ""
    },
    win1252: "windows1252",
    cp1252: "windows1252",
    windows1253: {
      type: "_sbcs",
      chars: ""
    },
    win1253: "windows1253",
    cp1253: "windows1253",
    windows1254: {
      type: "_sbcs",
      chars: ""
    },
    win1254: "windows1254",
    cp1254: "windows1254",
    windows1255: {
      type: "_sbcs",
      chars: ""
    },
    win1255: "windows1255",
    cp1255: "windows1255",
    windows1256: {
      type: "_sbcs",
      chars: ""
    },
    win1256: "windows1256",
    cp1256: "windows1256",
    windows1257: {
      type: "_sbcs",
      chars: ""
    },
    win1257: "windows1257",
    cp1257: "windows1257",
    windows1258: {
      type: "_sbcs",
      chars: ""
    },
    win1258: "windows1258",
    cp1258: "windows1258",
    iso88591: {
      type: "_sbcs",
      chars: ""
    },
    cp28591: "iso88591",
    iso88592: {
      type: "_sbcs",
      chars: ""
    },
    cp28592: "iso88592",
    iso88593: {
      type: "_sbcs",
      chars: ""
    },
    cp28593: "iso88593",
    iso88594: {
      type: "_sbcs",
      chars: ""
    },
    cp28594: "iso88594",
    iso88595: {
      type: "_sbcs",
      chars: ""
    },
    cp28595: "iso88595",
    iso88596: {
      type: "_sbcs",
      chars: ""
    },
    cp28596: "iso88596",
    iso88597: {
      type: "_sbcs",
      chars: ""
    },
    cp28597: "iso88597",
    iso88598: {
      type: "_sbcs",
      chars: ""
    },
    cp28598: "iso88598",
    iso88599: {
      type: "_sbcs",
      chars: ""
    },
    cp28599: "iso88599",
    iso885910: {
      type: "_sbcs",
      chars: ""
    },
    cp28600: "iso885910",
    iso885911: {
      type: "_sbcs",
      chars: ""
    },
    cp28601: "iso885911",
    iso885913: {
      type: "_sbcs",
      chars: ""
    },
    cp28603: "iso885913",
    iso885914: {
      type: "_sbcs",
      chars: ""
    },
    cp28604: "iso885914",
    iso885915: {
      type: "_sbcs",
      chars: ""
    },
    cp28605: "iso885915",
    iso885916: {
      type: "_sbcs",
      chars: ""
    },
    cp28606: "iso885916",
    cp437: {
      type: "_sbcs",
      chars: ""
    },
    ibm437: "cp437",
    csibm437: "cp437",
    cp737: {
      type: "_sbcs",
      chars: ""
    },
    ibm737: "cp737",
    csibm737: "cp737",
    cp775: {
      type: "_sbcs",
      chars: ""
    },
    ibm775: "cp775",
    csibm775: "cp775",
    cp850: {
      type: "_sbcs",
      chars: ""
    },
    ibm850: "cp850",
    csibm850: "cp850",
    cp852: {
      type: "_sbcs",
      chars: ""
    },
    ibm852: "cp852",
    csibm852: "cp852",
    cp855: {
      type: "_sbcs",
      chars: ""
    },
    ibm855: "cp855",
    csibm855: "cp855",
    cp856: {
      type: "_sbcs",
      chars: ""
    },
    ibm856: "cp856",
    csibm856: "cp856",
    cp857: {
      type: "_sbcs",
      chars: ""
    },
    ibm857: "cp857",
    csibm857: "cp857",
    cp858: {
      type: "_sbcs",
      chars: ""
    },
    ibm858: "cp858",
    csibm858: "cp858",
    cp860: {
      type: "_sbcs",
      chars: ""
    },
    ibm860: "cp860",
    csibm860: "cp860",
    cp861: {
      type: "_sbcs",
      chars: ""
    },
    ibm861: "cp861",
    csibm861: "cp861",
    cp862: {
      type: "_sbcs",
      chars: ""
    },
    ibm862: "cp862",
    csibm862: "cp862",
    cp863: {
      type: "_sbcs",
      chars: ""
    },
    ibm863: "cp863",
    csibm863: "cp863",
    cp864: {
      type: "_sbcs",
      chars: `\x00\x01\x02\x03\x04\x05\x06\x07\b	
\v\f\r\x0E\x0F\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1A\x1B\x1C\x1D\x1E\x1F !"#$&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_\`abcdefghijklmnopqrstuvwxyz{|}~`
    },
    ibm864: "cp864",
    csibm864: "cp864",
    cp865: {
      type: "_sbcs",
      chars: ""
    },
    ibm865: "cp865",
    csibm865: "cp865",
    cp866: {
      type: "_sbcs",
      chars: ""
    },
    ibm866: "cp866",
    csibm866: "cp866",
    cp869: {
      type: "_sbcs",
      chars: ""
    },
    ibm869: "cp869",
    csibm869: "cp869",
    cp922: {
      type: "_sbcs",
      chars: ""
    },
    ibm922: "cp922",
    csibm922: "cp922",
    cp1046: {
      type: "_sbcs",
      chars: ""
    },
    ibm1046: "cp1046",
    csibm1046: "cp1046",
    cp1124: {
      type: "_sbcs",
      chars: ""
    },
    ibm1124: "cp1124",
    csibm1124: "cp1124",
    cp1125: {
      type: "_sbcs",
      chars: ""
    },
    ibm1125: "cp1125",
    csibm1125: "cp1125",
    cp1129: {
      type: "_sbcs",
      chars: ""
    },
    ibm1129: "cp1129",
    csibm1129: "cp1129",
    cp1133: {
      type: "_sbcs",
      chars: ""
    },
    ibm1133: "cp1133",
    csibm1133: "cp1133",
    cp1161: {
      type: "_sbcs",
      chars: ""
    },
    ibm1161: "cp1161",
    csibm1161: "cp1161",
    cp1162: {
      type: "_sbcs",
      chars: ""
    },
    ibm1162: "cp1162",
    csibm1162: "cp1162",
    cp1163: {
      type: "_sbcs",
      chars: ""
    },
    ibm1163: "cp1163",
    csibm1163: "cp1163",
    maccroatian: {
      type: "_sbcs",
      chars: ""
    },
    maccyrillic: {
      type: "_sbcs",
      chars: ""
    },
    macgreek: {
      type: "_sbcs",
      chars: ""
    },
    maciceland: {
      type: "_sbcs",
      chars: ""
    },
    macroman: {
      type: "_sbcs",
      chars: ""
    },
    macromania: {
      type: "_sbcs",
      chars: ""
    },
    macthai: {
      type: "_sbcs",
      chars: "\uFEFF"
    },
    macturkish: {
      type: "_sbcs",
      chars: ""
    },
    macukraine: {
      type: "_sbcs",
      chars: ""
    },
    koi8r: {
      type: "_sbcs",
      chars: ""
    },
    koi8u: {
      type: "_sbcs",
      chars: ""
    },
    koi8ru: {
      type: "_sbcs",
      chars: ""
    },
    koi8t: {
      type: "_sbcs",
      chars: ""
    },
    armscii8: {
      type: "_sbcs",
      chars: ")(.,-"
    },
    rk1048: {
      type: "_sbcs",
      chars: ""
    },
    tcvn: {
      type: "_sbcs",
      chars: `\x00\x03\x07\b	
\v\f\r\x0E\x0F\x10\x18\x19\x1A\x1B\x1C\x1D\x1E\x1F !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_\`abcdefghijklmnopqrstuvwxyz{|}~`
    },
    georgianacademy: {
      type: "_sbcs",
      chars: ""
    },
    georgianps: {
      type: "_sbcs",
      chars: ""
    },
    pt154: {
      type: "_sbcs",
      chars: ""
    },
    viscii: {
      type: "_sbcs",
      chars: `\x00\x01\x03\x04\x07\b	
\v\f\r\x0E\x0F\x10\x11\x12\x13\x15\x16\x17\x18\x1A\x1B\x1C\x1D\x1F !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_\`abcdefghijklmnopqrstuvwxyz{|}~`
    },
    iso646cn: {
      type: "_sbcs",
      chars: `\x00\x01\x02\x03\x04\x05\x06\x07\b	
\v\f\r\x0E\x0F\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1A\x1B\x1C\x1D\x1E\x1F !"#%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_\`abcdefghijklmnopqrstuvwxyz{|}`
    },
    iso646jp: {
      type: "_sbcs",
      chars: `\x00\x01\x02\x03\x04\x05\x06\x07\b	
\v\f\r\x0E\x0F\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1A\x1B\x1C\x1D\x1E\x1F !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_\`abcdefghijklmnopqrstuvwxyz{|}`
    },
    hproman8: {
      type: "_sbcs",
      chars: ""
    },
    macintosh: {
      type: "_sbcs",
      chars: ""
    },
    ascii: {
      type: "_sbcs",
      chars: ""
    },
    tis620: {
      type: "_sbcs",
      chars: ""
    }
  };
});

// node_modules/encoding/node_modules/iconv-lite/encodings/dbcs-codec.js
var require_dbcs_codec2 = __commonJS((exports) => {
  var Buffer2 = require_safer().Buffer;
  exports._dbcs = DBCSCodec;
  var UNASSIGNED = -1;
  var GB18030_CODE = -2;
  var SEQ_START = -10;
  var NODE_START = -1000;
  var UNASSIGNED_NODE = new Array(256);
  var DEF_CHAR = -1;
  for (i = 0;i < 256; i++)
    UNASSIGNED_NODE[i] = UNASSIGNED;
  var i;
  function DBCSCodec(codecOptions, iconv) {
    this.encodingName = codecOptions.encodingName;
    if (!codecOptions)
      throw new Error("DBCS codec is called without the data.");
    if (!codecOptions.table)
      throw new Error("Encoding '" + this.encodingName + "' has no data.");
    var mappingTable = codecOptions.table();
    this.decodeTables = [];
    this.decodeTables[0] = UNASSIGNED_NODE.slice(0);
    this.decodeTableSeq = [];
    for (var i2 = 0;i2 < mappingTable.length; i2++)
      this._addDecodeChunk(mappingTable[i2]);
    if (typeof codecOptions.gb18030 === "function") {
      this.gb18030 = codecOptions.gb18030();
      var commonThirdByteNodeIdx = this.decodeTables.length;
      this.decodeTables.push(UNASSIGNED_NODE.slice(0));
      var commonFourthByteNodeIdx = this.decodeTables.length;
      this.decodeTables.push(UNASSIGNED_NODE.slice(0));
      var firstByteNode = this.decodeTables[0];
      for (var i2 = 129;i2 <= 254; i2++) {
        var secondByteNode = this.decodeTables[NODE_START - firstByteNode[i2]];
        for (var j = 48;j <= 57; j++) {
          if (secondByteNode[j] === UNASSIGNED) {
            secondByteNode[j] = NODE_START - commonThirdByteNodeIdx;
          } else if (secondByteNode[j] > NODE_START) {
            throw new Error("gb18030 decode tables conflict at byte 2");
          }
          var thirdByteNode = this.decodeTables[NODE_START - secondByteNode[j]];
          for (var k = 129;k <= 254; k++) {
            if (thirdByteNode[k] === UNASSIGNED) {
              thirdByteNode[k] = NODE_START - commonFourthByteNodeIdx;
            } else if (thirdByteNode[k] === NODE_START - commonFourthByteNodeIdx) {
              continue;
            } else if (thirdByteNode[k] > NODE_START) {
              throw new Error("gb18030 decode tables conflict at byte 3");
            }
            var fourthByteNode = this.decodeTables[NODE_START - thirdByteNode[k]];
            for (var l = 48;l <= 57; l++) {
              if (fourthByteNode[l] === UNASSIGNED)
                fourthByteNode[l] = GB18030_CODE;
            }
          }
        }
      }
    }
    this.defaultCharUnicode = iconv.defaultCharUnicode;
    this.encodeTable = [];
    this.encodeTableSeq = [];
    var skipEncodeChars = {};
    if (codecOptions.encodeSkipVals)
      for (var i2 = 0;i2 < codecOptions.encodeSkipVals.length; i2++) {
        var val = codecOptions.encodeSkipVals[i2];
        if (typeof val === "number")
          skipEncodeChars[val] = true;
        else
          for (var j = val.from;j <= val.to; j++)
            skipEncodeChars[j] = true;
      }
    this._fillEncodeTable(0, 0, skipEncodeChars);
    if (codecOptions.encodeAdd) {
      for (var uChar in codecOptions.encodeAdd)
        if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar))
          this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
    }
    this.defCharSB = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];
    if (this.defCharSB === UNASSIGNED)
      this.defCharSB = this.encodeTable[0]["?"];
    if (this.defCharSB === UNASSIGNED)
      this.defCharSB = 63;
  }
  DBCSCodec.prototype.encoder = DBCSEncoder;
  DBCSCodec.prototype.decoder = DBCSDecoder;
  DBCSCodec.prototype._getDecodeTrieNode = function(addr) {
    var bytes = [];
    for (;addr > 0; addr >>>= 8)
      bytes.push(addr & 255);
    if (bytes.length == 0)
      bytes.push(0);
    var node = this.decodeTables[0];
    for (var i2 = bytes.length - 1;i2 > 0; i2--) {
      var val = node[bytes[i2]];
      if (val == UNASSIGNED) {
        node[bytes[i2]] = NODE_START - this.decodeTables.length;
        this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));
      } else if (val <= NODE_START) {
        node = this.decodeTables[NODE_START - val];
      } else
        throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
    }
    return node;
  };
  DBCSCodec.prototype._addDecodeChunk = function(chunk) {
    var curAddr = parseInt(chunk[0], 16);
    var writeTable = this._getDecodeTrieNode(curAddr);
    curAddr = curAddr & 255;
    for (var k = 1;k < chunk.length; k++) {
      var part = chunk[k];
      if (typeof part === "string") {
        for (var l = 0;l < part.length; ) {
          var code = part.charCodeAt(l++);
          if (55296 <= code && code < 56320) {
            var codeTrail = part.charCodeAt(l++);
            if (56320 <= codeTrail && codeTrail < 57344)
              writeTable[curAddr++] = 65536 + (code - 55296) * 1024 + (codeTrail - 56320);
            else
              throw new Error("Incorrect surrogate pair in " + this.encodingName + " at chunk " + chunk[0]);
          } else if (4080 < code && code <= 4095) {
            var len = 4095 - code + 2;
            var seq = [];
            for (var m = 0;m < len; m++)
              seq.push(part.charCodeAt(l++));
            writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
            this.decodeTableSeq.push(seq);
          } else
            writeTable[curAddr++] = code;
        }
      } else if (typeof part === "number") {
        var charCode = writeTable[curAddr - 1] + 1;
        for (var l = 0;l < part; l++)
          writeTable[curAddr++] = charCode++;
      } else
        throw new Error("Incorrect type '" + typeof part + "' given in " + this.encodingName + " at chunk " + chunk[0]);
    }
    if (curAddr > 255)
      throw new Error("Incorrect chunk in " + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
  };
  DBCSCodec.prototype._getEncodeBucket = function(uCode) {
    var high = uCode >> 8;
    if (this.encodeTable[high] === undefined)
      this.encodeTable[high] = UNASSIGNED_NODE.slice(0);
    return this.encodeTable[high];
  };
  DBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 255;
    if (bucket[low] <= SEQ_START)
      this.encodeTableSeq[SEQ_START - bucket[low]][DEF_CHAR] = dbcsCode;
    else if (bucket[low] == UNASSIGNED)
      bucket[low] = dbcsCode;
  };
  DBCSCodec.prototype._setEncodeSequence = function(seq, dbcsCode) {
    var uCode = seq[0];
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 255;
    var node;
    if (bucket[low] <= SEQ_START) {
      node = this.encodeTableSeq[SEQ_START - bucket[low]];
    } else {
      node = {};
      if (bucket[low] !== UNASSIGNED)
        node[DEF_CHAR] = bucket[low];
      bucket[low] = SEQ_START - this.encodeTableSeq.length;
      this.encodeTableSeq.push(node);
    }
    for (var j = 1;j < seq.length - 1; j++) {
      var oldVal = node[uCode];
      if (typeof oldVal === "object")
        node = oldVal;
      else {
        node = node[uCode] = {};
        if (oldVal !== undefined)
          node[DEF_CHAR] = oldVal;
      }
    }
    uCode = seq[seq.length - 1];
    node[uCode] = dbcsCode;
  };
  DBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {
    var node = this.decodeTables[nodeIdx];
    var hasValues = false;
    var subNodeEmpty = {};
    for (var i2 = 0;i2 < 256; i2++) {
      var uCode = node[i2];
      var mbCode = prefix + i2;
      if (skipEncodeChars[mbCode])
        continue;
      if (uCode >= 0) {
        this._setEncodeChar(uCode, mbCode);
        hasValues = true;
      } else if (uCode <= NODE_START) {
        var subNodeIdx = NODE_START - uCode;
        if (!subNodeEmpty[subNodeIdx]) {
          var newPrefix = mbCode << 8 >>> 0;
          if (this._fillEncodeTable(subNodeIdx, newPrefix, skipEncodeChars))
            hasValues = true;
          else
            subNodeEmpty[subNodeIdx] = true;
        }
      } else if (uCode <= SEQ_START) {
        this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
        hasValues = true;
      }
    }
    return hasValues;
  };
  function DBCSEncoder(options, codec) {
    this.leadSurrogate = -1;
    this.seqObj = undefined;
    this.encodeTable = codec.encodeTable;
    this.encodeTableSeq = codec.encodeTableSeq;
    this.defaultCharSingleByte = codec.defCharSB;
    this.gb18030 = codec.gb18030;
  }
  DBCSEncoder.prototype.write = function(str) {
    var newBuf = Buffer2.alloc(str.length * (this.gb18030 ? 4 : 3)), leadSurrogate = this.leadSurrogate, seqObj = this.seqObj, nextChar = -1, i2 = 0, j = 0;
    while (true) {
      if (nextChar === -1) {
        if (i2 == str.length)
          break;
        var uCode = str.charCodeAt(i2++);
      } else {
        var uCode = nextChar;
        nextChar = -1;
      }
      if (55296 <= uCode && uCode < 57344) {
        if (uCode < 56320) {
          if (leadSurrogate === -1) {
            leadSurrogate = uCode;
            continue;
          } else {
            leadSurrogate = uCode;
            uCode = UNASSIGNED;
          }
        } else {
          if (leadSurrogate !== -1) {
            uCode = 65536 + (leadSurrogate - 55296) * 1024 + (uCode - 56320);
            leadSurrogate = -1;
          } else {
            uCode = UNASSIGNED;
          }
        }
      } else if (leadSurrogate !== -1) {
        nextChar = uCode;
        uCode = UNASSIGNED;
        leadSurrogate = -1;
      }
      var dbcsCode = UNASSIGNED;
      if (seqObj !== undefined && uCode != UNASSIGNED) {
        var resCode = seqObj[uCode];
        if (typeof resCode === "object") {
          seqObj = resCode;
          continue;
        } else if (typeof resCode == "number") {
          dbcsCode = resCode;
        } else if (resCode == undefined) {
          resCode = seqObj[DEF_CHAR];
          if (resCode !== undefined) {
            dbcsCode = resCode;
            nextChar = uCode;
          } else {}
        }
        seqObj = undefined;
      } else if (uCode >= 0) {
        var subtable = this.encodeTable[uCode >> 8];
        if (subtable !== undefined)
          dbcsCode = subtable[uCode & 255];
        if (dbcsCode <= SEQ_START) {
          seqObj = this.encodeTableSeq[SEQ_START - dbcsCode];
          continue;
        }
        if (dbcsCode == UNASSIGNED && this.gb18030) {
          var idx = findIdx(this.gb18030.uChars, uCode);
          if (idx != -1) {
            var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
            newBuf[j++] = 129 + Math.floor(dbcsCode / 12600);
            dbcsCode = dbcsCode % 12600;
            newBuf[j++] = 48 + Math.floor(dbcsCode / 1260);
            dbcsCode = dbcsCode % 1260;
            newBuf[j++] = 129 + Math.floor(dbcsCode / 10);
            dbcsCode = dbcsCode % 10;
            newBuf[j++] = 48 + dbcsCode;
            continue;
          }
        }
      }
      if (dbcsCode === UNASSIGNED)
        dbcsCode = this.defaultCharSingleByte;
      if (dbcsCode < 256) {
        newBuf[j++] = dbcsCode;
      } else if (dbcsCode < 65536) {
        newBuf[j++] = dbcsCode >> 8;
        newBuf[j++] = dbcsCode & 255;
      } else if (dbcsCode < 16777216) {
        newBuf[j++] = dbcsCode >> 16;
        newBuf[j++] = dbcsCode >> 8 & 255;
        newBuf[j++] = dbcsCode & 255;
      } else {
        newBuf[j++] = dbcsCode >>> 24;
        newBuf[j++] = dbcsCode >>> 16 & 255;
        newBuf[j++] = dbcsCode >>> 8 & 255;
        newBuf[j++] = dbcsCode & 255;
      }
    }
    this.seqObj = seqObj;
    this.leadSurrogate = leadSurrogate;
    return newBuf.slice(0, j);
  };
  DBCSEncoder.prototype.end = function() {
    if (this.leadSurrogate === -1 && this.seqObj === undefined)
      return;
    var newBuf = Buffer2.alloc(10), j = 0;
    if (this.seqObj) {
      var dbcsCode = this.seqObj[DEF_CHAR];
      if (dbcsCode !== undefined) {
        if (dbcsCode < 256) {
          newBuf[j++] = dbcsCode;
        } else {
          newBuf[j++] = dbcsCode >> 8;
          newBuf[j++] = dbcsCode & 255;
        }
      } else {}
      this.seqObj = undefined;
    }
    if (this.leadSurrogate !== -1) {
      newBuf[j++] = this.defaultCharSingleByte;
      this.leadSurrogate = -1;
    }
    return newBuf.slice(0, j);
  };
  DBCSEncoder.prototype.findIdx = findIdx;
  function DBCSDecoder(options, codec) {
    this.nodeIdx = 0;
    this.prevBytes = [];
    this.decodeTables = codec.decodeTables;
    this.decodeTableSeq = codec.decodeTableSeq;
    this.defaultCharUnicode = codec.defaultCharUnicode;
    this.gb18030 = codec.gb18030;
  }
  DBCSDecoder.prototype.write = function(buf) {
    var newBuf = Buffer2.alloc(buf.length * 2), nodeIdx = this.nodeIdx, prevBytes = this.prevBytes, prevOffset = this.prevBytes.length, seqStart = -this.prevBytes.length, uCode;
    for (var i2 = 0, j = 0;i2 < buf.length; i2++) {
      var curByte = i2 >= 0 ? buf[i2] : prevBytes[i2 + prevOffset];
      var uCode = this.decodeTables[nodeIdx][curByte];
      if (uCode >= 0) {} else if (uCode === UNASSIGNED) {
        uCode = this.defaultCharUnicode.charCodeAt(0);
        i2 = seqStart;
      } else if (uCode === GB18030_CODE) {
        if (i2 >= 3) {
          var ptr = (buf[i2 - 3] - 129) * 12600 + (buf[i2 - 2] - 48) * 1260 + (buf[i2 - 1] - 129) * 10 + (curByte - 48);
        } else {
          var ptr = (prevBytes[i2 - 3 + prevOffset] - 129) * 12600 + ((i2 - 2 >= 0 ? buf[i2 - 2] : prevBytes[i2 - 2 + prevOffset]) - 48) * 1260 + ((i2 - 1 >= 0 ? buf[i2 - 1] : prevBytes[i2 - 1 + prevOffset]) - 129) * 10 + (curByte - 48);
        }
        var idx = findIdx(this.gb18030.gbChars, ptr);
        uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
      } else if (uCode <= NODE_START) {
        nodeIdx = NODE_START - uCode;
        continue;
      } else if (uCode <= SEQ_START) {
        var seq = this.decodeTableSeq[SEQ_START - uCode];
        for (var k = 0;k < seq.length - 1; k++) {
          uCode = seq[k];
          newBuf[j++] = uCode & 255;
          newBuf[j++] = uCode >> 8;
        }
        uCode = seq[seq.length - 1];
      } else
        throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);
      if (uCode >= 65536) {
        uCode -= 65536;
        var uCodeLead = 55296 | uCode >> 10;
        newBuf[j++] = uCodeLead & 255;
        newBuf[j++] = uCodeLead >> 8;
        uCode = 56320 | uCode & 1023;
      }
      newBuf[j++] = uCode & 255;
      newBuf[j++] = uCode >> 8;
      nodeIdx = 0;
      seqStart = i2 + 1;
    }
    this.nodeIdx = nodeIdx;
    this.prevBytes = seqStart >= 0 ? Array.prototype.slice.call(buf, seqStart) : prevBytes.slice(seqStart + prevOffset).concat(Array.prototype.slice.call(buf));
    return newBuf.slice(0, j).toString("ucs2");
  };
  DBCSDecoder.prototype.end = function() {
    var ret = "";
    while (this.prevBytes.length > 0) {
      ret += this.defaultCharUnicode;
      var bytesArr = this.prevBytes.slice(1);
      this.prevBytes = [];
      this.nodeIdx = 0;
      if (bytesArr.length > 0)
        ret += this.write(bytesArr);
    }
    this.prevBytes = [];
    this.nodeIdx = 0;
    return ret;
  };
  function findIdx(table, val) {
    if (table[0] > val)
      return -1;
    var l = 0, r = table.length;
    while (l < r - 1) {
      var mid = l + (r - l + 1 >> 1);
      if (table[mid] <= val)
        l = mid;
      else
        r = mid;
    }
    return l;
  }
});

// node_modules/encoding/node_modules/iconv-lite/encodings/tables/shiftjis.json
var require_shiftjis2 = __commonJS((exports, module) => {
  module.exports = [
    ["0", "\x00", 128],
    ["a1", "", 62],
    ["8140", "", 9, ""],
    ["8180", ""],
    ["81b8", ""],
    ["81c8", ""],
    ["81da", ""],
    ["81f0", ""],
    ["81fc", ""],
    ["824f", "", 9],
    ["8260", "", 25],
    ["8281", "", 25],
    ["829f", "", 82],
    ["8340", "", 62],
    ["8380", "", 22],
    ["839f", "", 16, "", 6],
    ["83bf", "", 16, "", 6],
    ["8440", "", 5, "", 25],
    ["8470", "", 5, "", 7],
    ["8480", "", 17],
    ["849f", ""],
    ["8740", "", 19, "", 9],
    ["875f", ""],
    ["877e", ""],
    ["8780", "", 4, ""],
    ["889f", ""],
    ["8940", ""],
    ["8980", ""],
    ["8a40", ""],
    ["8a80", ""],
    ["8b40", ""],
    ["8b80", ""],
    ["8c40", ""],
    ["8c80", ""],
    ["8d40", ""],
    ["8d80", ""],
    ["8e40", ""],
    ["8e80", ""],
    ["8f40", ""],
    ["8f80", ""],
    ["9040", ""],
    ["9080", ""],
    ["9140", ""],
    ["9180", ""],
    ["9240", ""],
    ["9280", ""],
    ["9340", ""],
    ["9380", ""],
    ["9440", ""],
    ["9480", ""],
    ["9540", ""],
    ["9580", ""],
    ["9640", ""],
    ["9680", ""],
    ["9740", ""],
    ["9780", ""],
    ["9840", ""],
    ["989f", ""],
    ["9940", ""],
    ["9980", ""],
    ["9a40", ""],
    ["9a80", ""],
    ["9b40", ""],
    ["9b80", ""],
    ["9c40", ""],
    ["9c80", ""],
    ["9d40", ""],
    ["9d80", ""],
    ["9e40", ""],
    ["9e80", ""],
    ["9f40", ""],
    ["9f80", ""],
    ["e040", ""],
    ["e080", ""],
    ["e140", ""],
    ["e180", ""],
    ["e240", ""],
    ["e280", ""],
    ["e340", ""],
    ["e380", ""],
    ["e440", ""],
    ["e480", ""],
    ["e540", ""],
    ["e580", ""],
    ["e640", ""],
    ["e680", ""],
    ["e740", ""],
    ["e780", ""],
    ["e840", ""],
    ["e880", ""],
    ["e940", ""],
    ["e980", ""],
    ["ea40", ""],
    ["ea80", ""],
    ["ed40", ""],
    ["ed80", ""],
    ["ee40", ""],
    ["ee80", ""],
    ["eeef", "", 9, ""],
    ["f040", "", 62],
    ["f080", "", 124],
    ["f140", "", 62],
    ["f180", "", 124],
    ["f240", "", 62],
    ["f280", "", 124],
    ["f340", "", 62],
    ["f380", "", 124],
    ["f440", "", 62],
    ["f480", "", 124],
    ["f540", "", 62],
    ["f580", "", 124],
    ["f640", "", 62],
    ["f680", "", 124],
    ["f740", "", 62],
    ["f780", "", 124],
    ["f840", "", 62],
    ["f880", "", 124],
    ["f940", ""],
    ["fa40", "", 9, "", 9, ""],
    ["fa80", ""],
    ["fb40", ""],
    ["fb80", ""],
    ["fc40", ""]
  ];
});

// node_modules/encoding/node_modules/iconv-lite/encodings/tables/eucjp.json
var require_eucjp2 = __commonJS((exports, module) => {
  module.exports = [
    ["0", "\x00", 127],
    ["8ea1", "", 62],
    ["a1a1", "", 9, ""],
    ["a2a1", ""],
    ["a2ba", ""],
    ["a2ca", ""],
    ["a2dc", ""],
    ["a2f2", ""],
    ["a2fe", ""],
    ["a3b0", "", 9],
    ["a3c1", "", 25],
    ["a3e1", "", 25],
    ["a4a1", "", 82],
    ["a5a1", "", 85],
    ["a6a1", "", 16, "", 6],
    ["a6c1", "", 16, "", 6],
    ["a7a1", "", 5, "", 25],
    ["a7d1", "", 5, "", 25],
    ["a8a1", ""],
    ["ada1", "", 19, "", 9],
    ["adc0", ""],
    ["addf", "", 4, ""],
    ["b0a1", ""],
    ["b1a1", ""],
    ["b2a1", ""],
    ["b3a1", ""],
    ["b4a1", ""],
    ["b5a1", ""],
    ["b6a1", ""],
    ["b7a1", ""],
    ["b8a1", ""],
    ["b9a1", ""],
    ["baa1", ""],
    ["bba1", ""],
    ["bca1", ""],
    ["bda1", ""],
    ["bea1", ""],
    ["bfa1", ""],
    ["c0a1", ""],
    ["c1a1", ""],
    ["c2a1", ""],
    ["c3a1", ""],
    ["c4a1", ""],
    ["c5a1", ""],
    ["c6a1", ""],
    ["c7a1", ""],
    ["c8a1", ""],
    ["c9a1", ""],
    ["caa1", ""],
    ["cba1", ""],
    ["cca1", ""],
    ["cda1", ""],
    ["cea1", ""],
    ["cfa1", ""],
    ["d0a1", ""],
    ["d1a1", ""],
    ["d2a1", ""],
    ["d3a1", ""],
    ["d4a1", ""],
    ["d5a1", ""],
    ["d6a1", ""],
    ["d7a1", ""],
    ["d8a1", ""],
    ["d9a1", ""],
    ["daa1", ""],
    ["dba1", ""],
    ["dca1", ""],
    ["dda1", ""],
    ["dea1", ""],
    ["dfa1", ""],
    ["e0a1", ""],
    ["e1a1", ""],
    ["e2a1", ""],
    ["e3a1", ""],
    ["e4a1", ""],
    ["e5a1", ""],
    ["e6a1", ""],
    ["e7a1", ""],
    ["e8a1", ""],
    ["e9a1", ""],
    ["eaa1", ""],
    ["eba1", ""],
    ["eca1", ""],
    ["eda1", ""],
    ["eea1", ""],
    ["efa1", ""],
    ["f0a1", ""],
    ["f1a1", ""],
    ["f2a1", ""],
    ["f3a1", ""],
    ["f4a1", ""],
    ["f9a1", ""],
    ["faa1", ""],
    ["fba1", ""],
    ["fca1", ""],
    ["fcf1", "", 9, ""],
    ["8fa2af", ""],
    ["8fa2c2", ""],
    ["8fa2eb", ""],
    ["8fa6e1", ""],
    ["8fa6e7", ""],
    ["8fa6e9", ""],
    ["8fa6ec", ""],
    ["8fa6f1", ""],
    ["8fa7c2", "", 10, ""],
    ["8fa7f2", "", 10, ""],
    ["8fa9a1", ""],
    ["8fa9a4", ""],
    ["8fa9a6", ""],
    ["8fa9a8", ""],
    ["8fa9ab", ""],
    ["8fa9af", ""],
    ["8fa9c1", ""],
    ["8faaa1", ""],
    ["8faaba", ""],
    ["8faba1", ""],
    ["8fabbd", ""],
    ["8fabc5", ""],
    ["8fb0a1", ""],
    ["8fb1a1", ""],
    ["8fb2a1", "", 4, ""],
    ["8fb3a1", ""],
    ["8fb4a1", ""],
    ["8fb5a1", ""],
    ["8fb6a1", "", 5, "", 4, ""],
    ["8fb7a1", "", 4, ""],
    ["8fb8a1", ""],
    ["8fb9a1", ""],
    ["8fbaa1", "", 4, ""],
    ["8fbba1", ""],
    ["8fbca1", "", 4, ""],
    ["8fbda1", "", 4, ""],
    ["8fbea1", "", 4, ""],
    ["8fbfa1", ""],
    ["8fc0a1", ""],
    ["8fc1a1", ""],
    ["8fc2a1", ""],
    ["8fc3a1", "", 4, ""],
    ["8fc4a1", ""],
    ["8fc5a1", ""],
    ["8fc6a1", ""],
    ["8fc7a1", ""],
    ["8fc8a1", ""],
    ["8fc9a1", "", 4, "", 4, ""],
    ["8fcaa1", ""],
    ["8fcba1", ""],
    ["8fcca1", "", 9, ""],
    ["8fcda1", "", 5, ""],
    ["8fcea1", "", 6, ""],
    ["8fcfa1", ""],
    ["8fd0a1", ""],
    ["8fd1a1", ""],
    ["8fd2a1", "", 5],
    ["8fd3a1", ""],
    ["8fd4a1", "", 4, ""],
    ["8fd5a1", ""],
    ["8fd6a1", ""],
    ["8fd7a1", ""],
    ["8fd8a1", ""],
    ["8fd9a1", "", 4, "", 6, ""],
    ["8fdaa1", "", 4, ""],
    ["8fdba1", "", 6, ""],
    ["8fdca1", "", 4, ""],
    ["8fdda1", "", 4, ""],
    ["8fdea1", "", 4, ""],
    ["8fdfa1", ""],
    ["8fe0a1", ""],
    ["8fe1a1", "", 4, ""],
    ["8fe2a1", ""],
    ["8fe3a1", "", 5, "", 4, ""],
    ["8fe4a1", "", 4, ""],
    ["8fe5a1", "", 4, ""],
    ["8fe6a1", ""],
    ["8fe7a1", ""],
    ["8fe8a1", "", 4, ""],
    ["8fe9a1", "", 4],
    ["8feaa1", "", 4, ""],
    ["8feba1", "", 4, ""],
    ["8feca1", ""],
    ["8feda1", "", 4, "", 4, ""]
  ];
});

// node_modules/encoding/node_modules/iconv-lite/encodings/tables/cp936.json
var require_cp9362 = __commonJS((exports, module) => {
  module.exports = [
    ["0", "\x00", 127, ""],
    ["8140", "", 5, "", 9, "", 6, ""],
    ["8180", "", 6, "", 4, "", 4, "", 5, ""],
    ["8240", "", 4, "", 8, "", 4, "", 11],
    ["8280", "", 10, "", 4, "", 7, "", 5, "", 8, "", 20, "", 4, "", 6, ""],
    ["8340", "", 17, "", 5, "", 10, "", 4, "", 9, ""],
    ["8380", "", 5, "", 13, "", 28, "", 4, "", 4, "", 5],
    ["8440", "", 5, "", 5, ""],
    ["8480", "", 9, "", 4, "", 6, "", 6, "", 9, "", 5, "", 10, "", 7, ""],
    ["8540", "", 9, ""],
    ["8580", "", 4, "", 6, "", 4, "", 4, "", 7, ""],
    ["8640", "", 4, "", 5, "", 4, "", 5, ""],
    ["8680", "", 4, "", 4, "", 5, "", 6, "", 8, "", 4, "", 4, "", 4, ""],
    ["8740", "", 7, "", 11, "", 4, "", 4],
    ["8780", "", 7, "", 6, "", 14, "", 10, "", 6, "", 12, "", 8, "", 5, "", 6],
    ["8840", "", 9, "", 4, "", 4, ""],
    ["8880", "", 4, "", 6, "", 8, "", 6, "", 7, "", 4, "", 4, "", 7],
    ["8940", "", 5, "", 6, "", 4, "", 5, "", 4, "", 16, ""],
    ["8980", "", 4, "", 4, "", 7, "", 17, "", 10, "", 13, "", 5, "", 7, "", 4, ""],
    ["8a40", "", 4, "", 12, ""],
    ["8a80", "", 5, "", 6, "", 4, "", 11, "", 6, "", 4, "", 4, "", 9, "", 5],
    ["8b40", "", 8, "", 17, "", 6, "", 13, ""],
    ["8b80", "", 4, "", 4, "", 5, "", 4, "", 4, "", 22, "", 11, "", 25, "", 7, "", 6],
    ["8c40", "", 7, ""],
    ["8c80", "", 8, "", 4, "", 6, "", 6, "", 6, "", 4, "", 4, "", 4],
    ["8d40", "", 5, "", 5, "", 5, "", 6, "", 9, "", 4],
    ["8d80", "", 5, "", 4, "", 4, "", 4, "", 7, "", 7, "", 10, "", 10, "", 12, "", 21, ""],
    ["8e40", "", 21, "", 12, "", 6, "", 12, ""],
    ["8e80", "", 4, "", 7, "", 4, "", 4, "", 5, "", 6, "", 4, "", 14, "", 4, "", 4, "", 6],
    ["8f40", "", 5, "", 11, "", 8, ""],
    ["8f80", "", 6, "", 14, "", 5, "", 5, "", 4, ""],
    ["9040", "", 4, "", 4, "", 6, ""],
    ["9080", "", 7, "", 4, "", 4, "", 4, "", 4, "", 18, "", 6],
    ["9140", "", 6, "", 6, "", 18, "", 4, ""],
    ["9180", "", 6, "", 8, "", 9, "", 5, "", 4, "", 4, "", 16, "", 13, "", 8, "", 5, "", 4, ""],
    ["9240", "", 6, "", 5, ""],
    ["9280", "", 5, "", 7, "", 6, ""],
    ["9340", "", 6, "", 4, "", 4, "", 5, ""],
    ["9380", "", 5, "", 4, "", 6, "", 4, "", 7, "", 9, "", 6, "", 8, "", 4, "", 6, ""],
    ["9440", "", 24, "", 7, "", 7, "", 4, "", 8],
    ["9480", "", 4, "", 4, "", 14, "", 7, "", 7, ""],
    ["9540", "", 4, "", 4, "", 6, ""],
    ["9580", "", 4, "", 4, "", 8, "", 4, "", 4, "", 25, "", 7, "", 5, ""],
    ["9640", "", 5, "", 4, ""],
    ["9680", "", 7, "", 9, "", 7, "", 4, "", 6, "", 6, "", 5],
    ["9740", "", 7, "", 8, "", 7, "", 9, ""],
    ["9780", "", 6, "", 5, "", 4, "", 9, "", 4, "", 11, "", 7, "", 16, ""],
    ["9840", "", 4, "", 5, "", 9, ""],
    ["9880", "", 7, "", 5, "", 11, "", 9, "", 9, "", 11, "", 5, "", 5, "", 6, "", 4, "", 7, "", 6, ""],
    ["9940", "", 4, "", 10, "", 6, "", 8, "", 4, "", 7, "", 5],
    ["9980", "", 114, "", 6],
    ["9a40", "", 11, "", 7, "", 13, ""],
    ["9a80", "", 4, "", 7, "", 7, "", 6, "", 4, "", 4, "", 7, "", 6, "", 4, "", 4, ""],
    ["9b40", "", 4, ""],
    ["9b80", "", 5, "", 4, "", 4, "", 5, ""],
    ["9c40", "", 7, ""],
    ["9c80", "", 7, "", 7, "", 10, "", 14, "", 4, "", 6, "", 5],
    ["9d40", "", 7, "", 4, "", 9, "", 6, ""],
    ["9d80", "", 9, "", 5, "", 6, "", 12, "", 4, "", 10, "", 5, "", 5, "", 6, "", 10, ""],
    ["9e40", "", 7, "", 32, "", 7, "", 6, "", 6],
    ["9e80", "", 9, "", 17, "", 13, "", 11, "", 12, "", 12, ""],
    ["9f40", "", 6, "", 10, "", 4, "", 10, "", 7, ""],
    ["9f80", "", 13, "", 12, "", 4, "", 4, "", 5, "", 4, "", 4, "", 6, "", 5, "", 8, "", 9, "", 4],
    ["a040", "", 9, "", 5, "", 9, "", 11, "", 19],
    ["a080", "", 9, "", 6, "", 4, "", 11, "", 11, "", 6, ""],
    ["a1a1", "", 7, ""],
    ["a2a1", "", 9],
    ["a2b1", "", 19, "", 19, "", 9],
    ["a2e5", "", 9],
    ["a2f1", "", 11],
    ["a3a1", "", 88, ""],
    ["a4a1", "", 82],
    ["a5a1", "", 85],
    ["a6a1", "", 16, "", 6],
    ["a6c1", "", 16, "", 6],
    ["a6e0", ""],
    ["a6ee", ""],
    ["a6f4", ""],
    ["a7a1", "", 5, "", 25],
    ["a7d1", "", 5, "", 25],
    ["a840", "", 35, "", 6],
    ["a880", "", 7, ""],
    ["a8a1", ""],
    ["a8bd", ""],
    ["a8c0", ""],
    ["a8c5", "", 36],
    ["a940", "", 8, ""],
    ["a959", ""],
    ["a95c", ""],
    ["a960", "", 9, "", 8],
    ["a980", "", 4, ""],
    ["a996", ""],
    ["a9a4", "", 75],
    ["aa40", "", 5, "", 5, "", 8],
    ["aa80", "", 7, "", 10, ""],
    ["ab40", "", 11, "", 4, "", 5, "", 4],
    ["ab80", "", 6, "", 4],
    ["ac40", "", 10, "", 8, "", 5, "", 4, "", 11],
    ["ac80", "", 6, "", 12, "", 4, ""],
    ["ad40", "", 10, "", 7, "", 15, "", 12],
    ["ad80", "", 9, "", 8, "", 6, ""],
    ["ae40", "", 6, "", 7, "", 4, ""],
    ["ae80", "", 7, "", 6, "", 4, ""],
    ["af40", "", 4, ""],
    ["af80", ""],
    ["b040", "", 6, "", 5, "", 4, "", 6, "", 7, ""],
    ["b080", "", 7, "", 8, "", 9, ""],
    ["b140", "", 4, "", 7, "", 10, ""],
    ["b180", "", 4, "", 7, "", 7, ""],
    ["b240", "", 11, "", 5, "", 11, "", 4],
    ["b280", "", 12, "", 8, "", 4, ""],
    ["b340", "", 5, ""],
    ["b380", "", 11, "", 7, "", 6, ""],
    ["b440", "", 7, "", 9],
    ["b480", "", 4, "", 5, "", 6, ""],
    ["b540", "", 5, "", 9, "", 4, "", 14, "", 4, "", 8, ""],
    ["b580", "", 6, "", 4, ""],
    ["b640", "", 6, "", 11, "", 10, "", 4, "", 5, ""],
    ["b680", "", 6, "", 4, ""],
    ["b740", "", 14, "", 5, "", 9, "", 4, "", 16],
    ["b780", "", 6, ""],
    ["b840", "", 4, "", 10, "", 10, "", 9, "", 5, ""],
    ["b880", "", 4, ""],
    ["b940", "", 5, "", 10, "", 6, ""],
    ["b980", "", 7, ""],
    ["ba40", "", 4, "", 4, "", 7, "", 5, ""],
    ["ba80", "", 4, "", 5, "", 12, "", 5, ""],
    ["bb40", "", 9, "", 36, "", 5, "", 9],
    ["bb80", "", 6, "", 4, ""],
    ["bc40", "", 6, "", 6, "", 5, "", 7, "", 13, "", 5],
    ["bc80", "", 14, "", 6, ""],
    ["bd40", "", 54, "", 7],
    ["bd80", "", 32, ""],
    ["be40", "", 12, "", 6, "", 42],
    ["be80", "", 32, ""],
    ["bf40", "", 62],
    ["bf80", "", 4, "", 4, "", 21, ""],
    ["c040", "", 35, "", 23, ""],
    ["c080", "", 6, "", 9, ""],
    ["c140", "", 4, "", 7, "", 4, "", 4, "", 6, ""],
    ["c180", "", 4, "", 4, "", 5, ""],
    ["c240", "", 6, "", 5, ""],
    ["c280", "", 13, "", 5, "", 11, ""],
    ["c340", "", 5, "", 4, "", 6, ""],
    ["c380", "", 12, "", 4, ""],
    ["c440", "", 5, "", 4, "", 4, "", 5, "", 4, ""],
    ["c480", "", 7, "", 5, "", 6, ""],
    ["c540", "", 14, "", 4, "", 5, "", 4, "", 5, ""],
    ["c580", "", 7, "", 7, ""],
    ["c640", ""],
    ["c680", "", 4, "", 9, ""],
    ["c740", "", 4, "", 4, "", 6, "", 6, "", 6, ""],
    ["c780", ""],
    ["c840", "", 4, "", 5, "", 5, "", 7, "", 5, "", 7, ""],
    ["c880", "", 6, "", 4, "", 4, ""],
    ["c940", "", 4, "", 7, "", 12, ""],
    ["c980", "", 4, "", 4, "", 10, ""],
    ["ca40", "", 8, "", 8, "", 9, "", 4, "", 10],
    ["ca80", "", 4, "", 8, ""],
    ["cb40", "", 6, "", 10, "", 6, "", 5, "", 6, "", 6, "", 4, ""],
    ["cb80", "", 5, "", 6, "", 14, ""],
    ["cc40", "", 4, "", 10, "", 15, "", 13, ""],
    ["cc80", "", 11, "", 4, "", 7, ""],
    ["cd40", "", 6, "", 6, "", 4, "", 5, "", 4, "", 4, ""],
    ["cd80", ""],
    ["ce40", "", 6, "", 5, "", 7, ""],
    ["ce80", "", 4, "", 6, "", 4, ""],
    ["cf40", "", 4, "", 4, "", 6, "", 9],
    ["cf80", "", 5, "", 7, "", 4, ""],
    ["d040", "", 13, "", 5, "", 5, "", 5, "", 6, ""],
    ["d080", "", 4, "", 4, "", 5, ""],
    ["d140", "", 4, "", 4, "", 6, "", 5],
    ["d180", "", 4, "", 4, "", 4, ""],
    ["d240", "", 8, "", 24, "", 5, "", 19, ""],
    ["d280", "", 26, ""],
    ["d340", "", 30, "", 6],
    ["d380", "", 4, "", 5, "", 21, ""],
    ["d440", "", 31, "", 8, "", 21],
    ["d480", "", 25, "", 6, ""],
    ["d540", "", 7, "", 7, "", 46],
    ["d580", "", 32, ""],
    ["d640", "", 34, "", 27],
    ["d680", "", 30, ""],
    ["d740", "", 31, "", 4, "", 25],
    ["d780", "", 24, ""],
    ["d840", "", 8, "", 7, "", 5, "", 6, "", 6, "", 6, ""],
    ["d880", "", 6, "", 20, ""],
    ["d940", "", 62],
    ["d980", "", 32, ""],
    ["da40", "", 14, "", 8, "", 4, "", 9, ""],
    ["da80", "", 12, ""],
    ["db40", "", 6, "", 7, "", 4, ""],
    ["db80", "", 4, "", 5, "", 11, ""],
    ["dc40", "", 4, "", 6, "", 6, "", 11, "", 6, "", 7],
    ["dc80", "", 10, "", 21, ""],
    ["dd40", "", 62],
    ["dd80", "", 32, ""],
    ["de40", "", 32, ""],
    ["de80", "", 4, ""],
    ["df40", "", 5, "", 4, "", 4, "", 5, "", 4, "", 6, ""],
    ["df80", "", 4, ""],
    ["e040", "", 19, ""],
    ["e080", "", 10, "", 6, "", 8, ""],
    ["e140", "", 4, "", 6, "", 5, "", 5, ""],
    ["e180", "", 10, "", 9, "", 8, ""],
    ["e240", "", 62],
    ["e280", "", 32, "", 5, ""],
    ["e340", "", 45, "", 16],
    ["e380", "", 7, "", 24, ""],
    ["e440", "", 5, "", 24, "", 31],
    ["e480", "", 32, ""],
    ["e540", "", 51, "", 10],
    ["e580", "", 31, ""],
    ["e640", "", 34, "", 27],
    ["e680", "", 29, ""],
    ["e740", "", 7, "", 54],
    ["e780", "", 32, "", 6, "", 4, ""],
    ["e840", "", 14, "", 43, ""],
    ["e880", "", 20, ""],
    ["e940", "", 7, "", 42],
    ["e980", "", 32, ""],
    ["ea40", "", 27, "", 6, ""],
    ["ea80", "", 4, "", 12, ""],
    ["eb40", "", 9, "", 7, "", 9, "", 6, ""],
    ["eb80", "", 4, ""],
    ["ec40", "", 8, "", 4, "", 18, "", 7],
    ["ec80", "", 4, "", 7, "", 4, "", 4, ""],
    ["ed40", "", 6, "", 46],
    ["ed80", "", 4, "", 23, ""],
    ["ee40", "", 62],
    ["ee80", "", 32, "", 4, "", 6, ""],
    ["ef40", "", 5, "", 37, "", 4],
    ["ef80", "", 30, "", 4, "", 8, ""],
    ["f040", "", 4, "", 28, "", 26],
    ["f080", "", 9, "", 12, "", 4, "", 6, ""],
    ["f140", "", 10, "", 47],
    ["f180", "", 32, ""],
    ["f240", "", 62],
    ["f280", "", 32, ""],
    ["f340", "", 17, "", 6, "", 4, ""],
    ["f380", "", 8, "", 6, ""],
    ["f440", "", 5, "", 10, "", 10, "", 7, "", 5],
    ["f480", "", 32, ""],
    ["f540", "", 62],
    ["f580", "", 32, ""],
    ["f640", "", 62],
    ["f680", "", 32, "", 5, "", 5, "", 4, "", 7, ""],
    ["f740", "", 62],
    ["f780", "", 4, "", 4, ""],
    ["f840", "", 62],
    ["f880", "", 32],
    ["f940", "", 62],
    ["f980", "", 32],
    ["fa40", "", 62],
    ["fa80", "", 32],
    ["fb40", "", 27, "", 9, ""],
    ["fb80", "", 5, "", 8, "", 5, ""],
    ["fc40", "", 8, "", 4, "", 8, "", 6],
    ["fc80", "", 4, "", 5, "", 8, ""],
    ["fd40", "", 4, "", 4, "", 10, "", 38],
    ["fd80", "", 5, "", 11, "", 4, ""],
    ["fe40", ""]
  ];
});

// node_modules/encoding/node_modules/iconv-lite/encodings/tables/gbk-added.json
var require_gbk_added2 = __commonJS((exports, module) => {
  module.exports = [
    ["a140", "", 62],
    ["a180", "", 32],
    ["a240", "", 62],
    ["a280", "", 32],
    ["a2ab", "", 5],
    ["a2e3", ""],
    ["a2ef", ""],
    ["a2fd", ""],
    ["a340", "", 62],
    ["a380", "", 31, ""],
    ["a440", "", 62],
    ["a480", "", 32],
    ["a4f4", "", 10],
    ["a540", "", 62],
    ["a580", "", 32],
    ["a5f7", "", 7],
    ["a640", "", 62],
    ["a680", "", 32],
    ["a6b9", "", 7],
    ["a6d9", "", 6],
    ["a6ec", ""],
    ["a6f3", ""],
    ["a6f6", "", 8],
    ["a740", "", 62],
    ["a780", "", 32],
    ["a7c2", "", 14],
    ["a7f2", "", 12],
    ["a896", "", 10],
    ["a8bc", ""],
    ["a8bf", ""],
    ["a8c1", ""],
    ["a8ea", "", 20],
    ["a958", ""],
    ["a95b", ""],
    ["a95d", ""],
    ["a989", "", 11],
    ["a997", "", 12],
    ["a9f0", "", 14],
    ["aaa1", "", 93],
    ["aba1", "", 93],
    ["aca1", "", 93],
    ["ada1", "", 93],
    ["aea1", "", 93],
    ["afa1", "", 93],
    ["d7fa", "", 4],
    ["f8a1", "", 93],
    ["f9a1", "", 93],
    ["faa1", "", 93],
    ["fba1", "", 93],
    ["fca1", "", 93],
    ["fda1", "", 93],
    ["fe50", ""],
    ["fe80", "", 6, "", 93],
    ["8135f437", ""]
  ];
});

// node_modules/encoding/node_modules/iconv-lite/encodings/tables/gb18030-ranges.json
var require_gb18030_ranges2 = __commonJS((exports, module) => {
  module.exports = { uChars: [128, 165, 169, 178, 184, 216, 226, 235, 238, 244, 248, 251, 253, 258, 276, 284, 300, 325, 329, 334, 364, 463, 465, 467, 469, 471, 473, 475, 477, 506, 594, 610, 712, 716, 730, 930, 938, 962, 970, 1026, 1104, 1106, 8209, 8215, 8218, 8222, 8231, 8241, 8244, 8246, 8252, 8365, 8452, 8454, 8458, 8471, 8482, 8556, 8570, 8596, 8602, 8713, 8720, 8722, 8726, 8731, 8737, 8740, 8742, 8748, 8751, 8760, 8766, 8777, 8781, 8787, 8802, 8808, 8816, 8854, 8858, 8870, 8896, 8979, 9322, 9372, 9548, 9588, 9616, 9622, 9634, 9652, 9662, 9672, 9676, 9680, 9702, 9735, 9738, 9793, 9795, 11906, 11909, 11913, 11917, 11928, 11944, 11947, 11951, 11956, 11960, 11964, 11979, 12284, 12292, 12312, 12319, 12330, 12351, 12436, 12447, 12535, 12543, 12586, 12842, 12850, 12964, 13200, 13215, 13218, 13253, 13263, 13267, 13270, 13384, 13428, 13727, 13839, 13851, 14617, 14703, 14801, 14816, 14964, 15183, 15471, 15585, 16471, 16736, 17208, 17325, 17330, 17374, 17623, 17997, 18018, 18212, 18218, 18301, 18318, 18760, 18811, 18814, 18820, 18823, 18844, 18848, 18872, 19576, 19620, 19738, 19887, 40870, 59244, 59336, 59367, 59413, 59417, 59423, 59431, 59437, 59443, 59452, 59460, 59478, 59493, 63789, 63866, 63894, 63976, 63986, 64016, 64018, 64021, 64025, 64034, 64037, 64042, 65074, 65093, 65107, 65112, 65127, 65132, 65375, 65510, 65536], gbChars: [0, 36, 38, 45, 50, 81, 89, 95, 96, 100, 103, 104, 105, 109, 126, 133, 148, 172, 175, 179, 208, 306, 307, 308, 309, 310, 311, 312, 313, 341, 428, 443, 544, 545, 558, 741, 742, 749, 750, 805, 819, 820, 7922, 7924, 7925, 7927, 7934, 7943, 7944, 7945, 7950, 8062, 8148, 8149, 8152, 8164, 8174, 8236, 8240, 8262, 8264, 8374, 8380, 8381, 8384, 8388, 8390, 8392, 8393, 8394, 8396, 8401, 8406, 8416, 8419, 8424, 8437, 8439, 8445, 8482, 8485, 8496, 8521, 8603, 8936, 8946, 9046, 9050, 9063, 9066, 9076, 9092, 9100, 9108, 9111, 9113, 9131, 9162, 9164, 9218, 9219, 11329, 11331, 11334, 11336, 11346, 11361, 11363, 11366, 11370, 11372, 11375, 11389, 11682, 11686, 11687, 11692, 11694, 11714, 11716, 11723, 11725, 11730, 11736, 11982, 11989, 12102, 12336, 12348, 12350, 12384, 12393, 12395, 12397, 12510, 12553, 12851, 12962, 12973, 13738, 13823, 13919, 13933, 14080, 14298, 14585, 14698, 15583, 15847, 16318, 16434, 16438, 16481, 16729, 17102, 17122, 17315, 17320, 17402, 17418, 17859, 17909, 17911, 17915, 17916, 17936, 17939, 17961, 18664, 18703, 18814, 18962, 19043, 33469, 33470, 33471, 33484, 33485, 33490, 33497, 33501, 33505, 33513, 33520, 33536, 33550, 37845, 37921, 37948, 38029, 38038, 38064, 38065, 38066, 38069, 38075, 38076, 38078, 39108, 39109, 39113, 39114, 39115, 39116, 39265, 39394, 189000] };
});

// node_modules/encoding/node_modules/iconv-lite/encodings/tables/cp949.json
var require_cp9492 = __commonJS((exports, module) => {
  module.exports = [
    ["0", "\x00", 127],
    ["8141", "", 4, "", 6, ""],
    ["8161", "", 9, "", 5, ""],
    ["8181", "", 18, "", 4, "", 6, "", 5, "", 6, "", 7, "", 7, "", 4, "", 4, ""],
    ["8241", "", 7, "", 5],
    ["8261", "", 6, "", 5, ""],
    ["8281", "", 7, "", 7, "", 4, "", 10, "", 5, "", 17, "", 7, "", 6, "", 7, "", 18],
    ["8341", "", 5, "", 5, "", 7],
    ["8361", "", 18, ""],
    ["8381", "", 4, "", 6, "", 5, "", 5, "", 46, "", 6, "", 5, "", 8],
    ["8441", "", 5, "", 8],
    ["8461", "", 18],
    ["8481", "", 7, "", 6, "", 5, "", 10, "", 5, "", 18, "", 5, "", 6, "", 5, "", 26, ""],
    ["8541", "", 5, "", 4, "", 6, "", 4],
    ["8561", "", 5, "", 5, "", 6, ""],
    ["8581", "", 6, "", 6, "", 9, "", 26, "", 29, "", 6, "", 5, ""],
    ["8641", "", 6, "", 5, ""],
    ["8661", "", 6, "", 10],
    ["8681", "", 22, "", 4, "", 6, "", 5, "", 6, "", 22, "", 4, ""],
    ["8741", "", 9, "", 15],
    ["8761", "", 18, ""],
    ["8781", "", 5, "", 7, "", 7, "", 5, "", 6, "", 5, "", 18, "", 6, "", 26, "", 6, "", 4],
    ["8841", "", 4, "", 5, "", 6, "", 4],
    ["8861", "", 4, ""],
    ["8881", "", 15, "", 4, "", 6, "", 5, "", 54, ""],
    ["8941", "", 6, "", 5, ""],
    ["8961", "", 10, "", 5, ""],
    ["8981", "", 21, "", 18, "", 18, "", 6, "", 6, "", 7, "", 15],
    ["8a41", "", 10, "", 6, ""],
    ["8a61", "", 4, "", 18, ""],
    ["8a81", "", 4, "", 19, "", 5, "", 7, "", 5, "", 6, "", 5, "", 4, "", 5, "", 26, ""],
    ["8b41", "", 5, "", 4, "", 6, ""],
    ["8b61", "", 6, "", 8],
    ["8b81", "", 52, "", 4, "", 6, "", 5, "", 18, "", 18],
    ["8c41", "", 15, "", 4],
    ["8c61", "", 6, "", 5, "", 6, "", 5],
    ["8c81", "", 12, "", 26, "", 50, "", 5, "", 16],
    ["8d41", "", 16, "", 8],
    ["8d61", "", 17, ""],
    ["8d81", "", 4, "", 33, "", 6, "", 7, "", 6, "", 9, "", 6, "", 5, "", 6, ""],
    ["8e41", "", 6, "", 5, "", 8],
    ["8e61", "", 4, "", 19],
    ["8e81", "", 13, "", 6, "", 4, "", 6, "", 5, "", 6, "", 5, "", 11, "", 7, "", 6, "", 5, "", 7],
    ["8f41", "", 7, "", 17],
    ["8f61", "", 7, "", 6, "", 4],
    ["8f81", "", 5, "", 7, "", 5, "", 6, "", 5, "", 18, "", 6, "", 26, "", 6, "", 5],
    ["9041", "", 6, "", 5, ""],
    ["9061", "", 5, "", 15],
    ["9081", "", 12, "", 6, "", 5, "", 4, "", 6, "", 4, "", 5, "", 11, "", 33, ""],
    ["9141", "", 6, "", 5],
    ["9161", "", 9, "", 5],
    ["9181", "", 20, "", 4, "", 5, "", 14, "", 33, "", 7, "", 5, "", 6],
    ["9241", "", 7, "", 4, ""],
    ["9261", "", 7, "", 7, "", 4],
    ["9281", "", 21, "", 18, "", 6, "", 7, "", 6, "", 35, ""],
    ["9341", "", 4, ""],
    ["9361", "", 6, "", 8],
    ["9381", "", 37, "", 4, "", 4, "", 6, "", 5, "", 7, "", 22, ""],
    ["9441", "", 5, "", 5, "", 8],
    ["9461", "", 5, "", 6, "", 12],
    ["9481", "", 5, "", 6, "", 6, "", 9, "", 22, "", 4, "", 6, "", 10, "", 6, "", 24],
    ["9541", "", 11, "", 5, ""],
    ["9561", "", 6, "", 5, ""],
    ["9581", "", 6, "", 35, "", 4, "", 4, "", 4, "", 6, "", 5, "", 13, "", 14],
    ["9641", "", 23, ""],
    ["9661", "", 6, "", 5, "", 8],
    ["9681", "", 10, "", 5, "", 13, "", 33, "", 6, "", 44],
    ["9741", "", 16, "", 8],
    ["9761", "", 17, "", 7],
    ["9781", "", 11, "", 5, "", 6, "", 89, ""],
    ["9841", "", 16, "", 5, ""],
    ["9861", "", 6, "", 15],
    ["9881", "", 21, "", 6, "", 5, "", 4, "", 6, "", 5, "", 6, "", 5, "", 6, "", 5, ""],
    ["9941", "", 6, "", 5, ""],
    ["9961", "", 6, "", 5, ""],
    ["9981", "", 8, "", 5, "", 4, "", 11, "", 5, "", 6, "", 6, "", 6, "", 7, "", 6, "", 5, ""],
    ["9a41", "", 16],
    ["9a61", "", 6, "", 6, ""],
    ["9a81", "", 4, "", 6, "", 5, "", 5, "", 6, "", 5, "", 5, "", 33, "", 5, "", 6, ""],
    ["9b41", "", 6, "", 8],
    ["9b61", "", 17, "", 7],
    ["9b81", "", 25, "", 4, "", 5, "", 50, "", 22, ""],
    ["9c41", "", 4, "", 5, "", 5],
    ["9c61", "", 8, "", 6, "", 9],
    ["9c81", "", 8, "", 6, "", 6, "", 9, "", 26, "", 6, "", 5, "", 18, "", 6, "", 12],
    ["9d41", "", 13, "", 8],
    ["9d61", "", 25],
    ["9d81", "", 8, "", 5, "", 9, "", 6, "", 10, "", 6, "", 5, "", 6, "", 5, ""],
    ["9e41", "", 7, "", 9, ""],
    ["9e61", "", 4, "", 6, ""],
    ["9e81", "", 6, "", 6, "", 6, "", 5, "", 10, "", 5, "", 6, "", 5, "", 6, ""],
    ["9f41", "", 5, "", 4, "", 5, ""],
    ["9f61", "", 6, "", 5, ""],
    ["9f81", "", 4, "", 5, "", 6, "", 5, "", 6, "", 4, "", 6, "", 7, "", 4, "", 4, ""],
    ["a041", "", 5, "", 6, ""],
    ["a061", "", 5, "", 13],
    ["a081", "", 4, "", 4, "", 4, "", 6, "", 5, "", 6, "", 5, "", 26, "", 4, "", 5, "", 7, ""],
    ["a141", "", 18, ""],
    ["a161", "", 6, "", 5, ""],
    ["a181", "", 14, "", 5, "", 4, "", 9, ""],
    ["a241", "", 5, "", 18],
    ["a261", "", 6, "", 18],
    ["a281", "", 7, "", 6, "", 7, ""],
    ["a341", "", 6, "", 10, ""],
    ["a361", "", 6, "", 16],
    ["a381", "", 16, "", 4, "", 58, "", 32, ""],
    ["a441", "", 5, ""],
    ["a461", "", 5, "", 12],
    ["a481", "", 28, "", 93],
    ["a541", "", 4, "", 6, "", 5, ""],
    ["a561", "", 17, "", 5, ""],
    ["a581", "", 16, "", 14, "", 9],
    ["a5b0", "", 9],
    ["a5c1", "", 16, "", 6],
    ["a5e1", "", 16, "", 6],
    ["a641", "", 19, ""],
    ["a661", "", 5, "", 5, "", 6],
    ["a681", "", 6, "", 18, "", 7],
    ["a741", "", 4, "", 6, "", 7],
    ["a761", "", 22, ""],
    ["a781", "", 6, "", 5, "", 7, "", 9, "", 9, "", 4, "", 5, "", 4, ""],
    ["a841", "", 10, "", 14],
    ["a861", "", 18, "", 6],
    ["a881", "", 19, "", 11, ""],
    ["a8a6", ""],
    ["a8a8", ""],
    ["a8b1", "", 27, "", 25, "", 14, ""],
    ["a941", "", 14, "", 10],
    ["a961", "", 18],
    ["a981", "", 14, "", 6, "", 27, "", 25, "", 14, ""],
    ["aa41", "", 6, "", 4, ""],
    ["aa61", "", 4, "", 5, "", 6, ""],
    ["aa81", "", 29, "", 82],
    ["ab41", "", 6, "", 5, ""],
    ["ab61", "", 6, "", 5, "", 5],
    ["ab81", "", 8, "", 6, "", 12, "", 85],
    ["ac41", "", 5, "", 6, ""],
    ["ac61", "", 11, "", 4],
    ["ac81", "", 28, "", 5, "", 25],
    ["acd1", "", 5, "", 25],
    ["ad41", "", 6, "", 5, "", 7],
    ["ad61", "", 6, "", 10, ""],
    ["ad81", "", 5, "", 18, ""],
    ["ae41", "", 5, "", 16],
    ["ae61", "", 5, "", 6, "", 4],
    ["ae81", "", 6, "", 5, ""],
    ["af41", "", 19],
    ["af61", "", 13, "", 5, ""],
    ["af81", "", 5, "", 6, "", 5, ""],
    ["b041", "", 5, "", 5, "", 12],
    ["b061", "", 5, "", 19],
    ["b081", "", 13, "", 6, "", 5, "", 7, "", 4, ""],
    ["b141", "", 6, "", 5, ""],
    ["b161", "", 6, "", 5, "", 11],
    ["b181", "", 14, "", 6, ""],
    ["b241", "", 6, "", 5, ""],
    ["b261", "", 18, "", 5, ""],
    ["b281", "", 5, "", 18, "", 6, ""],
    ["b341", "", 19, ""],
    ["b361", "", 5, "", 5, "", 5],
    ["b381", "", 5, "", 5, "", 19, "", 4, ""],
    ["b441", "", 5, "", 6, "", 5],
    ["b461", "", 6, "", 10, ""],
    ["b481", "", 6, "", 18, "", 4, "", 4, ""],
    ["b541", "", 14, "", 5],
    ["b561", "", 5, "", 5, "", 4],
    ["b581", "", 6, "", 5, "", 11, ""],
    ["b641", "", 7, "", 17],
    ["b661", "", 15, ""],
    ["b681", "", 5, "", 6, "", 5, ""],
    ["b741", "", 13, "", 6, ""],
    ["b761", "", 20, ""],
    ["b781", "", 6, "", 14, ""],
    ["b841", "", 7, "", 17],
    ["b861", "", 8, "", 13],
    ["b881", "", 5, "", 24, "", 4, ""],
    ["b941", "", 6, "", 5, ""],
    ["b961", "", 14, "", 6, ""],
    ["b981", "", 22, "", 4, "", 4, ""],
    ["ba41", "", 5, "", 6, ""],
    ["ba61", "", 5, "", 4, "", 5],
    ["ba81", "", 6, "", 9, ""],
    ["bb41", "", 4, "", 5, "", 4, ""],
    ["bb61", "", 6, "", 5, ""],
    ["bb81", "", 31, ""],
    ["bc41", "", 17, ""],
    ["bc61", "", 5, "", 6, ""],
    ["bc81", "", 4, "", 6, "", 5, "", 5, "", 4, ""],
    ["bd41", "", 7, "", 7, ""],
    ["bd61", "", 5, "", 13],
    ["bd81", "", 5, "", 25, ""],
    ["be41", "", 7, "", 14],
    ["be61", "", 7, "", 7, ""],
    ["be81", "", 4, "", 4, "", 5, "", 8, "", 6, ""],
    ["bf41", "", 10, "", 14],
    ["bf61", "", 18, ""],
    ["bf81", "", 5, "", 7, "", 6, "", 5, ""],
    ["c041", "", 5, "", 6, "", 5],
    ["c061", "", 25],
    ["c081", "", 6, "", 5, "", 7, ""],
    ["c141", "", 5, "", 6, ""],
    ["c161", "", 19, ""],
    ["c181", "", 31, ""],
    ["c241", "", 4, "", 5, ""],
    ["c261", "", 4, "", 5, "", 6, ""],
    ["c281", "", 5, "", 7, "", 9, ""],
    ["c341", "", 4],
    ["c361", "", 4, "", 5, "", 11],
    ["c381", "", 5, "", 7, "", 5, ""],
    ["c441", "", 7, "", 7, ""],
    ["c461", "", 5, "", 4],
    ["c481", "", 5, "", 11, ""],
    ["c541", "", 6, "", 5, ""],
    ["c561", "", 6, "", 5, "", 4],
    ["c581", "", 6, "", 5, ""],
    ["c641", "", 6, "", 5],
    ["c6a1", ""],
    ["c7a1", ""],
    ["c8a1", ""],
    ["caa1", ""],
    ["cba1", ""],
    ["cca1", ""],
    ["cda1", ""],
    ["cea1", ""],
    ["cfa1", ""],
    ["d0a1", ""],
    ["d1a1", "", 5, "", 4, ""],
    ["d2a1", "", 4, "", 5, "", 10, "", 7, "", 5, ""],
    ["d3a1", ""],
    ["d4a1", ""],
    ["d5a1", ""],
    ["d6a1", ""],
    ["d7a1", ""],
    ["d8a1", ""],
    ["d9a1", ""],
    ["daa1", ""],
    ["dba1", ""],
    ["dca1", ""],
    ["dda1", ""],
    ["dea1", ""],
    ["dfa1", ""],
    ["e0a1", ""],
    ["e1a1", ""],
    ["e2a1", ""],
    ["e3a1", ""],
    ["e4a1", ""],
    ["e5a1", ""],
    ["e6a1", ""],
    ["e7a1", ""],
    ["e8a1", ""],
    ["e9a1", ""],
    ["eaa1", ""],
    ["eba1", ""],
    ["eca1", ""],
    ["eda1", ""],
    ["eea1", ""],
    ["efa1", ""],
    ["f0a1", ""],
    ["f1a1", ""],
    ["f2a1", ""],
    ["f3a1", ""],
    ["f4a1", ""],
    ["f5a1", ""],
    ["f6a1", ""],
    ["f7a1", ""],
    ["f8a1", ""],
    ["f9a1", ""],
    ["faa1", ""],
    ["fba1", ""],
    ["fca1", ""],
    ["fda1", ""]
  ];
});

// node_modules/encoding/node_modules/iconv-lite/encodings/tables/cp950.json
var require_cp9502 = __commonJS((exports, module) => {
  module.exports = [
    ["0", "\x00", 127],
    ["a140", ""],
    ["a1a1", "", 4, ""],
    ["a240", "", 7, ""],
    ["a2a1", "", 9, "", 9, "", 8, "", 25, "", 21],
    ["a340", "", 16, "", 6, "", 16, "", 6, "", 10],
    ["a3a1", "", 25, ""],
    ["a3e1", ""],
    ["a440", ""],
    ["a4a1", ""],
    ["a540", ""],
    ["a5a1", ""],
    ["a640", ""],
    ["a6a1", ""],
    ["a740", ""],
    ["a7a1", ""],
    ["a840", ""],
    ["a8a1", ""],
    ["a940", ""],
    ["a9a1", ""],
    ["aa40", ""],
    ["aaa1", ""],
    ["ab40", ""],
    ["aba1", ""],
    ["ac40", ""],
    ["aca1", ""],
    ["ad40", ""],
    ["ada1", ""],
    ["ae40", ""],
    ["aea1", ""],
    ["af40", ""],
    ["afa1", ""],
    ["b040", ""],
    ["b0a1", ""],
    ["b140", ""],
    ["b1a1", ""],
    ["b240", ""],
    ["b2a1", ""],
    ["b340", ""],
    ["b3a1", ""],
    ["b440", ""],
    ["b4a1", ""],
    ["b540", ""],
    ["b5a1", ""],
    ["b640", ""],
    ["b6a1", ""],
    ["b740", ""],
    ["b7a1", ""],
    ["b840", ""],
    ["b8a1", ""],
    ["b940", ""],
    ["b9a1", ""],
    ["ba40", ""],
    ["baa1", ""],
    ["bb40", ""],
    ["bba1", ""],
    ["bc40", ""],
    ["bca1", ""],
    ["bd40", ""],
    ["bda1", ""],
    ["be40", ""],
    ["bea1", ""],
    ["bf40", ""],
    ["bfa1", ""],
    ["c040", ""],
    ["c0a1", ""],
    ["c140", ""],
    ["c1a1", ""],
    ["c240", ""],
    ["c2a1", ""],
    ["c340", ""],
    ["c3a1", ""],
    ["c440", ""],
    ["c4a1", ""],
    ["c540", ""],
    ["c5a1", ""],
    ["c640", ""],
    ["c940", ""],
    ["c9a1", ""],
    ["ca40", ""],
    ["caa1", ""],
    ["cb40", ""],
    ["cba1", ""],
    ["cc40", ""],
    ["cca1", ""],
    ["cd40", ""],
    ["cda1", ""],
    ["ce40", ""],
    ["cea1", ""],
    ["cf40", ""],
    ["cfa1", ""],
    ["d040", ""],
    ["d0a1", ""],
    ["d140", ""],
    ["d1a1", ""],
    ["d240", ""],
    ["d2a1", ""],
    ["d340", ""],
    ["d3a1", ""],
    ["d440", ""],
    ["d4a1", ""],
    ["d540", ""],
    ["d5a1", ""],
    ["d640", ""],
    ["d6a1", ""],
    ["d740", ""],
    ["d7a1", ""],
    ["d840", ""],
    ["d8a1", ""],
    ["d940", ""],
    ["d9a1", ""],
    ["da40", ""],
    ["daa1", ""],
    ["db40", ""],
    ["dba1", ""],
    ["dc40", ""],
    ["dca1", ""],
    ["dd40", ""],
    ["dda1", ""],
    ["de40", ""],
    ["dea1", ""],
    ["df40", ""],
    ["dfa1", ""],
    ["e040", ""],
    ["e0a1", ""],
    ["e140", ""],
    ["e1a1", ""],
    ["e240", ""],
    ["e2a1", ""],
    ["e340", ""],
    ["e3a1", ""],
    ["e440", ""],
    ["e4a1", ""],
    ["e540", ""],
    ["e5a1", ""],
    ["e640", ""],
    ["e6a1", ""],
    ["e740", ""],
    ["e7a1", ""],
    ["e840", ""],
    ["e8a1", ""],
    ["e940", ""],
    ["e9a1", ""],
    ["ea40", ""],
    ["eaa1", ""],
    ["eb40", ""],
    ["eba1", ""],
    ["ec40", ""],
    ["eca1", ""],
    ["ed40", ""],
    ["eda1", ""],
    ["ee40", ""],
    ["eea1", ""],
    ["ef40", ""],
    ["efa1", ""],
    ["f040", ""],
    ["f0a1", ""],
    ["f140", ""],
    ["f1a1", ""],
    ["f240", ""],
    ["f2a1", ""],
    ["f340", ""],
    ["f3a1", ""],
    ["f440", ""],
    ["f4a1", ""],
    ["f540", ""],
    ["f5a1", ""],
    ["f640", ""],
    ["f6a1", ""],
    ["f740", ""],
    ["f7a1", ""],
    ["f840", ""],
    ["f8a1", ""],
    ["f940", ""],
    ["f9a1", ""]
  ];
});

// node_modules/encoding/node_modules/iconv-lite/encodings/tables/big5-added.json
var require_big5_added2 = __commonJS((exports, module) => {
  module.exports = [
    ["8740", ""],
    ["8767", ""],
    ["87a1", ""],
    ["8840", "", 4, ""],
    ["88a1", ""],
    ["8940", ""],
    ["8943", ""],
    ["8946", ""],
    ["894c", ""],
    ["89a1", ""],
    ["89ab", ""],
    ["89b0", ""],
    ["89b5", ""],
    ["89c1", ""],
    ["89c5", ""],
    ["8a40", ""],
    ["8a43", ""],
    ["8a64", ""],
    ["8a76", ""],
    ["8aa1", ""],
    ["8aac", ""],
    ["8ab2", ""],
    ["8abb", ""],
    ["8ac9", ""],
    ["8ace", ""],
    ["8adf", ""],
    ["8af6", ""],
    ["8b40", ""],
    ["8b55", ""],
    ["8ba1", ""],
    ["8bde", ""],
    ["8c40", ""],
    ["8ca1", ""],
    ["8ca7", ""],
    ["8cc9", ""],
    ["8cce", ""],
    ["8ce6", ""],
    ["8d40", ""],
    ["8d42", ""],
    ["8da1", ""],
    ["8e40", ""],
    ["8ea1", ""],
    ["8f40", ""],
    ["8fa1", ""],
    ["9040", ""],
    ["90a1", ""],
    ["9140", ""],
    ["91a1", ""],
    ["9240", ""],
    ["92a1", ""],
    ["9340", ""],
    ["93a1", ""],
    ["9440", ""],
    ["94a1", ""],
    ["9540", ""],
    ["95a1", ""],
    ["9640", ""],
    ["96a1", ""],
    ["9740", ""],
    ["97a1", ""],
    ["9840", ""],
    ["98a1", ""],
    ["9940", ""],
    ["99a1", ""],
    ["9a40", ""],
    ["9aa1", ""],
    ["9b40", ""],
    ["9b62", ""],
    ["9ba1", ""],
    ["9c40", ""],
    ["9ca1", ""],
    ["9d40", ""],
    ["9da1", ""],
    ["9e40", ""],
    ["9ea1", ""],
    ["9ead", ""],
    ["9ec5", ""],
    ["9ef5", ""],
    ["9f40", ""],
    ["9f4f", ""],
    ["9fa1", ""],
    ["9fae", ""],
    ["9fb2", ""],
    ["9fc1", ""],
    ["9fc9", ""],
    ["9fdb", ""],
    ["9fe7", ""],
    ["9feb", ""],
    ["9ff0", ""],
    ["a040", ""],
    ["a055", ""],
    ["a058", ""],
    ["a05b", ""],
    ["a063", ""],
    ["a073", ""],
    ["a0a1", ""],
    ["a0a6", ""],
    ["a0ae", ""],
    ["a0b0", ""],
    ["a0d4", ""],
    ["a0e2", ""],
    ["a3c0", "", 31, ""],
    ["c6a1", "", 9, "", 9, "", 9, "", 23],
    ["c740", "", 58, ""],
    ["c7a1", "", 81, "", 5, "", 4],
    ["c840", "", 26, "", 25, ""],
    ["c8a1", ""],
    ["c8cd", ""],
    ["c8f5", ""],
    ["f9fe", ""],
    ["fa40", ""],
    ["faa1", ""],
    ["fb40", ""],
    ["fba1", ""],
    ["fc40", ""],
    ["fca1", ""],
    ["fd40", ""],
    ["fda1", ""],
    ["fe40", ""],
    ["fea1", ""]
  ];
});

// node_modules/encoding/node_modules/iconv-lite/encodings/dbcs-data.js
var require_dbcs_data2 = __commonJS((exports, module) => {
  module.exports = {
    shiftjis: {
      type: "_dbcs",
      table: function() {
        return require_shiftjis2();
      },
      encodeAdd: { "": 92, "": 126 },
      encodeSkipVals: [{ from: 60736, to: 63808 }]
    },
    csshiftjis: "shiftjis",
    mskanji: "shiftjis",
    sjis: "shiftjis",
    windows31j: "shiftjis",
    ms31j: "shiftjis",
    xsjis: "shiftjis",
    windows932: "shiftjis",
    ms932: "shiftjis",
    "932": "shiftjis",
    cp932: "shiftjis",
    eucjp: {
      type: "_dbcs",
      table: function() {
        return require_eucjp2();
      },
      encodeAdd: { "": 92, "": 126 }
    },
    gb2312: "cp936",
    gb231280: "cp936",
    gb23121980: "cp936",
    csgb2312: "cp936",
    csiso58gb231280: "cp936",
    euccn: "cp936",
    windows936: "cp936",
    ms936: "cp936",
    "936": "cp936",
    cp936: {
      type: "_dbcs",
      table: function() {
        return require_cp9362();
      }
    },
    gbk: {
      type: "_dbcs",
      table: function() {
        return require_cp9362().concat(require_gbk_added2());
      }
    },
    xgbk: "gbk",
    isoir58: "gbk",
    gb18030: {
      type: "_dbcs",
      table: function() {
        return require_cp9362().concat(require_gbk_added2());
      },
      gb18030: function() {
        return require_gb18030_ranges2();
      },
      encodeSkipVals: [128],
      encodeAdd: { "": 41699 }
    },
    chinese: "gb18030",
    windows949: "cp949",
    ms949: "cp949",
    "949": "cp949",
    cp949: {
      type: "_dbcs",
      table: function() {
        return require_cp9492();
      }
    },
    cseuckr: "cp949",
    csksc56011987: "cp949",
    euckr: "cp949",
    isoir149: "cp949",
    korean: "cp949",
    ksc56011987: "cp949",
    ksc56011989: "cp949",
    ksc5601: "cp949",
    windows950: "cp950",
    ms950: "cp950",
    "950": "cp950",
    cp950: {
      type: "_dbcs",
      table: function() {
        return require_cp9502();
      }
    },
    big5: "big5hkscs",
    big5hkscs: {
      type: "_dbcs",
      table: function() {
        return require_cp9502().concat(require_big5_added2());
      },
      encodeSkipVals: [
        36457,
        36463,
        36478,
        36523,
        36532,
        36557,
        36560,
        36695,
        36713,
        36718,
        36811,
        36862,
        36973,
        36986,
        37060,
        37084,
        37105,
        37311,
        37551,
        37552,
        37553,
        37554,
        37585,
        37959,
        38090,
        38361,
        38652,
        39285,
        39798,
        39800,
        39803,
        39878,
        39902,
        39916,
        39926,
        40002,
        40019,
        40034,
        40040,
        40043,
        40055,
        40124,
        40125,
        40144,
        40279,
        40282,
        40388,
        40431,
        40443,
        40617,
        40687,
        40701,
        40800,
        40907,
        41079,
        41180,
        41183,
        36812,
        37576,
        38468,
        38637,
        41636,
        41637,
        41639,
        41638,
        41676,
        41678
      ]
    },
    cnbig5: "big5hkscs",
    csbig5: "big5hkscs",
    xxbig5: "big5hkscs"
  };
});

// node_modules/encoding/node_modules/iconv-lite/encodings/index.js
var require_encodings2 = __commonJS((exports, module) => {
  var modules = [
    require_internal2(),
    require_utf32(),
    require_utf162(),
    require_utf72(),
    require_sbcs_codec2(),
    require_sbcs_data2(),
    require_sbcs_data_generated2(),
    require_dbcs_codec2(),
    require_dbcs_data2()
  ];
  for (i = 0;i < modules.length; i++) {
    module = modules[i];
    for (enc in module)
      if (Object.prototype.hasOwnProperty.call(module, enc))
        exports[enc] = module[enc];
  }
  var module;
  var enc;
  var i;
});

// node_modules/encoding/node_modules/iconv-lite/lib/streams.js
var require_streams2 = __commonJS((exports, module) => {
  var Buffer2 = require_safer().Buffer;
  module.exports = function(stream_module) {
    var Transform = stream_module.Transform;
    function IconvLiteEncoderStream(conv, options) {
      this.conv = conv;
      options = options || {};
      options.decodeStrings = false;
      Transform.call(this, options);
    }
    IconvLiteEncoderStream.prototype = Object.create(Transform.prototype, {
      constructor: { value: IconvLiteEncoderStream }
    });
    IconvLiteEncoderStream.prototype._transform = function(chunk, encoding, done) {
      if (typeof chunk != "string")
        return done(new Error("Iconv encoding stream needs strings as its input."));
      try {
        var res = this.conv.write(chunk);
        if (res && res.length)
          this.push(res);
        done();
      } catch (e) {
        done(e);
      }
    };
    IconvLiteEncoderStream.prototype._flush = function(done) {
      try {
        var res = this.conv.end();
        if (res && res.length)
          this.push(res);
        done();
      } catch (e) {
        done(e);
      }
    };
    IconvLiteEncoderStream.prototype.collect = function(cb) {
      var chunks = [];
      this.on("error", cb);
      this.on("data", function(chunk) {
        chunks.push(chunk);
      });
      this.on("end", function() {
        cb(null, Buffer2.concat(chunks));
      });
      return this;
    };
    function IconvLiteDecoderStream(conv, options) {
      this.conv = conv;
      options = options || {};
      options.encoding = this.encoding = "utf8";
      Transform.call(this, options);
    }
    IconvLiteDecoderStream.prototype = Object.create(Transform.prototype, {
      constructor: { value: IconvLiteDecoderStream }
    });
    IconvLiteDecoderStream.prototype._transform = function(chunk, encoding, done) {
      if (!Buffer2.isBuffer(chunk) && !(chunk instanceof Uint8Array))
        return done(new Error("Iconv decoding stream needs buffers as its input."));
      try {
        var res = this.conv.write(chunk);
        if (res && res.length)
          this.push(res, this.encoding);
        done();
      } catch (e) {
        done(e);
      }
    };
    IconvLiteDecoderStream.prototype._flush = function(done) {
      try {
        var res = this.conv.end();
        if (res && res.length)
          this.push(res, this.encoding);
        done();
      } catch (e) {
        done(e);
      }
    };
    IconvLiteDecoderStream.prototype.collect = function(cb) {
      var res = "";
      this.on("error", cb);
      this.on("data", function(chunk) {
        res += chunk;
      });
      this.on("end", function() {
        cb(null, res);
      });
      return this;
    };
    return {
      IconvLiteEncoderStream,
      IconvLiteDecoderStream
    };
  };
});

// node_modules/encoding/node_modules/iconv-lite/lib/index.js
var require_lib4 = __commonJS((exports, module) => {
  var Buffer2 = require_safer().Buffer;
  var bomHandling = require_bom_handling2();
  var iconv = exports;
  iconv.encodings = null;
  iconv.defaultCharUnicode = "";
  iconv.defaultCharSingleByte = "?";
  iconv.encode = function encode(str, encoding, options) {
    str = "" + (str || "");
    var encoder = iconv.getEncoder(encoding, options);
    var res = encoder.write(str);
    var trail = encoder.end();
    return trail && trail.length > 0 ? Buffer2.concat([res, trail]) : res;
  };
  iconv.decode = function decode(buf, encoding, options) {
    if (typeof buf === "string") {
      if (!iconv.skipDecodeWarning) {
        console.error("Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding");
        iconv.skipDecodeWarning = true;
      }
      buf = Buffer2.from("" + (buf || ""), "binary");
    }
    var decoder = iconv.getDecoder(encoding, options);
    var res = decoder.write(buf);
    var trail = decoder.end();
    return trail ? res + trail : res;
  };
  iconv.encodingExists = function encodingExists(enc) {
    try {
      iconv.getCodec(enc);
      return true;
    } catch (e) {
      return false;
    }
  };
  iconv.toEncoding = iconv.encode;
  iconv.fromEncoding = iconv.decode;
  iconv._codecDataCache = {};
  iconv.getCodec = function getCodec(encoding) {
    if (!iconv.encodings)
      iconv.encodings = require_encodings2();
    var enc = iconv._canonicalizeEncoding(encoding);
    var codecOptions = {};
    while (true) {
      var codec = iconv._codecDataCache[enc];
      if (codec)
        return codec;
      var codecDef = iconv.encodings[enc];
      switch (typeof codecDef) {
        case "string":
          enc = codecDef;
          break;
        case "object":
          for (var key in codecDef)
            codecOptions[key] = codecDef[key];
          if (!codecOptions.encodingName)
            codecOptions.encodingName = enc;
          enc = codecDef.type;
          break;
        case "function":
          if (!codecOptions.encodingName)
            codecOptions.encodingName = enc;
          codec = new codecDef(codecOptions, iconv);
          iconv._codecDataCache[codecOptions.encodingName] = codec;
          return codec;
        default:
          throw new Error("Encoding not recognized: '" + encoding + "' (searched as: '" + enc + "')");
      }
    }
  };
  iconv._canonicalizeEncoding = function(encoding) {
    return ("" + encoding).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
  };
  iconv.getEncoder = function getEncoder(encoding, options) {
    var codec = iconv.getCodec(encoding), encoder = new codec.encoder(options, codec);
    if (codec.bomAware && options && options.addBOM)
      encoder = new bomHandling.PrependBOM(encoder, options);
    return encoder;
  };
  iconv.getDecoder = function getDecoder(encoding, options) {
    var codec = iconv.getCodec(encoding), decoder = new codec.decoder(options, codec);
    if (codec.bomAware && !(options && options.stripBOM === false))
      decoder = new bomHandling.StripBOM(decoder, options);
    return decoder;
  };
  iconv.enableStreamingAPI = function enableStreamingAPI(stream_module2) {
    if (iconv.supportsStreams)
      return;
    var streams = require_streams2()(stream_module2);
    iconv.IconvLiteEncoderStream = streams.IconvLiteEncoderStream;
    iconv.IconvLiteDecoderStream = streams.IconvLiteDecoderStream;
    iconv.encodeStream = function encodeStream(encoding, options) {
      return new iconv.IconvLiteEncoderStream(iconv.getEncoder(encoding, options), options);
    };
    iconv.decodeStream = function decodeStream(encoding, options) {
      return new iconv.IconvLiteDecoderStream(iconv.getDecoder(encoding, options), options);
    };
    iconv.supportsStreams = true;
  };
  var stream_module;
  try {
    stream_module = __require("stream");
  } catch (e) {}
  if (stream_module && stream_module.Transform) {
    iconv.enableStreamingAPI(stream_module);
  } else {
    iconv.encodeStream = iconv.decodeStream = function() {
      throw new Error("iconv-lite Streaming API is not enabled. Use iconv.enableStreamingAPI(require('stream')); to enable it.");
    };
  }
  if (false) {}
});

// node_modules/encoding/lib/encoding.js
var require_encoding2 = __commonJS((exports, module) => {
  var iconvLite = require_lib4();
  exports.convert = convert;
  function convert(str, to, from) {
    from = checkEncoding(from || "UTF-8");
    to = checkEncoding(to || "UTF-8");
    str = str || "";
    var result;
    if (from !== "UTF-8" && typeof str === "string") {
      str = Buffer.from(str, "binary");
    }
    if (from === to) {
      if (typeof str === "string") {
        result = Buffer.from(str);
      } else {
        result = str;
      }
    } else {
      try {
        result = convertIconvLite(str, to, from);
      } catch (E) {
        console.error(E);
        result = str;
      }
    }
    if (typeof result === "string") {
      result = Buffer.from(result, "utf-8");
    }
    return result;
  }
  function convertIconvLite(str, to, from) {
    if (to === "UTF-8") {
      return iconvLite.decode(str, from);
    } else if (from === "UTF-8") {
      return iconvLite.encode(str, to);
    } else {
      return iconvLite.encode(iconvLite.decode(str, from), to);
    }
  }
  function checkEncoding(name) {
    return (name || "").toString().trim().replace(/^latin[\-_]?(\d+)$/i, "ISO-8859-$1").replace(/^win(?:dows)?[\-_]?(\d+)$/i, "WINDOWS-$1").replace(/^utf[\-_]?(\d+)$/i, "UTF-$1").replace(/^ks_c_5601\-1987$/i, "CP949").replace(/^us[\-_]?ascii$/i, "ASCII").toUpperCase();
  }
});

// node_modules/node-fetch/lib/index.js
var require_lib5 = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  function _interopDefault(ex) {
    return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
  }
  var Stream = _interopDefault(__require("stream"));
  var http = _interopDefault(__require("http"));
  var Url = _interopDefault(__require("url"));
  var whatwgUrl = _interopDefault(require_public_api());
  var https = _interopDefault(__require("https"));
  var zlib = _interopDefault(__require("zlib"));
  var Readable = Stream.Readable;
  var BUFFER = Symbol("buffer");
  var TYPE = Symbol("type");

  class Blob {
    constructor() {
      this[TYPE] = "";
      const blobParts = arguments[0];
      const options = arguments[1];
      const buffers = [];
      let size = 0;
      if (blobParts) {
        const a = blobParts;
        const length = Number(a.length);
        for (let i = 0;i < length; i++) {
          const element = a[i];
          let buffer;
          if (element instanceof Buffer) {
            buffer = element;
          } else if (ArrayBuffer.isView(element)) {
            buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
          } else if (element instanceof ArrayBuffer) {
            buffer = Buffer.from(element);
          } else if (element instanceof Blob) {
            buffer = element[BUFFER];
          } else {
            buffer = Buffer.from(typeof element === "string" ? element : String(element));
          }
          size += buffer.length;
          buffers.push(buffer);
        }
      }
      this[BUFFER] = Buffer.concat(buffers);
      let type = options && options.type !== undefined && String(options.type).toLowerCase();
      if (type && !/[^\u0020-\u007E]/.test(type)) {
        this[TYPE] = type;
      }
    }
    get size() {
      return this[BUFFER].length;
    }
    get type() {
      return this[TYPE];
    }
    text() {
      return Promise.resolve(this[BUFFER].toString());
    }
    arrayBuffer() {
      const buf = this[BUFFER];
      const ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
      return Promise.resolve(ab);
    }
    stream() {
      const readable = new Readable;
      readable._read = function() {};
      readable.push(this[BUFFER]);
      readable.push(null);
      return readable;
    }
    toString() {
      return "[object Blob]";
    }
    slice() {
      const size = this.size;
      const start = arguments[0];
      const end = arguments[1];
      let relativeStart, relativeEnd;
      if (start === undefined) {
        relativeStart = 0;
      } else if (start < 0) {
        relativeStart = Math.max(size + start, 0);
      } else {
        relativeStart = Math.min(start, size);
      }
      if (end === undefined) {
        relativeEnd = size;
      } else if (end < 0) {
        relativeEnd = Math.max(size + end, 0);
      } else {
        relativeEnd = Math.min(end, size);
      }
      const span = Math.max(relativeEnd - relativeStart, 0);
      const buffer = this[BUFFER];
      const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
      const blob = new Blob([], { type: arguments[2] });
      blob[BUFFER] = slicedBuffer;
      return blob;
    }
  }
  Object.defineProperties(Blob.prototype, {
    size: { enumerable: true },
    type: { enumerable: true },
    slice: { enumerable: true }
  });
  Object.defineProperty(Blob.prototype, Symbol.toStringTag, {
    value: "Blob",
    writable: false,
    enumerable: false,
    configurable: true
  });
  function FetchError(message2, type, systemError) {
    Error.call(this, message2);
    this.message = message2;
    this.type = type;
    if (systemError) {
      this.code = this.errno = systemError.code;
    }
    Error.captureStackTrace(this, this.constructor);
  }
  FetchError.prototype = Object.create(Error.prototype);
  FetchError.prototype.constructor = FetchError;
  FetchError.prototype.name = "FetchError";
  var convert;
  try {
    convert = require_encoding2().convert;
  } catch (e) {}
  var INTERNALS = Symbol("Body internals");
  var PassThrough = Stream.PassThrough;
  function Body(body) {
    var _this = this;
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}, _ref$size = _ref.size;
    let size = _ref$size === undefined ? 0 : _ref$size;
    var _ref$timeout = _ref.timeout;
    let timeout = _ref$timeout === undefined ? 0 : _ref$timeout;
    if (body == null) {
      body = null;
    } else if (isURLSearchParams(body)) {
      body = Buffer.from(body.toString());
    } else if (isBlob(body))
      ;
    else if (Buffer.isBuffer(body))
      ;
    else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
      body = Buffer.from(body);
    } else if (ArrayBuffer.isView(body)) {
      body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
    } else if (body instanceof Stream)
      ;
    else {
      body = Buffer.from(String(body));
    }
    this[INTERNALS] = {
      body,
      disturbed: false,
      error: null
    };
    this.size = size;
    this.timeout = timeout;
    if (body instanceof Stream) {
      body.on("error", function(err) {
        const error = err.name === "AbortError" ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, "system", err);
        _this[INTERNALS].error = error;
      });
    }
  }
  Body.prototype = {
    get body() {
      return this[INTERNALS].body;
    },
    get bodyUsed() {
      return this[INTERNALS].disturbed;
    },
    arrayBuffer() {
      return consumeBody.call(this).then(function(buf) {
        return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
      });
    },
    blob() {
      let ct = this.headers && this.headers.get("content-type") || "";
      return consumeBody.call(this).then(function(buf) {
        return Object.assign(new Blob([], {
          type: ct.toLowerCase()
        }), {
          [BUFFER]: buf
        });
      });
    },
    json() {
      var _this2 = this;
      return consumeBody.call(this).then(function(buffer) {
        try {
          return JSON.parse(buffer.toString());
        } catch (err) {
          return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, "invalid-json"));
        }
      });
    },
    text() {
      return consumeBody.call(this).then(function(buffer) {
        return buffer.toString();
      });
    },
    buffer() {
      return consumeBody.call(this);
    },
    textConverted() {
      var _this3 = this;
      return consumeBody.call(this).then(function(buffer) {
        return convertBody(buffer, _this3.headers);
      });
    }
  };
  Object.defineProperties(Body.prototype, {
    body: { enumerable: true },
    bodyUsed: { enumerable: true },
    arrayBuffer: { enumerable: true },
    blob: { enumerable: true },
    json: { enumerable: true },
    text: { enumerable: true }
  });
  Body.mixIn = function(proto) {
    for (const name of Object.getOwnPropertyNames(Body.prototype)) {
      if (!(name in proto)) {
        const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);
        Object.defineProperty(proto, name, desc);
      }
    }
  };
  function consumeBody() {
    var _this4 = this;
    if (this[INTERNALS].disturbed) {
      return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));
    }
    this[INTERNALS].disturbed = true;
    if (this[INTERNALS].error) {
      return Body.Promise.reject(this[INTERNALS].error);
    }
    let body = this.body;
    if (body === null) {
      return Body.Promise.resolve(Buffer.alloc(0));
    }
    if (isBlob(body)) {
      body = body.stream();
    }
    if (Buffer.isBuffer(body)) {
      return Body.Promise.resolve(body);
    }
    if (!(body instanceof Stream)) {
      return Body.Promise.resolve(Buffer.alloc(0));
    }
    let accum = [];
    let accumBytes = 0;
    let abort = false;
    return new Body.Promise(function(resolve, reject) {
      let resTimeout;
      if (_this4.timeout) {
        resTimeout = setTimeout(function() {
          abort = true;
          reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, "body-timeout"));
        }, _this4.timeout);
      }
      body.on("error", function(err) {
        if (err.name === "AbortError") {
          abort = true;
          reject(err);
        } else {
          reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, "system", err));
        }
      });
      body.on("data", function(chunk) {
        if (abort || chunk === null) {
          return;
        }
        if (_this4.size && accumBytes + chunk.length > _this4.size) {
          abort = true;
          reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, "max-size"));
          return;
        }
        accumBytes += chunk.length;
        accum.push(chunk);
      });
      body.on("end", function() {
        if (abort) {
          return;
        }
        clearTimeout(resTimeout);
        try {
          resolve(Buffer.concat(accum, accumBytes));
        } catch (err) {
          reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, "system", err));
        }
      });
    });
  }
  function convertBody(buffer, headers) {
    if (typeof convert !== "function") {
      throw new Error("The package `encoding` must be installed to use the textConverted() function");
    }
    const ct = headers.get("content-type");
    let charset = "utf-8";
    let res, str;
    if (ct) {
      res = /charset=([^;]*)/i.exec(ct);
    }
    str = buffer.slice(0, 1024).toString();
    if (!res && str) {
      res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
    }
    if (!res && str) {
      res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);
      if (!res) {
        res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str);
        if (res) {
          res.pop();
        }
      }
      if (res) {
        res = /charset=(.*)/i.exec(res.pop());
      }
    }
    if (!res && str) {
      res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
    }
    if (res) {
      charset = res.pop();
      if (charset === "gb2312" || charset === "gbk") {
        charset = "gb18030";
      }
    }
    return convert(buffer, "UTF-8", charset).toString();
  }
  function isURLSearchParams(obj) {
    if (typeof obj !== "object" || typeof obj.append !== "function" || typeof obj.delete !== "function" || typeof obj.get !== "function" || typeof obj.getAll !== "function" || typeof obj.has !== "function" || typeof obj.set !== "function") {
      return false;
    }
    return obj.constructor.name === "URLSearchParams" || Object.prototype.toString.call(obj) === "[object URLSearchParams]" || typeof obj.sort === "function";
  }
  function isBlob(obj) {
    return typeof obj === "object" && typeof obj.arrayBuffer === "function" && typeof obj.type === "string" && typeof obj.stream === "function" && typeof obj.constructor === "function" && typeof obj.constructor.name === "string" && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
  }
  function clone(instance) {
    let p1, p2;
    let body = instance.body;
    if (instance.bodyUsed) {
      throw new Error("cannot clone body after it is used");
    }
    if (body instanceof Stream && typeof body.getBoundary !== "function") {
      p1 = new PassThrough;
      p2 = new PassThrough;
      body.pipe(p1);
      body.pipe(p2);
      instance[INTERNALS].body = p1;
      body = p2;
    }
    return body;
  }
  function extractContentType(body) {
    if (body === null) {
      return null;
    } else if (typeof body === "string") {
      return "text/plain;charset=UTF-8";
    } else if (isURLSearchParams(body)) {
      return "application/x-www-form-urlencoded;charset=UTF-8";
    } else if (isBlob(body)) {
      return body.type || null;
    } else if (Buffer.isBuffer(body)) {
      return null;
    } else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
      return null;
    } else if (ArrayBuffer.isView(body)) {
      return null;
    } else if (typeof body.getBoundary === "function") {
      return `multipart/form-data;boundary=${body.getBoundary()}`;
    } else if (body instanceof Stream) {
      return null;
    } else {
      return "text/plain;charset=UTF-8";
    }
  }
  function getTotalBytes(instance) {
    const body = instance.body;
    if (body === null) {
      return 0;
    } else if (isBlob(body)) {
      return body.size;
    } else if (Buffer.isBuffer(body)) {
      return body.length;
    } else if (body && typeof body.getLengthSync === "function") {
      if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || body.hasKnownLength && body.hasKnownLength()) {
        return body.getLengthSync();
      }
      return null;
    } else {
      return null;
    }
  }
  function writeToStream(dest, instance) {
    const body = instance.body;
    if (body === null) {
      dest.end();
    } else if (isBlob(body)) {
      body.stream().pipe(dest);
    } else if (Buffer.isBuffer(body)) {
      dest.write(body);
      dest.end();
    } else {
      body.pipe(dest);
    }
  }
  Body.Promise = global.Promise;
  var invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
  var invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
  function validateName(name) {
    name = `${name}`;
    if (invalidTokenRegex.test(name) || name === "") {
      throw new TypeError(`${name} is not a legal HTTP header name`);
    }
  }
  function validateValue(value) {
    value = `${value}`;
    if (invalidHeaderCharRegex.test(value)) {
      throw new TypeError(`${value} is not a legal HTTP header value`);
    }
  }
  function find(map, name) {
    name = name.toLowerCase();
    for (const key in map) {
      if (key.toLowerCase() === name) {
        return key;
      }
    }
    return;
  }
  var MAP = Symbol("map");

  class Headers {
    constructor() {
      let init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
      this[MAP] = Object.create(null);
      if (init instanceof Headers) {
        const rawHeaders = init.raw();
        const headerNames = Object.keys(rawHeaders);
        for (const headerName of headerNames) {
          for (const value of rawHeaders[headerName]) {
            this.append(headerName, value);
          }
        }
        return;
      }
      if (init == null)
        ;
      else if (typeof init === "object") {
        const method = init[Symbol.iterator];
        if (method != null) {
          if (typeof method !== "function") {
            throw new TypeError("Header pairs must be iterable");
          }
          const pairs = [];
          for (const pair of init) {
            if (typeof pair !== "object" || typeof pair[Symbol.iterator] !== "function") {
              throw new TypeError("Each header pair must be iterable");
            }
            pairs.push(Array.from(pair));
          }
          for (const pair of pairs) {
            if (pair.length !== 2) {
              throw new TypeError("Each header pair must be a name/value tuple");
            }
            this.append(pair[0], pair[1]);
          }
        } else {
          for (const key of Object.keys(init)) {
            const value = init[key];
            this.append(key, value);
          }
        }
      } else {
        throw new TypeError("Provided initializer must be an object");
      }
    }
    get(name) {
      name = `${name}`;
      validateName(name);
      const key = find(this[MAP], name);
      if (key === undefined) {
        return null;
      }
      return this[MAP][key].join(", ");
    }
    forEach(callback) {
      let thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
      let pairs = getHeaders(this);
      let i = 0;
      while (i < pairs.length) {
        var _pairs$i = pairs[i];
        const name = _pairs$i[0], value = _pairs$i[1];
        callback.call(thisArg, value, name, this);
        pairs = getHeaders(this);
        i++;
      }
    }
    set(name, value) {
      name = `${name}`;
      value = `${value}`;
      validateName(name);
      validateValue(value);
      const key = find(this[MAP], name);
      this[MAP][key !== undefined ? key : name] = [value];
    }
    append(name, value) {
      name = `${name}`;
      value = `${value}`;
      validateName(name);
      validateValue(value);
      const key = find(this[MAP], name);
      if (key !== undefined) {
        this[MAP][key].push(value);
      } else {
        this[MAP][name] = [value];
      }
    }
    has(name) {
      name = `${name}`;
      validateName(name);
      return find(this[MAP], name) !== undefined;
    }
    delete(name) {
      name = `${name}`;
      validateName(name);
      const key = find(this[MAP], name);
      if (key !== undefined) {
        delete this[MAP][key];
      }
    }
    raw() {
      return this[MAP];
    }
    keys() {
      return createHeadersIterator(this, "key");
    }
    values() {
      return createHeadersIterator(this, "value");
    }
    [Symbol.iterator]() {
      return createHeadersIterator(this, "key+value");
    }
  }
  Headers.prototype.entries = Headers.prototype[Symbol.iterator];
  Object.defineProperty(Headers.prototype, Symbol.toStringTag, {
    value: "Headers",
    writable: false,
    enumerable: false,
    configurable: true
  });
  Object.defineProperties(Headers.prototype, {
    get: { enumerable: true },
    forEach: { enumerable: true },
    set: { enumerable: true },
    append: { enumerable: true },
    has: { enumerable: true },
    delete: { enumerable: true },
    keys: { enumerable: true },
    values: { enumerable: true },
    entries: { enumerable: true }
  });
  function getHeaders(headers) {
    let kind = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "key+value";
    const keys = Object.keys(headers[MAP]).sort();
    return keys.map(kind === "key" ? function(k) {
      return k.toLowerCase();
    } : kind === "value" ? function(k) {
      return headers[MAP][k].join(", ");
    } : function(k) {
      return [k.toLowerCase(), headers[MAP][k].join(", ")];
    });
  }
  var INTERNAL = Symbol("internal");
  function createHeadersIterator(target, kind) {
    const iterator = Object.create(HeadersIteratorPrototype);
    iterator[INTERNAL] = {
      target,
      kind,
      index: 0
    };
    return iterator;
  }
  var HeadersIteratorPrototype = Object.setPrototypeOf({
    next() {
      if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
        throw new TypeError("Value of `this` is not a HeadersIterator");
      }
      var _INTERNAL = this[INTERNAL];
      const { target, kind, index } = _INTERNAL;
      const values = getHeaders(target, kind);
      const len = values.length;
      if (index >= len) {
        return {
          value: undefined,
          done: true
        };
      }
      this[INTERNAL].index = index + 1;
      return {
        value: values[index],
        done: false
      };
    }
  }, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));
  Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
    value: "HeadersIterator",
    writable: false,
    enumerable: false,
    configurable: true
  });
  function exportNodeCompatibleHeaders(headers) {
    const obj = Object.assign({ __proto__: null }, headers[MAP]);
    const hostHeaderKey = find(headers[MAP], "Host");
    if (hostHeaderKey !== undefined) {
      obj[hostHeaderKey] = obj[hostHeaderKey][0];
    }
    return obj;
  }
  function createHeadersLenient(obj) {
    const headers = new Headers;
    for (const name of Object.keys(obj)) {
      if (invalidTokenRegex.test(name)) {
        continue;
      }
      if (Array.isArray(obj[name])) {
        for (const val of obj[name]) {
          if (invalidHeaderCharRegex.test(val)) {
            continue;
          }
          if (headers[MAP][name] === undefined) {
            headers[MAP][name] = [val];
          } else {
            headers[MAP][name].push(val);
          }
        }
      } else if (!invalidHeaderCharRegex.test(obj[name])) {
        headers[MAP][name] = [obj[name]];
      }
    }
    return headers;
  }
  var INTERNALS$1 = Symbol("Response internals");
  var STATUS_CODES = http.STATUS_CODES;

  class Response {
    constructor() {
      let body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      Body.call(this, body, opts);
      const status = opts.status || 200;
      const headers = new Headers(opts.headers);
      if (body != null && !headers.has("Content-Type")) {
        const contentType = extractContentType(body);
        if (contentType) {
          headers.append("Content-Type", contentType);
        }
      }
      this[INTERNALS$1] = {
        url: opts.url,
        status,
        statusText: opts.statusText || STATUS_CODES[status],
        headers,
        counter: opts.counter
      };
    }
    get url() {
      return this[INTERNALS$1].url || "";
    }
    get status() {
      return this[INTERNALS$1].status;
    }
    get ok() {
      return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
    }
    get redirected() {
      return this[INTERNALS$1].counter > 0;
    }
    get statusText() {
      return this[INTERNALS$1].statusText;
    }
    get headers() {
      return this[INTERNALS$1].headers;
    }
    clone() {
      return new Response(clone(this), {
        url: this.url,
        status: this.status,
        statusText: this.statusText,
        headers: this.headers,
        ok: this.ok,
        redirected: this.redirected
      });
    }
  }
  Body.mixIn(Response.prototype);
  Object.defineProperties(Response.prototype, {
    url: { enumerable: true },
    status: { enumerable: true },
    ok: { enumerable: true },
    redirected: { enumerable: true },
    statusText: { enumerable: true },
    headers: { enumerable: true },
    clone: { enumerable: true }
  });
  Object.defineProperty(Response.prototype, Symbol.toStringTag, {
    value: "Response",
    writable: false,
    enumerable: false,
    configurable: true
  });
  var INTERNALS$2 = Symbol("Request internals");
  var URL = Url.URL || whatwgUrl.URL;
  var parse_url = Url.parse;
  var format_url = Url.format;
  function parseURL(urlStr) {
    if (/^[a-zA-Z][a-zA-Z\d+\-.]*:/.exec(urlStr)) {
      urlStr = new URL(urlStr).toString();
    }
    return parse_url(urlStr);
  }
  var streamDestructionSupported = "destroy" in Stream.Readable.prototype;
  function isRequest(input) {
    return typeof input === "object" && typeof input[INTERNALS$2] === "object";
  }
  function isAbortSignal(signal) {
    const proto = signal && typeof signal === "object" && Object.getPrototypeOf(signal);
    return !!(proto && proto.constructor.name === "AbortSignal");
  }

  class Request {
    constructor(input) {
      let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      let parsedURL;
      if (!isRequest(input)) {
        if (input && input.href) {
          parsedURL = parseURL(input.href);
        } else {
          parsedURL = parseURL(`${input}`);
        }
        input = {};
      } else {
        parsedURL = parseURL(input.url);
      }
      let method = init.method || input.method || "GET";
      method = method.toUpperCase();
      if ((init.body != null || isRequest(input) && input.body !== null) && (method === "GET" || method === "HEAD")) {
        throw new TypeError("Request with GET/HEAD method cannot have body");
      }
      let inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;
      Body.call(this, inputBody, {
        timeout: init.timeout || input.timeout || 0,
        size: init.size || input.size || 0
      });
      const headers = new Headers(init.headers || input.headers || {});
      if (inputBody != null && !headers.has("Content-Type")) {
        const contentType = extractContentType(inputBody);
        if (contentType) {
          headers.append("Content-Type", contentType);
        }
      }
      let signal = isRequest(input) ? input.signal : null;
      if ("signal" in init)
        signal = init.signal;
      if (signal != null && !isAbortSignal(signal)) {
        throw new TypeError("Expected signal to be an instanceof AbortSignal");
      }
      this[INTERNALS$2] = {
        method,
        redirect: init.redirect || input.redirect || "follow",
        headers,
        parsedURL,
        signal
      };
      this.follow = init.follow !== undefined ? init.follow : input.follow !== undefined ? input.follow : 20;
      this.compress = init.compress !== undefined ? init.compress : input.compress !== undefined ? input.compress : true;
      this.counter = init.counter || input.counter || 0;
      this.agent = init.agent || input.agent;
    }
    get method() {
      return this[INTERNALS$2].method;
    }
    get url() {
      return format_url(this[INTERNALS$2].parsedURL);
    }
    get headers() {
      return this[INTERNALS$2].headers;
    }
    get redirect() {
      return this[INTERNALS$2].redirect;
    }
    get signal() {
      return this[INTERNALS$2].signal;
    }
    clone() {
      return new Request(this);
    }
  }
  Body.mixIn(Request.prototype);
  Object.defineProperty(Request.prototype, Symbol.toStringTag, {
    value: "Request",
    writable: false,
    enumerable: false,
    configurable: true
  });
  Object.defineProperties(Request.prototype, {
    method: { enumerable: true },
    url: { enumerable: true },
    headers: { enumerable: true },
    redirect: { enumerable: true },
    clone: { enumerable: true },
    signal: { enumerable: true }
  });
  function getNodeRequestOptions(request) {
    const parsedURL = request[INTERNALS$2].parsedURL;
    const headers = new Headers(request[INTERNALS$2].headers);
    if (!headers.has("Accept")) {
      headers.set("Accept", "*/*");
    }
    if (!parsedURL.protocol || !parsedURL.hostname) {
      throw new TypeError("Only absolute URLs are supported");
    }
    if (!/^https?:$/.test(parsedURL.protocol)) {
      throw new TypeError("Only HTTP(S) protocols are supported");
    }
    if (request.signal && request.body instanceof Stream.Readable && !streamDestructionSupported) {
      throw new Error("Cancellation of streamed requests with AbortSignal is not supported in node < 8");
    }
    let contentLengthValue = null;
    if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {
      contentLengthValue = "0";
    }
    if (request.body != null) {
      const totalBytes = getTotalBytes(request);
      if (typeof totalBytes === "number") {
        contentLengthValue = String(totalBytes);
      }
    }
    if (contentLengthValue) {
      headers.set("Content-Length", contentLengthValue);
    }
    if (!headers.has("User-Agent")) {
      headers.set("User-Agent", "node-fetch/1.0 (+https://github.com/bitinn/node-fetch)");
    }
    if (request.compress && !headers.has("Accept-Encoding")) {
      headers.set("Accept-Encoding", "gzip,deflate");
    }
    let agent = request.agent;
    if (typeof agent === "function") {
      agent = agent(parsedURL);
    }
    return Object.assign({}, parsedURL, {
      method: request.method,
      headers: exportNodeCompatibleHeaders(headers),
      agent
    });
  }
  function AbortError(message2) {
    Error.call(this, message2);
    this.type = "aborted";
    this.message = message2;
    Error.captureStackTrace(this, this.constructor);
  }
  AbortError.prototype = Object.create(Error.prototype);
  AbortError.prototype.constructor = AbortError;
  AbortError.prototype.name = "AbortError";
  var URL$1 = Url.URL || whatwgUrl.URL;
  var PassThrough$1 = Stream.PassThrough;
  var isDomainOrSubdomain = function isDomainOrSubdomain(destination, original) {
    const orig = new URL$1(original).hostname;
    const dest = new URL$1(destination).hostname;
    return orig === dest || orig[orig.length - dest.length - 1] === "." && orig.endsWith(dest);
  };
  var isSameProtocol = function isSameProtocol(destination, original) {
    const orig = new URL$1(original).protocol;
    const dest = new URL$1(destination).protocol;
    return orig === dest;
  };
  function fetch(url, opts) {
    if (!fetch.Promise) {
      throw new Error("native promise missing, set fetch.Promise to your favorite alternative");
    }
    Body.Promise = fetch.Promise;
    return new fetch.Promise(function(resolve, reject) {
      const request = new Request(url, opts);
      const options = getNodeRequestOptions(request);
      const send = (options.protocol === "https:" ? https : http).request;
      const signal = request.signal;
      let response = null;
      const abort = function abort() {
        let error = new AbortError("The user aborted a request.");
        reject(error);
        if (request.body && request.body instanceof Stream.Readable) {
          destroyStream(request.body, error);
        }
        if (!response || !response.body)
          return;
        response.body.emit("error", error);
      };
      if (signal && signal.aborted) {
        abort();
        return;
      }
      const abortAndFinalize = function abortAndFinalize() {
        abort();
        finalize();
      };
      const req = send(options);
      let reqTimeout;
      if (signal) {
        signal.addEventListener("abort", abortAndFinalize);
      }
      function finalize() {
        req.abort();
        if (signal)
          signal.removeEventListener("abort", abortAndFinalize);
        clearTimeout(reqTimeout);
      }
      if (request.timeout) {
        req.once("socket", function(socket) {
          reqTimeout = setTimeout(function() {
            reject(new FetchError(`network timeout at: ${request.url}`, "request-timeout"));
            finalize();
          }, request.timeout);
        });
      }
      req.on("error", function(err) {
        reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, "system", err));
        if (response && response.body) {
          destroyStream(response.body, err);
        }
        finalize();
      });
      fixResponseChunkedTransferBadEnding(req, function(err) {
        if (signal && signal.aborted) {
          return;
        }
        if (response && response.body) {
          destroyStream(response.body, err);
        }
      });
      if (parseInt(process.version.substring(1)) < 14) {
        req.on("socket", function(s) {
          s.addListener("close", function(hadError) {
            const hasDataListener = s.listenerCount("data") > 0;
            if (response && hasDataListener && !hadError && !(signal && signal.aborted)) {
              const err = new Error("Premature close");
              err.code = "ERR_STREAM_PREMATURE_CLOSE";
              response.body.emit("error", err);
            }
          });
        });
      }
      req.on("response", function(res) {
        clearTimeout(reqTimeout);
        const headers = createHeadersLenient(res.headers);
        if (fetch.isRedirect(res.statusCode)) {
          const location = headers.get("Location");
          let locationURL = null;
          try {
            locationURL = location === null ? null : new URL$1(location, request.url).toString();
          } catch (err) {
            if (request.redirect !== "manual") {
              reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, "invalid-redirect"));
              finalize();
              return;
            }
          }
          switch (request.redirect) {
            case "error":
              reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
              finalize();
              return;
            case "manual":
              if (locationURL !== null) {
                try {
                  headers.set("Location", locationURL);
                } catch (err) {
                  reject(err);
                }
              }
              break;
            case "follow":
              if (locationURL === null) {
                break;
              }
              if (request.counter >= request.follow) {
                reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
                finalize();
                return;
              }
              const requestOpts = {
                headers: new Headers(request.headers),
                follow: request.follow,
                counter: request.counter + 1,
                agent: request.agent,
                compress: request.compress,
                method: request.method,
                body: request.body,
                signal: request.signal,
                timeout: request.timeout,
                size: request.size
              };
              if (!isDomainOrSubdomain(request.url, locationURL) || !isSameProtocol(request.url, locationURL)) {
                for (const name of ["authorization", "www-authenticate", "cookie", "cookie2"]) {
                  requestOpts.headers.delete(name);
                }
              }
              if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {
                reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
                finalize();
                return;
              }
              if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === "POST") {
                requestOpts.method = "GET";
                requestOpts.body = undefined;
                requestOpts.headers.delete("content-length");
              }
              resolve(fetch(new Request(locationURL, requestOpts)));
              finalize();
              return;
          }
        }
        res.once("end", function() {
          if (signal)
            signal.removeEventListener("abort", abortAndFinalize);
        });
        let body = res.pipe(new PassThrough$1);
        const response_options = {
          url: request.url,
          status: res.statusCode,
          statusText: res.statusMessage,
          headers,
          size: request.size,
          timeout: request.timeout,
          counter: request.counter
        };
        const codings = headers.get("Content-Encoding");
        if (!request.compress || request.method === "HEAD" || codings === null || res.statusCode === 204 || res.statusCode === 304) {
          response = new Response(body, response_options);
          resolve(response);
          return;
        }
        const zlibOptions = {
          flush: zlib.Z_SYNC_FLUSH,
          finishFlush: zlib.Z_SYNC_FLUSH
        };
        if (codings == "gzip" || codings == "x-gzip") {
          body = body.pipe(zlib.createGunzip(zlibOptions));
          response = new Response(body, response_options);
          resolve(response);
          return;
        }
        if (codings == "deflate" || codings == "x-deflate") {
          const raw = res.pipe(new PassThrough$1);
          raw.once("data", function(chunk) {
            if ((chunk[0] & 15) === 8) {
              body = body.pipe(zlib.createInflate());
            } else {
              body = body.pipe(zlib.createInflateRaw());
            }
            response = new Response(body, response_options);
            resolve(response);
          });
          raw.on("end", function() {
            if (!response) {
              response = new Response(body, response_options);
              resolve(response);
            }
          });
          return;
        }
        if (codings == "br" && typeof zlib.createBrotliDecompress === "function") {
          body = body.pipe(zlib.createBrotliDecompress());
          response = new Response(body, response_options);
          resolve(response);
          return;
        }
        response = new Response(body, response_options);
        resolve(response);
      });
      writeToStream(req, request);
    });
  }
  function fixResponseChunkedTransferBadEnding(request, errorCallback) {
    let socket;
    request.on("socket", function(s) {
      socket = s;
    });
    request.on("response", function(response) {
      const headers = response.headers;
      if (headers["transfer-encoding"] === "chunked" && !headers["content-length"]) {
        response.once("close", function(hadError) {
          const hasDataListener = socket && socket.listenerCount("data") > 0;
          if (hasDataListener && !hadError) {
            const err = new Error("Premature close");
            err.code = "ERR_STREAM_PREMATURE_CLOSE";
            errorCallback(err);
          }
        });
      }
    });
  }
  function destroyStream(stream, err) {
    if (stream.destroy) {
      stream.destroy(err);
    } else {
      stream.emit("error", err);
      stream.end();
    }
  }
  fetch.isRedirect = function(code) {
    return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
  };
  fetch.Promise = global.Promise;
  module.exports = exports = fetch;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = exports;
  exports.Headers = Headers;
  exports.Request = Request;
  exports.Response = Response;
  exports.FetchError = FetchError;
  exports.AbortError = AbortError;
});

// node_modules/apollo-server-env/dist/polyfills/fetch.js
var require_fetch = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Headers = exports.Response = exports.Request = exports.fetch = undefined;
  var node_fetch_1 = require_lib5();
  Object.defineProperty(exports, "fetch", { enumerable: true, get: function() {
    return __importDefault(node_fetch_1).default;
  } });
  Object.defineProperty(exports, "Request", { enumerable: true, get: function() {
    return node_fetch_1.Request;
  } });
  Object.defineProperty(exports, "Response", { enumerable: true, get: function() {
    return node_fetch_1.Response;
  } });
  Object.defineProperty(exports, "Headers", { enumerable: true, get: function() {
    return node_fetch_1.Headers;
  } });
});

// node_modules/apollo-server-env/dist/polyfills/url.js
var require_url = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.URLSearchParams = exports.URL = undefined;
  var url_1 = __require("url");
  Object.defineProperty(exports, "URL", { enumerable: true, get: function() {
    return url_1.URL;
  } });
  Object.defineProperty(exports, "URLSearchParams", { enumerable: true, get: function() {
    return url_1.URLSearchParams;
  } });
});

// node_modules/apollo-server-env/dist/index.js
var require_dist = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_fetch(), exports);
  __exportStar(require_url(), exports);
});

// node_modules/graphql/version.js
var require_version = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.versionInfo = exports.version = undefined;
  var version = "15.10.1";
  exports.version = version;
  var versionInfo = Object.freeze({
    major: 15,
    minor: 10,
    patch: 1,
    preReleaseTag: null
  });
  exports.versionInfo = versionInfo;
});

// node_modules/graphql/jsutils/isPromise.js
var require_isPromise = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isPromise;
  function isPromise(value) {
    return typeof (value === null || value === undefined ? undefined : value.then) === "function";
  }
});

// node_modules/graphql/jsutils/devAssert.js
var require_devAssert = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = devAssert;
  function devAssert(condition, message2) {
    var booleanCondition = Boolean(condition);
    if (!booleanCondition) {
      throw new Error(message2);
    }
  }
});

// node_modules/graphql/jsutils/isObjectLike.js
var require_isObjectLike = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isObjectLike;
  function _typeof(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function _typeof(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof = function _typeof(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof(obj);
  }
  function isObjectLike(value) {
    return _typeof(value) == "object" && value !== null;
  }
});

// node_modules/graphql/polyfills/symbols.js
var require_symbols = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.SYMBOL_TO_STRING_TAG = exports.SYMBOL_ASYNC_ITERATOR = exports.SYMBOL_ITERATOR = undefined;
  var SYMBOL_ITERATOR = typeof Symbol === "function" && Symbol.iterator != null ? Symbol.iterator : "@@iterator";
  exports.SYMBOL_ITERATOR = SYMBOL_ITERATOR;
  var SYMBOL_ASYNC_ITERATOR = typeof Symbol === "function" && Symbol.asyncIterator != null ? Symbol.asyncIterator : "@@asyncIterator";
  exports.SYMBOL_ASYNC_ITERATOR = SYMBOL_ASYNC_ITERATOR;
  var SYMBOL_TO_STRING_TAG = typeof Symbol === "function" && Symbol.toStringTag != null ? Symbol.toStringTag : "@@toStringTag";
  exports.SYMBOL_TO_STRING_TAG = SYMBOL_TO_STRING_TAG;
});

// node_modules/graphql/language/location.js
var require_location = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getLocation = getLocation;
  function getLocation(source, position) {
    var lineRegexp = /\r\n|[\n\r]/g;
    var line = 1;
    var column = position + 1;
    var match;
    while ((match = lineRegexp.exec(source.body)) && match.index < position) {
      line += 1;
      column = position + 1 - (match.index + match[0].length);
    }
    return {
      line,
      column
    };
  }
});

// node_modules/graphql/language/printLocation.js
var require_printLocation = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.printLocation = printLocation;
  exports.printSourceLocation = printSourceLocation;
  var _location = require_location();
  function printLocation(location) {
    return printSourceLocation(location.source, (0, _location.getLocation)(location.source, location.start));
  }
  function printSourceLocation(source, sourceLocation) {
    var firstLineColumnOffset = source.locationOffset.column - 1;
    var body = whitespace(firstLineColumnOffset) + source.body;
    var lineIndex = sourceLocation.line - 1;
    var lineOffset = source.locationOffset.line - 1;
    var lineNum = sourceLocation.line + lineOffset;
    var columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;
    var columnNum = sourceLocation.column + columnOffset;
    var locationStr = "".concat(source.name, ":").concat(lineNum, ":").concat(columnNum, `
`);
    var lines = body.split(/\r\n|[\n\r]/g);
    var locationLine = lines[lineIndex];
    if (locationLine.length > 120) {
      var subLineIndex = Math.floor(columnNum / 80);
      var subLineColumnNum = columnNum % 80;
      var subLines = [];
      for (var i = 0;i < locationLine.length; i += 80) {
        subLines.push(locationLine.slice(i, i + 80));
      }
      return locationStr + printPrefixedLines([["".concat(lineNum), subLines[0]]].concat(subLines.slice(1, subLineIndex + 1).map(function(subLine) {
        return ["", subLine];
      }), [[" ", whitespace(subLineColumnNum - 1) + "^"], ["", subLines[subLineIndex + 1]]]));
    }
    return locationStr + printPrefixedLines([
      ["".concat(lineNum - 1), lines[lineIndex - 1]],
      ["".concat(lineNum), locationLine],
      ["", whitespace(columnNum - 1) + "^"],
      ["".concat(lineNum + 1), lines[lineIndex + 1]]
    ]);
  }
  function printPrefixedLines(lines) {
    var existingLines = lines.filter(function(_ref) {
      var _ = _ref[0], line = _ref[1];
      return line !== undefined;
    });
    var padLen = Math.max.apply(Math, existingLines.map(function(_ref2) {
      var prefix = _ref2[0];
      return prefix.length;
    }));
    return existingLines.map(function(_ref3) {
      var prefix = _ref3[0], line = _ref3[1];
      return leftPad(padLen, prefix) + (line ? " | " + line : " |");
    }).join(`
`);
  }
  function whitespace(len) {
    return Array(len + 1).join(" ");
  }
  function leftPad(len, str) {
    return whitespace(len - str.length) + str;
  }
});

// node_modules/graphql/error/GraphQLError.js
var require_GraphQLError = __commonJS((exports) => {
  function _typeof(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function _typeof(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof = function _typeof(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof(obj);
  }
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.printError = printError;
  exports.formatError = formatError;
  exports.GraphQLError = undefined;
  var _devAssert = _interopRequireDefault(require_devAssert());
  var _isObjectLike = _interopRequireDefault(require_isObjectLike());
  var _symbols = require_symbols();
  var _location = require_location();
  var _printLocation = require_printLocation();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread(target) {
    for (var i = 1;i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties(target, props) {
    for (var i = 0;i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties(Constructor, staticProps);
    return Constructor;
  }
  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
    if (superClass)
      _setPrototypeOf(subClass, superClass);
  }
  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _possibleConstructorReturn(self2, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) {
      return call;
    }
    return _assertThisInitialized(self2);
  }
  function _assertThisInitialized(self2) {
    if (self2 === undefined) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map : undefined;
    _wrapNativeSuper = function _wrapNativeSuper(Class2) {
      if (Class2 === null || !_isNativeFunction(Class2))
        return Class2;
      if (typeof Class2 !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }
      if (typeof _cache !== "undefined") {
        if (_cache.has(Class2))
          return _cache.get(Class2);
        _cache.set(Class2, Wrapper);
      }
      function Wrapper() {
        return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
      }
      Wrapper.prototype = Object.create(Class2.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } });
      return _setPrototypeOf(Wrapper, Class2);
    };
    return _wrapNativeSuper(Class);
  }
  function _construct(Parent, args2, Class) {
    if (_isNativeReflectConstruct()) {
      _construct = Reflect.construct;
    } else {
      _construct = function _construct(Parent2, args3, Class2) {
        var a = [null];
        a.push.apply(a, args3);
        var Constructor = Function.bind.apply(Parent2, a);
        var instance = new Constructor;
        if (Class2)
          _setPrototypeOf(instance, Class2.prototype);
        return instance;
      };
    }
    return _construct.apply(null, arguments);
  }
  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));
      return true;
    } catch (e) {
      return false;
    }
  }
  function _isNativeFunction(fn2) {
    return Function.toString.call(fn2).indexOf("[native code]") !== -1;
  }
  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o2, p2) {
      o2.__proto__ = p2;
      return o2;
    };
    return _setPrototypeOf(o, p);
  }
  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o2) {
      return o2.__proto__ || Object.getPrototypeOf(o2);
    };
    return _getPrototypeOf(o);
  }
  var GraphQLError = /* @__PURE__ */ function(_Error) {
    _inherits(GraphQLError2, _Error);
    var _super = _createSuper(GraphQLError2);
    function GraphQLError2(message2, nodes, source, positions, path, originalError, extensions) {
      var _nodeLocations, _nodeLocations2, _nodeLocations3;
      var _this;
      _classCallCheck(this, GraphQLError2);
      _this = _super.call(this, message2);
      _this.name = "GraphQLError";
      _this.originalError = originalError !== null && originalError !== undefined ? originalError : undefined;
      _this.nodes = undefinedIfEmpty(Array.isArray(nodes) ? nodes : nodes ? [nodes] : undefined);
      var nodeLocations = [];
      for (var _i2 = 0, _ref3 = (_this$nodes = _this.nodes) !== null && _this$nodes !== undefined ? _this$nodes : [];_i2 < _ref3.length; _i2++) {
        var _this$nodes;
        var _ref4 = _ref3[_i2];
        var loc = _ref4.loc;
        if (loc != null) {
          nodeLocations.push(loc);
        }
      }
      nodeLocations = undefinedIfEmpty(nodeLocations);
      _this.source = source !== null && source !== undefined ? source : (_nodeLocations = nodeLocations) === null || _nodeLocations === undefined ? undefined : _nodeLocations[0].source;
      _this.positions = positions !== null && positions !== undefined ? positions : (_nodeLocations2 = nodeLocations) === null || _nodeLocations2 === undefined ? undefined : _nodeLocations2.map(function(loc2) {
        return loc2.start;
      });
      _this.locations = positions && source ? positions.map(function(pos) {
        return (0, _location.getLocation)(source, pos);
      }) : (_nodeLocations3 = nodeLocations) === null || _nodeLocations3 === undefined ? undefined : _nodeLocations3.map(function(loc2) {
        return (0, _location.getLocation)(loc2.source, loc2.start);
      });
      _this.path = path !== null && path !== undefined ? path : undefined;
      var originalExtensions = originalError === null || originalError === undefined ? undefined : originalError.extensions;
      if (extensions == null && (0, _isObjectLike.default)(originalExtensions)) {
        _this.extensions = _objectSpread({}, originalExtensions);
      } else {
        _this.extensions = extensions !== null && extensions !== undefined ? extensions : {};
      }
      Object.defineProperties(_assertThisInitialized(_this), {
        message: {
          enumerable: true
        },
        locations: {
          enumerable: _this.locations != null
        },
        path: {
          enumerable: _this.path != null
        },
        extensions: {
          enumerable: _this.extensions != null && Object.keys(_this.extensions).length > 0
        },
        name: {
          enumerable: false
        },
        nodes: {
          enumerable: false
        },
        source: {
          enumerable: false
        },
        positions: {
          enumerable: false
        },
        originalError: {
          enumerable: false
        }
      });
      if (originalError !== null && originalError !== undefined && originalError.stack) {
        Object.defineProperty(_assertThisInitialized(_this), "stack", {
          value: originalError.stack,
          writable: true,
          configurable: true
        });
        return _possibleConstructorReturn(_this);
      }
      if (Error.captureStackTrace) {
        Error.captureStackTrace(_assertThisInitialized(_this), GraphQLError2);
      } else {
        Object.defineProperty(_assertThisInitialized(_this), "stack", {
          value: Error().stack,
          writable: true,
          configurable: true
        });
      }
      return _this;
    }
    _createClass(GraphQLError2, [{
      key: "toString",
      value: function toString() {
        return printError(this);
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return formatError(this);
      }
    }, {
      key: _symbols.SYMBOL_TO_STRING_TAG,
      get: function get() {
        return "Object";
      }
    }]);
    return GraphQLError2;
  }(/* @__PURE__ */ _wrapNativeSuper(Error));
  exports.GraphQLError = GraphQLError;
  function undefinedIfEmpty(array) {
    return array === undefined || array.length === 0 ? undefined : array;
  }
  function printError(error) {
    var output = error.message;
    if (error.nodes) {
      for (var _i4 = 0, _error$nodes2 = error.nodes;_i4 < _error$nodes2.length; _i4++) {
        var node = _error$nodes2[_i4];
        if (node.loc) {
          output += `

` + (0, _printLocation.printLocation)(node.loc);
        }
      }
    } else if (error.source && error.locations) {
      for (var _i6 = 0, _error$locations2 = error.locations;_i6 < _error$locations2.length; _i6++) {
        var location = _error$locations2[_i6];
        output += `

` + (0, _printLocation.printSourceLocation)(error.source, location);
      }
    }
    return output;
  }
  function formatError(error) {
    var _error$message;
    error || (0, _devAssert.default)(0, "Received null or undefined error.");
    var message2 = (_error$message = error.message) !== null && _error$message !== undefined ? _error$message : "An unknown error occurred.";
    var locations = error.locations;
    var path = error.path;
    var extensions = error.extensions;
    return extensions && Object.keys(extensions).length > 0 ? {
      message: message2,
      locations,
      path,
      extensions
    } : {
      message: message2,
      locations,
      path
    };
  }
});

// node_modules/graphql/error/syntaxError.js
var require_syntaxError = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.syntaxError = syntaxError;
  var _GraphQLError = require_GraphQLError();
  function syntaxError(source, position, description) {
    return new _GraphQLError.GraphQLError("Syntax Error: ".concat(description), undefined, source, [position]);
  }
});

// node_modules/graphql/language/kinds.js
var require_kinds = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Kind = undefined;
  var Kind = Object.freeze({
    NAME: "Name",
    DOCUMENT: "Document",
    OPERATION_DEFINITION: "OperationDefinition",
    VARIABLE_DEFINITION: "VariableDefinition",
    SELECTION_SET: "SelectionSet",
    FIELD: "Field",
    ARGUMENT: "Argument",
    FRAGMENT_SPREAD: "FragmentSpread",
    INLINE_FRAGMENT: "InlineFragment",
    FRAGMENT_DEFINITION: "FragmentDefinition",
    VARIABLE: "Variable",
    INT: "IntValue",
    FLOAT: "FloatValue",
    STRING: "StringValue",
    BOOLEAN: "BooleanValue",
    NULL: "NullValue",
    ENUM: "EnumValue",
    LIST: "ListValue",
    OBJECT: "ObjectValue",
    OBJECT_FIELD: "ObjectField",
    DIRECTIVE: "Directive",
    NAMED_TYPE: "NamedType",
    LIST_TYPE: "ListType",
    NON_NULL_TYPE: "NonNullType",
    SCHEMA_DEFINITION: "SchemaDefinition",
    OPERATION_TYPE_DEFINITION: "OperationTypeDefinition",
    SCALAR_TYPE_DEFINITION: "ScalarTypeDefinition",
    OBJECT_TYPE_DEFINITION: "ObjectTypeDefinition",
    FIELD_DEFINITION: "FieldDefinition",
    INPUT_VALUE_DEFINITION: "InputValueDefinition",
    INTERFACE_TYPE_DEFINITION: "InterfaceTypeDefinition",
    UNION_TYPE_DEFINITION: "UnionTypeDefinition",
    ENUM_TYPE_DEFINITION: "EnumTypeDefinition",
    ENUM_VALUE_DEFINITION: "EnumValueDefinition",
    INPUT_OBJECT_TYPE_DEFINITION: "InputObjectTypeDefinition",
    DIRECTIVE_DEFINITION: "DirectiveDefinition",
    SCHEMA_EXTENSION: "SchemaExtension",
    SCALAR_TYPE_EXTENSION: "ScalarTypeExtension",
    OBJECT_TYPE_EXTENSION: "ObjectTypeExtension",
    INTERFACE_TYPE_EXTENSION: "InterfaceTypeExtension",
    UNION_TYPE_EXTENSION: "UnionTypeExtension",
    ENUM_TYPE_EXTENSION: "EnumTypeExtension",
    INPUT_OBJECT_TYPE_EXTENSION: "InputObjectTypeExtension"
  });
  exports.Kind = Kind;
});

// node_modules/graphql/jsutils/invariant.js
var require_invariant = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = invariant;
  function invariant(condition, message2) {
    var booleanCondition = Boolean(condition);
    if (!booleanCondition) {
      throw new Error(message2 != null ? message2 : "Unexpected invariant triggered.");
    }
  }
});

// node_modules/graphql/jsutils/nodejsCustomInspectSymbol.js
var require_nodejsCustomInspectSymbol = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var nodejsCustomInspectSymbol = typeof Symbol === "function" && typeof Symbol.for === "function" ? Symbol.for("nodejs.util.inspect.custom") : undefined;
  var _default = nodejsCustomInspectSymbol;
  exports.default = _default;
});

// node_modules/graphql/jsutils/defineInspect.js
var require_defineInspect = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = defineInspect;
  var _invariant = _interopRequireDefault(require_invariant());
  var _nodejsCustomInspectSymbol = _interopRequireDefault(require_nodejsCustomInspectSymbol());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function defineInspect(classObject) {
    var fn2 = classObject.prototype.toJSON;
    typeof fn2 === "function" || (0, _invariant.default)(0);
    classObject.prototype.inspect = fn2;
    if (_nodejsCustomInspectSymbol.default) {
      classObject.prototype[_nodejsCustomInspectSymbol.default] = fn2;
    }
  }
});

// node_modules/graphql/language/ast.js
var require_ast = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.isNode = isNode;
  exports.Token = exports.Location = undefined;
  var _defineInspect = _interopRequireDefault(require_defineInspect());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var Location = /* @__PURE__ */ function() {
    function Location2(startToken, endToken, source) {
      this.start = startToken.start;
      this.end = endToken.end;
      this.startToken = startToken;
      this.endToken = endToken;
      this.source = source;
    }
    var _proto = Location2.prototype;
    _proto.toJSON = function toJSON() {
      return {
        start: this.start,
        end: this.end
      };
    };
    return Location2;
  }();
  exports.Location = Location;
  (0, _defineInspect.default)(Location);
  var Token = /* @__PURE__ */ function() {
    function Token2(kind, start, end, line, column, prev, value) {
      this.kind = kind;
      this.start = start;
      this.end = end;
      this.line = line;
      this.column = column;
      this.value = value;
      this.prev = prev;
      this.next = null;
    }
    var _proto2 = Token2.prototype;
    _proto2.toJSON = function toJSON() {
      return {
        kind: this.kind,
        value: this.value,
        line: this.line,
        column: this.column
      };
    };
    return Token2;
  }();
  exports.Token = Token;
  (0, _defineInspect.default)(Token);
  function isNode(maybeNode) {
    return maybeNode != null && typeof maybeNode.kind === "string";
  }
});

// node_modules/graphql/language/tokenKind.js
var require_tokenKind = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.TokenKind = undefined;
  var TokenKind = Object.freeze({
    SOF: "<SOF>",
    EOF: "<EOF>",
    BANG: "!",
    DOLLAR: "$",
    AMP: "&",
    PAREN_L: "(",
    PAREN_R: ")",
    SPREAD: "...",
    COLON: ":",
    EQUALS: "=",
    AT: "@",
    BRACKET_L: "[",
    BRACKET_R: "]",
    BRACE_L: "{",
    PIPE: "|",
    BRACE_R: "}",
    NAME: "Name",
    INT: "Int",
    FLOAT: "Float",
    STRING: "String",
    BLOCK_STRING: "BlockString",
    COMMENT: "Comment"
  });
  exports.TokenKind = TokenKind;
});

// node_modules/graphql/jsutils/inspect.js
var require_inspect = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = inspect;
  var _nodejsCustomInspectSymbol = _interopRequireDefault(require_nodejsCustomInspectSymbol());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _typeof(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function _typeof(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof = function _typeof(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof(obj);
  }
  var MAX_ARRAY_LENGTH = 10;
  var MAX_RECURSIVE_DEPTH = 2;
  function inspect(value) {
    return formatValue(value, []);
  }
  function formatValue(value, seenValues) {
    switch (_typeof(value)) {
      case "string":
        return JSON.stringify(value);
      case "function":
        return value.name ? "[function ".concat(value.name, "]") : "[function]";
      case "object":
        if (value === null) {
          return "null";
        }
        return formatObjectValue(value, seenValues);
      default:
        return String(value);
    }
  }
  function formatObjectValue(value, previouslySeenValues) {
    if (previouslySeenValues.indexOf(value) !== -1) {
      return "[Circular]";
    }
    var seenValues = [].concat(previouslySeenValues, [value]);
    var customInspectFn = getCustomFn(value);
    if (customInspectFn !== undefined) {
      var customValue = customInspectFn.call(value);
      if (customValue !== value) {
        return typeof customValue === "string" ? customValue : formatValue(customValue, seenValues);
      }
    } else if (Array.isArray(value)) {
      return formatArray(value, seenValues);
    }
    return formatObject(value, seenValues);
  }
  function formatObject(object, seenValues) {
    var keys = Object.keys(object);
    if (keys.length === 0) {
      return "{}";
    }
    if (seenValues.length > MAX_RECURSIVE_DEPTH) {
      return "[" + getObjectTag(object) + "]";
    }
    var properties = keys.map(function(key) {
      var value = formatValue(object[key], seenValues);
      return key + ": " + value;
    });
    return "{ " + properties.join(", ") + " }";
  }
  function formatArray(array, seenValues) {
    if (array.length === 0) {
      return "[]";
    }
    if (seenValues.length > MAX_RECURSIVE_DEPTH) {
      return "[Array]";
    }
    var len = Math.min(MAX_ARRAY_LENGTH, array.length);
    var remaining = array.length - len;
    var items = [];
    for (var i = 0;i < len; ++i) {
      items.push(formatValue(array[i], seenValues));
    }
    if (remaining === 1) {
      items.push("... 1 more item");
    } else if (remaining > 1) {
      items.push("... ".concat(remaining, " more items"));
    }
    return "[" + items.join(", ") + "]";
  }
  function getCustomFn(object) {
    var customInspectFn = object[String(_nodejsCustomInspectSymbol.default)];
    if (typeof customInspectFn === "function") {
      return customInspectFn;
    }
    if (typeof object.inspect === "function") {
      return object.inspect;
    }
  }
  function getObjectTag(object) {
    var tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
    if (tag === "Object" && typeof object.constructor === "function") {
      var name = object.constructor.name;
      if (typeof name === "string" && name !== "") {
        return name;
      }
    }
    return tag;
  }
});

// node_modules/graphql/jsutils/instanceOf.js
var require_instanceOf = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _inspect = _interopRequireDefault(require_inspect());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _typeof(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function _typeof(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof = function _typeof(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof(obj);
  }
  var _default = function instanceOf(value, constructor) {
    if (value instanceof constructor) {
      return true;
    }
    if (_typeof(value) === "object" && value !== null) {
      var _value$constructor;
      var className = constructor.prototype[Symbol.toStringTag];
      var valueClassName = Symbol.toStringTag in value ? value[Symbol.toStringTag] : (_value$constructor = value.constructor) === null || _value$constructor === undefined ? undefined : _value$constructor.name;
      if (className === valueClassName) {
        var stringifiedValue = (0, _inspect.default)(value);
        throw new Error("Cannot use ".concat(className, ' "').concat(stringifiedValue, `" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`));
      }
    }
    return false;
  };
  exports.default = _default;
});

// node_modules/graphql/language/source.js
var require_source = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.isSource = isSource;
  exports.Source = undefined;
  var _symbols = require_symbols();
  var _inspect = _interopRequireDefault(require_inspect());
  var _devAssert = _interopRequireDefault(require_devAssert());
  var _instanceOf = _interopRequireDefault(require_instanceOf());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _defineProperties(target, props) {
    for (var i = 0;i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties(Constructor, staticProps);
    return Constructor;
  }
  var Source = /* @__PURE__ */ function() {
    function Source2(body) {
      var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "GraphQL request";
      var locationOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
        line: 1,
        column: 1
      };
      typeof body === "string" || (0, _devAssert.default)(0, "Body must be a string. Received: ".concat((0, _inspect.default)(body), "."));
      this.body = body;
      this.name = name;
      this.locationOffset = locationOffset;
      this.locationOffset.line > 0 || (0, _devAssert.default)(0, "line in locationOffset is 1-indexed and must be positive.");
      this.locationOffset.column > 0 || (0, _devAssert.default)(0, "column in locationOffset is 1-indexed and must be positive.");
    }
    _createClass(Source2, [{
      key: _symbols.SYMBOL_TO_STRING_TAG,
      get: function get() {
        return "Source";
      }
    }]);
    return Source2;
  }();
  exports.Source = Source;
  function isSource(source) {
    return (0, _instanceOf.default)(source, Source);
  }
});

// node_modules/graphql/language/directiveLocation.js
var require_directiveLocation = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.DirectiveLocation = undefined;
  var DirectiveLocation = Object.freeze({
    QUERY: "QUERY",
    MUTATION: "MUTATION",
    SUBSCRIPTION: "SUBSCRIPTION",
    FIELD: "FIELD",
    FRAGMENT_DEFINITION: "FRAGMENT_DEFINITION",
    FRAGMENT_SPREAD: "FRAGMENT_SPREAD",
    INLINE_FRAGMENT: "INLINE_FRAGMENT",
    VARIABLE_DEFINITION: "VARIABLE_DEFINITION",
    SCHEMA: "SCHEMA",
    SCALAR: "SCALAR",
    OBJECT: "OBJECT",
    FIELD_DEFINITION: "FIELD_DEFINITION",
    ARGUMENT_DEFINITION: "ARGUMENT_DEFINITION",
    INTERFACE: "INTERFACE",
    UNION: "UNION",
    ENUM: "ENUM",
    ENUM_VALUE: "ENUM_VALUE",
    INPUT_OBJECT: "INPUT_OBJECT",
    INPUT_FIELD_DEFINITION: "INPUT_FIELD_DEFINITION"
  });
  exports.DirectiveLocation = DirectiveLocation;
});

// node_modules/graphql/language/blockString.js
var require_blockString = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.dedentBlockStringValue = dedentBlockStringValue;
  exports.getBlockStringIndentation = getBlockStringIndentation;
  exports.printBlockString = printBlockString;
  function dedentBlockStringValue(rawString) {
    var lines = rawString.split(/\r\n|[\n\r]/g);
    var commonIndent = getBlockStringIndentation(rawString);
    if (commonIndent !== 0) {
      for (var i = 1;i < lines.length; i++) {
        lines[i] = lines[i].slice(commonIndent);
      }
    }
    var startLine = 0;
    while (startLine < lines.length && isBlank(lines[startLine])) {
      ++startLine;
    }
    var endLine = lines.length;
    while (endLine > startLine && isBlank(lines[endLine - 1])) {
      --endLine;
    }
    return lines.slice(startLine, endLine).join(`
`);
  }
  function isBlank(str) {
    for (var i = 0;i < str.length; ++i) {
      if (str[i] !== " " && str[i] !== "\t") {
        return false;
      }
    }
    return true;
  }
  function getBlockStringIndentation(value) {
    var _commonIndent;
    var isFirstLine = true;
    var isEmptyLine = true;
    var indent = 0;
    var commonIndent = null;
    for (var i = 0;i < value.length; ++i) {
      switch (value.charCodeAt(i)) {
        case 13:
          if (value.charCodeAt(i + 1) === 10) {
            ++i;
          }
        case 10:
          isFirstLine = false;
          isEmptyLine = true;
          indent = 0;
          break;
        case 9:
        case 32:
          ++indent;
          break;
        default:
          if (isEmptyLine && !isFirstLine && (commonIndent === null || indent < commonIndent)) {
            commonIndent = indent;
          }
          isEmptyLine = false;
      }
    }
    return (_commonIndent = commonIndent) !== null && _commonIndent !== undefined ? _commonIndent : 0;
  }
  function printBlockString(value) {
    var indentation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
    var preferMultipleLines = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var isSingleLine = value.indexOf(`
`) === -1;
    var hasLeadingSpace = value[0] === " " || value[0] === "\t";
    var hasTrailingQuote = value[value.length - 1] === '"';
    var hasTrailingSlash = value[value.length - 1] === "\\";
    var printAsMultipleLines = !isSingleLine || hasTrailingQuote || hasTrailingSlash || preferMultipleLines;
    var result = "";
    if (printAsMultipleLines && !(isSingleLine && hasLeadingSpace)) {
      result += `
` + indentation;
    }
    result += indentation ? value.replace(/\n/g, `
` + indentation) : value;
    if (printAsMultipleLines) {
      result += `
`;
    }
    return '"""' + result.replace(/"""/g, '\\"""') + '"""';
  }
});

// node_modules/graphql/language/lexer.js
var require_lexer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.isPunctuatorTokenKind = isPunctuatorTokenKind;
  exports.Lexer = undefined;
  var _syntaxError = require_syntaxError();
  var _ast = require_ast();
  var _tokenKind = require_tokenKind();
  var _blockString = require_blockString();
  var Lexer = /* @__PURE__ */ function() {
    function Lexer2(source) {
      var startOfFileToken = new _ast.Token(_tokenKind.TokenKind.SOF, 0, 0, 0, 0, null);
      this.source = source;
      this.lastToken = startOfFileToken;
      this.token = startOfFileToken;
      this.line = 1;
      this.lineStart = 0;
    }
    var _proto = Lexer2.prototype;
    _proto.advance = function advance() {
      this.lastToken = this.token;
      var token = this.token = this.lookahead();
      return token;
    };
    _proto.lookahead = function lookahead() {
      var token = this.token;
      if (token.kind !== _tokenKind.TokenKind.EOF) {
        do {
          var _token$next;
          token = (_token$next = token.next) !== null && _token$next !== undefined ? _token$next : token.next = readToken(this, token);
        } while (token.kind === _tokenKind.TokenKind.COMMENT);
      }
      return token;
    };
    return Lexer2;
  }();
  exports.Lexer = Lexer;
  function isPunctuatorTokenKind(kind) {
    return kind === _tokenKind.TokenKind.BANG || kind === _tokenKind.TokenKind.DOLLAR || kind === _tokenKind.TokenKind.AMP || kind === _tokenKind.TokenKind.PAREN_L || kind === _tokenKind.TokenKind.PAREN_R || kind === _tokenKind.TokenKind.SPREAD || kind === _tokenKind.TokenKind.COLON || kind === _tokenKind.TokenKind.EQUALS || kind === _tokenKind.TokenKind.AT || kind === _tokenKind.TokenKind.BRACKET_L || kind === _tokenKind.TokenKind.BRACKET_R || kind === _tokenKind.TokenKind.BRACE_L || kind === _tokenKind.TokenKind.PIPE || kind === _tokenKind.TokenKind.BRACE_R;
  }
  function printCharCode(code) {
    return isNaN(code) ? _tokenKind.TokenKind.EOF : code < 127 ? JSON.stringify(String.fromCharCode(code)) : '"\\u'.concat(("00" + code.toString(16).toUpperCase()).slice(-4), '"');
  }
  function readToken(lexer, prev) {
    var source = lexer.source;
    var body = source.body;
    var bodyLength = body.length;
    var pos = prev.end;
    while (pos < bodyLength) {
      var code = body.charCodeAt(pos);
      var _line = lexer.line;
      var _col = 1 + pos - lexer.lineStart;
      switch (code) {
        case 65279:
        case 9:
        case 32:
        case 44:
          ++pos;
          continue;
        case 10:
          ++pos;
          ++lexer.line;
          lexer.lineStart = pos;
          continue;
        case 13:
          if (body.charCodeAt(pos + 1) === 10) {
            pos += 2;
          } else {
            ++pos;
          }
          ++lexer.line;
          lexer.lineStart = pos;
          continue;
        case 33:
          return new _ast.Token(_tokenKind.TokenKind.BANG, pos, pos + 1, _line, _col, prev);
        case 35:
          return readComment(source, pos, _line, _col, prev);
        case 36:
          return new _ast.Token(_tokenKind.TokenKind.DOLLAR, pos, pos + 1, _line, _col, prev);
        case 38:
          return new _ast.Token(_tokenKind.TokenKind.AMP, pos, pos + 1, _line, _col, prev);
        case 40:
          return new _ast.Token(_tokenKind.TokenKind.PAREN_L, pos, pos + 1, _line, _col, prev);
        case 41:
          return new _ast.Token(_tokenKind.TokenKind.PAREN_R, pos, pos + 1, _line, _col, prev);
        case 46:
          if (body.charCodeAt(pos + 1) === 46 && body.charCodeAt(pos + 2) === 46) {
            return new _ast.Token(_tokenKind.TokenKind.SPREAD, pos, pos + 3, _line, _col, prev);
          }
          break;
        case 58:
          return new _ast.Token(_tokenKind.TokenKind.COLON, pos, pos + 1, _line, _col, prev);
        case 61:
          return new _ast.Token(_tokenKind.TokenKind.EQUALS, pos, pos + 1, _line, _col, prev);
        case 64:
          return new _ast.Token(_tokenKind.TokenKind.AT, pos, pos + 1, _line, _col, prev);
        case 91:
          return new _ast.Token(_tokenKind.TokenKind.BRACKET_L, pos, pos + 1, _line, _col, prev);
        case 93:
          return new _ast.Token(_tokenKind.TokenKind.BRACKET_R, pos, pos + 1, _line, _col, prev);
        case 123:
          return new _ast.Token(_tokenKind.TokenKind.BRACE_L, pos, pos + 1, _line, _col, prev);
        case 124:
          return new _ast.Token(_tokenKind.TokenKind.PIPE, pos, pos + 1, _line, _col, prev);
        case 125:
          return new _ast.Token(_tokenKind.TokenKind.BRACE_R, pos, pos + 1, _line, _col, prev);
        case 34:
          if (body.charCodeAt(pos + 1) === 34 && body.charCodeAt(pos + 2) === 34) {
            return readBlockString(source, pos, _line, _col, prev, lexer);
          }
          return readString(source, pos, _line, _col, prev);
        case 45:
        case 48:
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          return readNumber(source, pos, code, _line, _col, prev);
        case 65:
        case 66:
        case 67:
        case 68:
        case 69:
        case 70:
        case 71:
        case 72:
        case 73:
        case 74:
        case 75:
        case 76:
        case 77:
        case 78:
        case 79:
        case 80:
        case 81:
        case 82:
        case 83:
        case 84:
        case 85:
        case 86:
        case 87:
        case 88:
        case 89:
        case 90:
        case 95:
        case 97:
        case 98:
        case 99:
        case 100:
        case 101:
        case 102:
        case 103:
        case 104:
        case 105:
        case 106:
        case 107:
        case 108:
        case 109:
        case 110:
        case 111:
        case 112:
        case 113:
        case 114:
        case 115:
        case 116:
        case 117:
        case 118:
        case 119:
        case 120:
        case 121:
        case 122:
          return readName(source, pos, _line, _col, prev);
      }
      throw (0, _syntaxError.syntaxError)(source, pos, unexpectedCharacterMessage(code));
    }
    var line = lexer.line;
    var col = 1 + pos - lexer.lineStart;
    return new _ast.Token(_tokenKind.TokenKind.EOF, bodyLength, bodyLength, line, col, prev);
  }
  function unexpectedCharacterMessage(code) {
    if (code < 32 && code !== 9 && code !== 10 && code !== 13) {
      return "Cannot contain the invalid character ".concat(printCharCode(code), ".");
    }
    if (code === 39) {
      return `Unexpected single quote character ('), did you mean to use a double quote (")?`;
    }
    return "Cannot parse the unexpected character ".concat(printCharCode(code), ".");
  }
  function readComment(source, start, line, col, prev) {
    var body = source.body;
    var code;
    var position = start;
    do {
      code = body.charCodeAt(++position);
    } while (!isNaN(code) && (code > 31 || code === 9));
    return new _ast.Token(_tokenKind.TokenKind.COMMENT, start, position, line, col, prev, body.slice(start + 1, position));
  }
  function readNumber(source, start, firstCode, line, col, prev) {
    var body = source.body;
    var code = firstCode;
    var position = start;
    var isFloat = false;
    if (code === 45) {
      code = body.charCodeAt(++position);
    }
    if (code === 48) {
      code = body.charCodeAt(++position);
      if (code >= 48 && code <= 57) {
        throw (0, _syntaxError.syntaxError)(source, position, "Invalid number, unexpected digit after 0: ".concat(printCharCode(code), "."));
      }
    } else {
      position = readDigits(source, position, code);
      code = body.charCodeAt(position);
    }
    if (code === 46) {
      isFloat = true;
      code = body.charCodeAt(++position);
      position = readDigits(source, position, code);
      code = body.charCodeAt(position);
    }
    if (code === 69 || code === 101) {
      isFloat = true;
      code = body.charCodeAt(++position);
      if (code === 43 || code === 45) {
        code = body.charCodeAt(++position);
      }
      position = readDigits(source, position, code);
      code = body.charCodeAt(position);
    }
    if (code === 46 || isNameStart(code)) {
      throw (0, _syntaxError.syntaxError)(source, position, "Invalid number, expected digit but got: ".concat(printCharCode(code), "."));
    }
    return new _ast.Token(isFloat ? _tokenKind.TokenKind.FLOAT : _tokenKind.TokenKind.INT, start, position, line, col, prev, body.slice(start, position));
  }
  function readDigits(source, start, firstCode) {
    var body = source.body;
    var position = start;
    var code = firstCode;
    if (code >= 48 && code <= 57) {
      do {
        code = body.charCodeAt(++position);
      } while (code >= 48 && code <= 57);
      return position;
    }
    throw (0, _syntaxError.syntaxError)(source, position, "Invalid number, expected digit but got: ".concat(printCharCode(code), "."));
  }
  function readString(source, start, line, col, prev) {
    var body = source.body;
    var position = start + 1;
    var chunkStart = position;
    var code = 0;
    var value = "";
    while (position < body.length && !isNaN(code = body.charCodeAt(position)) && code !== 10 && code !== 13) {
      if (code === 34) {
        value += body.slice(chunkStart, position);
        return new _ast.Token(_tokenKind.TokenKind.STRING, start, position + 1, line, col, prev, value);
      }
      if (code < 32 && code !== 9) {
        throw (0, _syntaxError.syntaxError)(source, position, "Invalid character within String: ".concat(printCharCode(code), "."));
      }
      ++position;
      if (code === 92) {
        value += body.slice(chunkStart, position - 1);
        code = body.charCodeAt(position);
        switch (code) {
          case 34:
            value += '"';
            break;
          case 47:
            value += "/";
            break;
          case 92:
            value += "\\";
            break;
          case 98:
            value += "\b";
            break;
          case 102:
            value += "\f";
            break;
          case 110:
            value += `
`;
            break;
          case 114:
            value += "\r";
            break;
          case 116:
            value += "\t";
            break;
          case 117: {
            var charCode = uniCharCode(body.charCodeAt(position + 1), body.charCodeAt(position + 2), body.charCodeAt(position + 3), body.charCodeAt(position + 4));
            if (charCode < 0) {
              var invalidSequence = body.slice(position + 1, position + 5);
              throw (0, _syntaxError.syntaxError)(source, position, "Invalid character escape sequence: \\u".concat(invalidSequence, "."));
            }
            value += String.fromCharCode(charCode);
            position += 4;
            break;
          }
          default:
            throw (0, _syntaxError.syntaxError)(source, position, "Invalid character escape sequence: \\".concat(String.fromCharCode(code), "."));
        }
        ++position;
        chunkStart = position;
      }
    }
    throw (0, _syntaxError.syntaxError)(source, position, "Unterminated string.");
  }
  function readBlockString(source, start, line, col, prev, lexer) {
    var body = source.body;
    var position = start + 3;
    var chunkStart = position;
    var code = 0;
    var rawValue = "";
    while (position < body.length && !isNaN(code = body.charCodeAt(position))) {
      if (code === 34 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
        rawValue += body.slice(chunkStart, position);
        return new _ast.Token(_tokenKind.TokenKind.BLOCK_STRING, start, position + 3, line, col, prev, (0, _blockString.dedentBlockStringValue)(rawValue));
      }
      if (code < 32 && code !== 9 && code !== 10 && code !== 13) {
        throw (0, _syntaxError.syntaxError)(source, position, "Invalid character within String: ".concat(printCharCode(code), "."));
      }
      if (code === 10) {
        ++position;
        ++lexer.line;
        lexer.lineStart = position;
      } else if (code === 13) {
        if (body.charCodeAt(position + 1) === 10) {
          position += 2;
        } else {
          ++position;
        }
        ++lexer.line;
        lexer.lineStart = position;
      } else if (code === 92 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34 && body.charCodeAt(position + 3) === 34) {
        rawValue += body.slice(chunkStart, position) + '"""';
        position += 4;
        chunkStart = position;
      } else {
        ++position;
      }
    }
    throw (0, _syntaxError.syntaxError)(source, position, "Unterminated string.");
  }
  function uniCharCode(a, b, c, d) {
    return char2hex(a) << 12 | char2hex(b) << 8 | char2hex(c) << 4 | char2hex(d);
  }
  function char2hex(a) {
    return a >= 48 && a <= 57 ? a - 48 : a >= 65 && a <= 70 ? a - 55 : a >= 97 && a <= 102 ? a - 87 : -1;
  }
  function readName(source, start, line, col, prev) {
    var body = source.body;
    var bodyLength = body.length;
    var position = start + 1;
    var code = 0;
    while (position !== bodyLength && !isNaN(code = body.charCodeAt(position)) && (code === 95 || code >= 48 && code <= 57 || code >= 65 && code <= 90 || code >= 97 && code <= 122)) {
      ++position;
    }
    return new _ast.Token(_tokenKind.TokenKind.NAME, start, position, line, col, prev, body.slice(start, position));
  }
  function isNameStart(code) {
    return code === 95 || code >= 65 && code <= 90 || code >= 97 && code <= 122;
  }
});

// node_modules/graphql/language/parser.js
var require_parser = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.parse = parse;
  exports.parseValue = parseValue;
  exports.parseType = parseType;
  exports.Parser = undefined;
  var _syntaxError = require_syntaxError();
  var _kinds = require_kinds();
  var _ast = require_ast();
  var _tokenKind = require_tokenKind();
  var _source = require_source();
  var _directiveLocation = require_directiveLocation();
  var _lexer = require_lexer();
  function parse(source, options) {
    var parser = new Parser(source, options);
    return parser.parseDocument();
  }
  function parseValue(source, options) {
    var parser = new Parser(source, options);
    parser.expectToken(_tokenKind.TokenKind.SOF);
    var value = parser.parseValueLiteral(false);
    parser.expectToken(_tokenKind.TokenKind.EOF);
    return value;
  }
  function parseType(source, options) {
    var parser = new Parser(source, options);
    parser.expectToken(_tokenKind.TokenKind.SOF);
    var type = parser.parseTypeReference();
    parser.expectToken(_tokenKind.TokenKind.EOF);
    return type;
  }
  var Parser = /* @__PURE__ */ function() {
    function Parser2(source, options) {
      var sourceObj = (0, _source.isSource)(source) ? source : new _source.Source(source);
      this._lexer = new _lexer.Lexer(sourceObj);
      this._options = options;
    }
    var _proto = Parser2.prototype;
    _proto.parseName = function parseName() {
      var token = this.expectToken(_tokenKind.TokenKind.NAME);
      return {
        kind: _kinds.Kind.NAME,
        value: token.value,
        loc: this.loc(token)
      };
    };
    _proto.parseDocument = function parseDocument() {
      var start = this._lexer.token;
      return {
        kind: _kinds.Kind.DOCUMENT,
        definitions: this.many(_tokenKind.TokenKind.SOF, this.parseDefinition, _tokenKind.TokenKind.EOF),
        loc: this.loc(start)
      };
    };
    _proto.parseDefinition = function parseDefinition() {
      if (this.peek(_tokenKind.TokenKind.NAME)) {
        switch (this._lexer.token.value) {
          case "query":
          case "mutation":
          case "subscription":
            return this.parseOperationDefinition();
          case "fragment":
            return this.parseFragmentDefinition();
          case "schema":
          case "scalar":
          case "type":
          case "interface":
          case "union":
          case "enum":
          case "input":
          case "directive":
            return this.parseTypeSystemDefinition();
          case "extend":
            return this.parseTypeSystemExtension();
        }
      } else if (this.peek(_tokenKind.TokenKind.BRACE_L)) {
        return this.parseOperationDefinition();
      } else if (this.peekDescription()) {
        return this.parseTypeSystemDefinition();
      }
      throw this.unexpected();
    };
    _proto.parseOperationDefinition = function parseOperationDefinition() {
      var start = this._lexer.token;
      if (this.peek(_tokenKind.TokenKind.BRACE_L)) {
        return {
          kind: _kinds.Kind.OPERATION_DEFINITION,
          operation: "query",
          name: undefined,
          variableDefinitions: [],
          directives: [],
          selectionSet: this.parseSelectionSet(),
          loc: this.loc(start)
        };
      }
      var operation = this.parseOperationType();
      var name;
      if (this.peek(_tokenKind.TokenKind.NAME)) {
        name = this.parseName();
      }
      return {
        kind: _kinds.Kind.OPERATION_DEFINITION,
        operation,
        name,
        variableDefinitions: this.parseVariableDefinitions(),
        directives: this.parseDirectives(false),
        selectionSet: this.parseSelectionSet(),
        loc: this.loc(start)
      };
    };
    _proto.parseOperationType = function parseOperationType() {
      var operationToken = this.expectToken(_tokenKind.TokenKind.NAME);
      switch (operationToken.value) {
        case "query":
          return "query";
        case "mutation":
          return "mutation";
        case "subscription":
          return "subscription";
      }
      throw this.unexpected(operationToken);
    };
    _proto.parseVariableDefinitions = function parseVariableDefinitions() {
      return this.optionalMany(_tokenKind.TokenKind.PAREN_L, this.parseVariableDefinition, _tokenKind.TokenKind.PAREN_R);
    };
    _proto.parseVariableDefinition = function parseVariableDefinition() {
      var start = this._lexer.token;
      return {
        kind: _kinds.Kind.VARIABLE_DEFINITION,
        variable: this.parseVariable(),
        type: (this.expectToken(_tokenKind.TokenKind.COLON), this.parseTypeReference()),
        defaultValue: this.expectOptionalToken(_tokenKind.TokenKind.EQUALS) ? this.parseValueLiteral(true) : undefined,
        directives: this.parseDirectives(true),
        loc: this.loc(start)
      };
    };
    _proto.parseVariable = function parseVariable() {
      var start = this._lexer.token;
      this.expectToken(_tokenKind.TokenKind.DOLLAR);
      return {
        kind: _kinds.Kind.VARIABLE,
        name: this.parseName(),
        loc: this.loc(start)
      };
    };
    _proto.parseSelectionSet = function parseSelectionSet() {
      var start = this._lexer.token;
      return {
        kind: _kinds.Kind.SELECTION_SET,
        selections: this.many(_tokenKind.TokenKind.BRACE_L, this.parseSelection, _tokenKind.TokenKind.BRACE_R),
        loc: this.loc(start)
      };
    };
    _proto.parseSelection = function parseSelection() {
      return this.peek(_tokenKind.TokenKind.SPREAD) ? this.parseFragment() : this.parseField();
    };
    _proto.parseField = function parseField() {
      var start = this._lexer.token;
      var nameOrAlias = this.parseName();
      var alias;
      var name;
      if (this.expectOptionalToken(_tokenKind.TokenKind.COLON)) {
        alias = nameOrAlias;
        name = this.parseName();
      } else {
        name = nameOrAlias;
      }
      return {
        kind: _kinds.Kind.FIELD,
        alias,
        name,
        arguments: this.parseArguments(false),
        directives: this.parseDirectives(false),
        selectionSet: this.peek(_tokenKind.TokenKind.BRACE_L) ? this.parseSelectionSet() : undefined,
        loc: this.loc(start)
      };
    };
    _proto.parseArguments = function parseArguments(isConst) {
      var item = isConst ? this.parseConstArgument : this.parseArgument;
      return this.optionalMany(_tokenKind.TokenKind.PAREN_L, item, _tokenKind.TokenKind.PAREN_R);
    };
    _proto.parseArgument = function parseArgument() {
      var start = this._lexer.token;
      var name = this.parseName();
      this.expectToken(_tokenKind.TokenKind.COLON);
      return {
        kind: _kinds.Kind.ARGUMENT,
        name,
        value: this.parseValueLiteral(false),
        loc: this.loc(start)
      };
    };
    _proto.parseConstArgument = function parseConstArgument() {
      var start = this._lexer.token;
      return {
        kind: _kinds.Kind.ARGUMENT,
        name: this.parseName(),
        value: (this.expectToken(_tokenKind.TokenKind.COLON), this.parseValueLiteral(true)),
        loc: this.loc(start)
      };
    };
    _proto.parseFragment = function parseFragment() {
      var start = this._lexer.token;
      this.expectToken(_tokenKind.TokenKind.SPREAD);
      var hasTypeCondition = this.expectOptionalKeyword("on");
      if (!hasTypeCondition && this.peek(_tokenKind.TokenKind.NAME)) {
        return {
          kind: _kinds.Kind.FRAGMENT_SPREAD,
          name: this.parseFragmentName(),
          directives: this.parseDirectives(false),
          loc: this.loc(start)
        };
      }
      return {
        kind: _kinds.Kind.INLINE_FRAGMENT,
        typeCondition: hasTypeCondition ? this.parseNamedType() : undefined,
        directives: this.parseDirectives(false),
        selectionSet: this.parseSelectionSet(),
        loc: this.loc(start)
      };
    };
    _proto.parseFragmentDefinition = function parseFragmentDefinition() {
      var _this$_options;
      var start = this._lexer.token;
      this.expectKeyword("fragment");
      if (((_this$_options = this._options) === null || _this$_options === undefined ? undefined : _this$_options.experimentalFragmentVariables) === true) {
        return {
          kind: _kinds.Kind.FRAGMENT_DEFINITION,
          name: this.parseFragmentName(),
          variableDefinitions: this.parseVariableDefinitions(),
          typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
          directives: this.parseDirectives(false),
          selectionSet: this.parseSelectionSet(),
          loc: this.loc(start)
        };
      }
      return {
        kind: _kinds.Kind.FRAGMENT_DEFINITION,
        name: this.parseFragmentName(),
        typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
        directives: this.parseDirectives(false),
        selectionSet: this.parseSelectionSet(),
        loc: this.loc(start)
      };
    };
    _proto.parseFragmentName = function parseFragmentName() {
      if (this._lexer.token.value === "on") {
        throw this.unexpected();
      }
      return this.parseName();
    };
    _proto.parseValueLiteral = function parseValueLiteral(isConst) {
      var token = this._lexer.token;
      switch (token.kind) {
        case _tokenKind.TokenKind.BRACKET_L:
          return this.parseList(isConst);
        case _tokenKind.TokenKind.BRACE_L:
          return this.parseObject(isConst);
        case _tokenKind.TokenKind.INT:
          this._lexer.advance();
          return {
            kind: _kinds.Kind.INT,
            value: token.value,
            loc: this.loc(token)
          };
        case _tokenKind.TokenKind.FLOAT:
          this._lexer.advance();
          return {
            kind: _kinds.Kind.FLOAT,
            value: token.value,
            loc: this.loc(token)
          };
        case _tokenKind.TokenKind.STRING:
        case _tokenKind.TokenKind.BLOCK_STRING:
          return this.parseStringLiteral();
        case _tokenKind.TokenKind.NAME:
          this._lexer.advance();
          switch (token.value) {
            case "true":
              return {
                kind: _kinds.Kind.BOOLEAN,
                value: true,
                loc: this.loc(token)
              };
            case "false":
              return {
                kind: _kinds.Kind.BOOLEAN,
                value: false,
                loc: this.loc(token)
              };
            case "null":
              return {
                kind: _kinds.Kind.NULL,
                loc: this.loc(token)
              };
            default:
              return {
                kind: _kinds.Kind.ENUM,
                value: token.value,
                loc: this.loc(token)
              };
          }
        case _tokenKind.TokenKind.DOLLAR:
          if (!isConst) {
            return this.parseVariable();
          }
          break;
      }
      throw this.unexpected();
    };
    _proto.parseStringLiteral = function parseStringLiteral() {
      var token = this._lexer.token;
      this._lexer.advance();
      return {
        kind: _kinds.Kind.STRING,
        value: token.value,
        block: token.kind === _tokenKind.TokenKind.BLOCK_STRING,
        loc: this.loc(token)
      };
    };
    _proto.parseList = function parseList(isConst) {
      var _this = this;
      var start = this._lexer.token;
      var item = function item() {
        return _this.parseValueLiteral(isConst);
      };
      return {
        kind: _kinds.Kind.LIST,
        values: this.any(_tokenKind.TokenKind.BRACKET_L, item, _tokenKind.TokenKind.BRACKET_R),
        loc: this.loc(start)
      };
    };
    _proto.parseObject = function parseObject(isConst) {
      var _this2 = this;
      var start = this._lexer.token;
      var item = function item() {
        return _this2.parseObjectField(isConst);
      };
      return {
        kind: _kinds.Kind.OBJECT,
        fields: this.any(_tokenKind.TokenKind.BRACE_L, item, _tokenKind.TokenKind.BRACE_R),
        loc: this.loc(start)
      };
    };
    _proto.parseObjectField = function parseObjectField(isConst) {
      var start = this._lexer.token;
      var name = this.parseName();
      this.expectToken(_tokenKind.TokenKind.COLON);
      return {
        kind: _kinds.Kind.OBJECT_FIELD,
        name,
        value: this.parseValueLiteral(isConst),
        loc: this.loc(start)
      };
    };
    _proto.parseDirectives = function parseDirectives(isConst) {
      var directives = [];
      while (this.peek(_tokenKind.TokenKind.AT)) {
        directives.push(this.parseDirective(isConst));
      }
      return directives;
    };
    _proto.parseDirective = function parseDirective(isConst) {
      var start = this._lexer.token;
      this.expectToken(_tokenKind.TokenKind.AT);
      return {
        kind: _kinds.Kind.DIRECTIVE,
        name: this.parseName(),
        arguments: this.parseArguments(isConst),
        loc: this.loc(start)
      };
    };
    _proto.parseTypeReference = function parseTypeReference() {
      var start = this._lexer.token;
      var type;
      if (this.expectOptionalToken(_tokenKind.TokenKind.BRACKET_L)) {
        type = this.parseTypeReference();
        this.expectToken(_tokenKind.TokenKind.BRACKET_R);
        type = {
          kind: _kinds.Kind.LIST_TYPE,
          type,
          loc: this.loc(start)
        };
      } else {
        type = this.parseNamedType();
      }
      if (this.expectOptionalToken(_tokenKind.TokenKind.BANG)) {
        return {
          kind: _kinds.Kind.NON_NULL_TYPE,
          type,
          loc: this.loc(start)
        };
      }
      return type;
    };
    _proto.parseNamedType = function parseNamedType() {
      var start = this._lexer.token;
      return {
        kind: _kinds.Kind.NAMED_TYPE,
        name: this.parseName(),
        loc: this.loc(start)
      };
    };
    _proto.parseTypeSystemDefinition = function parseTypeSystemDefinition() {
      var keywordToken = this.peekDescription() ? this._lexer.lookahead() : this._lexer.token;
      if (keywordToken.kind === _tokenKind.TokenKind.NAME) {
        switch (keywordToken.value) {
          case "schema":
            return this.parseSchemaDefinition();
          case "scalar":
            return this.parseScalarTypeDefinition();
          case "type":
            return this.parseObjectTypeDefinition();
          case "interface":
            return this.parseInterfaceTypeDefinition();
          case "union":
            return this.parseUnionTypeDefinition();
          case "enum":
            return this.parseEnumTypeDefinition();
          case "input":
            return this.parseInputObjectTypeDefinition();
          case "directive":
            return this.parseDirectiveDefinition();
        }
      }
      throw this.unexpected(keywordToken);
    };
    _proto.peekDescription = function peekDescription() {
      return this.peek(_tokenKind.TokenKind.STRING) || this.peek(_tokenKind.TokenKind.BLOCK_STRING);
    };
    _proto.parseDescription = function parseDescription() {
      if (this.peekDescription()) {
        return this.parseStringLiteral();
      }
    };
    _proto.parseSchemaDefinition = function parseSchemaDefinition() {
      var start = this._lexer.token;
      var description = this.parseDescription();
      this.expectKeyword("schema");
      var directives = this.parseDirectives(true);
      var operationTypes = this.many(_tokenKind.TokenKind.BRACE_L, this.parseOperationTypeDefinition, _tokenKind.TokenKind.BRACE_R);
      return {
        kind: _kinds.Kind.SCHEMA_DEFINITION,
        description,
        directives,
        operationTypes,
        loc: this.loc(start)
      };
    };
    _proto.parseOperationTypeDefinition = function parseOperationTypeDefinition() {
      var start = this._lexer.token;
      var operation = this.parseOperationType();
      this.expectToken(_tokenKind.TokenKind.COLON);
      var type = this.parseNamedType();
      return {
        kind: _kinds.Kind.OPERATION_TYPE_DEFINITION,
        operation,
        type,
        loc: this.loc(start)
      };
    };
    _proto.parseScalarTypeDefinition = function parseScalarTypeDefinition() {
      var start = this._lexer.token;
      var description = this.parseDescription();
      this.expectKeyword("scalar");
      var name = this.parseName();
      var directives = this.parseDirectives(true);
      return {
        kind: _kinds.Kind.SCALAR_TYPE_DEFINITION,
        description,
        name,
        directives,
        loc: this.loc(start)
      };
    };
    _proto.parseObjectTypeDefinition = function parseObjectTypeDefinition() {
      var start = this._lexer.token;
      var description = this.parseDescription();
      this.expectKeyword("type");
      var name = this.parseName();
      var interfaces = this.parseImplementsInterfaces();
      var directives = this.parseDirectives(true);
      var fields = this.parseFieldsDefinition();
      return {
        kind: _kinds.Kind.OBJECT_TYPE_DEFINITION,
        description,
        name,
        interfaces,
        directives,
        fields,
        loc: this.loc(start)
      };
    };
    _proto.parseImplementsInterfaces = function parseImplementsInterfaces() {
      var _this$_options2;
      if (!this.expectOptionalKeyword("implements")) {
        return [];
      }
      if (((_this$_options2 = this._options) === null || _this$_options2 === undefined ? undefined : _this$_options2.allowLegacySDLImplementsInterfaces) === true) {
        var types = [];
        this.expectOptionalToken(_tokenKind.TokenKind.AMP);
        do {
          types.push(this.parseNamedType());
        } while (this.expectOptionalToken(_tokenKind.TokenKind.AMP) || this.peek(_tokenKind.TokenKind.NAME));
        return types;
      }
      return this.delimitedMany(_tokenKind.TokenKind.AMP, this.parseNamedType);
    };
    _proto.parseFieldsDefinition = function parseFieldsDefinition() {
      var _this$_options3;
      if (((_this$_options3 = this._options) === null || _this$_options3 === undefined ? undefined : _this$_options3.allowLegacySDLEmptyFields) === true && this.peek(_tokenKind.TokenKind.BRACE_L) && this._lexer.lookahead().kind === _tokenKind.TokenKind.BRACE_R) {
        this._lexer.advance();
        this._lexer.advance();
        return [];
      }
      return this.optionalMany(_tokenKind.TokenKind.BRACE_L, this.parseFieldDefinition, _tokenKind.TokenKind.BRACE_R);
    };
    _proto.parseFieldDefinition = function parseFieldDefinition() {
      var start = this._lexer.token;
      var description = this.parseDescription();
      var name = this.parseName();
      var args2 = this.parseArgumentDefs();
      this.expectToken(_tokenKind.TokenKind.COLON);
      var type = this.parseTypeReference();
      var directives = this.parseDirectives(true);
      return {
        kind: _kinds.Kind.FIELD_DEFINITION,
        description,
        name,
        arguments: args2,
        type,
        directives,
        loc: this.loc(start)
      };
    };
    _proto.parseArgumentDefs = function parseArgumentDefs() {
      return this.optionalMany(_tokenKind.TokenKind.PAREN_L, this.parseInputValueDef, _tokenKind.TokenKind.PAREN_R);
    };
    _proto.parseInputValueDef = function parseInputValueDef() {
      var start = this._lexer.token;
      var description = this.parseDescription();
      var name = this.parseName();
      this.expectToken(_tokenKind.TokenKind.COLON);
      var type = this.parseTypeReference();
      var defaultValue;
      if (this.expectOptionalToken(_tokenKind.TokenKind.EQUALS)) {
        defaultValue = this.parseValueLiteral(true);
      }
      var directives = this.parseDirectives(true);
      return {
        kind: _kinds.Kind.INPUT_VALUE_DEFINITION,
        description,
        name,
        type,
        defaultValue,
        directives,
        loc: this.loc(start)
      };
    };
    _proto.parseInterfaceTypeDefinition = function parseInterfaceTypeDefinition() {
      var start = this._lexer.token;
      var description = this.parseDescription();
      this.expectKeyword("interface");
      var name = this.parseName();
      var interfaces = this.parseImplementsInterfaces();
      var directives = this.parseDirectives(true);
      var fields = this.parseFieldsDefinition();
      return {
        kind: _kinds.Kind.INTERFACE_TYPE_DEFINITION,
        description,
        name,
        interfaces,
        directives,
        fields,
        loc: this.loc(start)
      };
    };
    _proto.parseUnionTypeDefinition = function parseUnionTypeDefinition() {
      var start = this._lexer.token;
      var description = this.parseDescription();
      this.expectKeyword("union");
      var name = this.parseName();
      var directives = this.parseDirectives(true);
      var types = this.parseUnionMemberTypes();
      return {
        kind: _kinds.Kind.UNION_TYPE_DEFINITION,
        description,
        name,
        directives,
        types,
        loc: this.loc(start)
      };
    };
    _proto.parseUnionMemberTypes = function parseUnionMemberTypes() {
      return this.expectOptionalToken(_tokenKind.TokenKind.EQUALS) ? this.delimitedMany(_tokenKind.TokenKind.PIPE, this.parseNamedType) : [];
    };
    _proto.parseEnumTypeDefinition = function parseEnumTypeDefinition() {
      var start = this._lexer.token;
      var description = this.parseDescription();
      this.expectKeyword("enum");
      var name = this.parseName();
      var directives = this.parseDirectives(true);
      var values = this.parseEnumValuesDefinition();
      return {
        kind: _kinds.Kind.ENUM_TYPE_DEFINITION,
        description,
        name,
        directives,
        values,
        loc: this.loc(start)
      };
    };
    _proto.parseEnumValuesDefinition = function parseEnumValuesDefinition() {
      return this.optionalMany(_tokenKind.TokenKind.BRACE_L, this.parseEnumValueDefinition, _tokenKind.TokenKind.BRACE_R);
    };
    _proto.parseEnumValueDefinition = function parseEnumValueDefinition() {
      var start = this._lexer.token;
      var description = this.parseDescription();
      var name = this.parseName();
      var directives = this.parseDirectives(true);
      return {
        kind: _kinds.Kind.ENUM_VALUE_DEFINITION,
        description,
        name,
        directives,
        loc: this.loc(start)
      };
    };
    _proto.parseInputObjectTypeDefinition = function parseInputObjectTypeDefinition() {
      var start = this._lexer.token;
      var description = this.parseDescription();
      this.expectKeyword("input");
      var name = this.parseName();
      var directives = this.parseDirectives(true);
      var fields = this.parseInputFieldsDefinition();
      return {
        kind: _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION,
        description,
        name,
        directives,
        fields,
        loc: this.loc(start)
      };
    };
    _proto.parseInputFieldsDefinition = function parseInputFieldsDefinition() {
      return this.optionalMany(_tokenKind.TokenKind.BRACE_L, this.parseInputValueDef, _tokenKind.TokenKind.BRACE_R);
    };
    _proto.parseTypeSystemExtension = function parseTypeSystemExtension() {
      var keywordToken = this._lexer.lookahead();
      if (keywordToken.kind === _tokenKind.TokenKind.NAME) {
        switch (keywordToken.value) {
          case "schema":
            return this.parseSchemaExtension();
          case "scalar":
            return this.parseScalarTypeExtension();
          case "type":
            return this.parseObjectTypeExtension();
          case "interface":
            return this.parseInterfaceTypeExtension();
          case "union":
            return this.parseUnionTypeExtension();
          case "enum":
            return this.parseEnumTypeExtension();
          case "input":
            return this.parseInputObjectTypeExtension();
        }
      }
      throw this.unexpected(keywordToken);
    };
    _proto.parseSchemaExtension = function parseSchemaExtension() {
      var start = this._lexer.token;
      this.expectKeyword("extend");
      this.expectKeyword("schema");
      var directives = this.parseDirectives(true);
      var operationTypes = this.optionalMany(_tokenKind.TokenKind.BRACE_L, this.parseOperationTypeDefinition, _tokenKind.TokenKind.BRACE_R);
      if (directives.length === 0 && operationTypes.length === 0) {
        throw this.unexpected();
      }
      return {
        kind: _kinds.Kind.SCHEMA_EXTENSION,
        directives,
        operationTypes,
        loc: this.loc(start)
      };
    };
    _proto.parseScalarTypeExtension = function parseScalarTypeExtension() {
      var start = this._lexer.token;
      this.expectKeyword("extend");
      this.expectKeyword("scalar");
      var name = this.parseName();
      var directives = this.parseDirectives(true);
      if (directives.length === 0) {
        throw this.unexpected();
      }
      return {
        kind: _kinds.Kind.SCALAR_TYPE_EXTENSION,
        name,
        directives,
        loc: this.loc(start)
      };
    };
    _proto.parseObjectTypeExtension = function parseObjectTypeExtension() {
      var start = this._lexer.token;
      this.expectKeyword("extend");
      this.expectKeyword("type");
      var name = this.parseName();
      var interfaces = this.parseImplementsInterfaces();
      var directives = this.parseDirectives(true);
      var fields = this.parseFieldsDefinition();
      if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
        throw this.unexpected();
      }
      return {
        kind: _kinds.Kind.OBJECT_TYPE_EXTENSION,
        name,
        interfaces,
        directives,
        fields,
        loc: this.loc(start)
      };
    };
    _proto.parseInterfaceTypeExtension = function parseInterfaceTypeExtension() {
      var start = this._lexer.token;
      this.expectKeyword("extend");
      this.expectKeyword("interface");
      var name = this.parseName();
      var interfaces = this.parseImplementsInterfaces();
      var directives = this.parseDirectives(true);
      var fields = this.parseFieldsDefinition();
      if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
        throw this.unexpected();
      }
      return {
        kind: _kinds.Kind.INTERFACE_TYPE_EXTENSION,
        name,
        interfaces,
        directives,
        fields,
        loc: this.loc(start)
      };
    };
    _proto.parseUnionTypeExtension = function parseUnionTypeExtension() {
      var start = this._lexer.token;
      this.expectKeyword("extend");
      this.expectKeyword("union");
      var name = this.parseName();
      var directives = this.parseDirectives(true);
      var types = this.parseUnionMemberTypes();
      if (directives.length === 0 && types.length === 0) {
        throw this.unexpected();
      }
      return {
        kind: _kinds.Kind.UNION_TYPE_EXTENSION,
        name,
        directives,
        types,
        loc: this.loc(start)
      };
    };
    _proto.parseEnumTypeExtension = function parseEnumTypeExtension() {
      var start = this._lexer.token;
      this.expectKeyword("extend");
      this.expectKeyword("enum");
      var name = this.parseName();
      var directives = this.parseDirectives(true);
      var values = this.parseEnumValuesDefinition();
      if (directives.length === 0 && values.length === 0) {
        throw this.unexpected();
      }
      return {
        kind: _kinds.Kind.ENUM_TYPE_EXTENSION,
        name,
        directives,
        values,
        loc: this.loc(start)
      };
    };
    _proto.parseInputObjectTypeExtension = function parseInputObjectTypeExtension() {
      var start = this._lexer.token;
      this.expectKeyword("extend");
      this.expectKeyword("input");
      var name = this.parseName();
      var directives = this.parseDirectives(true);
      var fields = this.parseInputFieldsDefinition();
      if (directives.length === 0 && fields.length === 0) {
        throw this.unexpected();
      }
      return {
        kind: _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION,
        name,
        directives,
        fields,
        loc: this.loc(start)
      };
    };
    _proto.parseDirectiveDefinition = function parseDirectiveDefinition() {
      var start = this._lexer.token;
      var description = this.parseDescription();
      this.expectKeyword("directive");
      this.expectToken(_tokenKind.TokenKind.AT);
      var name = this.parseName();
      var args2 = this.parseArgumentDefs();
      var repeatable = this.expectOptionalKeyword("repeatable");
      this.expectKeyword("on");
      var locations = this.parseDirectiveLocations();
      return {
        kind: _kinds.Kind.DIRECTIVE_DEFINITION,
        description,
        name,
        arguments: args2,
        repeatable,
        locations,
        loc: this.loc(start)
      };
    };
    _proto.parseDirectiveLocations = function parseDirectiveLocations() {
      return this.delimitedMany(_tokenKind.TokenKind.PIPE, this.parseDirectiveLocation);
    };
    _proto.parseDirectiveLocation = function parseDirectiveLocation() {
      var start = this._lexer.token;
      var name = this.parseName();
      if (_directiveLocation.DirectiveLocation[name.value] !== undefined) {
        return name;
      }
      throw this.unexpected(start);
    };
    _proto.loc = function loc(startToken) {
      var _this$_options4;
      if (((_this$_options4 = this._options) === null || _this$_options4 === undefined ? undefined : _this$_options4.noLocation) !== true) {
        return new _ast.Location(startToken, this._lexer.lastToken, this._lexer.source);
      }
    };
    _proto.peek = function peek(kind) {
      return this._lexer.token.kind === kind;
    };
    _proto.expectToken = function expectToken(kind) {
      var token = this._lexer.token;
      if (token.kind === kind) {
        this._lexer.advance();
        return token;
      }
      throw (0, _syntaxError.syntaxError)(this._lexer.source, token.start, "Expected ".concat(getTokenKindDesc(kind), ", found ").concat(getTokenDesc(token), "."));
    };
    _proto.expectOptionalToken = function expectOptionalToken(kind) {
      var token = this._lexer.token;
      if (token.kind === kind) {
        this._lexer.advance();
        return token;
      }
      return;
    };
    _proto.expectKeyword = function expectKeyword(value) {
      var token = this._lexer.token;
      if (token.kind === _tokenKind.TokenKind.NAME && token.value === value) {
        this._lexer.advance();
      } else {
        throw (0, _syntaxError.syntaxError)(this._lexer.source, token.start, 'Expected "'.concat(value, '", found ').concat(getTokenDesc(token), "."));
      }
    };
    _proto.expectOptionalKeyword = function expectOptionalKeyword(value) {
      var token = this._lexer.token;
      if (token.kind === _tokenKind.TokenKind.NAME && token.value === value) {
        this._lexer.advance();
        return true;
      }
      return false;
    };
    _proto.unexpected = function unexpected(atToken) {
      var token = atToken !== null && atToken !== undefined ? atToken : this._lexer.token;
      return (0, _syntaxError.syntaxError)(this._lexer.source, token.start, "Unexpected ".concat(getTokenDesc(token), "."));
    };
    _proto.any = function any(openKind, parseFn, closeKind) {
      this.expectToken(openKind);
      var nodes = [];
      while (!this.expectOptionalToken(closeKind)) {
        nodes.push(parseFn.call(this));
      }
      return nodes;
    };
    _proto.optionalMany = function optionalMany(openKind, parseFn, closeKind) {
      if (this.expectOptionalToken(openKind)) {
        var nodes = [];
        do {
          nodes.push(parseFn.call(this));
        } while (!this.expectOptionalToken(closeKind));
        return nodes;
      }
      return [];
    };
    _proto.many = function many(openKind, parseFn, closeKind) {
      this.expectToken(openKind);
      var nodes = [];
      do {
        nodes.push(parseFn.call(this));
      } while (!this.expectOptionalToken(closeKind));
      return nodes;
    };
    _proto.delimitedMany = function delimitedMany(delimiterKind, parseFn) {
      this.expectOptionalToken(delimiterKind);
      var nodes = [];
      do {
        nodes.push(parseFn.call(this));
      } while (this.expectOptionalToken(delimiterKind));
      return nodes;
    };
    return Parser2;
  }();
  exports.Parser = Parser;
  function getTokenDesc(token) {
    var value = token.value;
    return getTokenKindDesc(token.kind) + (value != null ? ' "'.concat(value, '"') : "");
  }
  function getTokenKindDesc(kind) {
    return (0, _lexer.isPunctuatorTokenKind)(kind) ? '"'.concat(kind, '"') : kind;
  }
});

// node_modules/graphql/language/visitor.js
var require_visitor = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.visit = visit;
  exports.visitInParallel = visitInParallel;
  exports.getVisitFn = getVisitFn;
  exports.BREAK = exports.QueryDocumentKeys = undefined;
  var _inspect = _interopRequireDefault(require_inspect());
  var _ast = require_ast();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var QueryDocumentKeys = {
    Name: [],
    Document: ["definitions"],
    OperationDefinition: ["name", "variableDefinitions", "directives", "selectionSet"],
    VariableDefinition: ["variable", "type", "defaultValue", "directives"],
    Variable: ["name"],
    SelectionSet: ["selections"],
    Field: ["alias", "name", "arguments", "directives", "selectionSet"],
    Argument: ["name", "value"],
    FragmentSpread: ["name", "directives"],
    InlineFragment: ["typeCondition", "directives", "selectionSet"],
    FragmentDefinition: [
      "name",
      "variableDefinitions",
      "typeCondition",
      "directives",
      "selectionSet"
    ],
    IntValue: [],
    FloatValue: [],
    StringValue: [],
    BooleanValue: [],
    NullValue: [],
    EnumValue: [],
    ListValue: ["values"],
    ObjectValue: ["fields"],
    ObjectField: ["name", "value"],
    Directive: ["name", "arguments"],
    NamedType: ["name"],
    ListType: ["type"],
    NonNullType: ["type"],
    SchemaDefinition: ["description", "directives", "operationTypes"],
    OperationTypeDefinition: ["type"],
    ScalarTypeDefinition: ["description", "name", "directives"],
    ObjectTypeDefinition: ["description", "name", "interfaces", "directives", "fields"],
    FieldDefinition: ["description", "name", "arguments", "type", "directives"],
    InputValueDefinition: ["description", "name", "type", "defaultValue", "directives"],
    InterfaceTypeDefinition: ["description", "name", "interfaces", "directives", "fields"],
    UnionTypeDefinition: ["description", "name", "directives", "types"],
    EnumTypeDefinition: ["description", "name", "directives", "values"],
    EnumValueDefinition: ["description", "name", "directives"],
    InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
    DirectiveDefinition: ["description", "name", "arguments", "locations"],
    SchemaExtension: ["directives", "operationTypes"],
    ScalarTypeExtension: ["name", "directives"],
    ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
    InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
    UnionTypeExtension: ["name", "directives", "types"],
    EnumTypeExtension: ["name", "directives", "values"],
    InputObjectTypeExtension: ["name", "directives", "fields"]
  };
  exports.QueryDocumentKeys = QueryDocumentKeys;
  var BREAK = Object.freeze({});
  exports.BREAK = BREAK;
  function visit(root, visitor) {
    var visitorKeys = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : QueryDocumentKeys;
    var stack2 = undefined;
    var inArray = Array.isArray(root);
    var keys = [root];
    var index = -1;
    var edits = [];
    var node = undefined;
    var key = undefined;
    var parent = undefined;
    var path = [];
    var ancestors = [];
    var newRoot = root;
    do {
      index++;
      var isLeaving = index === keys.length;
      var isEdited = isLeaving && edits.length !== 0;
      if (isLeaving) {
        key = ancestors.length === 0 ? undefined : path[path.length - 1];
        node = parent;
        parent = ancestors.pop();
        if (isEdited) {
          if (inArray) {
            node = node.slice();
          } else {
            var clone = {};
            for (var _i2 = 0, _Object$keys2 = Object.keys(node);_i2 < _Object$keys2.length; _i2++) {
              var k = _Object$keys2[_i2];
              clone[k] = node[k];
            }
            node = clone;
          }
          var editOffset = 0;
          for (var ii = 0;ii < edits.length; ii++) {
            var editKey = edits[ii][0];
            var editValue = edits[ii][1];
            if (inArray) {
              editKey -= editOffset;
            }
            if (inArray && editValue === null) {
              node.splice(editKey, 1);
              editOffset++;
            } else {
              node[editKey] = editValue;
            }
          }
        }
        index = stack2.index;
        keys = stack2.keys;
        edits = stack2.edits;
        inArray = stack2.inArray;
        stack2 = stack2.prev;
      } else {
        key = parent ? inArray ? index : keys[index] : undefined;
        node = parent ? parent[key] : newRoot;
        if (node === null || node === undefined) {
          continue;
        }
        if (parent) {
          path.push(key);
        }
      }
      var result = undefined;
      if (!Array.isArray(node)) {
        if (!(0, _ast.isNode)(node)) {
          throw new Error("Invalid AST Node: ".concat((0, _inspect.default)(node), "."));
        }
        var visitFn = getVisitFn(visitor, node.kind, isLeaving);
        if (visitFn) {
          result = visitFn.call(visitor, node, key, parent, path, ancestors);
          if (result === BREAK) {
            break;
          }
          if (result === false) {
            if (!isLeaving) {
              path.pop();
              continue;
            }
          } else if (result !== undefined) {
            edits.push([key, result]);
            if (!isLeaving) {
              if ((0, _ast.isNode)(result)) {
                node = result;
              } else {
                path.pop();
                continue;
              }
            }
          }
        }
      }
      if (result === undefined && isEdited) {
        edits.push([key, node]);
      }
      if (isLeaving) {
        path.pop();
      } else {
        var _visitorKeys$node$kin;
        stack2 = {
          inArray,
          index,
          keys,
          edits,
          prev: stack2
        };
        inArray = Array.isArray(node);
        keys = inArray ? node : (_visitorKeys$node$kin = visitorKeys[node.kind]) !== null && _visitorKeys$node$kin !== undefined ? _visitorKeys$node$kin : [];
        index = -1;
        edits = [];
        if (parent) {
          ancestors.push(parent);
        }
        parent = node;
      }
    } while (stack2 !== undefined);
    if (edits.length !== 0) {
      newRoot = edits[edits.length - 1][1];
    }
    return newRoot;
  }
  function visitInParallel(visitors) {
    var skipping = new Array(visitors.length);
    return {
      enter: function enter(node) {
        for (var i = 0;i < visitors.length; i++) {
          if (skipping[i] == null) {
            var fn2 = getVisitFn(visitors[i], node.kind, false);
            if (fn2) {
              var result = fn2.apply(visitors[i], arguments);
              if (result === false) {
                skipping[i] = node;
              } else if (result === BREAK) {
                skipping[i] = BREAK;
              } else if (result !== undefined) {
                return result;
              }
            }
          }
        }
      },
      leave: function leave(node) {
        for (var i = 0;i < visitors.length; i++) {
          if (skipping[i] == null) {
            var fn2 = getVisitFn(visitors[i], node.kind, true);
            if (fn2) {
              var result = fn2.apply(visitors[i], arguments);
              if (result === BREAK) {
                skipping[i] = BREAK;
              } else if (result !== undefined && result !== false) {
                return result;
              }
            }
          } else if (skipping[i] === node) {
            skipping[i] = null;
          }
        }
      }
    };
  }
  function getVisitFn(visitor, kind, isLeaving) {
    var kindVisitor = visitor[kind];
    if (kindVisitor) {
      if (!isLeaving && typeof kindVisitor === "function") {
        return kindVisitor;
      }
      var kindSpecificVisitor = isLeaving ? kindVisitor.leave : kindVisitor.enter;
      if (typeof kindSpecificVisitor === "function") {
        return kindSpecificVisitor;
      }
    } else {
      var specificVisitor = isLeaving ? visitor.leave : visitor.enter;
      if (specificVisitor) {
        if (typeof specificVisitor === "function") {
          return specificVisitor;
        }
        var specificKindVisitor = specificVisitor[kind];
        if (typeof specificKindVisitor === "function") {
          return specificKindVisitor;
        }
      }
    }
  }
});

// node_modules/graphql/polyfills/find.js
var require_find = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var find = Array.prototype.find ? function(list, predicate) {
    return Array.prototype.find.call(list, predicate);
  } : function(list, predicate) {
    for (var _i2 = 0;_i2 < list.length; _i2++) {
      var value = list[_i2];
      if (predicate(value)) {
        return value;
      }
    }
  };
  var _default = find;
  exports.default = _default;
});

// node_modules/graphql/polyfills/objectValues.js
var require_objectValues = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var objectValues = Object.values || function(obj) {
    return Object.keys(obj).map(function(key) {
      return obj[key];
    });
  };
  var _default = objectValues;
  exports.default = _default;
});

// node_modules/graphql/error/locatedError.js
var require_locatedError = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.locatedError = locatedError;
  var _inspect = _interopRequireDefault(require_inspect());
  var _GraphQLError = require_GraphQLError();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function locatedError(rawOriginalError, nodes, path) {
    var _nodes;
    var originalError = rawOriginalError instanceof Error ? rawOriginalError : new Error("Unexpected error value: " + (0, _inspect.default)(rawOriginalError));
    if (Array.isArray(originalError.path)) {
      return originalError;
    }
    return new _GraphQLError.GraphQLError(originalError.message, (_nodes = originalError.nodes) !== null && _nodes !== undefined ? _nodes : nodes, originalError.source, originalError.positions, path, originalError);
  }
});

// node_modules/graphql/utilities/assertValidName.js
var require_assertValidName = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.assertValidName = assertValidName;
  exports.isValidNameError = isValidNameError;
  var _devAssert = _interopRequireDefault(require_devAssert());
  var _GraphQLError = require_GraphQLError();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var NAME_RX = /^[_a-zA-Z][_a-zA-Z0-9]*$/;
  function assertValidName(name) {
    var error = isValidNameError(name);
    if (error) {
      throw error;
    }
    return name;
  }
  function isValidNameError(name) {
    typeof name === "string" || (0, _devAssert.default)(0, "Expected name to be a string.");
    if (name.length > 1 && name[0] === "_" && name[1] === "_") {
      return new _GraphQLError.GraphQLError('Name "'.concat(name, '" must not begin with "__", which is reserved by GraphQL introspection.'));
    }
    if (!NAME_RX.test(name)) {
      return new _GraphQLError.GraphQLError('Names must match /^[_a-zA-Z][_a-zA-Z0-9]*$/ but "'.concat(name, '" does not.'));
    }
  }
});

// node_modules/graphql/polyfills/objectEntries.js
var require_objectEntries = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var objectEntries = Object.entries || function(obj) {
    return Object.keys(obj).map(function(key) {
      return [key, obj[key]];
    });
  };
  var _default = objectEntries;
  exports.default = _default;
});

// node_modules/graphql/jsutils/keyMap.js
var require_keyMap = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = keyMap;
  function keyMap(list, keyFn) {
    return list.reduce(function(map, item) {
      map[keyFn(item)] = item;
      return map;
    }, Object.create(null));
  }
});

// node_modules/graphql/jsutils/mapValue.js
var require_mapValue = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = mapValue;
  var _objectEntries3 = _interopRequireDefault(require_objectEntries());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function mapValue(map, fn2) {
    var result = Object.create(null);
    for (var _i2 = 0, _objectEntries2 = (0, _objectEntries3.default)(map);_i2 < _objectEntries2.length; _i2++) {
      var _ref2 = _objectEntries2[_i2];
      var _key = _ref2[0];
      var _value = _ref2[1];
      result[_key] = fn2(_value, _key);
    }
    return result;
  }
});

// node_modules/graphql/jsutils/toObjMap.js
var require_toObjMap = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = toObjMap;
  var _objectEntries3 = _interopRequireDefault(require_objectEntries());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function toObjMap(obj) {
    if (Object.getPrototypeOf(obj) === null) {
      return obj;
    }
    var map = Object.create(null);
    for (var _i2 = 0, _objectEntries2 = (0, _objectEntries3.default)(obj);_i2 < _objectEntries2.length; _i2++) {
      var _ref2 = _objectEntries2[_i2];
      var key = _ref2[0];
      var value = _ref2[1];
      map[key] = value;
    }
    return map;
  }
});

// node_modules/graphql/jsutils/keyValMap.js
var require_keyValMap = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = keyValMap;
  function keyValMap(list, keyFn, valFn) {
    return list.reduce(function(map, item) {
      map[keyFn(item)] = valFn(item);
      return map;
    }, Object.create(null));
  }
});

// node_modules/graphql/jsutils/didYouMean.js
var require_didYouMean = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = didYouMean;
  var MAX_SUGGESTIONS = 5;
  function didYouMean(firstArg, secondArg) {
    var _ref = typeof firstArg === "string" ? [firstArg, secondArg] : [undefined, firstArg], subMessage = _ref[0], suggestionsArg = _ref[1];
    var message2 = " Did you mean ";
    if (subMessage) {
      message2 += subMessage + " ";
    }
    var suggestions = suggestionsArg.map(function(x) {
      return '"'.concat(x, '"');
    });
    switch (suggestions.length) {
      case 0:
        return "";
      case 1:
        return message2 + suggestions[0] + "?";
      case 2:
        return message2 + suggestions[0] + " or " + suggestions[1] + "?";
    }
    var selected = suggestions.slice(0, MAX_SUGGESTIONS);
    var lastItem = selected.pop();
    return message2 + selected.join(", ") + ", or " + lastItem + "?";
  }
});

// node_modules/graphql/jsutils/identityFunc.js
var require_identityFunc = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = identityFunc;
  function identityFunc(x) {
    return x;
  }
});

// node_modules/graphql/jsutils/naturalCompare.js
var require_naturalCompare = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = naturalCompare;
  function naturalCompare(aStr, bStr) {
    var aIdx = 0;
    var bIdx = 0;
    while (aIdx < aStr.length && bIdx < bStr.length) {
      var aChar = aStr.charCodeAt(aIdx);
      var bChar = bStr.charCodeAt(bIdx);
      if (isDigit(aChar) && isDigit(bChar)) {
        var aNum = 0;
        do {
          ++aIdx;
          aNum = aNum * 10 + aChar - DIGIT_0;
          aChar = aStr.charCodeAt(aIdx);
        } while (isDigit(aChar) && aNum > 0);
        var bNum = 0;
        do {
          ++bIdx;
          bNum = bNum * 10 + bChar - DIGIT_0;
          bChar = bStr.charCodeAt(bIdx);
        } while (isDigit(bChar) && bNum > 0);
        if (aNum < bNum) {
          return -1;
        }
        if (aNum > bNum) {
          return 1;
        }
      } else {
        if (aChar < bChar) {
          return -1;
        }
        if (aChar > bChar) {
          return 1;
        }
        ++aIdx;
        ++bIdx;
      }
    }
    return aStr.length - bStr.length;
  }
  var DIGIT_0 = 48;
  var DIGIT_9 = 57;
  function isDigit(code) {
    return !isNaN(code) && DIGIT_0 <= code && code <= DIGIT_9;
  }
});

// node_modules/graphql/jsutils/suggestionList.js
var require_suggestionList = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = suggestionList;
  var _naturalCompare = _interopRequireDefault(require_naturalCompare());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function suggestionList(input, options) {
    var optionsByDistance = Object.create(null);
    var lexicalDistance = new LexicalDistance(input);
    var threshold = Math.floor(input.length * 0.4) + 1;
    for (var _i2 = 0;_i2 < options.length; _i2++) {
      var option = options[_i2];
      var distance = lexicalDistance.measure(option, threshold);
      if (distance !== undefined) {
        optionsByDistance[option] = distance;
      }
    }
    return Object.keys(optionsByDistance).sort(function(a, b) {
      var distanceDiff = optionsByDistance[a] - optionsByDistance[b];
      return distanceDiff !== 0 ? distanceDiff : (0, _naturalCompare.default)(a, b);
    });
  }
  var LexicalDistance = /* @__PURE__ */ function() {
    function LexicalDistance2(input) {
      this._input = input;
      this._inputLowerCase = input.toLowerCase();
      this._inputArray = stringToArray(this._inputLowerCase);
      this._rows = [new Array(input.length + 1).fill(0), new Array(input.length + 1).fill(0), new Array(input.length + 1).fill(0)];
    }
    var _proto = LexicalDistance2.prototype;
    _proto.measure = function measure(option, threshold) {
      if (this._input === option) {
        return 0;
      }
      var optionLowerCase = option.toLowerCase();
      if (this._inputLowerCase === optionLowerCase) {
        return 1;
      }
      var a = stringToArray(optionLowerCase);
      var b = this._inputArray;
      if (a.length < b.length) {
        var tmp = a;
        a = b;
        b = tmp;
      }
      var aLength = a.length;
      var bLength = b.length;
      if (aLength - bLength > threshold) {
        return;
      }
      var rows = this._rows;
      for (var j = 0;j <= bLength; j++) {
        rows[0][j] = j;
      }
      for (var i = 1;i <= aLength; i++) {
        var upRow = rows[(i - 1) % 3];
        var currentRow = rows[i % 3];
        var smallestCell = currentRow[0] = i;
        for (var _j = 1;_j <= bLength; _j++) {
          var cost = a[i - 1] === b[_j - 1] ? 0 : 1;
          var currentCell = Math.min(upRow[_j] + 1, currentRow[_j - 1] + 1, upRow[_j - 1] + cost);
          if (i > 1 && _j > 1 && a[i - 1] === b[_j - 2] && a[i - 2] === b[_j - 1]) {
            var doubleDiagonalCell = rows[(i - 2) % 3][_j - 2];
            currentCell = Math.min(currentCell, doubleDiagonalCell + 1);
          }
          if (currentCell < smallestCell) {
            smallestCell = currentCell;
          }
          currentRow[_j] = currentCell;
        }
        if (smallestCell > threshold) {
          return;
        }
      }
      var distance = rows[aLength % 3][bLength];
      return distance <= threshold ? distance : undefined;
    };
    return LexicalDistance2;
  }();
  function stringToArray(str) {
    var strLength = str.length;
    var array = new Array(strLength);
    for (var i = 0;i < strLength; ++i) {
      array[i] = str.charCodeAt(i);
    }
    return array;
  }
});

// node_modules/graphql/language/printer.js
var require_printer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.print = print;
  var _visitor = require_visitor();
  var _blockString = require_blockString();
  function print(ast) {
    return (0, _visitor.visit)(ast, {
      leave: printDocASTReducer
    });
  }
  var MAX_LINE_LENGTH = 80;
  var printDocASTReducer = {
    Name: function Name(node) {
      return node.value;
    },
    Variable: function Variable(node) {
      return "$" + node.name;
    },
    Document: function Document(node) {
      return join(node.definitions, `

`) + `
`;
    },
    OperationDefinition: function OperationDefinition(node) {
      var op = node.operation;
      var name = node.name;
      var varDefs = wrap("(", join(node.variableDefinitions, ", "), ")");
      var directives = join(node.directives, " ");
      var selectionSet = node.selectionSet;
      return !name && !directives && !varDefs && op === "query" ? selectionSet : join([op, join([name, varDefs]), directives, selectionSet], " ");
    },
    VariableDefinition: function VariableDefinition(_ref) {
      var { variable, type, defaultValue, directives } = _ref;
      return variable + ": " + type + wrap(" = ", defaultValue) + wrap(" ", join(directives, " "));
    },
    SelectionSet: function SelectionSet(_ref2) {
      var selections = _ref2.selections;
      return block(selections);
    },
    Field: function Field(_ref3) {
      var { alias, name, arguments: args2, directives, selectionSet } = _ref3;
      var prefix = wrap("", alias, ": ") + name;
      var argsLine = prefix + wrap("(", join(args2, ", "), ")");
      if (argsLine.length > MAX_LINE_LENGTH) {
        argsLine = prefix + wrap(`(
`, indent(join(args2, `
`)), `
)`);
      }
      return join([argsLine, join(directives, " "), selectionSet], " ");
    },
    Argument: function Argument(_ref4) {
      var { name, value } = _ref4;
      return name + ": " + value;
    },
    FragmentSpread: function FragmentSpread(_ref5) {
      var { name, directives } = _ref5;
      return "..." + name + wrap(" ", join(directives, " "));
    },
    InlineFragment: function InlineFragment(_ref6) {
      var { typeCondition, directives, selectionSet } = _ref6;
      return join(["...", wrap("on ", typeCondition), join(directives, " "), selectionSet], " ");
    },
    FragmentDefinition: function FragmentDefinition(_ref7) {
      var { name, typeCondition, variableDefinitions, directives, selectionSet } = _ref7;
      return "fragment ".concat(name).concat(wrap("(", join(variableDefinitions, ", "), ")"), " ") + "on ".concat(typeCondition, " ").concat(wrap("", join(directives, " "), " ")) + selectionSet;
    },
    IntValue: function IntValue(_ref8) {
      var value = _ref8.value;
      return value;
    },
    FloatValue: function FloatValue(_ref9) {
      var value = _ref9.value;
      return value;
    },
    StringValue: function StringValue(_ref10, key) {
      var { value, block: isBlockString } = _ref10;
      return isBlockString ? (0, _blockString.printBlockString)(value, key === "description" ? "" : "  ") : JSON.stringify(value);
    },
    BooleanValue: function BooleanValue(_ref11) {
      var value = _ref11.value;
      return value ? "true" : "false";
    },
    NullValue: function NullValue() {
      return "null";
    },
    EnumValue: function EnumValue(_ref12) {
      var value = _ref12.value;
      return value;
    },
    ListValue: function ListValue(_ref13) {
      var values = _ref13.values;
      return "[" + join(values, ", ") + "]";
    },
    ObjectValue: function ObjectValue(_ref14) {
      var fields = _ref14.fields;
      return "{" + join(fields, ", ") + "}";
    },
    ObjectField: function ObjectField(_ref15) {
      var { name, value } = _ref15;
      return name + ": " + value;
    },
    Directive: function Directive(_ref16) {
      var { name, arguments: args2 } = _ref16;
      return "@" + name + wrap("(", join(args2, ", "), ")");
    },
    NamedType: function NamedType(_ref17) {
      var name = _ref17.name;
      return name;
    },
    ListType: function ListType(_ref18) {
      var type = _ref18.type;
      return "[" + type + "]";
    },
    NonNullType: function NonNullType(_ref19) {
      var type = _ref19.type;
      return type + "!";
    },
    SchemaDefinition: addDescription(function(_ref20) {
      var { directives, operationTypes } = _ref20;
      return join(["schema", join(directives, " "), block(operationTypes)], " ");
    }),
    OperationTypeDefinition: function OperationTypeDefinition(_ref21) {
      var { operation, type } = _ref21;
      return operation + ": " + type;
    },
    ScalarTypeDefinition: addDescription(function(_ref22) {
      var { name, directives } = _ref22;
      return join(["scalar", name, join(directives, " ")], " ");
    }),
    ObjectTypeDefinition: addDescription(function(_ref23) {
      var { name, interfaces, directives, fields } = _ref23;
      return join(["type", name, wrap("implements ", join(interfaces, " & ")), join(directives, " "), block(fields)], " ");
    }),
    FieldDefinition: addDescription(function(_ref24) {
      var { name, arguments: args2, type, directives } = _ref24;
      return name + (hasMultilineItems(args2) ? wrap(`(
`, indent(join(args2, `
`)), `
)`) : wrap("(", join(args2, ", "), ")")) + ": " + type + wrap(" ", join(directives, " "));
    }),
    InputValueDefinition: addDescription(function(_ref25) {
      var { name, type, defaultValue, directives } = _ref25;
      return join([name + ": " + type, wrap("= ", defaultValue), join(directives, " ")], " ");
    }),
    InterfaceTypeDefinition: addDescription(function(_ref26) {
      var { name, interfaces, directives, fields } = _ref26;
      return join(["interface", name, wrap("implements ", join(interfaces, " & ")), join(directives, " "), block(fields)], " ");
    }),
    UnionTypeDefinition: addDescription(function(_ref27) {
      var { name, directives, types } = _ref27;
      return join(["union", name, join(directives, " "), types && types.length !== 0 ? "= " + join(types, " | ") : ""], " ");
    }),
    EnumTypeDefinition: addDescription(function(_ref28) {
      var { name, directives, values } = _ref28;
      return join(["enum", name, join(directives, " "), block(values)], " ");
    }),
    EnumValueDefinition: addDescription(function(_ref29) {
      var { name, directives } = _ref29;
      return join([name, join(directives, " ")], " ");
    }),
    InputObjectTypeDefinition: addDescription(function(_ref30) {
      var { name, directives, fields } = _ref30;
      return join(["input", name, join(directives, " "), block(fields)], " ");
    }),
    DirectiveDefinition: addDescription(function(_ref31) {
      var { name, arguments: args2, repeatable, locations } = _ref31;
      return "directive @" + name + (hasMultilineItems(args2) ? wrap(`(
`, indent(join(args2, `
`)), `
)`) : wrap("(", join(args2, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join(locations, " | ");
    }),
    SchemaExtension: function SchemaExtension(_ref32) {
      var { directives, operationTypes } = _ref32;
      return join(["extend schema", join(directives, " "), block(operationTypes)], " ");
    },
    ScalarTypeExtension: function ScalarTypeExtension(_ref33) {
      var { name, directives } = _ref33;
      return join(["extend scalar", name, join(directives, " ")], " ");
    },
    ObjectTypeExtension: function ObjectTypeExtension(_ref34) {
      var { name, interfaces, directives, fields } = _ref34;
      return join(["extend type", name, wrap("implements ", join(interfaces, " & ")), join(directives, " "), block(fields)], " ");
    },
    InterfaceTypeExtension: function InterfaceTypeExtension(_ref35) {
      var { name, interfaces, directives, fields } = _ref35;
      return join(["extend interface", name, wrap("implements ", join(interfaces, " & ")), join(directives, " "), block(fields)], " ");
    },
    UnionTypeExtension: function UnionTypeExtension(_ref36) {
      var { name, directives, types } = _ref36;
      return join(["extend union", name, join(directives, " "), types && types.length !== 0 ? "= " + join(types, " | ") : ""], " ");
    },
    EnumTypeExtension: function EnumTypeExtension(_ref37) {
      var { name, directives, values } = _ref37;
      return join(["extend enum", name, join(directives, " "), block(values)], " ");
    },
    InputObjectTypeExtension: function InputObjectTypeExtension(_ref38) {
      var { name, directives, fields } = _ref38;
      return join(["extend input", name, join(directives, " "), block(fields)], " ");
    }
  };
  function addDescription(cb) {
    return function(node) {
      return join([node.description, cb(node)], `
`);
    };
  }
  function join(maybeArray) {
    var _maybeArray$filter$jo;
    var separator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
    return (_maybeArray$filter$jo = maybeArray === null || maybeArray === undefined ? undefined : maybeArray.filter(function(x) {
      return x;
    }).join(separator)) !== null && _maybeArray$filter$jo !== undefined ? _maybeArray$filter$jo : "";
  }
  function block(array) {
    return wrap(`{
`, indent(join(array, `
`)), `
}`);
  }
  function wrap(start, maybeString) {
    var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";
    return maybeString != null && maybeString !== "" ? start + maybeString + end : "";
  }
  function indent(str) {
    return wrap("  ", str.replace(/\n/g, `
  `));
  }
  function isMultiline(str) {
    return str.indexOf(`
`) !== -1;
  }
  function hasMultilineItems(maybeArray) {
    return maybeArray != null && maybeArray.some(isMultiline);
  }
});

// node_modules/graphql/utilities/valueFromASTUntyped.js
var require_valueFromASTUntyped = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.valueFromASTUntyped = valueFromASTUntyped;
  var _inspect = _interopRequireDefault(require_inspect());
  var _invariant = _interopRequireDefault(require_invariant());
  var _keyValMap = _interopRequireDefault(require_keyValMap());
  var _kinds = require_kinds();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function valueFromASTUntyped(valueNode, variables) {
    switch (valueNode.kind) {
      case _kinds.Kind.NULL:
        return null;
      case _kinds.Kind.INT:
        return parseInt(valueNode.value, 10);
      case _kinds.Kind.FLOAT:
        return parseFloat(valueNode.value);
      case _kinds.Kind.STRING:
      case _kinds.Kind.ENUM:
      case _kinds.Kind.BOOLEAN:
        return valueNode.value;
      case _kinds.Kind.LIST:
        return valueNode.values.map(function(node) {
          return valueFromASTUntyped(node, variables);
        });
      case _kinds.Kind.OBJECT:
        return (0, _keyValMap.default)(valueNode.fields, function(field) {
          return field.name.value;
        }, function(field) {
          return valueFromASTUntyped(field.value, variables);
        });
      case _kinds.Kind.VARIABLE:
        return variables === null || variables === undefined ? undefined : variables[valueNode.name.value];
    }
    (0, _invariant.default)(0, "Unexpected value node: " + (0, _inspect.default)(valueNode));
  }
});

// node_modules/graphql/type/definition.js
var require_definition = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.isType = isType;
  exports.assertType = assertType;
  exports.isScalarType = isScalarType;
  exports.assertScalarType = assertScalarType;
  exports.isObjectType = isObjectType;
  exports.assertObjectType = assertObjectType;
  exports.isInterfaceType = isInterfaceType;
  exports.assertInterfaceType = assertInterfaceType;
  exports.isUnionType = isUnionType;
  exports.assertUnionType = assertUnionType;
  exports.isEnumType = isEnumType;
  exports.assertEnumType = assertEnumType;
  exports.isInputObjectType = isInputObjectType;
  exports.assertInputObjectType = assertInputObjectType;
  exports.isListType = isListType;
  exports.assertListType = assertListType;
  exports.isNonNullType = isNonNullType;
  exports.assertNonNullType = assertNonNullType;
  exports.isInputType = isInputType;
  exports.assertInputType = assertInputType;
  exports.isOutputType = isOutputType;
  exports.assertOutputType = assertOutputType;
  exports.isLeafType = isLeafType;
  exports.assertLeafType = assertLeafType;
  exports.isCompositeType = isCompositeType;
  exports.assertCompositeType = assertCompositeType;
  exports.isAbstractType = isAbstractType;
  exports.assertAbstractType = assertAbstractType;
  exports.GraphQLList = GraphQLList;
  exports.GraphQLNonNull = GraphQLNonNull;
  exports.isWrappingType = isWrappingType;
  exports.assertWrappingType = assertWrappingType;
  exports.isNullableType = isNullableType;
  exports.assertNullableType = assertNullableType;
  exports.getNullableType = getNullableType;
  exports.isNamedType = isNamedType;
  exports.assertNamedType = assertNamedType;
  exports.getNamedType = getNamedType;
  exports.argsToArgsConfig = argsToArgsConfig;
  exports.isRequiredArgument = isRequiredArgument;
  exports.isRequiredInputField = isRequiredInputField;
  exports.GraphQLInputObjectType = exports.GraphQLEnumType = exports.GraphQLUnionType = exports.GraphQLInterfaceType = exports.GraphQLObjectType = exports.GraphQLScalarType = undefined;
  var _objectEntries = _interopRequireDefault(require_objectEntries());
  var _symbols = require_symbols();
  var _inspect = _interopRequireDefault(require_inspect());
  var _keyMap = _interopRequireDefault(require_keyMap());
  var _mapValue = _interopRequireDefault(require_mapValue());
  var _toObjMap = _interopRequireDefault(require_toObjMap());
  var _devAssert = _interopRequireDefault(require_devAssert());
  var _keyValMap = _interopRequireDefault(require_keyValMap());
  var _instanceOf = _interopRequireDefault(require_instanceOf());
  var _didYouMean = _interopRequireDefault(require_didYouMean());
  var _isObjectLike = _interopRequireDefault(require_isObjectLike());
  var _identityFunc = _interopRequireDefault(require_identityFunc());
  var _defineInspect = _interopRequireDefault(require_defineInspect());
  var _suggestionList = _interopRequireDefault(require_suggestionList());
  var _GraphQLError = require_GraphQLError();
  var _kinds = require_kinds();
  var _printer = require_printer();
  var _valueFromASTUntyped = require_valueFromASTUntyped();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _defineProperties(target, props) {
    for (var i = 0;i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties(Constructor, staticProps);
    return Constructor;
  }
  function isType(type) {
    return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type) || isListType(type) || isNonNullType(type);
  }
  function assertType(type) {
    if (!isType(type)) {
      throw new Error("Expected ".concat((0, _inspect.default)(type), " to be a GraphQL type."));
    }
    return type;
  }
  function isScalarType(type) {
    return (0, _instanceOf.default)(type, GraphQLScalarType);
  }
  function assertScalarType(type) {
    if (!isScalarType(type)) {
      throw new Error("Expected ".concat((0, _inspect.default)(type), " to be a GraphQL Scalar type."));
    }
    return type;
  }
  function isObjectType(type) {
    return (0, _instanceOf.default)(type, GraphQLObjectType);
  }
  function assertObjectType(type) {
    if (!isObjectType(type)) {
      throw new Error("Expected ".concat((0, _inspect.default)(type), " to be a GraphQL Object type."));
    }
    return type;
  }
  function isInterfaceType(type) {
    return (0, _instanceOf.default)(type, GraphQLInterfaceType);
  }
  function assertInterfaceType(type) {
    if (!isInterfaceType(type)) {
      throw new Error("Expected ".concat((0, _inspect.default)(type), " to be a GraphQL Interface type."));
    }
    return type;
  }
  function isUnionType(type) {
    return (0, _instanceOf.default)(type, GraphQLUnionType);
  }
  function assertUnionType(type) {
    if (!isUnionType(type)) {
      throw new Error("Expected ".concat((0, _inspect.default)(type), " to be a GraphQL Union type."));
    }
    return type;
  }
  function isEnumType(type) {
    return (0, _instanceOf.default)(type, GraphQLEnumType);
  }
  function assertEnumType(type) {
    if (!isEnumType(type)) {
      throw new Error("Expected ".concat((0, _inspect.default)(type), " to be a GraphQL Enum type."));
    }
    return type;
  }
  function isInputObjectType(type) {
    return (0, _instanceOf.default)(type, GraphQLInputObjectType);
  }
  function assertInputObjectType(type) {
    if (!isInputObjectType(type)) {
      throw new Error("Expected ".concat((0, _inspect.default)(type), " to be a GraphQL Input Object type."));
    }
    return type;
  }
  function isListType(type) {
    return (0, _instanceOf.default)(type, GraphQLList);
  }
  function assertListType(type) {
    if (!isListType(type)) {
      throw new Error("Expected ".concat((0, _inspect.default)(type), " to be a GraphQL List type."));
    }
    return type;
  }
  function isNonNullType(type) {
    return (0, _instanceOf.default)(type, GraphQLNonNull);
  }
  function assertNonNullType(type) {
    if (!isNonNullType(type)) {
      throw new Error("Expected ".concat((0, _inspect.default)(type), " to be a GraphQL Non-Null type."));
    }
    return type;
  }
  function isInputType(type) {
    return isScalarType(type) || isEnumType(type) || isInputObjectType(type) || isWrappingType(type) && isInputType(type.ofType);
  }
  function assertInputType(type) {
    if (!isInputType(type)) {
      throw new Error("Expected ".concat((0, _inspect.default)(type), " to be a GraphQL input type."));
    }
    return type;
  }
  function isOutputType(type) {
    return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isWrappingType(type) && isOutputType(type.ofType);
  }
  function assertOutputType(type) {
    if (!isOutputType(type)) {
      throw new Error("Expected ".concat((0, _inspect.default)(type), " to be a GraphQL output type."));
    }
    return type;
  }
  function isLeafType(type) {
    return isScalarType(type) || isEnumType(type);
  }
  function assertLeafType(type) {
    if (!isLeafType(type)) {
      throw new Error("Expected ".concat((0, _inspect.default)(type), " to be a GraphQL leaf type."));
    }
    return type;
  }
  function isCompositeType(type) {
    return isObjectType(type) || isInterfaceType(type) || isUnionType(type);
  }
  function assertCompositeType(type) {
    if (!isCompositeType(type)) {
      throw new Error("Expected ".concat((0, _inspect.default)(type), " to be a GraphQL composite type."));
    }
    return type;
  }
  function isAbstractType(type) {
    return isInterfaceType(type) || isUnionType(type);
  }
  function assertAbstractType(type) {
    if (!isAbstractType(type)) {
      throw new Error("Expected ".concat((0, _inspect.default)(type), " to be a GraphQL abstract type."));
    }
    return type;
  }
  function GraphQLList(ofType) {
    if (this instanceof GraphQLList) {
      this.ofType = assertType(ofType);
    } else {
      return new GraphQLList(ofType);
    }
  }
  GraphQLList.prototype.toString = function toString() {
    return "[" + String(this.ofType) + "]";
  };
  GraphQLList.prototype.toJSON = function toJSON() {
    return this.toString();
  };
  Object.defineProperty(GraphQLList.prototype, _symbols.SYMBOL_TO_STRING_TAG, {
    get: function get() {
      return "GraphQLList";
    }
  });
  (0, _defineInspect.default)(GraphQLList);
  function GraphQLNonNull(ofType) {
    if (this instanceof GraphQLNonNull) {
      this.ofType = assertNullableType(ofType);
    } else {
      return new GraphQLNonNull(ofType);
    }
  }
  GraphQLNonNull.prototype.toString = function toString() {
    return String(this.ofType) + "!";
  };
  GraphQLNonNull.prototype.toJSON = function toJSON() {
    return this.toString();
  };
  Object.defineProperty(GraphQLNonNull.prototype, _symbols.SYMBOL_TO_STRING_TAG, {
    get: function get() {
      return "GraphQLNonNull";
    }
  });
  (0, _defineInspect.default)(GraphQLNonNull);
  function isWrappingType(type) {
    return isListType(type) || isNonNullType(type);
  }
  function assertWrappingType(type) {
    if (!isWrappingType(type)) {
      throw new Error("Expected ".concat((0, _inspect.default)(type), " to be a GraphQL wrapping type."));
    }
    return type;
  }
  function isNullableType(type) {
    return isType(type) && !isNonNullType(type);
  }
  function assertNullableType(type) {
    if (!isNullableType(type)) {
      throw new Error("Expected ".concat((0, _inspect.default)(type), " to be a GraphQL nullable type."));
    }
    return type;
  }
  function getNullableType(type) {
    if (type) {
      return isNonNullType(type) ? type.ofType : type;
    }
  }
  function isNamedType(type) {
    return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type);
  }
  function assertNamedType(type) {
    if (!isNamedType(type)) {
      throw new Error("Expected ".concat((0, _inspect.default)(type), " to be a GraphQL named type."));
    }
    return type;
  }
  function getNamedType(type) {
    if (type) {
      var unwrappedType = type;
      while (isWrappingType(unwrappedType)) {
        unwrappedType = unwrappedType.ofType;
      }
      return unwrappedType;
    }
  }
  function resolveThunk(thunk) {
    return typeof thunk === "function" ? thunk() : thunk;
  }
  function undefineIfEmpty(arr) {
    return arr && arr.length > 0 ? arr : undefined;
  }
  var GraphQLScalarType = /* @__PURE__ */ function() {
    function GraphQLScalarType2(config) {
      var _config$parseValue, _config$serialize, _config$parseLiteral;
      var parseValue = (_config$parseValue = config.parseValue) !== null && _config$parseValue !== undefined ? _config$parseValue : _identityFunc.default;
      this.name = config.name;
      this.description = config.description;
      this.specifiedByUrl = config.specifiedByUrl;
      this.serialize = (_config$serialize = config.serialize) !== null && _config$serialize !== undefined ? _config$serialize : _identityFunc.default;
      this.parseValue = parseValue;
      this.parseLiteral = (_config$parseLiteral = config.parseLiteral) !== null && _config$parseLiteral !== undefined ? _config$parseLiteral : function(node, variables) {
        return parseValue((0, _valueFromASTUntyped.valueFromASTUntyped)(node, variables));
      };
      this.extensions = config.extensions && (0, _toObjMap.default)(config.extensions);
      this.astNode = config.astNode;
      this.extensionASTNodes = undefineIfEmpty(config.extensionASTNodes);
      typeof config.name === "string" || (0, _devAssert.default)(0, "Must provide name.");
      config.specifiedByUrl == null || typeof config.specifiedByUrl === "string" || (0, _devAssert.default)(0, "".concat(this.name, ' must provide "specifiedByUrl" as a string, ') + "but got: ".concat((0, _inspect.default)(config.specifiedByUrl), "."));
      config.serialize == null || typeof config.serialize === "function" || (0, _devAssert.default)(0, "".concat(this.name, ' must provide "serialize" function. If this custom Scalar is also used as an input type, ensure "parseValue" and "parseLiteral" functions are also provided.'));
      if (config.parseLiteral) {
        typeof config.parseValue === "function" && typeof config.parseLiteral === "function" || (0, _devAssert.default)(0, "".concat(this.name, ' must provide both "parseValue" and "parseLiteral" functions.'));
      }
    }
    var _proto = GraphQLScalarType2.prototype;
    _proto.toConfig = function toConfig() {
      var _this$extensionASTNod;
      return {
        name: this.name,
        description: this.description,
        specifiedByUrl: this.specifiedByUrl,
        serialize: this.serialize,
        parseValue: this.parseValue,
        parseLiteral: this.parseLiteral,
        extensions: this.extensions,
        astNode: this.astNode,
        extensionASTNodes: (_this$extensionASTNod = this.extensionASTNodes) !== null && _this$extensionASTNod !== undefined ? _this$extensionASTNod : []
      };
    };
    _proto.toString = function toString() {
      return this.name;
    };
    _proto.toJSON = function toJSON() {
      return this.toString();
    };
    _createClass(GraphQLScalarType2, [{
      key: _symbols.SYMBOL_TO_STRING_TAG,
      get: function get() {
        return "GraphQLScalarType";
      }
    }]);
    return GraphQLScalarType2;
  }();
  exports.GraphQLScalarType = GraphQLScalarType;
  (0, _defineInspect.default)(GraphQLScalarType);
  var GraphQLObjectType = /* @__PURE__ */ function() {
    function GraphQLObjectType2(config) {
      this.name = config.name;
      this.description = config.description;
      this.isTypeOf = config.isTypeOf;
      this.extensions = config.extensions && (0, _toObjMap.default)(config.extensions);
      this.astNode = config.astNode;
      this.extensionASTNodes = undefineIfEmpty(config.extensionASTNodes);
      this._fields = defineFieldMap.bind(undefined, config);
      this._interfaces = defineInterfaces.bind(undefined, config);
      typeof config.name === "string" || (0, _devAssert.default)(0, "Must provide name.");
      config.isTypeOf == null || typeof config.isTypeOf === "function" || (0, _devAssert.default)(0, "".concat(this.name, ' must provide "isTypeOf" as a function, ') + "but got: ".concat((0, _inspect.default)(config.isTypeOf), "."));
    }
    var _proto2 = GraphQLObjectType2.prototype;
    _proto2.getFields = function getFields() {
      if (typeof this._fields === "function") {
        this._fields = this._fields();
      }
      return this._fields;
    };
    _proto2.getInterfaces = function getInterfaces() {
      if (typeof this._interfaces === "function") {
        this._interfaces = this._interfaces();
      }
      return this._interfaces;
    };
    _proto2.toConfig = function toConfig() {
      return {
        name: this.name,
        description: this.description,
        interfaces: this.getInterfaces(),
        fields: fieldsToFieldsConfig(this.getFields()),
        isTypeOf: this.isTypeOf,
        extensions: this.extensions,
        astNode: this.astNode,
        extensionASTNodes: this.extensionASTNodes || []
      };
    };
    _proto2.toString = function toString() {
      return this.name;
    };
    _proto2.toJSON = function toJSON() {
      return this.toString();
    };
    _createClass(GraphQLObjectType2, [{
      key: _symbols.SYMBOL_TO_STRING_TAG,
      get: function get() {
        return "GraphQLObjectType";
      }
    }]);
    return GraphQLObjectType2;
  }();
  exports.GraphQLObjectType = GraphQLObjectType;
  (0, _defineInspect.default)(GraphQLObjectType);
  function defineInterfaces(config) {
    var _resolveThunk;
    var interfaces = (_resolveThunk = resolveThunk(config.interfaces)) !== null && _resolveThunk !== undefined ? _resolveThunk : [];
    Array.isArray(interfaces) || (0, _devAssert.default)(0, "".concat(config.name, " interfaces must be an Array or a function which returns an Array."));
    return interfaces;
  }
  function defineFieldMap(config) {
    var fieldMap = resolveThunk(config.fields);
    isPlainObj(fieldMap) || (0, _devAssert.default)(0, "".concat(config.name, " fields must be an object with field names as keys or a function which returns such an object."));
    return (0, _mapValue.default)(fieldMap, function(fieldConfig, fieldName) {
      var _fieldConfig$args;
      isPlainObj(fieldConfig) || (0, _devAssert.default)(0, "".concat(config.name, ".").concat(fieldName, " field config must be an object."));
      !("isDeprecated" in fieldConfig) || (0, _devAssert.default)(0, "".concat(config.name, ".").concat(fieldName, ' should provide "deprecationReason" instead of "isDeprecated".'));
      fieldConfig.resolve == null || typeof fieldConfig.resolve === "function" || (0, _devAssert.default)(0, "".concat(config.name, ".").concat(fieldName, " field resolver must be a function if ") + "provided, but got: ".concat((0, _inspect.default)(fieldConfig.resolve), "."));
      var argsConfig = (_fieldConfig$args = fieldConfig.args) !== null && _fieldConfig$args !== undefined ? _fieldConfig$args : {};
      isPlainObj(argsConfig) || (0, _devAssert.default)(0, "".concat(config.name, ".").concat(fieldName, " args must be an object with argument names as keys."));
      var args2 = (0, _objectEntries.default)(argsConfig).map(function(_ref) {
        var argName = _ref[0], argConfig = _ref[1];
        return {
          name: argName,
          description: argConfig.description,
          type: argConfig.type,
          defaultValue: argConfig.defaultValue,
          deprecationReason: argConfig.deprecationReason,
          extensions: argConfig.extensions && (0, _toObjMap.default)(argConfig.extensions),
          astNode: argConfig.astNode
        };
      });
      return {
        name: fieldName,
        description: fieldConfig.description,
        type: fieldConfig.type,
        args: args2,
        resolve: fieldConfig.resolve,
        subscribe: fieldConfig.subscribe,
        isDeprecated: fieldConfig.deprecationReason != null,
        deprecationReason: fieldConfig.deprecationReason,
        extensions: fieldConfig.extensions && (0, _toObjMap.default)(fieldConfig.extensions),
        astNode: fieldConfig.astNode
      };
    });
  }
  function isPlainObj(obj) {
    return (0, _isObjectLike.default)(obj) && !Array.isArray(obj);
  }
  function fieldsToFieldsConfig(fields) {
    return (0, _mapValue.default)(fields, function(field) {
      return {
        description: field.description,
        type: field.type,
        args: argsToArgsConfig(field.args),
        resolve: field.resolve,
        subscribe: field.subscribe,
        deprecationReason: field.deprecationReason,
        extensions: field.extensions,
        astNode: field.astNode
      };
    });
  }
  function argsToArgsConfig(args2) {
    return (0, _keyValMap.default)(args2, function(arg) {
      return arg.name;
    }, function(arg) {
      return {
        description: arg.description,
        type: arg.type,
        defaultValue: arg.defaultValue,
        deprecationReason: arg.deprecationReason,
        extensions: arg.extensions,
        astNode: arg.astNode
      };
    });
  }
  function isRequiredArgument(arg) {
    return isNonNullType(arg.type) && arg.defaultValue === undefined;
  }
  var GraphQLInterfaceType = /* @__PURE__ */ function() {
    function GraphQLInterfaceType2(config) {
      this.name = config.name;
      this.description = config.description;
      this.resolveType = config.resolveType;
      this.extensions = config.extensions && (0, _toObjMap.default)(config.extensions);
      this.astNode = config.astNode;
      this.extensionASTNodes = undefineIfEmpty(config.extensionASTNodes);
      this._fields = defineFieldMap.bind(undefined, config);
      this._interfaces = defineInterfaces.bind(undefined, config);
      typeof config.name === "string" || (0, _devAssert.default)(0, "Must provide name.");
      config.resolveType == null || typeof config.resolveType === "function" || (0, _devAssert.default)(0, "".concat(this.name, ' must provide "resolveType" as a function, ') + "but got: ".concat((0, _inspect.default)(config.resolveType), "."));
    }
    var _proto3 = GraphQLInterfaceType2.prototype;
    _proto3.getFields = function getFields() {
      if (typeof this._fields === "function") {
        this._fields = this._fields();
      }
      return this._fields;
    };
    _proto3.getInterfaces = function getInterfaces() {
      if (typeof this._interfaces === "function") {
        this._interfaces = this._interfaces();
      }
      return this._interfaces;
    };
    _proto3.toConfig = function toConfig() {
      var _this$extensionASTNod2;
      return {
        name: this.name,
        description: this.description,
        interfaces: this.getInterfaces(),
        fields: fieldsToFieldsConfig(this.getFields()),
        resolveType: this.resolveType,
        extensions: this.extensions,
        astNode: this.astNode,
        extensionASTNodes: (_this$extensionASTNod2 = this.extensionASTNodes) !== null && _this$extensionASTNod2 !== undefined ? _this$extensionASTNod2 : []
      };
    };
    _proto3.toString = function toString() {
      return this.name;
    };
    _proto3.toJSON = function toJSON() {
      return this.toString();
    };
    _createClass(GraphQLInterfaceType2, [{
      key: _symbols.SYMBOL_TO_STRING_TAG,
      get: function get() {
        return "GraphQLInterfaceType";
      }
    }]);
    return GraphQLInterfaceType2;
  }();
  exports.GraphQLInterfaceType = GraphQLInterfaceType;
  (0, _defineInspect.default)(GraphQLInterfaceType);
  var GraphQLUnionType = /* @__PURE__ */ function() {
    function GraphQLUnionType2(config) {
      this.name = config.name;
      this.description = config.description;
      this.resolveType = config.resolveType;
      this.extensions = config.extensions && (0, _toObjMap.default)(config.extensions);
      this.astNode = config.astNode;
      this.extensionASTNodes = undefineIfEmpty(config.extensionASTNodes);
      this._types = defineTypes.bind(undefined, config);
      typeof config.name === "string" || (0, _devAssert.default)(0, "Must provide name.");
      config.resolveType == null || typeof config.resolveType === "function" || (0, _devAssert.default)(0, "".concat(this.name, ' must provide "resolveType" as a function, ') + "but got: ".concat((0, _inspect.default)(config.resolveType), "."));
    }
    var _proto4 = GraphQLUnionType2.prototype;
    _proto4.getTypes = function getTypes() {
      if (typeof this._types === "function") {
        this._types = this._types();
      }
      return this._types;
    };
    _proto4.toConfig = function toConfig() {
      var _this$extensionASTNod3;
      return {
        name: this.name,
        description: this.description,
        types: this.getTypes(),
        resolveType: this.resolveType,
        extensions: this.extensions,
        astNode: this.astNode,
        extensionASTNodes: (_this$extensionASTNod3 = this.extensionASTNodes) !== null && _this$extensionASTNod3 !== undefined ? _this$extensionASTNod3 : []
      };
    };
    _proto4.toString = function toString() {
      return this.name;
    };
    _proto4.toJSON = function toJSON() {
      return this.toString();
    };
    _createClass(GraphQLUnionType2, [{
      key: _symbols.SYMBOL_TO_STRING_TAG,
      get: function get() {
        return "GraphQLUnionType";
      }
    }]);
    return GraphQLUnionType2;
  }();
  exports.GraphQLUnionType = GraphQLUnionType;
  (0, _defineInspect.default)(GraphQLUnionType);
  function defineTypes(config) {
    var types = resolveThunk(config.types);
    Array.isArray(types) || (0, _devAssert.default)(0, "Must provide Array of types or a function which returns such an array for Union ".concat(config.name, "."));
    return types;
  }
  var GraphQLEnumType = /* @__PURE__ */ function() {
    function GraphQLEnumType2(config) {
      this.name = config.name;
      this.description = config.description;
      this.extensions = config.extensions && (0, _toObjMap.default)(config.extensions);
      this.astNode = config.astNode;
      this.extensionASTNodes = undefineIfEmpty(config.extensionASTNodes);
      this._values = defineEnumValues(this.name, config.values);
      this._valueLookup = new Map(this._values.map(function(enumValue) {
        return [enumValue.value, enumValue];
      }));
      this._nameLookup = (0, _keyMap.default)(this._values, function(value) {
        return value.name;
      });
      typeof config.name === "string" || (0, _devAssert.default)(0, "Must provide name.");
    }
    var _proto5 = GraphQLEnumType2.prototype;
    _proto5.getValues = function getValues() {
      return this._values;
    };
    _proto5.getValue = function getValue(name) {
      return this._nameLookup[name];
    };
    _proto5.serialize = function serialize(outputValue) {
      var enumValue = this._valueLookup.get(outputValue);
      if (enumValue === undefined) {
        throw new _GraphQLError.GraphQLError('Enum "'.concat(this.name, '" cannot represent value: ').concat((0, _inspect.default)(outputValue)));
      }
      return enumValue.name;
    };
    _proto5.parseValue = function parseValue(inputValue) {
      if (typeof inputValue !== "string") {
        var valueStr = (0, _inspect.default)(inputValue);
        throw new _GraphQLError.GraphQLError('Enum "'.concat(this.name, '" cannot represent non-string value: ').concat(valueStr, ".") + didYouMeanEnumValue(this, valueStr));
      }
      var enumValue = this.getValue(inputValue);
      if (enumValue == null) {
        throw new _GraphQLError.GraphQLError('Value "'.concat(inputValue, '" does not exist in "').concat(this.name, '" enum.') + didYouMeanEnumValue(this, inputValue));
      }
      return enumValue.value;
    };
    _proto5.parseLiteral = function parseLiteral(valueNode, _variables) {
      if (valueNode.kind !== _kinds.Kind.ENUM) {
        var valueStr = (0, _printer.print)(valueNode);
        throw new _GraphQLError.GraphQLError('Enum "'.concat(this.name, '" cannot represent non-enum value: ').concat(valueStr, ".") + didYouMeanEnumValue(this, valueStr), valueNode);
      }
      var enumValue = this.getValue(valueNode.value);
      if (enumValue == null) {
        var _valueStr = (0, _printer.print)(valueNode);
        throw new _GraphQLError.GraphQLError('Value "'.concat(_valueStr, '" does not exist in "').concat(this.name, '" enum.') + didYouMeanEnumValue(this, _valueStr), valueNode);
      }
      return enumValue.value;
    };
    _proto5.toConfig = function toConfig() {
      var _this$extensionASTNod4;
      var values = (0, _keyValMap.default)(this.getValues(), function(value) {
        return value.name;
      }, function(value) {
        return {
          description: value.description,
          value: value.value,
          deprecationReason: value.deprecationReason,
          extensions: value.extensions,
          astNode: value.astNode
        };
      });
      return {
        name: this.name,
        description: this.description,
        values,
        extensions: this.extensions,
        astNode: this.astNode,
        extensionASTNodes: (_this$extensionASTNod4 = this.extensionASTNodes) !== null && _this$extensionASTNod4 !== undefined ? _this$extensionASTNod4 : []
      };
    };
    _proto5.toString = function toString() {
      return this.name;
    };
    _proto5.toJSON = function toJSON() {
      return this.toString();
    };
    _createClass(GraphQLEnumType2, [{
      key: _symbols.SYMBOL_TO_STRING_TAG,
      get: function get() {
        return "GraphQLEnumType";
      }
    }]);
    return GraphQLEnumType2;
  }();
  exports.GraphQLEnumType = GraphQLEnumType;
  (0, _defineInspect.default)(GraphQLEnumType);
  function didYouMeanEnumValue(enumType, unknownValueStr) {
    var allNames = enumType.getValues().map(function(value) {
      return value.name;
    });
    var suggestedValues = (0, _suggestionList.default)(unknownValueStr, allNames);
    return (0, _didYouMean.default)("the enum value", suggestedValues);
  }
  function defineEnumValues(typeName, valueMap) {
    isPlainObj(valueMap) || (0, _devAssert.default)(0, "".concat(typeName, " values must be an object with value names as keys."));
    return (0, _objectEntries.default)(valueMap).map(function(_ref2) {
      var valueName = _ref2[0], valueConfig = _ref2[1];
      isPlainObj(valueConfig) || (0, _devAssert.default)(0, "".concat(typeName, ".").concat(valueName, ' must refer to an object with a "value" key ') + "representing an internal value but got: ".concat((0, _inspect.default)(valueConfig), "."));
      !("isDeprecated" in valueConfig) || (0, _devAssert.default)(0, "".concat(typeName, ".").concat(valueName, ' should provide "deprecationReason" instead of "isDeprecated".'));
      return {
        name: valueName,
        description: valueConfig.description,
        value: valueConfig.value !== undefined ? valueConfig.value : valueName,
        isDeprecated: valueConfig.deprecationReason != null,
        deprecationReason: valueConfig.deprecationReason,
        extensions: valueConfig.extensions && (0, _toObjMap.default)(valueConfig.extensions),
        astNode: valueConfig.astNode
      };
    });
  }
  var GraphQLInputObjectType = /* @__PURE__ */ function() {
    function GraphQLInputObjectType2(config) {
      this.name = config.name;
      this.description = config.description;
      this.extensions = config.extensions && (0, _toObjMap.default)(config.extensions);
      this.astNode = config.astNode;
      this.extensionASTNodes = undefineIfEmpty(config.extensionASTNodes);
      this._fields = defineInputFieldMap.bind(undefined, config);
      typeof config.name === "string" || (0, _devAssert.default)(0, "Must provide name.");
    }
    var _proto6 = GraphQLInputObjectType2.prototype;
    _proto6.getFields = function getFields() {
      if (typeof this._fields === "function") {
        this._fields = this._fields();
      }
      return this._fields;
    };
    _proto6.toConfig = function toConfig() {
      var _this$extensionASTNod5;
      var fields = (0, _mapValue.default)(this.getFields(), function(field) {
        return {
          description: field.description,
          type: field.type,
          defaultValue: field.defaultValue,
          deprecationReason: field.deprecationReason,
          extensions: field.extensions,
          astNode: field.astNode
        };
      });
      return {
        name: this.name,
        description: this.description,
        fields,
        extensions: this.extensions,
        astNode: this.astNode,
        extensionASTNodes: (_this$extensionASTNod5 = this.extensionASTNodes) !== null && _this$extensionASTNod5 !== undefined ? _this$extensionASTNod5 : []
      };
    };
    _proto6.toString = function toString() {
      return this.name;
    };
    _proto6.toJSON = function toJSON() {
      return this.toString();
    };
    _createClass(GraphQLInputObjectType2, [{
      key: _symbols.SYMBOL_TO_STRING_TAG,
      get: function get() {
        return "GraphQLInputObjectType";
      }
    }]);
    return GraphQLInputObjectType2;
  }();
  exports.GraphQLInputObjectType = GraphQLInputObjectType;
  (0, _defineInspect.default)(GraphQLInputObjectType);
  function defineInputFieldMap(config) {
    var fieldMap = resolveThunk(config.fields);
    isPlainObj(fieldMap) || (0, _devAssert.default)(0, "".concat(config.name, " fields must be an object with field names as keys or a function which returns such an object."));
    return (0, _mapValue.default)(fieldMap, function(fieldConfig, fieldName) {
      !("resolve" in fieldConfig) || (0, _devAssert.default)(0, "".concat(config.name, ".").concat(fieldName, " field has a resolve property, but Input Types cannot define resolvers."));
      return {
        name: fieldName,
        description: fieldConfig.description,
        type: fieldConfig.type,
        defaultValue: fieldConfig.defaultValue,
        deprecationReason: fieldConfig.deprecationReason,
        extensions: fieldConfig.extensions && (0, _toObjMap.default)(fieldConfig.extensions),
        astNode: fieldConfig.astNode
      };
    });
  }
  function isRequiredInputField(field) {
    return isNonNullType(field.type) && field.defaultValue === undefined;
  }
});

// node_modules/graphql/utilities/typeComparators.js
var require_typeComparators = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.isEqualType = isEqualType;
  exports.isTypeSubTypeOf = isTypeSubTypeOf;
  exports.doTypesOverlap = doTypesOverlap;
  var _definition = require_definition();
  function isEqualType(typeA, typeB) {
    if (typeA === typeB) {
      return true;
    }
    if ((0, _definition.isNonNullType)(typeA) && (0, _definition.isNonNullType)(typeB)) {
      return isEqualType(typeA.ofType, typeB.ofType);
    }
    if ((0, _definition.isListType)(typeA) && (0, _definition.isListType)(typeB)) {
      return isEqualType(typeA.ofType, typeB.ofType);
    }
    return false;
  }
  function isTypeSubTypeOf(schema, maybeSubType, superType) {
    if (maybeSubType === superType) {
      return true;
    }
    if ((0, _definition.isNonNullType)(superType)) {
      if ((0, _definition.isNonNullType)(maybeSubType)) {
        return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
      }
      return false;
    }
    if ((0, _definition.isNonNullType)(maybeSubType)) {
      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType);
    }
    if ((0, _definition.isListType)(superType)) {
      if ((0, _definition.isListType)(maybeSubType)) {
        return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
      }
      return false;
    }
    if ((0, _definition.isListType)(maybeSubType)) {
      return false;
    }
    return (0, _definition.isAbstractType)(superType) && ((0, _definition.isInterfaceType)(maybeSubType) || (0, _definition.isObjectType)(maybeSubType)) && schema.isSubType(superType, maybeSubType);
  }
  function doTypesOverlap(schema, typeA, typeB) {
    if (typeA === typeB) {
      return true;
    }
    if ((0, _definition.isAbstractType)(typeA)) {
      if ((0, _definition.isAbstractType)(typeB)) {
        return schema.getPossibleTypes(typeA).some(function(type) {
          return schema.isSubType(typeB, type);
        });
      }
      return schema.isSubType(typeA, typeB);
    }
    if ((0, _definition.isAbstractType)(typeB)) {
      return schema.isSubType(typeB, typeA);
    }
    return false;
  }
});

// node_modules/graphql/polyfills/arrayFrom.js
var require_arrayFrom = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _symbols = require_symbols();
  var arrayFrom = Array.from || function(obj, mapFn, thisArg) {
    if (obj == null) {
      throw new TypeError("Array.from requires an array-like object - not null or undefined");
    }
    var iteratorMethod = obj[_symbols.SYMBOL_ITERATOR];
    if (typeof iteratorMethod === "function") {
      var iterator = iteratorMethod.call(obj);
      var result = [];
      var step;
      for (var i = 0;!(step = iterator.next()).done; ++i) {
        result.push(mapFn.call(thisArg, step.value, i));
        if (i > 9999999) {
          throw new TypeError("Near-infinite iteration.");
        }
      }
      return result;
    }
    var length = obj.length;
    if (typeof length === "number" && length >= 0 && length % 1 === 0) {
      var _result = [];
      for (var _i = 0;_i < length; ++_i) {
        if (Object.prototype.hasOwnProperty.call(obj, _i)) {
          _result.push(mapFn.call(thisArg, obj[_i], _i));
        }
      }
      return _result;
    }
    return [];
  };
  var _default = arrayFrom;
  exports.default = _default;
});

// node_modules/graphql/polyfills/isFinite.js
var require_isFinite = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var isFinitePolyfill = Number.isFinite || function(value) {
    return typeof value === "number" && isFinite(value);
  };
  var _default = isFinitePolyfill;
  exports.default = _default;
});

// node_modules/graphql/jsutils/safeArrayFrom.js
var require_safeArrayFrom = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = safeArrayFrom;
  var _symbols = require_symbols();
  function _typeof(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function _typeof(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof = function _typeof(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof(obj);
  }
  function safeArrayFrom(collection) {
    var mapFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function(item) {
      return item;
    };
    if (collection == null || _typeof(collection) !== "object") {
      return null;
    }
    if (Array.isArray(collection)) {
      return collection.map(mapFn);
    }
    var iteratorMethod = collection[_symbols.SYMBOL_ITERATOR];
    if (typeof iteratorMethod === "function") {
      var iterator = iteratorMethod.call(collection);
      var result = [];
      var step;
      for (var i = 0;!(step = iterator.next()).done; ++i) {
        result.push(mapFn(step.value, i));
      }
      return result;
    }
    var length = collection.length;
    if (typeof length === "number" && length >= 0 && length % 1 === 0) {
      var _result = [];
      for (var _i = 0;_i < length; ++_i) {
        if (!Object.prototype.hasOwnProperty.call(collection, _i)) {
          return null;
        }
        _result.push(mapFn(collection[String(_i)], _i));
      }
      return _result;
    }
    return null;
  }
});

// node_modules/graphql/polyfills/isInteger.js
var require_isInteger = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var isInteger = Number.isInteger || function(value) {
    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
  };
  var _default = isInteger;
  exports.default = _default;
});

// node_modules/graphql/type/scalars.js
var require_scalars = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.isSpecifiedScalarType = isSpecifiedScalarType;
  exports.specifiedScalarTypes = exports.GraphQLID = exports.GraphQLBoolean = exports.GraphQLString = exports.GraphQLFloat = exports.GraphQLInt = undefined;
  var _isFinite = _interopRequireDefault(require_isFinite());
  var _isInteger = _interopRequireDefault(require_isInteger());
  var _inspect = _interopRequireDefault(require_inspect());
  var _isObjectLike = _interopRequireDefault(require_isObjectLike());
  var _kinds = require_kinds();
  var _printer = require_printer();
  var _GraphQLError = require_GraphQLError();
  var _definition = require_definition();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var MAX_INT = 2147483647;
  var MIN_INT = -2147483648;
  function serializeInt(outputValue) {
    var coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "boolean") {
      return coercedValue ? 1 : 0;
    }
    var num = coercedValue;
    if (typeof coercedValue === "string" && coercedValue !== "") {
      num = Number(coercedValue);
    }
    if (!(0, _isInteger.default)(num)) {
      throw new _GraphQLError.GraphQLError("Int cannot represent non-integer value: ".concat((0, _inspect.default)(coercedValue)));
    }
    if (num > MAX_INT || num < MIN_INT) {
      throw new _GraphQLError.GraphQLError("Int cannot represent non 32-bit signed integer value: " + (0, _inspect.default)(coercedValue));
    }
    return num;
  }
  function coerceInt(inputValue) {
    if (!(0, _isInteger.default)(inputValue)) {
      throw new _GraphQLError.GraphQLError("Int cannot represent non-integer value: ".concat((0, _inspect.default)(inputValue)));
    }
    if (inputValue > MAX_INT || inputValue < MIN_INT) {
      throw new _GraphQLError.GraphQLError("Int cannot represent non 32-bit signed integer value: ".concat(inputValue));
    }
    return inputValue;
  }
  var GraphQLInt = new _definition.GraphQLScalarType({
    name: "Int",
    description: "The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.",
    serialize: serializeInt,
    parseValue: coerceInt,
    parseLiteral: function parseLiteral(valueNode) {
      if (valueNode.kind !== _kinds.Kind.INT) {
        throw new _GraphQLError.GraphQLError("Int cannot represent non-integer value: ".concat((0, _printer.print)(valueNode)), valueNode);
      }
      var num = parseInt(valueNode.value, 10);
      if (num > MAX_INT || num < MIN_INT) {
        throw new _GraphQLError.GraphQLError("Int cannot represent non 32-bit signed integer value: ".concat(valueNode.value), valueNode);
      }
      return num;
    }
  });
  exports.GraphQLInt = GraphQLInt;
  function serializeFloat(outputValue) {
    var coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "boolean") {
      return coercedValue ? 1 : 0;
    }
    var num = coercedValue;
    if (typeof coercedValue === "string" && coercedValue !== "") {
      num = Number(coercedValue);
    }
    if (!(0, _isFinite.default)(num)) {
      throw new _GraphQLError.GraphQLError("Float cannot represent non numeric value: ".concat((0, _inspect.default)(coercedValue)));
    }
    return num;
  }
  function coerceFloat(inputValue) {
    if (!(0, _isFinite.default)(inputValue)) {
      throw new _GraphQLError.GraphQLError("Float cannot represent non numeric value: ".concat((0, _inspect.default)(inputValue)));
    }
    return inputValue;
  }
  var GraphQLFloat = new _definition.GraphQLScalarType({
    name: "Float",
    description: "The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).",
    serialize: serializeFloat,
    parseValue: coerceFloat,
    parseLiteral: function parseLiteral(valueNode) {
      if (valueNode.kind !== _kinds.Kind.FLOAT && valueNode.kind !== _kinds.Kind.INT) {
        throw new _GraphQLError.GraphQLError("Float cannot represent non numeric value: ".concat((0, _printer.print)(valueNode)), valueNode);
      }
      return parseFloat(valueNode.value);
    }
  });
  exports.GraphQLFloat = GraphQLFloat;
  function serializeObject(outputValue) {
    if ((0, _isObjectLike.default)(outputValue)) {
      if (typeof outputValue.valueOf === "function") {
        var valueOfResult = outputValue.valueOf();
        if (!(0, _isObjectLike.default)(valueOfResult)) {
          return valueOfResult;
        }
      }
      if (typeof outputValue.toJSON === "function") {
        return outputValue.toJSON();
      }
    }
    return outputValue;
  }
  function serializeString(outputValue) {
    var coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "string") {
      return coercedValue;
    }
    if (typeof coercedValue === "boolean") {
      return coercedValue ? "true" : "false";
    }
    if ((0, _isFinite.default)(coercedValue)) {
      return coercedValue.toString();
    }
    throw new _GraphQLError.GraphQLError("String cannot represent value: ".concat((0, _inspect.default)(outputValue)));
  }
  function coerceString(inputValue) {
    if (typeof inputValue !== "string") {
      throw new _GraphQLError.GraphQLError("String cannot represent a non string value: ".concat((0, _inspect.default)(inputValue)));
    }
    return inputValue;
  }
  var GraphQLString = new _definition.GraphQLScalarType({
    name: "String",
    description: "The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.",
    serialize: serializeString,
    parseValue: coerceString,
    parseLiteral: function parseLiteral(valueNode) {
      if (valueNode.kind !== _kinds.Kind.STRING) {
        throw new _GraphQLError.GraphQLError("String cannot represent a non string value: ".concat((0, _printer.print)(valueNode)), valueNode);
      }
      return valueNode.value;
    }
  });
  exports.GraphQLString = GraphQLString;
  function serializeBoolean(outputValue) {
    var coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "boolean") {
      return coercedValue;
    }
    if ((0, _isFinite.default)(coercedValue)) {
      return coercedValue !== 0;
    }
    throw new _GraphQLError.GraphQLError("Boolean cannot represent a non boolean value: ".concat((0, _inspect.default)(coercedValue)));
  }
  function coerceBoolean(inputValue) {
    if (typeof inputValue !== "boolean") {
      throw new _GraphQLError.GraphQLError("Boolean cannot represent a non boolean value: ".concat((0, _inspect.default)(inputValue)));
    }
    return inputValue;
  }
  var GraphQLBoolean = new _definition.GraphQLScalarType({
    name: "Boolean",
    description: "The `Boolean` scalar type represents `true` or `false`.",
    serialize: serializeBoolean,
    parseValue: coerceBoolean,
    parseLiteral: function parseLiteral(valueNode) {
      if (valueNode.kind !== _kinds.Kind.BOOLEAN) {
        throw new _GraphQLError.GraphQLError("Boolean cannot represent a non boolean value: ".concat((0, _printer.print)(valueNode)), valueNode);
      }
      return valueNode.value;
    }
  });
  exports.GraphQLBoolean = GraphQLBoolean;
  function serializeID(outputValue) {
    var coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "string") {
      return coercedValue;
    }
    if ((0, _isInteger.default)(coercedValue)) {
      return String(coercedValue);
    }
    throw new _GraphQLError.GraphQLError("ID cannot represent value: ".concat((0, _inspect.default)(outputValue)));
  }
  function coerceID(inputValue) {
    if (typeof inputValue === "string") {
      return inputValue;
    }
    if ((0, _isInteger.default)(inputValue)) {
      return inputValue.toString();
    }
    throw new _GraphQLError.GraphQLError("ID cannot represent value: ".concat((0, _inspect.default)(inputValue)));
  }
  var GraphQLID = new _definition.GraphQLScalarType({
    name: "ID",
    description: 'The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.',
    serialize: serializeID,
    parseValue: coerceID,
    parseLiteral: function parseLiteral(valueNode) {
      if (valueNode.kind !== _kinds.Kind.STRING && valueNode.kind !== _kinds.Kind.INT) {
        throw new _GraphQLError.GraphQLError("ID cannot represent a non-string and non-integer value: " + (0, _printer.print)(valueNode), valueNode);
      }
      return valueNode.value;
    }
  });
  exports.GraphQLID = GraphQLID;
  var specifiedScalarTypes = Object.freeze([GraphQLString, GraphQLInt, GraphQLFloat, GraphQLBoolean, GraphQLID]);
  exports.specifiedScalarTypes = specifiedScalarTypes;
  function isSpecifiedScalarType(type) {
    return specifiedScalarTypes.some(function(_ref) {
      var name = _ref.name;
      return type.name === name;
    });
  }
});

// node_modules/graphql/utilities/astFromValue.js
var require_astFromValue = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.astFromValue = astFromValue;
  var _isFinite = _interopRequireDefault(require_isFinite());
  var _objectValues3 = _interopRequireDefault(require_objectValues());
  var _inspect = _interopRequireDefault(require_inspect());
  var _invariant = _interopRequireDefault(require_invariant());
  var _isObjectLike = _interopRequireDefault(require_isObjectLike());
  var _safeArrayFrom = _interopRequireDefault(require_safeArrayFrom());
  var _kinds = require_kinds();
  var _scalars = require_scalars();
  var _definition = require_definition();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function astFromValue(value, type) {
    if ((0, _definition.isNonNullType)(type)) {
      var astValue = astFromValue(value, type.ofType);
      if ((astValue === null || astValue === undefined ? undefined : astValue.kind) === _kinds.Kind.NULL) {
        return null;
      }
      return astValue;
    }
    if (value === null) {
      return {
        kind: _kinds.Kind.NULL
      };
    }
    if (value === undefined) {
      return null;
    }
    if ((0, _definition.isListType)(type)) {
      var itemType = type.ofType;
      var items = (0, _safeArrayFrom.default)(value);
      if (items != null) {
        var valuesNodes = [];
        for (var _i2 = 0;_i2 < items.length; _i2++) {
          var item = items[_i2];
          var itemNode = astFromValue(item, itemType);
          if (itemNode != null) {
            valuesNodes.push(itemNode);
          }
        }
        return {
          kind: _kinds.Kind.LIST,
          values: valuesNodes
        };
      }
      return astFromValue(value, itemType);
    }
    if ((0, _definition.isInputObjectType)(type)) {
      if (!(0, _isObjectLike.default)(value)) {
        return null;
      }
      var fieldNodes = [];
      for (var _i4 = 0, _objectValues2 = (0, _objectValues3.default)(type.getFields());_i4 < _objectValues2.length; _i4++) {
        var field = _objectValues2[_i4];
        var fieldValue = astFromValue(value[field.name], field.type);
        if (fieldValue) {
          fieldNodes.push({
            kind: _kinds.Kind.OBJECT_FIELD,
            name: {
              kind: _kinds.Kind.NAME,
              value: field.name
            },
            value: fieldValue
          });
        }
      }
      return {
        kind: _kinds.Kind.OBJECT,
        fields: fieldNodes
      };
    }
    if ((0, _definition.isLeafType)(type)) {
      var serialized = type.serialize(value);
      if (serialized == null) {
        return null;
      }
      if (typeof serialized === "boolean") {
        return {
          kind: _kinds.Kind.BOOLEAN,
          value: serialized
        };
      }
      if (typeof serialized === "number" && (0, _isFinite.default)(serialized)) {
        var stringNum = String(serialized);
        return integerStringRegExp.test(stringNum) ? {
          kind: _kinds.Kind.INT,
          value: stringNum
        } : {
          kind: _kinds.Kind.FLOAT,
          value: stringNum
        };
      }
      if (typeof serialized === "string") {
        if ((0, _definition.isEnumType)(type)) {
          return {
            kind: _kinds.Kind.ENUM,
            value: serialized
          };
        }
        if (type === _scalars.GraphQLID && integerStringRegExp.test(serialized)) {
          return {
            kind: _kinds.Kind.INT,
            value: serialized
          };
        }
        return {
          kind: _kinds.Kind.STRING,
          value: serialized
        };
      }
      throw new TypeError("Cannot convert value to AST: ".concat((0, _inspect.default)(serialized), "."));
    }
    (0, _invariant.default)(0, "Unexpected input type: " + (0, _inspect.default)(type));
  }
  var integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;
});

// node_modules/graphql/type/introspection.js
var require_introspection = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.isIntrospectionType = isIntrospectionType;
  exports.introspectionTypes = exports.TypeNameMetaFieldDef = exports.TypeMetaFieldDef = exports.SchemaMetaFieldDef = exports.__TypeKind = exports.TypeKind = exports.__EnumValue = exports.__InputValue = exports.__Field = exports.__Type = exports.__DirectiveLocation = exports.__Directive = exports.__Schema = undefined;
  var _objectValues = _interopRequireDefault(require_objectValues());
  var _inspect = _interopRequireDefault(require_inspect());
  var _invariant = _interopRequireDefault(require_invariant());
  var _printer = require_printer();
  var _directiveLocation = require_directiveLocation();
  var _astFromValue = require_astFromValue();
  var _scalars = require_scalars();
  var _definition = require_definition();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var __Schema = new _definition.GraphQLObjectType({
    name: "__Schema",
    description: "A GraphQL Schema defines the capabilities of a GraphQL server. It exposes all available types and directives on the server, as well as the entry points for query, mutation, and subscription operations.",
    fields: function fields() {
      return {
        description: {
          type: _scalars.GraphQLString,
          resolve: function resolve(schema) {
            return schema.description;
          }
        },
        types: {
          description: "A list of all types supported by this server.",
          type: new _definition.GraphQLNonNull(new _definition.GraphQLList(new _definition.GraphQLNonNull(__Type))),
          resolve: function resolve(schema) {
            return (0, _objectValues.default)(schema.getTypeMap());
          }
        },
        queryType: {
          description: "The type that query operations will be rooted at.",
          type: new _definition.GraphQLNonNull(__Type),
          resolve: function resolve(schema) {
            return schema.getQueryType();
          }
        },
        mutationType: {
          description: "If this server supports mutation, the type that mutation operations will be rooted at.",
          type: __Type,
          resolve: function resolve(schema) {
            return schema.getMutationType();
          }
        },
        subscriptionType: {
          description: "If this server support subscription, the type that subscription operations will be rooted at.",
          type: __Type,
          resolve: function resolve(schema) {
            return schema.getSubscriptionType();
          }
        },
        directives: {
          description: "A list of all directives supported by this server.",
          type: new _definition.GraphQLNonNull(new _definition.GraphQLList(new _definition.GraphQLNonNull(__Directive))),
          resolve: function resolve(schema) {
            return schema.getDirectives();
          }
        }
      };
    }
  });
  exports.__Schema = __Schema;
  var __Directive = new _definition.GraphQLObjectType({
    name: "__Directive",
    description: `A Directive provides a way to describe alternate runtime execution and type validation behavior in a GraphQL document.

In some cases, you need to provide options to alter GraphQL's execution behavior in ways field arguments will not suffice, such as conditionally including or skipping a field. Directives provide this by describing additional information to the executor.`,
    fields: function fields() {
      return {
        name: {
          type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
          resolve: function resolve(directive) {
            return directive.name;
          }
        },
        description: {
          type: _scalars.GraphQLString,
          resolve: function resolve(directive) {
            return directive.description;
          }
        },
        isRepeatable: {
          type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
          resolve: function resolve(directive) {
            return directive.isRepeatable;
          }
        },
        locations: {
          type: new _definition.GraphQLNonNull(new _definition.GraphQLList(new _definition.GraphQLNonNull(__DirectiveLocation))),
          resolve: function resolve(directive) {
            return directive.locations;
          }
        },
        args: {
          type: new _definition.GraphQLNonNull(new _definition.GraphQLList(new _definition.GraphQLNonNull(__InputValue))),
          args: {
            includeDeprecated: {
              type: _scalars.GraphQLBoolean,
              defaultValue: false
            }
          },
          resolve: function resolve(field, _ref) {
            var includeDeprecated = _ref.includeDeprecated;
            return includeDeprecated ? field.args : field.args.filter(function(arg) {
              return arg.deprecationReason == null;
            });
          }
        }
      };
    }
  });
  exports.__Directive = __Directive;
  var __DirectiveLocation = new _definition.GraphQLEnumType({
    name: "__DirectiveLocation",
    description: "A Directive can be adjacent to many parts of the GraphQL language, a __DirectiveLocation describes one such possible adjacencies.",
    values: {
      QUERY: {
        value: _directiveLocation.DirectiveLocation.QUERY,
        description: "Location adjacent to a query operation."
      },
      MUTATION: {
        value: _directiveLocation.DirectiveLocation.MUTATION,
        description: "Location adjacent to a mutation operation."
      },
      SUBSCRIPTION: {
        value: _directiveLocation.DirectiveLocation.SUBSCRIPTION,
        description: "Location adjacent to a subscription operation."
      },
      FIELD: {
        value: _directiveLocation.DirectiveLocation.FIELD,
        description: "Location adjacent to a field."
      },
      FRAGMENT_DEFINITION: {
        value: _directiveLocation.DirectiveLocation.FRAGMENT_DEFINITION,
        description: "Location adjacent to a fragment definition."
      },
      FRAGMENT_SPREAD: {
        value: _directiveLocation.DirectiveLocation.FRAGMENT_SPREAD,
        description: "Location adjacent to a fragment spread."
      },
      INLINE_FRAGMENT: {
        value: _directiveLocation.DirectiveLocation.INLINE_FRAGMENT,
        description: "Location adjacent to an inline fragment."
      },
      VARIABLE_DEFINITION: {
        value: _directiveLocation.DirectiveLocation.VARIABLE_DEFINITION,
        description: "Location adjacent to a variable definition."
      },
      SCHEMA: {
        value: _directiveLocation.DirectiveLocation.SCHEMA,
        description: "Location adjacent to a schema definition."
      },
      SCALAR: {
        value: _directiveLocation.DirectiveLocation.SCALAR,
        description: "Location adjacent to a scalar definition."
      },
      OBJECT: {
        value: _directiveLocation.DirectiveLocation.OBJECT,
        description: "Location adjacent to an object type definition."
      },
      FIELD_DEFINITION: {
        value: _directiveLocation.DirectiveLocation.FIELD_DEFINITION,
        description: "Location adjacent to a field definition."
      },
      ARGUMENT_DEFINITION: {
        value: _directiveLocation.DirectiveLocation.ARGUMENT_DEFINITION,
        description: "Location adjacent to an argument definition."
      },
      INTERFACE: {
        value: _directiveLocation.DirectiveLocation.INTERFACE,
        description: "Location adjacent to an interface definition."
      },
      UNION: {
        value: _directiveLocation.DirectiveLocation.UNION,
        description: "Location adjacent to a union definition."
      },
      ENUM: {
        value: _directiveLocation.DirectiveLocation.ENUM,
        description: "Location adjacent to an enum definition."
      },
      ENUM_VALUE: {
        value: _directiveLocation.DirectiveLocation.ENUM_VALUE,
        description: "Location adjacent to an enum value definition."
      },
      INPUT_OBJECT: {
        value: _directiveLocation.DirectiveLocation.INPUT_OBJECT,
        description: "Location adjacent to an input object type definition."
      },
      INPUT_FIELD_DEFINITION: {
        value: _directiveLocation.DirectiveLocation.INPUT_FIELD_DEFINITION,
        description: "Location adjacent to an input object field definition."
      }
    }
  });
  exports.__DirectiveLocation = __DirectiveLocation;
  var __Type = new _definition.GraphQLObjectType({
    name: "__Type",
    description: "The fundamental unit of any GraphQL Schema is the type. There are many kinds of types in GraphQL as represented by the `__TypeKind` enum.\n\nDepending on the kind of a type, certain fields describe information about that type. Scalar types provide no information beyond a name, description and optional `specifiedByUrl`, while Enum types provide their values. Object and Interface types provide the fields they describe. Abstract types, Union and Interface, provide the Object types possible at runtime. List and NonNull types compose other types.",
    fields: function fields() {
      return {
        kind: {
          type: new _definition.GraphQLNonNull(__TypeKind),
          resolve: function resolve(type) {
            if ((0, _definition.isScalarType)(type)) {
              return TypeKind.SCALAR;
            }
            if ((0, _definition.isObjectType)(type)) {
              return TypeKind.OBJECT;
            }
            if ((0, _definition.isInterfaceType)(type)) {
              return TypeKind.INTERFACE;
            }
            if ((0, _definition.isUnionType)(type)) {
              return TypeKind.UNION;
            }
            if ((0, _definition.isEnumType)(type)) {
              return TypeKind.ENUM;
            }
            if ((0, _definition.isInputObjectType)(type)) {
              return TypeKind.INPUT_OBJECT;
            }
            if ((0, _definition.isListType)(type)) {
              return TypeKind.LIST;
            }
            if ((0, _definition.isNonNullType)(type)) {
              return TypeKind.NON_NULL;
            }
            (0, _invariant.default)(0, 'Unexpected type: "'.concat((0, _inspect.default)(type), '".'));
          }
        },
        name: {
          type: _scalars.GraphQLString,
          resolve: function resolve(type) {
            return type.name !== undefined ? type.name : undefined;
          }
        },
        description: {
          type: _scalars.GraphQLString,
          resolve: function resolve(type) {
            return type.description !== undefined ? type.description : undefined;
          }
        },
        specifiedByUrl: {
          type: _scalars.GraphQLString,
          resolve: function resolve(obj) {
            return obj.specifiedByUrl !== undefined ? obj.specifiedByUrl : undefined;
          }
        },
        fields: {
          type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__Field)),
          args: {
            includeDeprecated: {
              type: _scalars.GraphQLBoolean,
              defaultValue: false
            }
          },
          resolve: function resolve(type, _ref2) {
            var includeDeprecated = _ref2.includeDeprecated;
            if ((0, _definition.isObjectType)(type) || (0, _definition.isInterfaceType)(type)) {
              var fields = (0, _objectValues.default)(type.getFields());
              return includeDeprecated ? fields : fields.filter(function(field) {
                return field.deprecationReason == null;
              });
            }
          }
        },
        interfaces: {
          type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__Type)),
          resolve: function resolve(type) {
            if ((0, _definition.isObjectType)(type) || (0, _definition.isInterfaceType)(type)) {
              return type.getInterfaces();
            }
          }
        },
        possibleTypes: {
          type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__Type)),
          resolve: function resolve(type, _args, _context, _ref3) {
            var schema = _ref3.schema;
            if ((0, _definition.isAbstractType)(type)) {
              return schema.getPossibleTypes(type);
            }
          }
        },
        enumValues: {
          type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__EnumValue)),
          args: {
            includeDeprecated: {
              type: _scalars.GraphQLBoolean,
              defaultValue: false
            }
          },
          resolve: function resolve(type, _ref4) {
            var includeDeprecated = _ref4.includeDeprecated;
            if ((0, _definition.isEnumType)(type)) {
              var values = type.getValues();
              return includeDeprecated ? values : values.filter(function(field) {
                return field.deprecationReason == null;
              });
            }
          }
        },
        inputFields: {
          type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__InputValue)),
          args: {
            includeDeprecated: {
              type: _scalars.GraphQLBoolean,
              defaultValue: false
            }
          },
          resolve: function resolve(type, _ref5) {
            var includeDeprecated = _ref5.includeDeprecated;
            if ((0, _definition.isInputObjectType)(type)) {
              var values = (0, _objectValues.default)(type.getFields());
              return includeDeprecated ? values : values.filter(function(field) {
                return field.deprecationReason == null;
              });
            }
          }
        },
        ofType: {
          type: __Type,
          resolve: function resolve(type) {
            return type.ofType !== undefined ? type.ofType : undefined;
          }
        }
      };
    }
  });
  exports.__Type = __Type;
  var __Field = new _definition.GraphQLObjectType({
    name: "__Field",
    description: "Object and Interface types are described by a list of Fields, each of which has a name, potentially a list of arguments, and a return type.",
    fields: function fields() {
      return {
        name: {
          type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
          resolve: function resolve(field) {
            return field.name;
          }
        },
        description: {
          type: _scalars.GraphQLString,
          resolve: function resolve(field) {
            return field.description;
          }
        },
        args: {
          type: new _definition.GraphQLNonNull(new _definition.GraphQLList(new _definition.GraphQLNonNull(__InputValue))),
          args: {
            includeDeprecated: {
              type: _scalars.GraphQLBoolean,
              defaultValue: false
            }
          },
          resolve: function resolve(field, _ref6) {
            var includeDeprecated = _ref6.includeDeprecated;
            return includeDeprecated ? field.args : field.args.filter(function(arg) {
              return arg.deprecationReason == null;
            });
          }
        },
        type: {
          type: new _definition.GraphQLNonNull(__Type),
          resolve: function resolve(field) {
            return field.type;
          }
        },
        isDeprecated: {
          type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
          resolve: function resolve(field) {
            return field.deprecationReason != null;
          }
        },
        deprecationReason: {
          type: _scalars.GraphQLString,
          resolve: function resolve(field) {
            return field.deprecationReason;
          }
        }
      };
    }
  });
  exports.__Field = __Field;
  var __InputValue = new _definition.GraphQLObjectType({
    name: "__InputValue",
    description: "Arguments provided to Fields or Directives and the input fields of an InputObject are represented as Input Values which describe their type and optionally a default value.",
    fields: function fields() {
      return {
        name: {
          type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
          resolve: function resolve(inputValue) {
            return inputValue.name;
          }
        },
        description: {
          type: _scalars.GraphQLString,
          resolve: function resolve(inputValue) {
            return inputValue.description;
          }
        },
        type: {
          type: new _definition.GraphQLNonNull(__Type),
          resolve: function resolve(inputValue) {
            return inputValue.type;
          }
        },
        defaultValue: {
          type: _scalars.GraphQLString,
          description: "A GraphQL-formatted string representing the default value for this input value.",
          resolve: function resolve(inputValue) {
            var { type, defaultValue } = inputValue;
            var valueAST = (0, _astFromValue.astFromValue)(defaultValue, type);
            return valueAST ? (0, _printer.print)(valueAST) : null;
          }
        },
        isDeprecated: {
          type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
          resolve: function resolve(field) {
            return field.deprecationReason != null;
          }
        },
        deprecationReason: {
          type: _scalars.GraphQLString,
          resolve: function resolve(obj) {
            return obj.deprecationReason;
          }
        }
      };
    }
  });
  exports.__InputValue = __InputValue;
  var __EnumValue = new _definition.GraphQLObjectType({
    name: "__EnumValue",
    description: "One possible value for a given Enum. Enum values are unique values, not a placeholder for a string or numeric value. However an Enum value is returned in a JSON response as a string.",
    fields: function fields() {
      return {
        name: {
          type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
          resolve: function resolve(enumValue) {
            return enumValue.name;
          }
        },
        description: {
          type: _scalars.GraphQLString,
          resolve: function resolve(enumValue) {
            return enumValue.description;
          }
        },
        isDeprecated: {
          type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
          resolve: function resolve(enumValue) {
            return enumValue.deprecationReason != null;
          }
        },
        deprecationReason: {
          type: _scalars.GraphQLString,
          resolve: function resolve(enumValue) {
            return enumValue.deprecationReason;
          }
        }
      };
    }
  });
  exports.__EnumValue = __EnumValue;
  var TypeKind = Object.freeze({
    SCALAR: "SCALAR",
    OBJECT: "OBJECT",
    INTERFACE: "INTERFACE",
    UNION: "UNION",
    ENUM: "ENUM",
    INPUT_OBJECT: "INPUT_OBJECT",
    LIST: "LIST",
    NON_NULL: "NON_NULL"
  });
  exports.TypeKind = TypeKind;
  var __TypeKind = new _definition.GraphQLEnumType({
    name: "__TypeKind",
    description: "An enum describing what kind of type a given `__Type` is.",
    values: {
      SCALAR: {
        value: TypeKind.SCALAR,
        description: "Indicates this type is a scalar."
      },
      OBJECT: {
        value: TypeKind.OBJECT,
        description: "Indicates this type is an object. `fields` and `interfaces` are valid fields."
      },
      INTERFACE: {
        value: TypeKind.INTERFACE,
        description: "Indicates this type is an interface. `fields`, `interfaces`, and `possibleTypes` are valid fields."
      },
      UNION: {
        value: TypeKind.UNION,
        description: "Indicates this type is a union. `possibleTypes` is a valid field."
      },
      ENUM: {
        value: TypeKind.ENUM,
        description: "Indicates this type is an enum. `enumValues` is a valid field."
      },
      INPUT_OBJECT: {
        value: TypeKind.INPUT_OBJECT,
        description: "Indicates this type is an input object. `inputFields` is a valid field."
      },
      LIST: {
        value: TypeKind.LIST,
        description: "Indicates this type is a list. `ofType` is a valid field."
      },
      NON_NULL: {
        value: TypeKind.NON_NULL,
        description: "Indicates this type is a non-null. `ofType` is a valid field."
      }
    }
  });
  exports.__TypeKind = __TypeKind;
  var SchemaMetaFieldDef = {
    name: "__schema",
    type: new _definition.GraphQLNonNull(__Schema),
    description: "Access the current type schema of this server.",
    args: [],
    resolve: function resolve(_source, _args, _context, _ref7) {
      var schema = _ref7.schema;
      return schema;
    },
    isDeprecated: false,
    deprecationReason: undefined,
    extensions: undefined,
    astNode: undefined
  };
  exports.SchemaMetaFieldDef = SchemaMetaFieldDef;
  var TypeMetaFieldDef = {
    name: "__type",
    type: __Type,
    description: "Request the type information of a single type.",
    args: [{
      name: "name",
      description: undefined,
      type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
      defaultValue: undefined,
      deprecationReason: undefined,
      extensions: undefined,
      astNode: undefined
    }],
    resolve: function resolve(_source, _ref8, _context, _ref9) {
      var name = _ref8.name;
      var schema = _ref9.schema;
      return schema.getType(name);
    },
    isDeprecated: false,
    deprecationReason: undefined,
    extensions: undefined,
    astNode: undefined
  };
  exports.TypeMetaFieldDef = TypeMetaFieldDef;
  var TypeNameMetaFieldDef = {
    name: "__typename",
    type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
    description: "The name of the current Object type at runtime.",
    args: [],
    resolve: function resolve(_source, _args, _context, _ref10) {
      var parentType = _ref10.parentType;
      return parentType.name;
    },
    isDeprecated: false,
    deprecationReason: undefined,
    extensions: undefined,
    astNode: undefined
  };
  exports.TypeNameMetaFieldDef = TypeNameMetaFieldDef;
  var introspectionTypes = Object.freeze([__Schema, __Directive, __DirectiveLocation, __Type, __Field, __InputValue, __EnumValue, __TypeKind]);
  exports.introspectionTypes = introspectionTypes;
  function isIntrospectionType(type) {
    return introspectionTypes.some(function(_ref11) {
      var name = _ref11.name;
      return type.name === name;
    });
  }
});

// node_modules/graphql/type/directives.js
var require_directives = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.isDirective = isDirective;
  exports.assertDirective = assertDirective;
  exports.isSpecifiedDirective = isSpecifiedDirective;
  exports.specifiedDirectives = exports.GraphQLSpecifiedByDirective = exports.GraphQLDeprecatedDirective = exports.DEFAULT_DEPRECATION_REASON = exports.GraphQLSkipDirective = exports.GraphQLIncludeDirective = exports.GraphQLDirective = undefined;
  var _objectEntries = _interopRequireDefault(require_objectEntries());
  var _symbols = require_symbols();
  var _inspect = _interopRequireDefault(require_inspect());
  var _toObjMap = _interopRequireDefault(require_toObjMap());
  var _devAssert = _interopRequireDefault(require_devAssert());
  var _instanceOf = _interopRequireDefault(require_instanceOf());
  var _isObjectLike = _interopRequireDefault(require_isObjectLike());
  var _defineInspect = _interopRequireDefault(require_defineInspect());
  var _directiveLocation = require_directiveLocation();
  var _scalars = require_scalars();
  var _definition = require_definition();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _defineProperties(target, props) {
    for (var i = 0;i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties(Constructor, staticProps);
    return Constructor;
  }
  function isDirective(directive) {
    return (0, _instanceOf.default)(directive, GraphQLDirective);
  }
  function assertDirective(directive) {
    if (!isDirective(directive)) {
      throw new Error("Expected ".concat((0, _inspect.default)(directive), " to be a GraphQL directive."));
    }
    return directive;
  }
  var GraphQLDirective = /* @__PURE__ */ function() {
    function GraphQLDirective2(config) {
      var _config$isRepeatable, _config$args;
      this.name = config.name;
      this.description = config.description;
      this.locations = config.locations;
      this.isRepeatable = (_config$isRepeatable = config.isRepeatable) !== null && _config$isRepeatable !== undefined ? _config$isRepeatable : false;
      this.extensions = config.extensions && (0, _toObjMap.default)(config.extensions);
      this.astNode = config.astNode;
      config.name || (0, _devAssert.default)(0, "Directive must be named.");
      Array.isArray(config.locations) || (0, _devAssert.default)(0, "@".concat(config.name, " locations must be an Array."));
      var args2 = (_config$args = config.args) !== null && _config$args !== undefined ? _config$args : {};
      (0, _isObjectLike.default)(args2) && !Array.isArray(args2) || (0, _devAssert.default)(0, "@".concat(config.name, " args must be an object with argument names as keys."));
      this.args = (0, _objectEntries.default)(args2).map(function(_ref) {
        var argName = _ref[0], argConfig = _ref[1];
        return {
          name: argName,
          description: argConfig.description,
          type: argConfig.type,
          defaultValue: argConfig.defaultValue,
          deprecationReason: argConfig.deprecationReason,
          extensions: argConfig.extensions && (0, _toObjMap.default)(argConfig.extensions),
          astNode: argConfig.astNode
        };
      });
    }
    var _proto = GraphQLDirective2.prototype;
    _proto.toConfig = function toConfig() {
      return {
        name: this.name,
        description: this.description,
        locations: this.locations,
        args: (0, _definition.argsToArgsConfig)(this.args),
        isRepeatable: this.isRepeatable,
        extensions: this.extensions,
        astNode: this.astNode
      };
    };
    _proto.toString = function toString() {
      return "@" + this.name;
    };
    _proto.toJSON = function toJSON() {
      return this.toString();
    };
    _createClass(GraphQLDirective2, [{
      key: _symbols.SYMBOL_TO_STRING_TAG,
      get: function get() {
        return "GraphQLDirective";
      }
    }]);
    return GraphQLDirective2;
  }();
  exports.GraphQLDirective = GraphQLDirective;
  (0, _defineInspect.default)(GraphQLDirective);
  var GraphQLIncludeDirective = new GraphQLDirective({
    name: "include",
    description: "Directs the executor to include this field or fragment only when the `if` argument is true.",
    locations: [_directiveLocation.DirectiveLocation.FIELD, _directiveLocation.DirectiveLocation.FRAGMENT_SPREAD, _directiveLocation.DirectiveLocation.INLINE_FRAGMENT],
    args: {
      if: {
        type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
        description: "Included when true."
      }
    }
  });
  exports.GraphQLIncludeDirective = GraphQLIncludeDirective;
  var GraphQLSkipDirective = new GraphQLDirective({
    name: "skip",
    description: "Directs the executor to skip this field or fragment when the `if` argument is true.",
    locations: [_directiveLocation.DirectiveLocation.FIELD, _directiveLocation.DirectiveLocation.FRAGMENT_SPREAD, _directiveLocation.DirectiveLocation.INLINE_FRAGMENT],
    args: {
      if: {
        type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
        description: "Skipped when true."
      }
    }
  });
  exports.GraphQLSkipDirective = GraphQLSkipDirective;
  var DEFAULT_DEPRECATION_REASON = "No longer supported";
  exports.DEFAULT_DEPRECATION_REASON = DEFAULT_DEPRECATION_REASON;
  var GraphQLDeprecatedDirective = new GraphQLDirective({
    name: "deprecated",
    description: "Marks an element of a GraphQL schema as no longer supported.",
    locations: [_directiveLocation.DirectiveLocation.FIELD_DEFINITION, _directiveLocation.DirectiveLocation.ARGUMENT_DEFINITION, _directiveLocation.DirectiveLocation.INPUT_FIELD_DEFINITION, _directiveLocation.DirectiveLocation.ENUM_VALUE],
    args: {
      reason: {
        type: _scalars.GraphQLString,
        description: "Explains why this element was deprecated, usually also including a suggestion for how to access supported similar data. Formatted using the Markdown syntax, as specified by [CommonMark](https://commonmark.org/).",
        defaultValue: DEFAULT_DEPRECATION_REASON
      }
    }
  });
  exports.GraphQLDeprecatedDirective = GraphQLDeprecatedDirective;
  var GraphQLSpecifiedByDirective = new GraphQLDirective({
    name: "specifiedBy",
    description: "Exposes a URL that specifies the behaviour of this scalar.",
    locations: [_directiveLocation.DirectiveLocation.SCALAR],
    args: {
      url: {
        type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
        description: "The URL that specifies the behaviour of this scalar."
      }
    }
  });
  exports.GraphQLSpecifiedByDirective = GraphQLSpecifiedByDirective;
  var specifiedDirectives = Object.freeze([GraphQLIncludeDirective, GraphQLSkipDirective, GraphQLDeprecatedDirective, GraphQLSpecifiedByDirective]);
  exports.specifiedDirectives = specifiedDirectives;
  function isSpecifiedDirective(directive) {
    return specifiedDirectives.some(function(_ref2) {
      var name = _ref2.name;
      return name === directive.name;
    });
  }
});

// node_modules/graphql/type/schema.js
var require_schema = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.isSchema = isSchema;
  exports.assertSchema = assertSchema;
  exports.GraphQLSchema = undefined;
  var _find = _interopRequireDefault(require_find());
  var _arrayFrom3 = _interopRequireDefault(require_arrayFrom());
  var _objectValues5 = _interopRequireDefault(require_objectValues());
  var _symbols = require_symbols();
  var _inspect = _interopRequireDefault(require_inspect());
  var _toObjMap = _interopRequireDefault(require_toObjMap());
  var _devAssert = _interopRequireDefault(require_devAssert());
  var _instanceOf = _interopRequireDefault(require_instanceOf());
  var _isObjectLike = _interopRequireDefault(require_isObjectLike());
  var _introspection = require_introspection();
  var _directives = require_directives();
  var _definition = require_definition();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _defineProperties(target, props) {
    for (var i = 0;i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties(Constructor, staticProps);
    return Constructor;
  }
  function isSchema(schema) {
    return (0, _instanceOf.default)(schema, GraphQLSchema);
  }
  function assertSchema(schema) {
    if (!isSchema(schema)) {
      throw new Error("Expected ".concat((0, _inspect.default)(schema), " to be a GraphQL schema."));
    }
    return schema;
  }
  var GraphQLSchema = /* @__PURE__ */ function() {
    function GraphQLSchema2(config) {
      var _config$directives;
      this.__validationErrors = config.assumeValid === true ? [] : undefined;
      (0, _isObjectLike.default)(config) || (0, _devAssert.default)(0, "Must provide configuration object.");
      !config.types || Array.isArray(config.types) || (0, _devAssert.default)(0, '"types" must be Array if provided but got: '.concat((0, _inspect.default)(config.types), "."));
      !config.directives || Array.isArray(config.directives) || (0, _devAssert.default)(0, '"directives" must be Array if provided but got: ' + "".concat((0, _inspect.default)(config.directives), "."));
      this.description = config.description;
      this.extensions = config.extensions && (0, _toObjMap.default)(config.extensions);
      this.astNode = config.astNode;
      this.extensionASTNodes = config.extensionASTNodes;
      this._queryType = config.query;
      this._mutationType = config.mutation;
      this._subscriptionType = config.subscription;
      this._directives = (_config$directives = config.directives) !== null && _config$directives !== undefined ? _config$directives : _directives.specifiedDirectives;
      var allReferencedTypes = new Set(config.types);
      if (config.types != null) {
        for (var _i2 = 0, _config$types2 = config.types;_i2 < _config$types2.length; _i2++) {
          var type = _config$types2[_i2];
          allReferencedTypes.delete(type);
          collectReferencedTypes(type, allReferencedTypes);
        }
      }
      if (this._queryType != null) {
        collectReferencedTypes(this._queryType, allReferencedTypes);
      }
      if (this._mutationType != null) {
        collectReferencedTypes(this._mutationType, allReferencedTypes);
      }
      if (this._subscriptionType != null) {
        collectReferencedTypes(this._subscriptionType, allReferencedTypes);
      }
      for (var _i4 = 0, _this$_directives2 = this._directives;_i4 < _this$_directives2.length; _i4++) {
        var directive = _this$_directives2[_i4];
        if ((0, _directives.isDirective)(directive)) {
          for (var _i6 = 0, _directive$args2 = directive.args;_i6 < _directive$args2.length; _i6++) {
            var arg = _directive$args2[_i6];
            collectReferencedTypes(arg.type, allReferencedTypes);
          }
        }
      }
      collectReferencedTypes(_introspection.__Schema, allReferencedTypes);
      this._typeMap = Object.create(null);
      this._subTypeMap = Object.create(null);
      this._implementationsMap = Object.create(null);
      for (var _i8 = 0, _arrayFrom2 = (0, _arrayFrom3.default)(allReferencedTypes);_i8 < _arrayFrom2.length; _i8++) {
        var namedType = _arrayFrom2[_i8];
        if (namedType == null) {
          continue;
        }
        var typeName = namedType.name;
        typeName || (0, _devAssert.default)(0, "One of the provided types for building the Schema is missing a name.");
        if (this._typeMap[typeName] !== undefined) {
          throw new Error('Schema must contain uniquely named types but contains multiple types named "'.concat(typeName, '".'));
        }
        this._typeMap[typeName] = namedType;
        if ((0, _definition.isInterfaceType)(namedType)) {
          for (var _i10 = 0, _namedType$getInterfa2 = namedType.getInterfaces();_i10 < _namedType$getInterfa2.length; _i10++) {
            var iface = _namedType$getInterfa2[_i10];
            if ((0, _definition.isInterfaceType)(iface)) {
              var implementations = this._implementationsMap[iface.name];
              if (implementations === undefined) {
                implementations = this._implementationsMap[iface.name] = {
                  objects: [],
                  interfaces: []
                };
              }
              implementations.interfaces.push(namedType);
            }
          }
        } else if ((0, _definition.isObjectType)(namedType)) {
          for (var _i12 = 0, _namedType$getInterfa4 = namedType.getInterfaces();_i12 < _namedType$getInterfa4.length; _i12++) {
            var _iface = _namedType$getInterfa4[_i12];
            if ((0, _definition.isInterfaceType)(_iface)) {
              var _implementations = this._implementationsMap[_iface.name];
              if (_implementations === undefined) {
                _implementations = this._implementationsMap[_iface.name] = {
                  objects: [],
                  interfaces: []
                };
              }
              _implementations.objects.push(namedType);
            }
          }
        }
      }
    }
    var _proto = GraphQLSchema2.prototype;
    _proto.getQueryType = function getQueryType() {
      return this._queryType;
    };
    _proto.getMutationType = function getMutationType() {
      return this._mutationType;
    };
    _proto.getSubscriptionType = function getSubscriptionType() {
      return this._subscriptionType;
    };
    _proto.getTypeMap = function getTypeMap() {
      return this._typeMap;
    };
    _proto.getType = function getType(name) {
      return this.getTypeMap()[name];
    };
    _proto.getPossibleTypes = function getPossibleTypes(abstractType) {
      return (0, _definition.isUnionType)(abstractType) ? abstractType.getTypes() : this.getImplementations(abstractType).objects;
    };
    _proto.getImplementations = function getImplementations(interfaceType) {
      var implementations = this._implementationsMap[interfaceType.name];
      return implementations !== null && implementations !== undefined ? implementations : {
        objects: [],
        interfaces: []
      };
    };
    _proto.isPossibleType = function isPossibleType(abstractType, possibleType) {
      return this.isSubType(abstractType, possibleType);
    };
    _proto.isSubType = function isSubType(abstractType, maybeSubType) {
      var map = this._subTypeMap[abstractType.name];
      if (map === undefined) {
        map = Object.create(null);
        if ((0, _definition.isUnionType)(abstractType)) {
          for (var _i14 = 0, _abstractType$getType2 = abstractType.getTypes();_i14 < _abstractType$getType2.length; _i14++) {
            var type = _abstractType$getType2[_i14];
            map[type.name] = true;
          }
        } else {
          var implementations = this.getImplementations(abstractType);
          for (var _i16 = 0, _implementations$obje2 = implementations.objects;_i16 < _implementations$obje2.length; _i16++) {
            var _type = _implementations$obje2[_i16];
            map[_type.name] = true;
          }
          for (var _i18 = 0, _implementations$inte2 = implementations.interfaces;_i18 < _implementations$inte2.length; _i18++) {
            var _type2 = _implementations$inte2[_i18];
            map[_type2.name] = true;
          }
        }
        this._subTypeMap[abstractType.name] = map;
      }
      return map[maybeSubType.name] !== undefined;
    };
    _proto.getDirectives = function getDirectives() {
      return this._directives;
    };
    _proto.getDirective = function getDirective(name) {
      return (0, _find.default)(this.getDirectives(), function(directive) {
        return directive.name === name;
      });
    };
    _proto.toConfig = function toConfig() {
      var _this$extensionASTNod;
      return {
        description: this.description,
        query: this.getQueryType(),
        mutation: this.getMutationType(),
        subscription: this.getSubscriptionType(),
        types: (0, _objectValues5.default)(this.getTypeMap()),
        directives: this.getDirectives().slice(),
        extensions: this.extensions,
        astNode: this.astNode,
        extensionASTNodes: (_this$extensionASTNod = this.extensionASTNodes) !== null && _this$extensionASTNod !== undefined ? _this$extensionASTNod : [],
        assumeValid: this.__validationErrors !== undefined
      };
    };
    _createClass(GraphQLSchema2, [{
      key: _symbols.SYMBOL_TO_STRING_TAG,
      get: function get() {
        return "GraphQLSchema";
      }
    }]);
    return GraphQLSchema2;
  }();
  exports.GraphQLSchema = GraphQLSchema;
  function collectReferencedTypes(type, typeSet) {
    var namedType = (0, _definition.getNamedType)(type);
    if (!typeSet.has(namedType)) {
      typeSet.add(namedType);
      if ((0, _definition.isUnionType)(namedType)) {
        for (var _i20 = 0, _namedType$getTypes2 = namedType.getTypes();_i20 < _namedType$getTypes2.length; _i20++) {
          var memberType = _namedType$getTypes2[_i20];
          collectReferencedTypes(memberType, typeSet);
        }
      } else if ((0, _definition.isObjectType)(namedType) || (0, _definition.isInterfaceType)(namedType)) {
        for (var _i22 = 0, _namedType$getInterfa6 = namedType.getInterfaces();_i22 < _namedType$getInterfa6.length; _i22++) {
          var interfaceType = _namedType$getInterfa6[_i22];
          collectReferencedTypes(interfaceType, typeSet);
        }
        for (var _i24 = 0, _objectValues2 = (0, _objectValues5.default)(namedType.getFields());_i24 < _objectValues2.length; _i24++) {
          var field = _objectValues2[_i24];
          collectReferencedTypes(field.type, typeSet);
          for (var _i26 = 0, _field$args2 = field.args;_i26 < _field$args2.length; _i26++) {
            var arg = _field$args2[_i26];
            collectReferencedTypes(arg.type, typeSet);
          }
        }
      } else if ((0, _definition.isInputObjectType)(namedType)) {
        for (var _i28 = 0, _objectValues4 = (0, _objectValues5.default)(namedType.getFields());_i28 < _objectValues4.length; _i28++) {
          var _field = _objectValues4[_i28];
          collectReferencedTypes(_field.type, typeSet);
        }
      }
    }
    return typeSet;
  }
});

// node_modules/graphql/type/validate.js
var require_validate = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.validateSchema = validateSchema;
  exports.assertValidSchema = assertValidSchema;
  var _find = _interopRequireDefault(require_find());
  var _objectValues5 = _interopRequireDefault(require_objectValues());
  var _inspect = _interopRequireDefault(require_inspect());
  var _GraphQLError = require_GraphQLError();
  var _locatedError = require_locatedError();
  var _assertValidName = require_assertValidName();
  var _typeComparators = require_typeComparators();
  var _schema = require_schema();
  var _introspection = require_introspection();
  var _directives = require_directives();
  var _definition = require_definition();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function validateSchema(schema) {
    (0, _schema.assertSchema)(schema);
    if (schema.__validationErrors) {
      return schema.__validationErrors;
    }
    var context = new SchemaValidationContext(schema);
    validateRootTypes(context);
    validateDirectives(context);
    validateTypes(context);
    var errors = context.getErrors();
    schema.__validationErrors = errors;
    return errors;
  }
  function assertValidSchema(schema) {
    var errors = validateSchema(schema);
    if (errors.length !== 0) {
      throw new Error(errors.map(function(error) {
        return error.message;
      }).join(`

`));
    }
  }
  var SchemaValidationContext = /* @__PURE__ */ function() {
    function SchemaValidationContext2(schema) {
      this._errors = [];
      this.schema = schema;
    }
    var _proto = SchemaValidationContext2.prototype;
    _proto.reportError = function reportError(message2, nodes) {
      var _nodes = Array.isArray(nodes) ? nodes.filter(Boolean) : nodes;
      this.addError(new _GraphQLError.GraphQLError(message2, _nodes));
    };
    _proto.addError = function addError(error) {
      this._errors.push(error);
    };
    _proto.getErrors = function getErrors() {
      return this._errors;
    };
    return SchemaValidationContext2;
  }();
  function validateRootTypes(context) {
    var schema = context.schema;
    var queryType = schema.getQueryType();
    if (!queryType) {
      context.reportError("Query root type must be provided.", schema.astNode);
    } else if (!(0, _definition.isObjectType)(queryType)) {
      var _getOperationTypeNode;
      context.reportError("Query root type must be Object type, it cannot be ".concat((0, _inspect.default)(queryType), "."), (_getOperationTypeNode = getOperationTypeNode(schema, "query")) !== null && _getOperationTypeNode !== undefined ? _getOperationTypeNode : queryType.astNode);
    }
    var mutationType = schema.getMutationType();
    if (mutationType && !(0, _definition.isObjectType)(mutationType)) {
      var _getOperationTypeNode2;
      context.reportError("Mutation root type must be Object type if provided, it cannot be " + "".concat((0, _inspect.default)(mutationType), "."), (_getOperationTypeNode2 = getOperationTypeNode(schema, "mutation")) !== null && _getOperationTypeNode2 !== undefined ? _getOperationTypeNode2 : mutationType.astNode);
    }
    var subscriptionType = schema.getSubscriptionType();
    if (subscriptionType && !(0, _definition.isObjectType)(subscriptionType)) {
      var _getOperationTypeNode3;
      context.reportError("Subscription root type must be Object type if provided, it cannot be " + "".concat((0, _inspect.default)(subscriptionType), "."), (_getOperationTypeNode3 = getOperationTypeNode(schema, "subscription")) !== null && _getOperationTypeNode3 !== undefined ? _getOperationTypeNode3 : subscriptionType.astNode);
    }
  }
  function getOperationTypeNode(schema, operation) {
    var operationNodes = getAllSubNodes(schema, function(node2) {
      return node2.operationTypes;
    });
    for (var _i2 = 0;_i2 < operationNodes.length; _i2++) {
      var node = operationNodes[_i2];
      if (node.operation === operation) {
        return node.type;
      }
    }
    return;
  }
  function validateDirectives(context) {
    for (var _i4 = 0, _context$schema$getDi2 = context.schema.getDirectives();_i4 < _context$schema$getDi2.length; _i4++) {
      var directive = _context$schema$getDi2[_i4];
      if (!(0, _directives.isDirective)(directive)) {
        context.reportError("Expected directive but got: ".concat((0, _inspect.default)(directive), "."), directive === null || directive === undefined ? undefined : directive.astNode);
        continue;
      }
      validateName(context, directive);
      for (var _i6 = 0, _directive$args2 = directive.args;_i6 < _directive$args2.length; _i6++) {
        var arg = _directive$args2[_i6];
        validateName(context, arg);
        if (!(0, _definition.isInputType)(arg.type)) {
          context.reportError("The type of @".concat(directive.name, "(").concat(arg.name, ":) must be Input Type ") + "but got: ".concat((0, _inspect.default)(arg.type), "."), arg.astNode);
        }
        if ((0, _definition.isRequiredArgument)(arg) && arg.deprecationReason != null) {
          var _arg$astNode;
          context.reportError("Required argument @".concat(directive.name, "(").concat(arg.name, ":) cannot be deprecated."), [
            getDeprecatedDirectiveNode(arg.astNode),
            (_arg$astNode = arg.astNode) === null || _arg$astNode === undefined ? undefined : _arg$astNode.type
          ]);
        }
      }
    }
  }
  function validateName(context, node) {
    var error = (0, _assertValidName.isValidNameError)(node.name);
    if (error) {
      context.addError((0, _locatedError.locatedError)(error, node.astNode));
    }
  }
  function validateTypes(context) {
    var validateInputObjectCircularRefs = createInputObjectCircularRefsValidator(context);
    var typeMap = context.schema.getTypeMap();
    for (var _i8 = 0, _objectValues2 = (0, _objectValues5.default)(typeMap);_i8 < _objectValues2.length; _i8++) {
      var type = _objectValues2[_i8];
      if (!(0, _definition.isNamedType)(type)) {
        context.reportError("Expected GraphQL named type but got: ".concat((0, _inspect.default)(type), "."), type.astNode);
        continue;
      }
      if (!(0, _introspection.isIntrospectionType)(type)) {
        validateName(context, type);
      }
      if ((0, _definition.isObjectType)(type)) {
        validateFields(context, type);
        validateInterfaces(context, type);
      } else if ((0, _definition.isInterfaceType)(type)) {
        validateFields(context, type);
        validateInterfaces(context, type);
      } else if ((0, _definition.isUnionType)(type)) {
        validateUnionMembers(context, type);
      } else if ((0, _definition.isEnumType)(type)) {
        validateEnumValues(context, type);
      } else if ((0, _definition.isInputObjectType)(type)) {
        validateInputFields(context, type);
        validateInputObjectCircularRefs(type);
      }
    }
  }
  function validateFields(context, type) {
    var fields = (0, _objectValues5.default)(type.getFields());
    if (fields.length === 0) {
      context.reportError("Type ".concat(type.name, " must define one or more fields."), getAllNodes(type));
    }
    for (var _i10 = 0;_i10 < fields.length; _i10++) {
      var field = fields[_i10];
      validateName(context, field);
      if (!(0, _definition.isOutputType)(field.type)) {
        var _field$astNode;
        context.reportError("The type of ".concat(type.name, ".").concat(field.name, " must be Output Type ") + "but got: ".concat((0, _inspect.default)(field.type), "."), (_field$astNode = field.astNode) === null || _field$astNode === undefined ? undefined : _field$astNode.type);
      }
      for (var _i12 = 0, _field$args2 = field.args;_i12 < _field$args2.length; _i12++) {
        var arg = _field$args2[_i12];
        var argName = arg.name;
        validateName(context, arg);
        if (!(0, _definition.isInputType)(arg.type)) {
          var _arg$astNode2;
          context.reportError("The type of ".concat(type.name, ".").concat(field.name, "(").concat(argName, ":) must be Input ") + "Type but got: ".concat((0, _inspect.default)(arg.type), "."), (_arg$astNode2 = arg.astNode) === null || _arg$astNode2 === undefined ? undefined : _arg$astNode2.type);
        }
        if ((0, _definition.isRequiredArgument)(arg) && arg.deprecationReason != null) {
          var _arg$astNode3;
          context.reportError("Required argument ".concat(type.name, ".").concat(field.name, "(").concat(argName, ":) cannot be deprecated."), [
            getDeprecatedDirectiveNode(arg.astNode),
            (_arg$astNode3 = arg.astNode) === null || _arg$astNode3 === undefined ? undefined : _arg$astNode3.type
          ]);
        }
      }
    }
  }
  function validateInterfaces(context, type) {
    var ifaceTypeNames = Object.create(null);
    for (var _i14 = 0, _type$getInterfaces2 = type.getInterfaces();_i14 < _type$getInterfaces2.length; _i14++) {
      var iface = _type$getInterfaces2[_i14];
      if (!(0, _definition.isInterfaceType)(iface)) {
        context.reportError("Type ".concat((0, _inspect.default)(type), " must only implement Interface types, ") + "it cannot implement ".concat((0, _inspect.default)(iface), "."), getAllImplementsInterfaceNodes(type, iface));
        continue;
      }
      if (type === iface) {
        context.reportError("Type ".concat(type.name, " cannot implement itself because it would create a circular reference."), getAllImplementsInterfaceNodes(type, iface));
        continue;
      }
      if (ifaceTypeNames[iface.name]) {
        context.reportError("Type ".concat(type.name, " can only implement ").concat(iface.name, " once."), getAllImplementsInterfaceNodes(type, iface));
        continue;
      }
      ifaceTypeNames[iface.name] = true;
      validateTypeImplementsAncestors(context, type, iface);
      validateTypeImplementsInterface(context, type, iface);
    }
  }
  function validateTypeImplementsInterface(context, type, iface) {
    var typeFieldMap = type.getFields();
    for (var _i16 = 0, _objectValues4 = (0, _objectValues5.default)(iface.getFields());_i16 < _objectValues4.length; _i16++) {
      var ifaceField = _objectValues4[_i16];
      var fieldName = ifaceField.name;
      var typeField = typeFieldMap[fieldName];
      if (!typeField) {
        context.reportError("Interface field ".concat(iface.name, ".").concat(fieldName, " expected but ").concat(type.name, " does not provide it."), [ifaceField.astNode].concat(getAllNodes(type)));
        continue;
      }
      if (!(0, _typeComparators.isTypeSubTypeOf)(context.schema, typeField.type, ifaceField.type)) {
        var _ifaceField$astNode, _typeField$astNode;
        context.reportError("Interface field ".concat(iface.name, ".").concat(fieldName, " expects type ") + "".concat((0, _inspect.default)(ifaceField.type), " but ").concat(type.name, ".").concat(fieldName, " ") + "is type ".concat((0, _inspect.default)(typeField.type), "."), [
          (_ifaceField$astNode = ifaceField.astNode) === null || _ifaceField$astNode === undefined ? undefined : _ifaceField$astNode.type,
          (_typeField$astNode = typeField.astNode) === null || _typeField$astNode === undefined ? undefined : _typeField$astNode.type
        ]);
      }
      var _loop = function _loop(_i182, _ifaceField$args22) {
        var ifaceArg = _ifaceField$args22[_i182];
        var argName = ifaceArg.name;
        var typeArg = (0, _find.default)(typeField.args, function(arg) {
          return arg.name === argName;
        });
        if (!typeArg) {
          context.reportError("Interface field argument ".concat(iface.name, ".").concat(fieldName, "(").concat(argName, ":) expected but ").concat(type.name, ".").concat(fieldName, " does not provide it."), [ifaceArg.astNode, typeField.astNode]);
          return "continue";
        }
        if (!(0, _typeComparators.isEqualType)(ifaceArg.type, typeArg.type)) {
          var _ifaceArg$astNode, _typeArg$astNode;
          context.reportError("Interface field argument ".concat(iface.name, ".").concat(fieldName, "(").concat(argName, ":) ") + "expects type ".concat((0, _inspect.default)(ifaceArg.type), " but ") + "".concat(type.name, ".").concat(fieldName, "(").concat(argName, ":) is type ") + "".concat((0, _inspect.default)(typeArg.type), "."), [
            (_ifaceArg$astNode = ifaceArg.astNode) === null || _ifaceArg$astNode === undefined ? undefined : _ifaceArg$astNode.type,
            (_typeArg$astNode = typeArg.astNode) === null || _typeArg$astNode === undefined ? undefined : _typeArg$astNode.type
          ]);
        }
      };
      for (var _i18 = 0, _ifaceField$args2 = ifaceField.args;_i18 < _ifaceField$args2.length; _i18++) {
        var _ret = _loop(_i18, _ifaceField$args2);
        if (_ret === "continue")
          continue;
      }
      var _loop2 = function _loop2(_i202, _typeField$args22) {
        var typeArg = _typeField$args22[_i202];
        var argName = typeArg.name;
        var ifaceArg = (0, _find.default)(ifaceField.args, function(arg) {
          return arg.name === argName;
        });
        if (!ifaceArg && (0, _definition.isRequiredArgument)(typeArg)) {
          context.reportError("Object field ".concat(type.name, ".").concat(fieldName, " includes required argument ").concat(argName, " that is missing from the Interface field ").concat(iface.name, ".").concat(fieldName, "."), [typeArg.astNode, ifaceField.astNode]);
        }
      };
      for (var _i20 = 0, _typeField$args2 = typeField.args;_i20 < _typeField$args2.length; _i20++) {
        _loop2(_i20, _typeField$args2);
      }
    }
  }
  function validateTypeImplementsAncestors(context, type, iface) {
    var ifaceInterfaces = type.getInterfaces();
    for (var _i22 = 0, _iface$getInterfaces2 = iface.getInterfaces();_i22 < _iface$getInterfaces2.length; _i22++) {
      var transitive = _iface$getInterfaces2[_i22];
      if (ifaceInterfaces.indexOf(transitive) === -1) {
        context.reportError(transitive === type ? "Type ".concat(type.name, " cannot implement ").concat(iface.name, " because it would create a circular reference.") : "Type ".concat(type.name, " must implement ").concat(transitive.name, " because it is implemented by ").concat(iface.name, "."), [].concat(getAllImplementsInterfaceNodes(iface, transitive), getAllImplementsInterfaceNodes(type, iface)));
      }
    }
  }
  function validateUnionMembers(context, union) {
    var memberTypes = union.getTypes();
    if (memberTypes.length === 0) {
      context.reportError("Union type ".concat(union.name, " must define one or more member types."), getAllNodes(union));
    }
    var includedTypeNames = Object.create(null);
    for (var _i24 = 0;_i24 < memberTypes.length; _i24++) {
      var memberType = memberTypes[_i24];
      if (includedTypeNames[memberType.name]) {
        context.reportError("Union type ".concat(union.name, " can only include type ").concat(memberType.name, " once."), getUnionMemberTypeNodes(union, memberType.name));
        continue;
      }
      includedTypeNames[memberType.name] = true;
      if (!(0, _definition.isObjectType)(memberType)) {
        context.reportError("Union type ".concat(union.name, " can only include Object types, ") + "it cannot include ".concat((0, _inspect.default)(memberType), "."), getUnionMemberTypeNodes(union, String(memberType)));
      }
    }
  }
  function validateEnumValues(context, enumType) {
    var enumValues = enumType.getValues();
    if (enumValues.length === 0) {
      context.reportError("Enum type ".concat(enumType.name, " must define one or more values."), getAllNodes(enumType));
    }
    for (var _i26 = 0;_i26 < enumValues.length; _i26++) {
      var enumValue = enumValues[_i26];
      var valueName = enumValue.name;
      validateName(context, enumValue);
      if (valueName === "true" || valueName === "false" || valueName === "null") {
        context.reportError("Enum type ".concat(enumType.name, " cannot include value: ").concat(valueName, "."), enumValue.astNode);
      }
    }
  }
  function validateInputFields(context, inputObj) {
    var fields = (0, _objectValues5.default)(inputObj.getFields());
    if (fields.length === 0) {
      context.reportError("Input Object type ".concat(inputObj.name, " must define one or more fields."), getAllNodes(inputObj));
    }
    for (var _i28 = 0;_i28 < fields.length; _i28++) {
      var field = fields[_i28];
      validateName(context, field);
      if (!(0, _definition.isInputType)(field.type)) {
        var _field$astNode2;
        context.reportError("The type of ".concat(inputObj.name, ".").concat(field.name, " must be Input Type ") + "but got: ".concat((0, _inspect.default)(field.type), "."), (_field$astNode2 = field.astNode) === null || _field$astNode2 === undefined ? undefined : _field$astNode2.type);
      }
      if ((0, _definition.isRequiredInputField)(field) && field.deprecationReason != null) {
        var _field$astNode3;
        context.reportError("Required input field ".concat(inputObj.name, ".").concat(field.name, " cannot be deprecated."), [
          getDeprecatedDirectiveNode(field.astNode),
          (_field$astNode3 = field.astNode) === null || _field$astNode3 === undefined ? undefined : _field$astNode3.type
        ]);
      }
    }
  }
  function createInputObjectCircularRefsValidator(context) {
    var visitedTypes = Object.create(null);
    var fieldPath = [];
    var fieldPathIndexByTypeName = Object.create(null);
    return detectCycleRecursive;
    function detectCycleRecursive(inputObj) {
      if (visitedTypes[inputObj.name]) {
        return;
      }
      visitedTypes[inputObj.name] = true;
      fieldPathIndexByTypeName[inputObj.name] = fieldPath.length;
      var fields = (0, _objectValues5.default)(inputObj.getFields());
      for (var _i30 = 0;_i30 < fields.length; _i30++) {
        var field = fields[_i30];
        if ((0, _definition.isNonNullType)(field.type) && (0, _definition.isInputObjectType)(field.type.ofType)) {
          var fieldType = field.type.ofType;
          var cycleIndex = fieldPathIndexByTypeName[fieldType.name];
          fieldPath.push(field);
          if (cycleIndex === undefined) {
            detectCycleRecursive(fieldType);
          } else {
            var cyclePath = fieldPath.slice(cycleIndex);
            var pathStr = cyclePath.map(function(fieldObj) {
              return fieldObj.name;
            }).join(".");
            context.reportError('Cannot reference Input Object "'.concat(fieldType.name, '" within itself through a series of non-null fields: "').concat(pathStr, '".'), cyclePath.map(function(fieldObj) {
              return fieldObj.astNode;
            }));
          }
          fieldPath.pop();
        }
      }
      fieldPathIndexByTypeName[inputObj.name] = undefined;
    }
  }
  function getAllNodes(object) {
    var { astNode, extensionASTNodes } = object;
    return astNode ? extensionASTNodes ? [astNode].concat(extensionASTNodes) : [astNode] : extensionASTNodes !== null && extensionASTNodes !== undefined ? extensionASTNodes : [];
  }
  function getAllSubNodes(object, getter) {
    var subNodes = [];
    for (var _i32 = 0, _getAllNodes2 = getAllNodes(object);_i32 < _getAllNodes2.length; _i32++) {
      var _getter;
      var node = _getAllNodes2[_i32];
      subNodes = subNodes.concat((_getter = getter(node)) !== null && _getter !== undefined ? _getter : []);
    }
    return subNodes;
  }
  function getAllImplementsInterfaceNodes(type, iface) {
    return getAllSubNodes(type, function(typeNode) {
      return typeNode.interfaces;
    }).filter(function(ifaceNode) {
      return ifaceNode.name.value === iface.name;
    });
  }
  function getUnionMemberTypeNodes(union, typeName) {
    return getAllSubNodes(union, function(unionNode) {
      return unionNode.types;
    }).filter(function(typeNode) {
      return typeNode.name.value === typeName;
    });
  }
  function getDeprecatedDirectiveNode(definitionNode) {
    var _definitionNode$direc;
    return definitionNode === null || definitionNode === undefined ? undefined : (_definitionNode$direc = definitionNode.directives) === null || _definitionNode$direc === undefined ? undefined : _definitionNode$direc.find(function(node) {
      return node.name.value === _directives.GraphQLDeprecatedDirective.name;
    });
  }
});

// node_modules/graphql/utilities/typeFromAST.js
var require_typeFromAST = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.typeFromAST = typeFromAST;
  var _inspect = _interopRequireDefault(require_inspect());
  var _invariant = _interopRequireDefault(require_invariant());
  var _kinds = require_kinds();
  var _definition = require_definition();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function typeFromAST(schema, typeNode) {
    var innerType;
    if (typeNode.kind === _kinds.Kind.LIST_TYPE) {
      innerType = typeFromAST(schema, typeNode.type);
      return innerType && new _definition.GraphQLList(innerType);
    }
    if (typeNode.kind === _kinds.Kind.NON_NULL_TYPE) {
      innerType = typeFromAST(schema, typeNode.type);
      return innerType && new _definition.GraphQLNonNull(innerType);
    }
    if (typeNode.kind === _kinds.Kind.NAMED_TYPE) {
      return schema.getType(typeNode.name.value);
    }
    (0, _invariant.default)(0, "Unexpected type node: " + (0, _inspect.default)(typeNode));
  }
});

// node_modules/graphql/utilities/TypeInfo.js
var require_TypeInfo = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.visitWithTypeInfo = visitWithTypeInfo;
  exports.TypeInfo = undefined;
  var _find = _interopRequireDefault(require_find());
  var _kinds = require_kinds();
  var _ast = require_ast();
  var _visitor = require_visitor();
  var _definition = require_definition();
  var _introspection = require_introspection();
  var _typeFromAST = require_typeFromAST();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var TypeInfo = /* @__PURE__ */ function() {
    function TypeInfo2(schema, getFieldDefFn, initialType) {
      this._schema = schema;
      this._typeStack = [];
      this._parentTypeStack = [];
      this._inputTypeStack = [];
      this._fieldDefStack = [];
      this._defaultValueStack = [];
      this._directive = null;
      this._argument = null;
      this._enumValue = null;
      this._getFieldDef = getFieldDefFn !== null && getFieldDefFn !== undefined ? getFieldDefFn : getFieldDef;
      if (initialType) {
        if ((0, _definition.isInputType)(initialType)) {
          this._inputTypeStack.push(initialType);
        }
        if ((0, _definition.isCompositeType)(initialType)) {
          this._parentTypeStack.push(initialType);
        }
        if ((0, _definition.isOutputType)(initialType)) {
          this._typeStack.push(initialType);
        }
      }
    }
    var _proto = TypeInfo2.prototype;
    _proto.getType = function getType() {
      if (this._typeStack.length > 0) {
        return this._typeStack[this._typeStack.length - 1];
      }
    };
    _proto.getParentType = function getParentType() {
      if (this._parentTypeStack.length > 0) {
        return this._parentTypeStack[this._parentTypeStack.length - 1];
      }
    };
    _proto.getInputType = function getInputType() {
      if (this._inputTypeStack.length > 0) {
        return this._inputTypeStack[this._inputTypeStack.length - 1];
      }
    };
    _proto.getParentInputType = function getParentInputType() {
      if (this._inputTypeStack.length > 1) {
        return this._inputTypeStack[this._inputTypeStack.length - 2];
      }
    };
    _proto.getFieldDef = function getFieldDef() {
      if (this._fieldDefStack.length > 0) {
        return this._fieldDefStack[this._fieldDefStack.length - 1];
      }
    };
    _proto.getDefaultValue = function getDefaultValue() {
      if (this._defaultValueStack.length > 0) {
        return this._defaultValueStack[this._defaultValueStack.length - 1];
      }
    };
    _proto.getDirective = function getDirective() {
      return this._directive;
    };
    _proto.getArgument = function getArgument() {
      return this._argument;
    };
    _proto.getEnumValue = function getEnumValue() {
      return this._enumValue;
    };
    _proto.enter = function enter(node) {
      var schema = this._schema;
      switch (node.kind) {
        case _kinds.Kind.SELECTION_SET: {
          var namedType = (0, _definition.getNamedType)(this.getType());
          this._parentTypeStack.push((0, _definition.isCompositeType)(namedType) ? namedType : undefined);
          break;
        }
        case _kinds.Kind.FIELD: {
          var parentType = this.getParentType();
          var fieldDef;
          var fieldType;
          if (parentType) {
            fieldDef = this._getFieldDef(schema, parentType, node);
            if (fieldDef) {
              fieldType = fieldDef.type;
            }
          }
          this._fieldDefStack.push(fieldDef);
          this._typeStack.push((0, _definition.isOutputType)(fieldType) ? fieldType : undefined);
          break;
        }
        case _kinds.Kind.DIRECTIVE:
          this._directive = schema.getDirective(node.name.value);
          break;
        case _kinds.Kind.OPERATION_DEFINITION: {
          var type;
          switch (node.operation) {
            case "query":
              type = schema.getQueryType();
              break;
            case "mutation":
              type = schema.getMutationType();
              break;
            case "subscription":
              type = schema.getSubscriptionType();
              break;
          }
          this._typeStack.push((0, _definition.isObjectType)(type) ? type : undefined);
          break;
        }
        case _kinds.Kind.INLINE_FRAGMENT:
        case _kinds.Kind.FRAGMENT_DEFINITION: {
          var typeConditionAST = node.typeCondition;
          var outputType = typeConditionAST ? (0, _typeFromAST.typeFromAST)(schema, typeConditionAST) : (0, _definition.getNamedType)(this.getType());
          this._typeStack.push((0, _definition.isOutputType)(outputType) ? outputType : undefined);
          break;
        }
        case _kinds.Kind.VARIABLE_DEFINITION: {
          var inputType = (0, _typeFromAST.typeFromAST)(schema, node.type);
          this._inputTypeStack.push((0, _definition.isInputType)(inputType) ? inputType : undefined);
          break;
        }
        case _kinds.Kind.ARGUMENT: {
          var _this$getDirective;
          var argDef;
          var argType;
          var fieldOrDirective = (_this$getDirective = this.getDirective()) !== null && _this$getDirective !== undefined ? _this$getDirective : this.getFieldDef();
          if (fieldOrDirective) {
            argDef = (0, _find.default)(fieldOrDirective.args, function(arg) {
              return arg.name === node.name.value;
            });
            if (argDef) {
              argType = argDef.type;
            }
          }
          this._argument = argDef;
          this._defaultValueStack.push(argDef ? argDef.defaultValue : undefined);
          this._inputTypeStack.push((0, _definition.isInputType)(argType) ? argType : undefined);
          break;
        }
        case _kinds.Kind.LIST: {
          var listType = (0, _definition.getNullableType)(this.getInputType());
          var itemType = (0, _definition.isListType)(listType) ? listType.ofType : listType;
          this._defaultValueStack.push(undefined);
          this._inputTypeStack.push((0, _definition.isInputType)(itemType) ? itemType : undefined);
          break;
        }
        case _kinds.Kind.OBJECT_FIELD: {
          var objectType = (0, _definition.getNamedType)(this.getInputType());
          var inputFieldType;
          var inputField;
          if ((0, _definition.isInputObjectType)(objectType)) {
            inputField = objectType.getFields()[node.name.value];
            if (inputField) {
              inputFieldType = inputField.type;
            }
          }
          this._defaultValueStack.push(inputField ? inputField.defaultValue : undefined);
          this._inputTypeStack.push((0, _definition.isInputType)(inputFieldType) ? inputFieldType : undefined);
          break;
        }
        case _kinds.Kind.ENUM: {
          var enumType = (0, _definition.getNamedType)(this.getInputType());
          var enumValue;
          if ((0, _definition.isEnumType)(enumType)) {
            enumValue = enumType.getValue(node.value);
          }
          this._enumValue = enumValue;
          break;
        }
      }
    };
    _proto.leave = function leave(node) {
      switch (node.kind) {
        case _kinds.Kind.SELECTION_SET:
          this._parentTypeStack.pop();
          break;
        case _kinds.Kind.FIELD:
          this._fieldDefStack.pop();
          this._typeStack.pop();
          break;
        case _kinds.Kind.DIRECTIVE:
          this._directive = null;
          break;
        case _kinds.Kind.OPERATION_DEFINITION:
        case _kinds.Kind.INLINE_FRAGMENT:
        case _kinds.Kind.FRAGMENT_DEFINITION:
          this._typeStack.pop();
          break;
        case _kinds.Kind.VARIABLE_DEFINITION:
          this._inputTypeStack.pop();
          break;
        case _kinds.Kind.ARGUMENT:
          this._argument = null;
          this._defaultValueStack.pop();
          this._inputTypeStack.pop();
          break;
        case _kinds.Kind.LIST:
        case _kinds.Kind.OBJECT_FIELD:
          this._defaultValueStack.pop();
          this._inputTypeStack.pop();
          break;
        case _kinds.Kind.ENUM:
          this._enumValue = null;
          break;
      }
    };
    return TypeInfo2;
  }();
  exports.TypeInfo = TypeInfo;
  function getFieldDef(schema, parentType, fieldNode) {
    var name = fieldNode.name.value;
    if (name === _introspection.SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {
      return _introspection.SchemaMetaFieldDef;
    }
    if (name === _introspection.TypeMetaFieldDef.name && schema.getQueryType() === parentType) {
      return _introspection.TypeMetaFieldDef;
    }
    if (name === _introspection.TypeNameMetaFieldDef.name && (0, _definition.isCompositeType)(parentType)) {
      return _introspection.TypeNameMetaFieldDef;
    }
    if ((0, _definition.isObjectType)(parentType) || (0, _definition.isInterfaceType)(parentType)) {
      return parentType.getFields()[name];
    }
  }
  function visitWithTypeInfo(typeInfo, visitor) {
    return {
      enter: function enter(node) {
        typeInfo.enter(node);
        var fn2 = (0, _visitor.getVisitFn)(visitor, node.kind, false);
        if (fn2) {
          var result = fn2.apply(visitor, arguments);
          if (result !== undefined) {
            typeInfo.leave(node);
            if ((0, _ast.isNode)(result)) {
              typeInfo.enter(result);
            }
          }
          return result;
        }
      },
      leave: function leave(node) {
        var fn2 = (0, _visitor.getVisitFn)(visitor, node.kind, true);
        var result;
        if (fn2) {
          result = fn2.apply(visitor, arguments);
        }
        typeInfo.leave(node);
        return result;
      }
    };
  }
});

// node_modules/graphql/language/predicates.js
var require_predicates = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.isDefinitionNode = isDefinitionNode;
  exports.isExecutableDefinitionNode = isExecutableDefinitionNode;
  exports.isSelectionNode = isSelectionNode;
  exports.isValueNode = isValueNode;
  exports.isTypeNode = isTypeNode;
  exports.isTypeSystemDefinitionNode = isTypeSystemDefinitionNode;
  exports.isTypeDefinitionNode = isTypeDefinitionNode;
  exports.isTypeSystemExtensionNode = isTypeSystemExtensionNode;
  exports.isTypeExtensionNode = isTypeExtensionNode;
  var _kinds = require_kinds();
  function isDefinitionNode(node) {
    return isExecutableDefinitionNode(node) || isTypeSystemDefinitionNode(node) || isTypeSystemExtensionNode(node);
  }
  function isExecutableDefinitionNode(node) {
    return node.kind === _kinds.Kind.OPERATION_DEFINITION || node.kind === _kinds.Kind.FRAGMENT_DEFINITION;
  }
  function isSelectionNode(node) {
    return node.kind === _kinds.Kind.FIELD || node.kind === _kinds.Kind.FRAGMENT_SPREAD || node.kind === _kinds.Kind.INLINE_FRAGMENT;
  }
  function isValueNode(node) {
    return node.kind === _kinds.Kind.VARIABLE || node.kind === _kinds.Kind.INT || node.kind === _kinds.Kind.FLOAT || node.kind === _kinds.Kind.STRING || node.kind === _kinds.Kind.BOOLEAN || node.kind === _kinds.Kind.NULL || node.kind === _kinds.Kind.ENUM || node.kind === _kinds.Kind.LIST || node.kind === _kinds.Kind.OBJECT;
  }
  function isTypeNode(node) {
    return node.kind === _kinds.Kind.NAMED_TYPE || node.kind === _kinds.Kind.LIST_TYPE || node.kind === _kinds.Kind.NON_NULL_TYPE;
  }
  function isTypeSystemDefinitionNode(node) {
    return node.kind === _kinds.Kind.SCHEMA_DEFINITION || isTypeDefinitionNode(node) || node.kind === _kinds.Kind.DIRECTIVE_DEFINITION;
  }
  function isTypeDefinitionNode(node) {
    return node.kind === _kinds.Kind.SCALAR_TYPE_DEFINITION || node.kind === _kinds.Kind.OBJECT_TYPE_DEFINITION || node.kind === _kinds.Kind.INTERFACE_TYPE_DEFINITION || node.kind === _kinds.Kind.UNION_TYPE_DEFINITION || node.kind === _kinds.Kind.ENUM_TYPE_DEFINITION || node.kind === _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION;
  }
  function isTypeSystemExtensionNode(node) {
    return node.kind === _kinds.Kind.SCHEMA_EXTENSION || isTypeExtensionNode(node);
  }
  function isTypeExtensionNode(node) {
    return node.kind === _kinds.Kind.SCALAR_TYPE_EXTENSION || node.kind === _kinds.Kind.OBJECT_TYPE_EXTENSION || node.kind === _kinds.Kind.INTERFACE_TYPE_EXTENSION || node.kind === _kinds.Kind.UNION_TYPE_EXTENSION || node.kind === _kinds.Kind.ENUM_TYPE_EXTENSION || node.kind === _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION;
  }
});

// node_modules/graphql/validation/rules/ExecutableDefinitionsRule.js
var require_ExecutableDefinitionsRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ExecutableDefinitionsRule = ExecutableDefinitionsRule;
  var _GraphQLError = require_GraphQLError();
  var _kinds = require_kinds();
  var _predicates = require_predicates();
  function ExecutableDefinitionsRule(context) {
    return {
      Document: function Document(node) {
        for (var _i2 = 0, _node$definitions2 = node.definitions;_i2 < _node$definitions2.length; _i2++) {
          var definition = _node$definitions2[_i2];
          if (!(0, _predicates.isExecutableDefinitionNode)(definition)) {
            var defName = definition.kind === _kinds.Kind.SCHEMA_DEFINITION || definition.kind === _kinds.Kind.SCHEMA_EXTENSION ? "schema" : '"' + definition.name.value + '"';
            context.reportError(new _GraphQLError.GraphQLError("The ".concat(defName, " definition is not executable."), definition));
          }
        }
        return false;
      }
    };
  }
});

// node_modules/graphql/validation/rules/UniqueOperationNamesRule.js
var require_UniqueOperationNamesRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.UniqueOperationNamesRule = UniqueOperationNamesRule;
  var _GraphQLError = require_GraphQLError();
  function UniqueOperationNamesRule(context) {
    var knownOperationNames = Object.create(null);
    return {
      OperationDefinition: function OperationDefinition(node) {
        var operationName = node.name;
        if (operationName) {
          if (knownOperationNames[operationName.value]) {
            context.reportError(new _GraphQLError.GraphQLError('There can be only one operation named "'.concat(operationName.value, '".'), [knownOperationNames[operationName.value], operationName]));
          } else {
            knownOperationNames[operationName.value] = operationName;
          }
        }
        return false;
      },
      FragmentDefinition: function FragmentDefinition() {
        return false;
      }
    };
  }
});

// node_modules/graphql/validation/rules/LoneAnonymousOperationRule.js
var require_LoneAnonymousOperationRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.LoneAnonymousOperationRule = LoneAnonymousOperationRule;
  var _GraphQLError = require_GraphQLError();
  var _kinds = require_kinds();
  function LoneAnonymousOperationRule(context) {
    var operationCount = 0;
    return {
      Document: function Document(node) {
        operationCount = node.definitions.filter(function(definition) {
          return definition.kind === _kinds.Kind.OPERATION_DEFINITION;
        }).length;
      },
      OperationDefinition: function OperationDefinition(node) {
        if (!node.name && operationCount > 1) {
          context.reportError(new _GraphQLError.GraphQLError("This anonymous operation must be the only defined operation.", node));
        }
      }
    };
  }
});

// node_modules/graphql/validation/rules/SingleFieldSubscriptionsRule.js
var require_SingleFieldSubscriptionsRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.SingleFieldSubscriptionsRule = SingleFieldSubscriptionsRule;
  var _GraphQLError = require_GraphQLError();
  function SingleFieldSubscriptionsRule(context) {
    return {
      OperationDefinition: function OperationDefinition(node) {
        if (node.operation === "subscription") {
          if (node.selectionSet.selections.length !== 1) {
            context.reportError(new _GraphQLError.GraphQLError(node.name ? 'Subscription "'.concat(node.name.value, '" must select only one top level field.') : "Anonymous Subscription must select only one top level field.", node.selectionSet.selections.slice(1)));
          }
        }
      }
    };
  }
});

// node_modules/graphql/validation/rules/KnownTypeNamesRule.js
var require_KnownTypeNamesRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.KnownTypeNamesRule = KnownTypeNamesRule;
  var _didYouMean = _interopRequireDefault(require_didYouMean());
  var _suggestionList = _interopRequireDefault(require_suggestionList());
  var _GraphQLError = require_GraphQLError();
  var _predicates = require_predicates();
  var _scalars = require_scalars();
  var _introspection = require_introspection();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function KnownTypeNamesRule(context) {
    var schema = context.getSchema();
    var existingTypesMap = schema ? schema.getTypeMap() : Object.create(null);
    var definedTypes = Object.create(null);
    for (var _i2 = 0, _context$getDocument$2 = context.getDocument().definitions;_i2 < _context$getDocument$2.length; _i2++) {
      var def = _context$getDocument$2[_i2];
      if ((0, _predicates.isTypeDefinitionNode)(def)) {
        definedTypes[def.name.value] = true;
      }
    }
    var typeNames = Object.keys(existingTypesMap).concat(Object.keys(definedTypes));
    return {
      NamedType: function NamedType(node, _1, parent, _2, ancestors) {
        var typeName = node.name.value;
        if (!existingTypesMap[typeName] && !definedTypes[typeName]) {
          var _ancestors$;
          var definitionNode = (_ancestors$ = ancestors[2]) !== null && _ancestors$ !== undefined ? _ancestors$ : parent;
          var isSDL = definitionNode != null && isSDLNode(definitionNode);
          if (isSDL && isStandardTypeName(typeName)) {
            return;
          }
          var suggestedTypes = (0, _suggestionList.default)(typeName, isSDL ? standardTypeNames.concat(typeNames) : typeNames);
          context.reportError(new _GraphQLError.GraphQLError('Unknown type "'.concat(typeName, '".') + (0, _didYouMean.default)(suggestedTypes), node));
        }
      }
    };
  }
  var standardTypeNames = [].concat(_scalars.specifiedScalarTypes, _introspection.introspectionTypes).map(function(type) {
    return type.name;
  });
  function isStandardTypeName(typeName) {
    return standardTypeNames.indexOf(typeName) !== -1;
  }
  function isSDLNode(value) {
    return !Array.isArray(value) && ((0, _predicates.isTypeSystemDefinitionNode)(value) || (0, _predicates.isTypeSystemExtensionNode)(value));
  }
});

// node_modules/graphql/validation/rules/FragmentsOnCompositeTypesRule.js
var require_FragmentsOnCompositeTypesRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.FragmentsOnCompositeTypesRule = FragmentsOnCompositeTypesRule;
  var _GraphQLError = require_GraphQLError();
  var _printer = require_printer();
  var _definition = require_definition();
  var _typeFromAST = require_typeFromAST();
  function FragmentsOnCompositeTypesRule(context) {
    return {
      InlineFragment: function InlineFragment(node) {
        var typeCondition = node.typeCondition;
        if (typeCondition) {
          var type = (0, _typeFromAST.typeFromAST)(context.getSchema(), typeCondition);
          if (type && !(0, _definition.isCompositeType)(type)) {
            var typeStr = (0, _printer.print)(typeCondition);
            context.reportError(new _GraphQLError.GraphQLError('Fragment cannot condition on non composite type "'.concat(typeStr, '".'), typeCondition));
          }
        }
      },
      FragmentDefinition: function FragmentDefinition(node) {
        var type = (0, _typeFromAST.typeFromAST)(context.getSchema(), node.typeCondition);
        if (type && !(0, _definition.isCompositeType)(type)) {
          var typeStr = (0, _printer.print)(node.typeCondition);
          context.reportError(new _GraphQLError.GraphQLError('Fragment "'.concat(node.name.value, '" cannot condition on non composite type "').concat(typeStr, '".'), node.typeCondition));
        }
      }
    };
  }
});

// node_modules/graphql/validation/rules/VariablesAreInputTypesRule.js
var require_VariablesAreInputTypesRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.VariablesAreInputTypesRule = VariablesAreInputTypesRule;
  var _GraphQLError = require_GraphQLError();
  var _printer = require_printer();
  var _definition = require_definition();
  var _typeFromAST = require_typeFromAST();
  function VariablesAreInputTypesRule(context) {
    return {
      VariableDefinition: function VariableDefinition(node) {
        var type = (0, _typeFromAST.typeFromAST)(context.getSchema(), node.type);
        if (type && !(0, _definition.isInputType)(type)) {
          var variableName = node.variable.name.value;
          var typeName = (0, _printer.print)(node.type);
          context.reportError(new _GraphQLError.GraphQLError('Variable "$'.concat(variableName, '" cannot be non-input type "').concat(typeName, '".'), node.type));
        }
      }
    };
  }
});

// node_modules/graphql/validation/rules/ScalarLeafsRule.js
var require_ScalarLeafsRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ScalarLeafsRule = ScalarLeafsRule;
  var _inspect = _interopRequireDefault(require_inspect());
  var _GraphQLError = require_GraphQLError();
  var _definition = require_definition();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function ScalarLeafsRule(context) {
    return {
      Field: function Field(node) {
        var type = context.getType();
        var selectionSet = node.selectionSet;
        if (type) {
          if ((0, _definition.isLeafType)((0, _definition.getNamedType)(type))) {
            if (selectionSet) {
              var fieldName = node.name.value;
              var typeStr = (0, _inspect.default)(type);
              context.reportError(new _GraphQLError.GraphQLError('Field "'.concat(fieldName, '" must not have a selection since type "').concat(typeStr, '" has no subfields.'), selectionSet));
            }
          } else if (!selectionSet) {
            var _fieldName = node.name.value;
            var _typeStr = (0, _inspect.default)(type);
            context.reportError(new _GraphQLError.GraphQLError('Field "'.concat(_fieldName, '" of type "').concat(_typeStr, '" must have a selection of subfields. Did you mean "').concat(_fieldName, ' { ... }"?'), node));
          }
        }
      }
    };
  }
});

// node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.js
var require_FieldsOnCorrectTypeRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.FieldsOnCorrectTypeRule = FieldsOnCorrectTypeRule;
  var _arrayFrom = _interopRequireDefault(require_arrayFrom());
  var _didYouMean = _interopRequireDefault(require_didYouMean());
  var _suggestionList = _interopRequireDefault(require_suggestionList());
  var _naturalCompare = _interopRequireDefault(require_naturalCompare());
  var _GraphQLError = require_GraphQLError();
  var _definition = require_definition();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function FieldsOnCorrectTypeRule(context) {
    return {
      Field: function Field(node) {
        var type = context.getParentType();
        if (type) {
          var fieldDef = context.getFieldDef();
          if (!fieldDef) {
            var schema = context.getSchema();
            var fieldName = node.name.value;
            var suggestion = (0, _didYouMean.default)("to use an inline fragment on", getSuggestedTypeNames(schema, type, fieldName));
            if (suggestion === "") {
              suggestion = (0, _didYouMean.default)(getSuggestedFieldNames(type, fieldName));
            }
            context.reportError(new _GraphQLError.GraphQLError('Cannot query field "'.concat(fieldName, '" on type "').concat(type.name, '".') + suggestion, node));
          }
        }
      }
    };
  }
  function getSuggestedTypeNames(schema, type, fieldName) {
    if (!(0, _definition.isAbstractType)(type)) {
      return [];
    }
    var suggestedTypes = new Set;
    var usageCount = Object.create(null);
    for (var _i2 = 0, _schema$getPossibleTy2 = schema.getPossibleTypes(type);_i2 < _schema$getPossibleTy2.length; _i2++) {
      var possibleType = _schema$getPossibleTy2[_i2];
      if (!possibleType.getFields()[fieldName]) {
        continue;
      }
      suggestedTypes.add(possibleType);
      usageCount[possibleType.name] = 1;
      for (var _i4 = 0, _possibleType$getInte2 = possibleType.getInterfaces();_i4 < _possibleType$getInte2.length; _i4++) {
        var _usageCount$possibleI;
        var possibleInterface = _possibleType$getInte2[_i4];
        if (!possibleInterface.getFields()[fieldName]) {
          continue;
        }
        suggestedTypes.add(possibleInterface);
        usageCount[possibleInterface.name] = ((_usageCount$possibleI = usageCount[possibleInterface.name]) !== null && _usageCount$possibleI !== undefined ? _usageCount$possibleI : 0) + 1;
      }
    }
    return (0, _arrayFrom.default)(suggestedTypes).sort(function(typeA, typeB) {
      var usageCountDiff = usageCount[typeB.name] - usageCount[typeA.name];
      if (usageCountDiff !== 0) {
        return usageCountDiff;
      }
      if ((0, _definition.isInterfaceType)(typeA) && schema.isSubType(typeA, typeB)) {
        return -1;
      }
      if ((0, _definition.isInterfaceType)(typeB) && schema.isSubType(typeB, typeA)) {
        return 1;
      }
      return (0, _naturalCompare.default)(typeA.name, typeB.name);
    }).map(function(x) {
      return x.name;
    });
  }
  function getSuggestedFieldNames(type, fieldName) {
    if ((0, _definition.isObjectType)(type) || (0, _definition.isInterfaceType)(type)) {
      var possibleFieldNames = Object.keys(type.getFields());
      return (0, _suggestionList.default)(fieldName, possibleFieldNames);
    }
    return [];
  }
});

// node_modules/graphql/validation/rules/UniqueFragmentNamesRule.js
var require_UniqueFragmentNamesRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.UniqueFragmentNamesRule = UniqueFragmentNamesRule;
  var _GraphQLError = require_GraphQLError();
  function UniqueFragmentNamesRule(context) {
    var knownFragmentNames = Object.create(null);
    return {
      OperationDefinition: function OperationDefinition() {
        return false;
      },
      FragmentDefinition: function FragmentDefinition(node) {
        var fragmentName = node.name.value;
        if (knownFragmentNames[fragmentName]) {
          context.reportError(new _GraphQLError.GraphQLError('There can be only one fragment named "'.concat(fragmentName, '".'), [knownFragmentNames[fragmentName], node.name]));
        } else {
          knownFragmentNames[fragmentName] = node.name;
        }
        return false;
      }
    };
  }
});

// node_modules/graphql/validation/rules/KnownFragmentNamesRule.js
var require_KnownFragmentNamesRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.KnownFragmentNamesRule = KnownFragmentNamesRule;
  var _GraphQLError = require_GraphQLError();
  function KnownFragmentNamesRule(context) {
    return {
      FragmentSpread: function FragmentSpread(node) {
        var fragmentName = node.name.value;
        var fragment = context.getFragment(fragmentName);
        if (!fragment) {
          context.reportError(new _GraphQLError.GraphQLError('Unknown fragment "'.concat(fragmentName, '".'), node.name));
        }
      }
    };
  }
});

// node_modules/graphql/validation/rules/NoUnusedFragmentsRule.js
var require_NoUnusedFragmentsRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.NoUnusedFragmentsRule = NoUnusedFragmentsRule;
  var _GraphQLError = require_GraphQLError();
  function NoUnusedFragmentsRule(context) {
    var operationDefs = [];
    var fragmentDefs = [];
    return {
      OperationDefinition: function OperationDefinition(node) {
        operationDefs.push(node);
        return false;
      },
      FragmentDefinition: function FragmentDefinition(node) {
        fragmentDefs.push(node);
        return false;
      },
      Document: {
        leave: function leave() {
          var fragmentNameUsed = Object.create(null);
          for (var _i2 = 0;_i2 < operationDefs.length; _i2++) {
            var operation = operationDefs[_i2];
            for (var _i4 = 0, _context$getRecursive2 = context.getRecursivelyReferencedFragments(operation);_i4 < _context$getRecursive2.length; _i4++) {
              var fragment = _context$getRecursive2[_i4];
              fragmentNameUsed[fragment.name.value] = true;
            }
          }
          for (var _i6 = 0;_i6 < fragmentDefs.length; _i6++) {
            var fragmentDef = fragmentDefs[_i6];
            var fragName = fragmentDef.name.value;
            if (fragmentNameUsed[fragName] !== true) {
              context.reportError(new _GraphQLError.GraphQLError('Fragment "'.concat(fragName, '" is never used.'), fragmentDef));
            }
          }
        }
      }
    };
  }
});

// node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.js
var require_PossibleFragmentSpreadsRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.PossibleFragmentSpreadsRule = PossibleFragmentSpreadsRule;
  var _inspect = _interopRequireDefault(require_inspect());
  var _GraphQLError = require_GraphQLError();
  var _definition = require_definition();
  var _typeFromAST = require_typeFromAST();
  var _typeComparators = require_typeComparators();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function PossibleFragmentSpreadsRule(context) {
    return {
      InlineFragment: function InlineFragment(node) {
        var fragType = context.getType();
        var parentType = context.getParentType();
        if ((0, _definition.isCompositeType)(fragType) && (0, _definition.isCompositeType)(parentType) && !(0, _typeComparators.doTypesOverlap)(context.getSchema(), fragType, parentType)) {
          var parentTypeStr = (0, _inspect.default)(parentType);
          var fragTypeStr = (0, _inspect.default)(fragType);
          context.reportError(new _GraphQLError.GraphQLError('Fragment cannot be spread here as objects of type "'.concat(parentTypeStr, '" can never be of type "').concat(fragTypeStr, '".'), node));
        }
      },
      FragmentSpread: function FragmentSpread(node) {
        var fragName = node.name.value;
        var fragType = getFragmentType(context, fragName);
        var parentType = context.getParentType();
        if (fragType && parentType && !(0, _typeComparators.doTypesOverlap)(context.getSchema(), fragType, parentType)) {
          var parentTypeStr = (0, _inspect.default)(parentType);
          var fragTypeStr = (0, _inspect.default)(fragType);
          context.reportError(new _GraphQLError.GraphQLError('Fragment "'.concat(fragName, '" cannot be spread here as objects of type "').concat(parentTypeStr, '" can never be of type "').concat(fragTypeStr, '".'), node));
        }
      }
    };
  }
  function getFragmentType(context, name) {
    var frag = context.getFragment(name);
    if (frag) {
      var type = (0, _typeFromAST.typeFromAST)(context.getSchema(), frag.typeCondition);
      if ((0, _definition.isCompositeType)(type)) {
        return type;
      }
    }
  }
});

// node_modules/graphql/validation/rules/NoFragmentCyclesRule.js
var require_NoFragmentCyclesRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.NoFragmentCyclesRule = NoFragmentCyclesRule;
  var _GraphQLError = require_GraphQLError();
  function NoFragmentCyclesRule(context) {
    var visitedFrags = Object.create(null);
    var spreadPath = [];
    var spreadPathIndexByName = Object.create(null);
    return {
      OperationDefinition: function OperationDefinition() {
        return false;
      },
      FragmentDefinition: function FragmentDefinition(node) {
        detectCycleRecursive(node);
        return false;
      }
    };
    function detectCycleRecursive(fragment) {
      if (visitedFrags[fragment.name.value]) {
        return;
      }
      var fragmentName = fragment.name.value;
      visitedFrags[fragmentName] = true;
      var spreadNodes = context.getFragmentSpreads(fragment.selectionSet);
      if (spreadNodes.length === 0) {
        return;
      }
      spreadPathIndexByName[fragmentName] = spreadPath.length;
      for (var _i2 = 0;_i2 < spreadNodes.length; _i2++) {
        var spreadNode = spreadNodes[_i2];
        var spreadName = spreadNode.name.value;
        var cycleIndex = spreadPathIndexByName[spreadName];
        spreadPath.push(spreadNode);
        if (cycleIndex === undefined) {
          var spreadFragment = context.getFragment(spreadName);
          if (spreadFragment) {
            detectCycleRecursive(spreadFragment);
          }
        } else {
          var cyclePath = spreadPath.slice(cycleIndex);
          var viaPath = cyclePath.slice(0, -1).map(function(s) {
            return '"' + s.name.value + '"';
          }).join(", ");
          context.reportError(new _GraphQLError.GraphQLError('Cannot spread fragment "'.concat(spreadName, '" within itself') + (viaPath !== "" ? " via ".concat(viaPath, ".") : "."), cyclePath));
        }
        spreadPath.pop();
      }
      spreadPathIndexByName[fragmentName] = undefined;
    }
  }
});

// node_modules/graphql/validation/rules/UniqueVariableNamesRule.js
var require_UniqueVariableNamesRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.UniqueVariableNamesRule = UniqueVariableNamesRule;
  var _GraphQLError = require_GraphQLError();
  function UniqueVariableNamesRule(context) {
    var knownVariableNames = Object.create(null);
    return {
      OperationDefinition: function OperationDefinition() {
        knownVariableNames = Object.create(null);
      },
      VariableDefinition: function VariableDefinition(node) {
        var variableName = node.variable.name.value;
        if (knownVariableNames[variableName]) {
          context.reportError(new _GraphQLError.GraphQLError('There can be only one variable named "$'.concat(variableName, '".'), [knownVariableNames[variableName], node.variable.name]));
        } else {
          knownVariableNames[variableName] = node.variable.name;
        }
      }
    };
  }
});

// node_modules/graphql/validation/rules/NoUndefinedVariablesRule.js
var require_NoUndefinedVariablesRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.NoUndefinedVariablesRule = NoUndefinedVariablesRule;
  var _GraphQLError = require_GraphQLError();
  function NoUndefinedVariablesRule(context) {
    var variableNameDefined = Object.create(null);
    return {
      OperationDefinition: {
        enter: function enter() {
          variableNameDefined = Object.create(null);
        },
        leave: function leave(operation) {
          var usages = context.getRecursiveVariableUsages(operation);
          for (var _i2 = 0;_i2 < usages.length; _i2++) {
            var _ref2 = usages[_i2];
            var node = _ref2.node;
            var varName = node.name.value;
            if (variableNameDefined[varName] !== true) {
              context.reportError(new _GraphQLError.GraphQLError(operation.name ? 'Variable "$'.concat(varName, '" is not defined by operation "').concat(operation.name.value, '".') : 'Variable "$'.concat(varName, '" is not defined.'), [node, operation]));
            }
          }
        }
      },
      VariableDefinition: function VariableDefinition(node) {
        variableNameDefined[node.variable.name.value] = true;
      }
    };
  }
});

// node_modules/graphql/validation/rules/NoUnusedVariablesRule.js
var require_NoUnusedVariablesRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.NoUnusedVariablesRule = NoUnusedVariablesRule;
  var _GraphQLError = require_GraphQLError();
  function NoUnusedVariablesRule(context) {
    var variableDefs = [];
    return {
      OperationDefinition: {
        enter: function enter() {
          variableDefs = [];
        },
        leave: function leave(operation) {
          var variableNameUsed = Object.create(null);
          var usages = context.getRecursiveVariableUsages(operation);
          for (var _i2 = 0;_i2 < usages.length; _i2++) {
            var _ref2 = usages[_i2];
            var node = _ref2.node;
            variableNameUsed[node.name.value] = true;
          }
          for (var _i4 = 0, _variableDefs2 = variableDefs;_i4 < _variableDefs2.length; _i4++) {
            var variableDef = _variableDefs2[_i4];
            var variableName = variableDef.variable.name.value;
            if (variableNameUsed[variableName] !== true) {
              context.reportError(new _GraphQLError.GraphQLError(operation.name ? 'Variable "$'.concat(variableName, '" is never used in operation "').concat(operation.name.value, '".') : 'Variable "$'.concat(variableName, '" is never used.'), variableDef));
            }
          }
        }
      },
      VariableDefinition: function VariableDefinition(def) {
        variableDefs.push(def);
      }
    };
  }
});

// node_modules/graphql/validation/rules/KnownDirectivesRule.js
var require_KnownDirectivesRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.KnownDirectivesRule = KnownDirectivesRule;
  var _inspect = _interopRequireDefault(require_inspect());
  var _invariant = _interopRequireDefault(require_invariant());
  var _GraphQLError = require_GraphQLError();
  var _kinds = require_kinds();
  var _directiveLocation = require_directiveLocation();
  var _directives = require_directives();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function KnownDirectivesRule(context) {
    var locationsMap = Object.create(null);
    var schema = context.getSchema();
    var definedDirectives = schema ? schema.getDirectives() : _directives.specifiedDirectives;
    for (var _i2 = 0;_i2 < definedDirectives.length; _i2++) {
      var directive = definedDirectives[_i2];
      locationsMap[directive.name] = directive.locations;
    }
    var astDefinitions = context.getDocument().definitions;
    for (var _i4 = 0;_i4 < astDefinitions.length; _i4++) {
      var def = astDefinitions[_i4];
      if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
        locationsMap[def.name.value] = def.locations.map(function(name) {
          return name.value;
        });
      }
    }
    return {
      Directive: function Directive(node, _key, _parent, _path, ancestors) {
        var name = node.name.value;
        var locations = locationsMap[name];
        if (!locations) {
          context.reportError(new _GraphQLError.GraphQLError('Unknown directive "@'.concat(name, '".'), node));
          return;
        }
        var candidateLocation = getDirectiveLocationForASTPath(ancestors);
        if (candidateLocation && locations.indexOf(candidateLocation) === -1) {
          context.reportError(new _GraphQLError.GraphQLError('Directive "@'.concat(name, '" may not be used on ').concat(candidateLocation, "."), node));
        }
      }
    };
  }
  function getDirectiveLocationForASTPath(ancestors) {
    var appliedTo = ancestors[ancestors.length - 1];
    !Array.isArray(appliedTo) || (0, _invariant.default)(0);
    switch (appliedTo.kind) {
      case _kinds.Kind.OPERATION_DEFINITION:
        return getDirectiveLocationForOperation(appliedTo.operation);
      case _kinds.Kind.FIELD:
        return _directiveLocation.DirectiveLocation.FIELD;
      case _kinds.Kind.FRAGMENT_SPREAD:
        return _directiveLocation.DirectiveLocation.FRAGMENT_SPREAD;
      case _kinds.Kind.INLINE_FRAGMENT:
        return _directiveLocation.DirectiveLocation.INLINE_FRAGMENT;
      case _kinds.Kind.FRAGMENT_DEFINITION:
        return _directiveLocation.DirectiveLocation.FRAGMENT_DEFINITION;
      case _kinds.Kind.VARIABLE_DEFINITION:
        return _directiveLocation.DirectiveLocation.VARIABLE_DEFINITION;
      case _kinds.Kind.SCHEMA_DEFINITION:
      case _kinds.Kind.SCHEMA_EXTENSION:
        return _directiveLocation.DirectiveLocation.SCHEMA;
      case _kinds.Kind.SCALAR_TYPE_DEFINITION:
      case _kinds.Kind.SCALAR_TYPE_EXTENSION:
        return _directiveLocation.DirectiveLocation.SCALAR;
      case _kinds.Kind.OBJECT_TYPE_DEFINITION:
      case _kinds.Kind.OBJECT_TYPE_EXTENSION:
        return _directiveLocation.DirectiveLocation.OBJECT;
      case _kinds.Kind.FIELD_DEFINITION:
        return _directiveLocation.DirectiveLocation.FIELD_DEFINITION;
      case _kinds.Kind.INTERFACE_TYPE_DEFINITION:
      case _kinds.Kind.INTERFACE_TYPE_EXTENSION:
        return _directiveLocation.DirectiveLocation.INTERFACE;
      case _kinds.Kind.UNION_TYPE_DEFINITION:
      case _kinds.Kind.UNION_TYPE_EXTENSION:
        return _directiveLocation.DirectiveLocation.UNION;
      case _kinds.Kind.ENUM_TYPE_DEFINITION:
      case _kinds.Kind.ENUM_TYPE_EXTENSION:
        return _directiveLocation.DirectiveLocation.ENUM;
      case _kinds.Kind.ENUM_VALUE_DEFINITION:
        return _directiveLocation.DirectiveLocation.ENUM_VALUE;
      case _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION:
      case _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION:
        return _directiveLocation.DirectiveLocation.INPUT_OBJECT;
      case _kinds.Kind.INPUT_VALUE_DEFINITION: {
        var parentNode = ancestors[ancestors.length - 3];
        return parentNode.kind === _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION ? _directiveLocation.DirectiveLocation.INPUT_FIELD_DEFINITION : _directiveLocation.DirectiveLocation.ARGUMENT_DEFINITION;
      }
    }
  }
  function getDirectiveLocationForOperation(operation) {
    switch (operation) {
      case "query":
        return _directiveLocation.DirectiveLocation.QUERY;
      case "mutation":
        return _directiveLocation.DirectiveLocation.MUTATION;
      case "subscription":
        return _directiveLocation.DirectiveLocation.SUBSCRIPTION;
    }
    (0, _invariant.default)(0, "Unexpected operation: " + (0, _inspect.default)(operation));
  }
});

// node_modules/graphql/validation/rules/UniqueDirectivesPerLocationRule.js
var require_UniqueDirectivesPerLocationRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.UniqueDirectivesPerLocationRule = UniqueDirectivesPerLocationRule;
  var _GraphQLError = require_GraphQLError();
  var _kinds = require_kinds();
  var _predicates = require_predicates();
  var _directives = require_directives();
  function UniqueDirectivesPerLocationRule(context) {
    var uniqueDirectiveMap = Object.create(null);
    var schema = context.getSchema();
    var definedDirectives = schema ? schema.getDirectives() : _directives.specifiedDirectives;
    for (var _i2 = 0;_i2 < definedDirectives.length; _i2++) {
      var directive = definedDirectives[_i2];
      uniqueDirectiveMap[directive.name] = !directive.isRepeatable;
    }
    var astDefinitions = context.getDocument().definitions;
    for (var _i4 = 0;_i4 < astDefinitions.length; _i4++) {
      var def = astDefinitions[_i4];
      if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
        uniqueDirectiveMap[def.name.value] = !def.repeatable;
      }
    }
    var schemaDirectives = Object.create(null);
    var typeDirectivesMap = Object.create(null);
    return {
      enter: function enter(node) {
        if (node.directives == null) {
          return;
        }
        var seenDirectives;
        if (node.kind === _kinds.Kind.SCHEMA_DEFINITION || node.kind === _kinds.Kind.SCHEMA_EXTENSION) {
          seenDirectives = schemaDirectives;
        } else if ((0, _predicates.isTypeDefinitionNode)(node) || (0, _predicates.isTypeExtensionNode)(node)) {
          var typeName = node.name.value;
          seenDirectives = typeDirectivesMap[typeName];
          if (seenDirectives === undefined) {
            typeDirectivesMap[typeName] = seenDirectives = Object.create(null);
          }
        } else {
          seenDirectives = Object.create(null);
        }
        for (var _i6 = 0, _node$directives2 = node.directives;_i6 < _node$directives2.length; _i6++) {
          var _directive = _node$directives2[_i6];
          var directiveName = _directive.name.value;
          if (uniqueDirectiveMap[directiveName]) {
            if (seenDirectives[directiveName]) {
              context.reportError(new _GraphQLError.GraphQLError('The directive "@'.concat(directiveName, '" can only be used once at this location.'), [seenDirectives[directiveName], _directive]));
            } else {
              seenDirectives[directiveName] = _directive;
            }
          }
        }
      }
    };
  }
});

// node_modules/graphql/validation/rules/KnownArgumentNamesRule.js
var require_KnownArgumentNamesRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.KnownArgumentNamesRule = KnownArgumentNamesRule;
  exports.KnownArgumentNamesOnDirectivesRule = KnownArgumentNamesOnDirectivesRule;
  var _didYouMean = _interopRequireDefault(require_didYouMean());
  var _suggestionList = _interopRequireDefault(require_suggestionList());
  var _GraphQLError = require_GraphQLError();
  var _kinds = require_kinds();
  var _directives = require_directives();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread(target) {
    for (var i = 1;i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function KnownArgumentNamesRule(context) {
    return _objectSpread(_objectSpread({}, KnownArgumentNamesOnDirectivesRule(context)), {}, {
      Argument: function Argument(argNode) {
        var argDef = context.getArgument();
        var fieldDef = context.getFieldDef();
        var parentType = context.getParentType();
        if (!argDef && fieldDef && parentType) {
          var argName = argNode.name.value;
          var knownArgsNames = fieldDef.args.map(function(arg) {
            return arg.name;
          });
          var suggestions = (0, _suggestionList.default)(argName, knownArgsNames);
          context.reportError(new _GraphQLError.GraphQLError('Unknown argument "'.concat(argName, '" on field "').concat(parentType.name, ".").concat(fieldDef.name, '".') + (0, _didYouMean.default)(suggestions), argNode));
        }
      }
    });
  }
  function KnownArgumentNamesOnDirectivesRule(context) {
    var directiveArgs = Object.create(null);
    var schema = context.getSchema();
    var definedDirectives = schema ? schema.getDirectives() : _directives.specifiedDirectives;
    for (var _i2 = 0;_i2 < definedDirectives.length; _i2++) {
      var directive = definedDirectives[_i2];
      directiveArgs[directive.name] = directive.args.map(function(arg) {
        return arg.name;
      });
    }
    var astDefinitions = context.getDocument().definitions;
    for (var _i4 = 0;_i4 < astDefinitions.length; _i4++) {
      var def = astDefinitions[_i4];
      if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
        var _def$arguments;
        var argsNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== undefined ? _def$arguments : [];
        directiveArgs[def.name.value] = argsNodes.map(function(arg) {
          return arg.name.value;
        });
      }
    }
    return {
      Directive: function Directive(directiveNode) {
        var directiveName = directiveNode.name.value;
        var knownArgs = directiveArgs[directiveName];
        if (directiveNode.arguments && knownArgs) {
          for (var _i6 = 0, _directiveNode$argume2 = directiveNode.arguments;_i6 < _directiveNode$argume2.length; _i6++) {
            var argNode = _directiveNode$argume2[_i6];
            var argName = argNode.name.value;
            if (knownArgs.indexOf(argName) === -1) {
              var suggestions = (0, _suggestionList.default)(argName, knownArgs);
              context.reportError(new _GraphQLError.GraphQLError('Unknown argument "'.concat(argName, '" on directive "@').concat(directiveName, '".') + (0, _didYouMean.default)(suggestions), argNode));
            }
          }
        }
        return false;
      }
    };
  }
});

// node_modules/graphql/validation/rules/UniqueArgumentNamesRule.js
var require_UniqueArgumentNamesRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.UniqueArgumentNamesRule = UniqueArgumentNamesRule;
  var _GraphQLError = require_GraphQLError();
  function UniqueArgumentNamesRule(context) {
    var knownArgNames = Object.create(null);
    return {
      Field: function Field() {
        knownArgNames = Object.create(null);
      },
      Directive: function Directive() {
        knownArgNames = Object.create(null);
      },
      Argument: function Argument(node) {
        var argName = node.name.value;
        if (knownArgNames[argName]) {
          context.reportError(new _GraphQLError.GraphQLError('There can be only one argument named "'.concat(argName, '".'), [knownArgNames[argName], node.name]));
        } else {
          knownArgNames[argName] = node.name;
        }
        return false;
      }
    };
  }
});

// node_modules/graphql/validation/rules/ValuesOfCorrectTypeRule.js
var require_ValuesOfCorrectTypeRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ValuesOfCorrectTypeRule = ValuesOfCorrectTypeRule;
  var _objectValues3 = _interopRequireDefault(require_objectValues());
  var _keyMap = _interopRequireDefault(require_keyMap());
  var _inspect = _interopRequireDefault(require_inspect());
  var _didYouMean = _interopRequireDefault(require_didYouMean());
  var _suggestionList = _interopRequireDefault(require_suggestionList());
  var _GraphQLError = require_GraphQLError();
  var _printer = require_printer();
  var _definition = require_definition();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function ValuesOfCorrectTypeRule(context) {
    return {
      ListValue: function ListValue(node) {
        var type = (0, _definition.getNullableType)(context.getParentInputType());
        if (!(0, _definition.isListType)(type)) {
          isValidValueNode(context, node);
          return false;
        }
      },
      ObjectValue: function ObjectValue(node) {
        var type = (0, _definition.getNamedType)(context.getInputType());
        if (!(0, _definition.isInputObjectType)(type)) {
          isValidValueNode(context, node);
          return false;
        }
        var fieldNodeMap = (0, _keyMap.default)(node.fields, function(field) {
          return field.name.value;
        });
        for (var _i2 = 0, _objectValues2 = (0, _objectValues3.default)(type.getFields());_i2 < _objectValues2.length; _i2++) {
          var fieldDef = _objectValues2[_i2];
          var fieldNode = fieldNodeMap[fieldDef.name];
          if (!fieldNode && (0, _definition.isRequiredInputField)(fieldDef)) {
            var typeStr = (0, _inspect.default)(fieldDef.type);
            context.reportError(new _GraphQLError.GraphQLError('Field "'.concat(type.name, ".").concat(fieldDef.name, '" of required type "').concat(typeStr, '" was not provided.'), node));
          }
        }
      },
      ObjectField: function ObjectField(node) {
        var parentType = (0, _definition.getNamedType)(context.getParentInputType());
        var fieldType = context.getInputType();
        if (!fieldType && (0, _definition.isInputObjectType)(parentType)) {
          var suggestions = (0, _suggestionList.default)(node.name.value, Object.keys(parentType.getFields()));
          context.reportError(new _GraphQLError.GraphQLError('Field "'.concat(node.name.value, '" is not defined by type "').concat(parentType.name, '".') + (0, _didYouMean.default)(suggestions), node));
        }
      },
      NullValue: function NullValue(node) {
        var type = context.getInputType();
        if ((0, _definition.isNonNullType)(type)) {
          context.reportError(new _GraphQLError.GraphQLError('Expected value of type "'.concat((0, _inspect.default)(type), '", found ').concat((0, _printer.print)(node), "."), node));
        }
      },
      EnumValue: function EnumValue(node) {
        return isValidValueNode(context, node);
      },
      IntValue: function IntValue(node) {
        return isValidValueNode(context, node);
      },
      FloatValue: function FloatValue(node) {
        return isValidValueNode(context, node);
      },
      StringValue: function StringValue(node) {
        return isValidValueNode(context, node);
      },
      BooleanValue: function BooleanValue(node) {
        return isValidValueNode(context, node);
      }
    };
  }
  function isValidValueNode(context, node) {
    var locationType = context.getInputType();
    if (!locationType) {
      return;
    }
    var type = (0, _definition.getNamedType)(locationType);
    if (!(0, _definition.isLeafType)(type)) {
      var typeStr = (0, _inspect.default)(locationType);
      context.reportError(new _GraphQLError.GraphQLError('Expected value of type "'.concat(typeStr, '", found ').concat((0, _printer.print)(node), "."), node));
      return;
    }
    try {
      var parseResult = type.parseLiteral(node, undefined);
      if (parseResult === undefined) {
        var _typeStr = (0, _inspect.default)(locationType);
        context.reportError(new _GraphQLError.GraphQLError('Expected value of type "'.concat(_typeStr, '", found ').concat((0, _printer.print)(node), "."), node));
      }
    } catch (error) {
      var _typeStr2 = (0, _inspect.default)(locationType);
      if (error instanceof _GraphQLError.GraphQLError) {
        context.reportError(error);
      } else {
        context.reportError(new _GraphQLError.GraphQLError('Expected value of type "'.concat(_typeStr2, '", found ').concat((0, _printer.print)(node), "; ") + error.message, node, undefined, undefined, undefined, error));
      }
    }
  }
});

// node_modules/graphql/validation/rules/ProvidedRequiredArgumentsRule.js
var require_ProvidedRequiredArgumentsRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ProvidedRequiredArgumentsRule = ProvidedRequiredArgumentsRule;
  exports.ProvidedRequiredArgumentsOnDirectivesRule = ProvidedRequiredArgumentsOnDirectivesRule;
  var _inspect = _interopRequireDefault(require_inspect());
  var _keyMap = _interopRequireDefault(require_keyMap());
  var _GraphQLError = require_GraphQLError();
  var _kinds = require_kinds();
  var _printer = require_printer();
  var _directives = require_directives();
  var _definition = require_definition();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread(target) {
    for (var i = 1;i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function ProvidedRequiredArgumentsRule(context) {
    return _objectSpread(_objectSpread({}, ProvidedRequiredArgumentsOnDirectivesRule(context)), {}, {
      Field: {
        leave: function leave(fieldNode) {
          var _fieldNode$arguments;
          var fieldDef = context.getFieldDef();
          if (!fieldDef) {
            return false;
          }
          var argNodes = (_fieldNode$arguments = fieldNode.arguments) !== null && _fieldNode$arguments !== undefined ? _fieldNode$arguments : [];
          var argNodeMap = (0, _keyMap.default)(argNodes, function(arg) {
            return arg.name.value;
          });
          for (var _i2 = 0, _fieldDef$args2 = fieldDef.args;_i2 < _fieldDef$args2.length; _i2++) {
            var argDef = _fieldDef$args2[_i2];
            var argNode = argNodeMap[argDef.name];
            if (!argNode && (0, _definition.isRequiredArgument)(argDef)) {
              var argTypeStr = (0, _inspect.default)(argDef.type);
              context.reportError(new _GraphQLError.GraphQLError('Field "'.concat(fieldDef.name, '" argument "').concat(argDef.name, '" of type "').concat(argTypeStr, '" is required, but it was not provided.'), fieldNode));
            }
          }
        }
      }
    });
  }
  function ProvidedRequiredArgumentsOnDirectivesRule(context) {
    var requiredArgsMap = Object.create(null);
    var schema = context.getSchema();
    var definedDirectives = schema ? schema.getDirectives() : _directives.specifiedDirectives;
    for (var _i4 = 0;_i4 < definedDirectives.length; _i4++) {
      var directive = definedDirectives[_i4];
      requiredArgsMap[directive.name] = (0, _keyMap.default)(directive.args.filter(_definition.isRequiredArgument), function(arg) {
        return arg.name;
      });
    }
    var astDefinitions = context.getDocument().definitions;
    for (var _i6 = 0;_i6 < astDefinitions.length; _i6++) {
      var def = astDefinitions[_i6];
      if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
        var _def$arguments;
        var argNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== undefined ? _def$arguments : [];
        requiredArgsMap[def.name.value] = (0, _keyMap.default)(argNodes.filter(isRequiredArgumentNode), function(arg) {
          return arg.name.value;
        });
      }
    }
    return {
      Directive: {
        leave: function leave(directiveNode) {
          var directiveName = directiveNode.name.value;
          var requiredArgs = requiredArgsMap[directiveName];
          if (requiredArgs) {
            var _directiveNode$argume;
            var _argNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== undefined ? _directiveNode$argume : [];
            var argNodeMap = (0, _keyMap.default)(_argNodes, function(arg) {
              return arg.name.value;
            });
            for (var _i8 = 0, _Object$keys2 = Object.keys(requiredArgs);_i8 < _Object$keys2.length; _i8++) {
              var argName = _Object$keys2[_i8];
              if (!argNodeMap[argName]) {
                var argType = requiredArgs[argName].type;
                var argTypeStr = (0, _definition.isType)(argType) ? (0, _inspect.default)(argType) : (0, _printer.print)(argType);
                context.reportError(new _GraphQLError.GraphQLError('Directive "@'.concat(directiveName, '" argument "').concat(argName, '" of type "').concat(argTypeStr, '" is required, but it was not provided.'), directiveNode));
              }
            }
          }
        }
      }
    };
  }
  function isRequiredArgumentNode(arg) {
    return arg.type.kind === _kinds.Kind.NON_NULL_TYPE && arg.defaultValue == null;
  }
});

// node_modules/graphql/validation/rules/VariablesInAllowedPositionRule.js
var require_VariablesInAllowedPositionRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.VariablesInAllowedPositionRule = VariablesInAllowedPositionRule;
  var _inspect = _interopRequireDefault(require_inspect());
  var _GraphQLError = require_GraphQLError();
  var _kinds = require_kinds();
  var _definition = require_definition();
  var _typeFromAST = require_typeFromAST();
  var _typeComparators = require_typeComparators();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function VariablesInAllowedPositionRule(context) {
    var varDefMap = Object.create(null);
    return {
      OperationDefinition: {
        enter: function enter() {
          varDefMap = Object.create(null);
        },
        leave: function leave(operation) {
          var usages = context.getRecursiveVariableUsages(operation);
          for (var _i2 = 0;_i2 < usages.length; _i2++) {
            var _ref2 = usages[_i2];
            var node = _ref2.node;
            var type = _ref2.type;
            var defaultValue = _ref2.defaultValue;
            var varName = node.name.value;
            var varDef = varDefMap[varName];
            if (varDef && type) {
              var schema = context.getSchema();
              var varType = (0, _typeFromAST.typeFromAST)(schema, varDef.type);
              if (varType && !allowedVariableUsage(schema, varType, varDef.defaultValue, type, defaultValue)) {
                var varTypeStr = (0, _inspect.default)(varType);
                var typeStr = (0, _inspect.default)(type);
                context.reportError(new _GraphQLError.GraphQLError('Variable "$'.concat(varName, '" of type "').concat(varTypeStr, '" used in position expecting type "').concat(typeStr, '".'), [varDef, node]));
              }
            }
          }
        }
      },
      VariableDefinition: function VariableDefinition(node) {
        varDefMap[node.variable.name.value] = node;
      }
    };
  }
  function allowedVariableUsage(schema, varType, varDefaultValue, locationType, locationDefaultValue) {
    if ((0, _definition.isNonNullType)(locationType) && !(0, _definition.isNonNullType)(varType)) {
      var hasNonNullVariableDefaultValue = varDefaultValue != null && varDefaultValue.kind !== _kinds.Kind.NULL;
      var hasLocationDefaultValue = locationDefaultValue !== undefined;
      if (!hasNonNullVariableDefaultValue && !hasLocationDefaultValue) {
        return false;
      }
      var nullableLocationType = locationType.ofType;
      return (0, _typeComparators.isTypeSubTypeOf)(schema, varType, nullableLocationType);
    }
    return (0, _typeComparators.isTypeSubTypeOf)(schema, varType, locationType);
  }
});

// node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.js
var require_OverlappingFieldsCanBeMergedRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.OverlappingFieldsCanBeMergedRule = OverlappingFieldsCanBeMergedRule;
  var _find = _interopRequireDefault(require_find());
  var _objectEntries3 = _interopRequireDefault(require_objectEntries());
  var _inspect = _interopRequireDefault(require_inspect());
  var _GraphQLError = require_GraphQLError();
  var _kinds = require_kinds();
  var _printer = require_printer();
  var _definition = require_definition();
  var _typeFromAST = require_typeFromAST();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function reasonMessage(reason) {
    if (Array.isArray(reason)) {
      return reason.map(function(_ref) {
        var responseName = _ref[0], subReason = _ref[1];
        return 'subfields "'.concat(responseName, '" conflict because ') + reasonMessage(subReason);
      }).join(" and ");
    }
    return reason;
  }
  function OverlappingFieldsCanBeMergedRule(context) {
    var comparedFragmentPairs = new PairSet;
    var cachedFieldsAndFragmentNames = new Map;
    return {
      SelectionSet: function SelectionSet(selectionSet) {
        var conflicts = findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, context.getParentType(), selectionSet);
        for (var _i2 = 0;_i2 < conflicts.length; _i2++) {
          var _ref3 = conflicts[_i2];
          var _ref2$ = _ref3[0];
          var responseName = _ref2$[0];
          var reason = _ref2$[1];
          var fields1 = _ref3[1];
          var fields2 = _ref3[2];
          var reasonMsg = reasonMessage(reason);
          context.reportError(new _GraphQLError.GraphQLError('Fields "'.concat(responseName, '" conflict because ').concat(reasonMsg, ". Use different aliases on the fields to fetch both if this was intentional."), fields1.concat(fields2)));
        }
      }
    };
  }
  function findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentType, selectionSet) {
    var conflicts = [];
    var _getFieldsAndFragment = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet), fieldMap = _getFieldsAndFragment[0], fragmentNames = _getFieldsAndFragment[1];
    collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap);
    if (fragmentNames.length !== 0) {
      for (var i = 0;i < fragmentNames.length; i++) {
        collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, fieldMap, fragmentNames[i]);
        for (var j = i + 1;j < fragmentNames.length; j++) {
          collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, fragmentNames[i], fragmentNames[j]);
        }
      }
    }
    return conflicts;
  }
  function collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentName) {
    var fragment = context.getFragment(fragmentName);
    if (!fragment) {
      return;
    }
    var _getReferencedFieldsA = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment), fieldMap2 = _getReferencedFieldsA[0], fragmentNames2 = _getReferencedFieldsA[1];
    if (fieldMap === fieldMap2) {
      return;
    }
    collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fieldMap2);
    for (var i = 0;i < fragmentNames2.length; i++) {
      var referencedFragmentName = fragmentNames2[i];
      if (comparedFragmentPairs.has(referencedFragmentName, fragmentName, areMutuallyExclusive)) {
        continue;
      }
      comparedFragmentPairs.add(referencedFragmentName, fragmentName, areMutuallyExclusive);
      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentNames2[i]);
    }
  }
  function collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2) {
    if (fragmentName1 === fragmentName2) {
      return;
    }
    if (comparedFragmentPairs.has(fragmentName1, fragmentName2, areMutuallyExclusive)) {
      return;
    }
    comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);
    var fragment1 = context.getFragment(fragmentName1);
    var fragment2 = context.getFragment(fragmentName2);
    if (!fragment1 || !fragment2) {
      return;
    }
    var _getReferencedFieldsA2 = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment1), fieldMap1 = _getReferencedFieldsA2[0], fragmentNames1 = _getReferencedFieldsA2[1];
    var _getReferencedFieldsA3 = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment2), fieldMap2 = _getReferencedFieldsA3[0], fragmentNames2 = _getReferencedFieldsA3[1];
    collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2);
    for (var j = 0;j < fragmentNames2.length; j++) {
      collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentNames2[j]);
    }
    for (var i = 0;i < fragmentNames1.length; i++) {
      collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentNames1[i], fragmentName2);
    }
  }
  function findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, parentType1, selectionSet1, parentType2, selectionSet2) {
    var conflicts = [];
    var _getFieldsAndFragment2 = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType1, selectionSet1), fieldMap1 = _getFieldsAndFragment2[0], fragmentNames1 = _getFieldsAndFragment2[1];
    var _getFieldsAndFragment3 = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType2, selectionSet2), fieldMap2 = _getFieldsAndFragment3[0], fragmentNames2 = _getFieldsAndFragment3[1];
    collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2);
    if (fragmentNames2.length !== 0) {
      for (var j = 0;j < fragmentNames2.length; j++) {
        collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fragmentNames2[j]);
      }
    }
    if (fragmentNames1.length !== 0) {
      for (var i = 0;i < fragmentNames1.length; i++) {
        collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap2, fragmentNames1[i]);
      }
    }
    for (var _i3 = 0;_i3 < fragmentNames1.length; _i3++) {
      for (var _j = 0;_j < fragmentNames2.length; _j++) {
        collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentNames1[_i3], fragmentNames2[_j]);
      }
    }
    return conflicts;
  }
  function collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap) {
    for (var _i5 = 0, _objectEntries2 = (0, _objectEntries3.default)(fieldMap);_i5 < _objectEntries2.length; _i5++) {
      var _ref5 = _objectEntries2[_i5];
      var responseName = _ref5[0];
      var fields = _ref5[1];
      if (fields.length > 1) {
        for (var i = 0;i < fields.length; i++) {
          for (var j = i + 1;j < fields.length; j++) {
            var conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, responseName, fields[i], fields[j]);
            if (conflict) {
              conflicts.push(conflict);
            }
          }
        }
      }
    }
  }
  function collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, fieldMap1, fieldMap2) {
    for (var _i7 = 0, _Object$keys2 = Object.keys(fieldMap1);_i7 < _Object$keys2.length; _i7++) {
      var responseName = _Object$keys2[_i7];
      var fields2 = fieldMap2[responseName];
      if (fields2) {
        var fields1 = fieldMap1[responseName];
        for (var i = 0;i < fields1.length; i++) {
          for (var j = 0;j < fields2.length; j++) {
            var conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, fields1[i], fields2[j]);
            if (conflict) {
              conflicts.push(conflict);
            }
          }
        }
      }
    }
  }
  function findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2) {
    var parentType1 = field1[0], node1 = field1[1], def1 = field1[2];
    var parentType2 = field2[0], node2 = field2[1], def2 = field2[2];
    var areMutuallyExclusive = parentFieldsAreMutuallyExclusive || parentType1 !== parentType2 && (0, _definition.isObjectType)(parentType1) && (0, _definition.isObjectType)(parentType2);
    if (!areMutuallyExclusive) {
      var _node1$arguments, _node2$arguments;
      var name1 = node1.name.value;
      var name2 = node2.name.value;
      if (name1 !== name2) {
        return [[responseName, '"'.concat(name1, '" and "').concat(name2, '" are different fields')], [node1], [node2]];
      }
      var args1 = (_node1$arguments = node1.arguments) !== null && _node1$arguments !== undefined ? _node1$arguments : [];
      var args2 = (_node2$arguments = node2.arguments) !== null && _node2$arguments !== undefined ? _node2$arguments : [];
      if (!sameArguments(args1, args2)) {
        return [[responseName, "they have differing arguments"], [node1], [node2]];
      }
    }
    var type1 = def1 === null || def1 === undefined ? undefined : def1.type;
    var type2 = def2 === null || def2 === undefined ? undefined : def2.type;
    if (type1 && type2 && doTypesConflict(type1, type2)) {
      return [[responseName, 'they return conflicting types "'.concat((0, _inspect.default)(type1), '" and "').concat((0, _inspect.default)(type2), '"')], [node1], [node2]];
    }
    var selectionSet1 = node1.selectionSet;
    var selectionSet2 = node2.selectionSet;
    if (selectionSet1 && selectionSet2) {
      var conflicts = findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, (0, _definition.getNamedType)(type1), selectionSet1, (0, _definition.getNamedType)(type2), selectionSet2);
      return subfieldConflicts(conflicts, responseName, node1, node2);
    }
  }
  function sameArguments(arguments1, arguments2) {
    if (arguments1.length !== arguments2.length) {
      return false;
    }
    return arguments1.every(function(argument1) {
      var argument2 = (0, _find.default)(arguments2, function(argument) {
        return argument.name.value === argument1.name.value;
      });
      if (!argument2) {
        return false;
      }
      return sameValue(argument1.value, argument2.value);
    });
  }
  function sameValue(value1, value2) {
    return (0, _printer.print)(value1) === (0, _printer.print)(value2);
  }
  function doTypesConflict(type1, type2) {
    if ((0, _definition.isListType)(type1)) {
      return (0, _definition.isListType)(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
    }
    if ((0, _definition.isListType)(type2)) {
      return true;
    }
    if ((0, _definition.isNonNullType)(type1)) {
      return (0, _definition.isNonNullType)(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
    }
    if ((0, _definition.isNonNullType)(type2)) {
      return true;
    }
    if ((0, _definition.isLeafType)(type1) || (0, _definition.isLeafType)(type2)) {
      return type1 !== type2;
    }
    return false;
  }
  function getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet) {
    var cached = cachedFieldsAndFragmentNames.get(selectionSet);
    if (!cached) {
      var nodeAndDefs = Object.create(null);
      var fragmentNames = Object.create(null);
      _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames);
      cached = [nodeAndDefs, Object.keys(fragmentNames)];
      cachedFieldsAndFragmentNames.set(selectionSet, cached);
    }
    return cached;
  }
  function getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment) {
    var cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);
    if (cached) {
      return cached;
    }
    var fragmentType = (0, _typeFromAST.typeFromAST)(context.getSchema(), fragment.typeCondition);
    return getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragmentType, fragment.selectionSet);
  }
  function _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames) {
    for (var _i9 = 0, _selectionSet$selecti2 = selectionSet.selections;_i9 < _selectionSet$selecti2.length; _i9++) {
      var selection = _selectionSet$selecti2[_i9];
      switch (selection.kind) {
        case _kinds.Kind.FIELD: {
          var fieldName = selection.name.value;
          var fieldDef = undefined;
          if ((0, _definition.isObjectType)(parentType) || (0, _definition.isInterfaceType)(parentType)) {
            fieldDef = parentType.getFields()[fieldName];
          }
          var responseName = selection.alias ? selection.alias.value : fieldName;
          if (!nodeAndDefs[responseName]) {
            nodeAndDefs[responseName] = [];
          }
          nodeAndDefs[responseName].push([parentType, selection, fieldDef]);
          break;
        }
        case _kinds.Kind.FRAGMENT_SPREAD:
          fragmentNames[selection.name.value] = true;
          break;
        case _kinds.Kind.INLINE_FRAGMENT: {
          var typeCondition = selection.typeCondition;
          var inlineFragmentType = typeCondition ? (0, _typeFromAST.typeFromAST)(context.getSchema(), typeCondition) : parentType;
          _collectFieldsAndFragmentNames(context, inlineFragmentType, selection.selectionSet, nodeAndDefs, fragmentNames);
          break;
        }
      }
    }
  }
  function subfieldConflicts(conflicts, responseName, node1, node2) {
    if (conflicts.length > 0) {
      return [[responseName, conflicts.map(function(_ref6) {
        var reason = _ref6[0];
        return reason;
      })], conflicts.reduce(function(allFields, _ref7) {
        var fields1 = _ref7[1];
        return allFields.concat(fields1);
      }, [node1]), conflicts.reduce(function(allFields, _ref8) {
        var fields2 = _ref8[2];
        return allFields.concat(fields2);
      }, [node2])];
    }
  }
  var PairSet = /* @__PURE__ */ function() {
    function PairSet2() {
      this._data = Object.create(null);
    }
    var _proto = PairSet2.prototype;
    _proto.has = function has(a, b, areMutuallyExclusive) {
      var first = this._data[a];
      var result = first && first[b];
      if (result === undefined) {
        return false;
      }
      if (areMutuallyExclusive === false) {
        return result === false;
      }
      return true;
    };
    _proto.add = function add(a, b, areMutuallyExclusive) {
      this._pairSetAdd(a, b, areMutuallyExclusive);
      this._pairSetAdd(b, a, areMutuallyExclusive);
    };
    _proto._pairSetAdd = function _pairSetAdd(a, b, areMutuallyExclusive) {
      var map = this._data[a];
      if (!map) {
        map = Object.create(null);
        this._data[a] = map;
      }
      map[b] = areMutuallyExclusive;
    };
    return PairSet2;
  }();
});

// node_modules/graphql/validation/rules/UniqueInputFieldNamesRule.js
var require_UniqueInputFieldNamesRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.UniqueInputFieldNamesRule = UniqueInputFieldNamesRule;
  var _GraphQLError = require_GraphQLError();
  function UniqueInputFieldNamesRule(context) {
    var knownNameStack = [];
    var knownNames = Object.create(null);
    return {
      ObjectValue: {
        enter: function enter() {
          knownNameStack.push(knownNames);
          knownNames = Object.create(null);
        },
        leave: function leave() {
          knownNames = knownNameStack.pop();
        }
      },
      ObjectField: function ObjectField(node) {
        var fieldName = node.name.value;
        if (knownNames[fieldName]) {
          context.reportError(new _GraphQLError.GraphQLError('There can be only one input field named "'.concat(fieldName, '".'), [knownNames[fieldName], node.name]));
        } else {
          knownNames[fieldName] = node.name;
        }
      }
    };
  }
});

// node_modules/graphql/validation/rules/MaxIntrospectionDepthRule.js
var require_MaxIntrospectionDepthRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.MaxIntrospectionDepthRule = MaxIntrospectionDepthRule;
  var _GraphQLError = require_GraphQLError();
  var _kinds = require_kinds();
  var MAX_LISTS_DEPTH = 3;
  function MaxIntrospectionDepthRule(context) {
    function checkDepth(node) {
      var visitedFragments = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Object.create(null);
      var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      if (node.kind === _kinds.Kind.FRAGMENT_SPREAD) {
        var _fragmentName = node.name.value;
        if (visitedFragments[_fragmentName] === true) {
          return false;
        }
        var fragment = context.getFragment(_fragmentName);
        if (!fragment) {
          return false;
        }
        try {
          visitedFragments[_fragmentName] = true;
          return checkDepth(fragment, visitedFragments, depth);
        } finally {
          visitedFragments[_fragmentName] = null;
        }
      }
      if (node.kind === _kinds.Kind.FIELD && (node.name.value === "fields" || node.name.value === "interfaces" || node.name.value === "possibleTypes" || node.name.value === "inputFields")) {
        depth++;
        if (depth >= MAX_LISTS_DEPTH) {
          return true;
        }
      }
      if ("selectionSet" in node && node.selectionSet) {
        for (var _i2 = 0, _node$selectionSet$se2 = node.selectionSet.selections;_i2 < _node$selectionSet$se2.length; _i2++) {
          var child = _node$selectionSet$se2[_i2];
          if (checkDepth(child, visitedFragments, depth)) {
            return true;
          }
        }
      }
      return false;
    }
    return {
      Field: function Field(node) {
        if (node.name.value === "__schema" || node.name.value === "__type") {
          if (checkDepth(node)) {
            context.reportError(new _GraphQLError.GraphQLError("Maximum introspection depth exceeded", [node]));
            return false;
          }
        }
      }
    };
  }
});

// node_modules/graphql/validation/rules/LoneSchemaDefinitionRule.js
var require_LoneSchemaDefinitionRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.LoneSchemaDefinitionRule = LoneSchemaDefinitionRule;
  var _GraphQLError = require_GraphQLError();
  function LoneSchemaDefinitionRule(context) {
    var _ref, _ref2, _oldSchema$astNode;
    var oldSchema = context.getSchema();
    var alreadyDefined = (_ref = (_ref2 = (_oldSchema$astNode = oldSchema === null || oldSchema === undefined ? undefined : oldSchema.astNode) !== null && _oldSchema$astNode !== undefined ? _oldSchema$astNode : oldSchema === null || oldSchema === undefined ? undefined : oldSchema.getQueryType()) !== null && _ref2 !== undefined ? _ref2 : oldSchema === null || oldSchema === undefined ? undefined : oldSchema.getMutationType()) !== null && _ref !== undefined ? _ref : oldSchema === null || oldSchema === undefined ? undefined : oldSchema.getSubscriptionType();
    var schemaDefinitionsCount = 0;
    return {
      SchemaDefinition: function SchemaDefinition(node) {
        if (alreadyDefined) {
          context.reportError(new _GraphQLError.GraphQLError("Cannot define a new schema within a schema extension.", node));
          return;
        }
        if (schemaDefinitionsCount > 0) {
          context.reportError(new _GraphQLError.GraphQLError("Must provide only one schema definition.", node));
        }
        ++schemaDefinitionsCount;
      }
    };
  }
});

// node_modules/graphql/validation/rules/UniqueOperationTypesRule.js
var require_UniqueOperationTypesRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.UniqueOperationTypesRule = UniqueOperationTypesRule;
  var _GraphQLError = require_GraphQLError();
  function UniqueOperationTypesRule(context) {
    var schema = context.getSchema();
    var definedOperationTypes = Object.create(null);
    var existingOperationTypes = schema ? {
      query: schema.getQueryType(),
      mutation: schema.getMutationType(),
      subscription: schema.getSubscriptionType()
    } : {};
    return {
      SchemaDefinition: checkOperationTypes,
      SchemaExtension: checkOperationTypes
    };
    function checkOperationTypes(node) {
      var _node$operationTypes;
      var operationTypesNodes = (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== undefined ? _node$operationTypes : [];
      for (var _i2 = 0;_i2 < operationTypesNodes.length; _i2++) {
        var operationType = operationTypesNodes[_i2];
        var operation = operationType.operation;
        var alreadyDefinedOperationType = definedOperationTypes[operation];
        if (existingOperationTypes[operation]) {
          context.reportError(new _GraphQLError.GraphQLError("Type for ".concat(operation, " already defined in the schema. It cannot be redefined."), operationType));
        } else if (alreadyDefinedOperationType) {
          context.reportError(new _GraphQLError.GraphQLError("There can be only one ".concat(operation, " type in schema."), [alreadyDefinedOperationType, operationType]));
        } else {
          definedOperationTypes[operation] = operationType;
        }
      }
      return false;
    }
  }
});

// node_modules/graphql/validation/rules/UniqueTypeNamesRule.js
var require_UniqueTypeNamesRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.UniqueTypeNamesRule = UniqueTypeNamesRule;
  var _GraphQLError = require_GraphQLError();
  function UniqueTypeNamesRule(context) {
    var knownTypeNames = Object.create(null);
    var schema = context.getSchema();
    return {
      ScalarTypeDefinition: checkTypeName,
      ObjectTypeDefinition: checkTypeName,
      InterfaceTypeDefinition: checkTypeName,
      UnionTypeDefinition: checkTypeName,
      EnumTypeDefinition: checkTypeName,
      InputObjectTypeDefinition: checkTypeName
    };
    function checkTypeName(node) {
      var typeName = node.name.value;
      if (schema !== null && schema !== undefined && schema.getType(typeName)) {
        context.reportError(new _GraphQLError.GraphQLError('Type "'.concat(typeName, '" already exists in the schema. It cannot also be defined in this type definition.'), node.name));
        return;
      }
      if (knownTypeNames[typeName]) {
        context.reportError(new _GraphQLError.GraphQLError('There can be only one type named "'.concat(typeName, '".'), [knownTypeNames[typeName], node.name]));
      } else {
        knownTypeNames[typeName] = node.name;
      }
      return false;
    }
  }
});

// node_modules/graphql/validation/rules/UniqueEnumValueNamesRule.js
var require_UniqueEnumValueNamesRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.UniqueEnumValueNamesRule = UniqueEnumValueNamesRule;
  var _GraphQLError = require_GraphQLError();
  var _definition = require_definition();
  function UniqueEnumValueNamesRule(context) {
    var schema = context.getSchema();
    var existingTypeMap = schema ? schema.getTypeMap() : Object.create(null);
    var knownValueNames = Object.create(null);
    return {
      EnumTypeDefinition: checkValueUniqueness,
      EnumTypeExtension: checkValueUniqueness
    };
    function checkValueUniqueness(node) {
      var _node$values;
      var typeName = node.name.value;
      if (!knownValueNames[typeName]) {
        knownValueNames[typeName] = Object.create(null);
      }
      var valueNodes = (_node$values = node.values) !== null && _node$values !== undefined ? _node$values : [];
      var valueNames = knownValueNames[typeName];
      for (var _i2 = 0;_i2 < valueNodes.length; _i2++) {
        var valueDef = valueNodes[_i2];
        var valueName = valueDef.name.value;
        var existingType = existingTypeMap[typeName];
        if ((0, _definition.isEnumType)(existingType) && existingType.getValue(valueName)) {
          context.reportError(new _GraphQLError.GraphQLError('Enum value "'.concat(typeName, ".").concat(valueName, '" already exists in the schema. It cannot also be defined in this type extension.'), valueDef.name));
        } else if (valueNames[valueName]) {
          context.reportError(new _GraphQLError.GraphQLError('Enum value "'.concat(typeName, ".").concat(valueName, '" can only be defined once.'), [valueNames[valueName], valueDef.name]));
        } else {
          valueNames[valueName] = valueDef.name;
        }
      }
      return false;
    }
  }
});

// node_modules/graphql/validation/rules/UniqueFieldDefinitionNamesRule.js
var require_UniqueFieldDefinitionNamesRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.UniqueFieldDefinitionNamesRule = UniqueFieldDefinitionNamesRule;
  var _GraphQLError = require_GraphQLError();
  var _definition = require_definition();
  function UniqueFieldDefinitionNamesRule(context) {
    var schema = context.getSchema();
    var existingTypeMap = schema ? schema.getTypeMap() : Object.create(null);
    var knownFieldNames = Object.create(null);
    return {
      InputObjectTypeDefinition: checkFieldUniqueness,
      InputObjectTypeExtension: checkFieldUniqueness,
      InterfaceTypeDefinition: checkFieldUniqueness,
      InterfaceTypeExtension: checkFieldUniqueness,
      ObjectTypeDefinition: checkFieldUniqueness,
      ObjectTypeExtension: checkFieldUniqueness
    };
    function checkFieldUniqueness(node) {
      var _node$fields;
      var typeName = node.name.value;
      if (!knownFieldNames[typeName]) {
        knownFieldNames[typeName] = Object.create(null);
      }
      var fieldNodes = (_node$fields = node.fields) !== null && _node$fields !== undefined ? _node$fields : [];
      var fieldNames = knownFieldNames[typeName];
      for (var _i2 = 0;_i2 < fieldNodes.length; _i2++) {
        var fieldDef = fieldNodes[_i2];
        var fieldName = fieldDef.name.value;
        if (hasField(existingTypeMap[typeName], fieldName)) {
          context.reportError(new _GraphQLError.GraphQLError('Field "'.concat(typeName, ".").concat(fieldName, '" already exists in the schema. It cannot also be defined in this type extension.'), fieldDef.name));
        } else if (fieldNames[fieldName]) {
          context.reportError(new _GraphQLError.GraphQLError('Field "'.concat(typeName, ".").concat(fieldName, '" can only be defined once.'), [fieldNames[fieldName], fieldDef.name]));
        } else {
          fieldNames[fieldName] = fieldDef.name;
        }
      }
      return false;
    }
  }
  function hasField(type, fieldName) {
    if ((0, _definition.isObjectType)(type) || (0, _definition.isInterfaceType)(type) || (0, _definition.isInputObjectType)(type)) {
      return type.getFields()[fieldName] != null;
    }
    return false;
  }
});

// node_modules/graphql/validation/rules/UniqueDirectiveNamesRule.js
var require_UniqueDirectiveNamesRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.UniqueDirectiveNamesRule = UniqueDirectiveNamesRule;
  var _GraphQLError = require_GraphQLError();
  function UniqueDirectiveNamesRule(context) {
    var knownDirectiveNames = Object.create(null);
    var schema = context.getSchema();
    return {
      DirectiveDefinition: function DirectiveDefinition(node) {
        var directiveName = node.name.value;
        if (schema !== null && schema !== undefined && schema.getDirective(directiveName)) {
          context.reportError(new _GraphQLError.GraphQLError('Directive "@'.concat(directiveName, '" already exists in the schema. It cannot be redefined.'), node.name));
          return;
        }
        if (knownDirectiveNames[directiveName]) {
          context.reportError(new _GraphQLError.GraphQLError('There can be only one directive named "@'.concat(directiveName, '".'), [knownDirectiveNames[directiveName], node.name]));
        } else {
          knownDirectiveNames[directiveName] = node.name;
        }
        return false;
      }
    };
  }
});

// node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.js
var require_PossibleTypeExtensionsRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.PossibleTypeExtensionsRule = PossibleTypeExtensionsRule;
  var _inspect = _interopRequireDefault(require_inspect());
  var _invariant = _interopRequireDefault(require_invariant());
  var _didYouMean = _interopRequireDefault(require_didYouMean());
  var _suggestionList = _interopRequireDefault(require_suggestionList());
  var _GraphQLError = require_GraphQLError();
  var _kinds = require_kinds();
  var _predicates = require_predicates();
  var _definition = require_definition();
  var _defKindToExtKind;
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function PossibleTypeExtensionsRule(context) {
    var schema = context.getSchema();
    var definedTypes = Object.create(null);
    for (var _i2 = 0, _context$getDocument$2 = context.getDocument().definitions;_i2 < _context$getDocument$2.length; _i2++) {
      var def = _context$getDocument$2[_i2];
      if ((0, _predicates.isTypeDefinitionNode)(def)) {
        definedTypes[def.name.value] = def;
      }
    }
    return {
      ScalarTypeExtension: checkExtension,
      ObjectTypeExtension: checkExtension,
      InterfaceTypeExtension: checkExtension,
      UnionTypeExtension: checkExtension,
      EnumTypeExtension: checkExtension,
      InputObjectTypeExtension: checkExtension
    };
    function checkExtension(node) {
      var typeName = node.name.value;
      var defNode = definedTypes[typeName];
      var existingType = schema === null || schema === undefined ? undefined : schema.getType(typeName);
      var expectedKind;
      if (defNode) {
        expectedKind = defKindToExtKind[defNode.kind];
      } else if (existingType) {
        expectedKind = typeToExtKind(existingType);
      }
      if (expectedKind) {
        if (expectedKind !== node.kind) {
          var kindStr = extensionKindToTypeName(node.kind);
          context.reportError(new _GraphQLError.GraphQLError("Cannot extend non-".concat(kindStr, ' type "').concat(typeName, '".'), defNode ? [defNode, node] : node));
        }
      } else {
        var allTypeNames = Object.keys(definedTypes);
        if (schema) {
          allTypeNames = allTypeNames.concat(Object.keys(schema.getTypeMap()));
        }
        var suggestedTypes = (0, _suggestionList.default)(typeName, allTypeNames);
        context.reportError(new _GraphQLError.GraphQLError('Cannot extend type "'.concat(typeName, '" because it is not defined.') + (0, _didYouMean.default)(suggestedTypes), node.name));
      }
    }
  }
  var defKindToExtKind = (_defKindToExtKind = {}, _defineProperty(_defKindToExtKind, _kinds.Kind.SCALAR_TYPE_DEFINITION, _kinds.Kind.SCALAR_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, _kinds.Kind.OBJECT_TYPE_DEFINITION, _kinds.Kind.OBJECT_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, _kinds.Kind.INTERFACE_TYPE_DEFINITION, _kinds.Kind.INTERFACE_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, _kinds.Kind.UNION_TYPE_DEFINITION, _kinds.Kind.UNION_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, _kinds.Kind.ENUM_TYPE_DEFINITION, _kinds.Kind.ENUM_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION, _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION), _defKindToExtKind);
  function typeToExtKind(type) {
    if ((0, _definition.isScalarType)(type)) {
      return _kinds.Kind.SCALAR_TYPE_EXTENSION;
    }
    if ((0, _definition.isObjectType)(type)) {
      return _kinds.Kind.OBJECT_TYPE_EXTENSION;
    }
    if ((0, _definition.isInterfaceType)(type)) {
      return _kinds.Kind.INTERFACE_TYPE_EXTENSION;
    }
    if ((0, _definition.isUnionType)(type)) {
      return _kinds.Kind.UNION_TYPE_EXTENSION;
    }
    if ((0, _definition.isEnumType)(type)) {
      return _kinds.Kind.ENUM_TYPE_EXTENSION;
    }
    if ((0, _definition.isInputObjectType)(type)) {
      return _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION;
    }
    (0, _invariant.default)(0, "Unexpected type: " + (0, _inspect.default)(type));
  }
  function extensionKindToTypeName(kind) {
    switch (kind) {
      case _kinds.Kind.SCALAR_TYPE_EXTENSION:
        return "scalar";
      case _kinds.Kind.OBJECT_TYPE_EXTENSION:
        return "object";
      case _kinds.Kind.INTERFACE_TYPE_EXTENSION:
        return "interface";
      case _kinds.Kind.UNION_TYPE_EXTENSION:
        return "union";
      case _kinds.Kind.ENUM_TYPE_EXTENSION:
        return "enum";
      case _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION:
        return "input object";
    }
    (0, _invariant.default)(0, "Unexpected kind: " + (0, _inspect.default)(kind));
  }
});

// node_modules/graphql/validation/specifiedRules.js
var require_specifiedRules = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.specifiedSDLRules = exports.specifiedRules = exports.recommendedRules = undefined;
  var _ExecutableDefinitionsRule = require_ExecutableDefinitionsRule();
  var _UniqueOperationNamesRule = require_UniqueOperationNamesRule();
  var _LoneAnonymousOperationRule = require_LoneAnonymousOperationRule();
  var _SingleFieldSubscriptionsRule = require_SingleFieldSubscriptionsRule();
  var _KnownTypeNamesRule = require_KnownTypeNamesRule();
  var _FragmentsOnCompositeTypesRule = require_FragmentsOnCompositeTypesRule();
  var _VariablesAreInputTypesRule = require_VariablesAreInputTypesRule();
  var _ScalarLeafsRule = require_ScalarLeafsRule();
  var _FieldsOnCorrectTypeRule = require_FieldsOnCorrectTypeRule();
  var _UniqueFragmentNamesRule = require_UniqueFragmentNamesRule();
  var _KnownFragmentNamesRule = require_KnownFragmentNamesRule();
  var _NoUnusedFragmentsRule = require_NoUnusedFragmentsRule();
  var _PossibleFragmentSpreadsRule = require_PossibleFragmentSpreadsRule();
  var _NoFragmentCyclesRule = require_NoFragmentCyclesRule();
  var _UniqueVariableNamesRule = require_UniqueVariableNamesRule();
  var _NoUndefinedVariablesRule = require_NoUndefinedVariablesRule();
  var _NoUnusedVariablesRule = require_NoUnusedVariablesRule();
  var _KnownDirectivesRule = require_KnownDirectivesRule();
  var _UniqueDirectivesPerLocationRule = require_UniqueDirectivesPerLocationRule();
  var _KnownArgumentNamesRule = require_KnownArgumentNamesRule();
  var _UniqueArgumentNamesRule = require_UniqueArgumentNamesRule();
  var _ValuesOfCorrectTypeRule = require_ValuesOfCorrectTypeRule();
  var _ProvidedRequiredArgumentsRule = require_ProvidedRequiredArgumentsRule();
  var _VariablesInAllowedPositionRule = require_VariablesInAllowedPositionRule();
  var _OverlappingFieldsCanBeMergedRule = require_OverlappingFieldsCanBeMergedRule();
  var _UniqueInputFieldNamesRule = require_UniqueInputFieldNamesRule();
  var _MaxIntrospectionDepthRule = require_MaxIntrospectionDepthRule();
  var _LoneSchemaDefinitionRule = require_LoneSchemaDefinitionRule();
  var _UniqueOperationTypesRule = require_UniqueOperationTypesRule();
  var _UniqueTypeNamesRule = require_UniqueTypeNamesRule();
  var _UniqueEnumValueNamesRule = require_UniqueEnumValueNamesRule();
  var _UniqueFieldDefinitionNamesRule = require_UniqueFieldDefinitionNamesRule();
  var _UniqueDirectiveNamesRule = require_UniqueDirectiveNamesRule();
  var _PossibleTypeExtensionsRule = require_PossibleTypeExtensionsRule();
  var recommendedRules = Object.freeze([_MaxIntrospectionDepthRule.MaxIntrospectionDepthRule]);
  exports.recommendedRules = recommendedRules;
  var specifiedRules = Object.freeze([_ExecutableDefinitionsRule.ExecutableDefinitionsRule, _UniqueOperationNamesRule.UniqueOperationNamesRule, _LoneAnonymousOperationRule.LoneAnonymousOperationRule, _SingleFieldSubscriptionsRule.SingleFieldSubscriptionsRule, _KnownTypeNamesRule.KnownTypeNamesRule, _FragmentsOnCompositeTypesRule.FragmentsOnCompositeTypesRule, _VariablesAreInputTypesRule.VariablesAreInputTypesRule, _ScalarLeafsRule.ScalarLeafsRule, _FieldsOnCorrectTypeRule.FieldsOnCorrectTypeRule, _UniqueFragmentNamesRule.UniqueFragmentNamesRule, _KnownFragmentNamesRule.KnownFragmentNamesRule, _NoUnusedFragmentsRule.NoUnusedFragmentsRule, _PossibleFragmentSpreadsRule.PossibleFragmentSpreadsRule, _NoFragmentCyclesRule.NoFragmentCyclesRule, _UniqueVariableNamesRule.UniqueVariableNamesRule, _NoUndefinedVariablesRule.NoUndefinedVariablesRule, _NoUnusedVariablesRule.NoUnusedVariablesRule, _KnownDirectivesRule.KnownDirectivesRule, _UniqueDirectivesPerLocationRule.UniqueDirectivesPerLocationRule, _KnownArgumentNamesRule.KnownArgumentNamesRule, _UniqueArgumentNamesRule.UniqueArgumentNamesRule, _ValuesOfCorrectTypeRule.ValuesOfCorrectTypeRule, _ProvidedRequiredArgumentsRule.ProvidedRequiredArgumentsRule, _VariablesInAllowedPositionRule.VariablesInAllowedPositionRule, _OverlappingFieldsCanBeMergedRule.OverlappingFieldsCanBeMergedRule, _UniqueInputFieldNamesRule.UniqueInputFieldNamesRule].concat(recommendedRules));
  exports.specifiedRules = specifiedRules;
  var specifiedSDLRules = Object.freeze([_LoneSchemaDefinitionRule.LoneSchemaDefinitionRule, _UniqueOperationTypesRule.UniqueOperationTypesRule, _UniqueTypeNamesRule.UniqueTypeNamesRule, _UniqueEnumValueNamesRule.UniqueEnumValueNamesRule, _UniqueFieldDefinitionNamesRule.UniqueFieldDefinitionNamesRule, _UniqueDirectiveNamesRule.UniqueDirectiveNamesRule, _KnownTypeNamesRule.KnownTypeNamesRule, _KnownDirectivesRule.KnownDirectivesRule, _UniqueDirectivesPerLocationRule.UniqueDirectivesPerLocationRule, _PossibleTypeExtensionsRule.PossibleTypeExtensionsRule, _KnownArgumentNamesRule.KnownArgumentNamesOnDirectivesRule, _UniqueArgumentNamesRule.UniqueArgumentNamesRule, _UniqueInputFieldNamesRule.UniqueInputFieldNamesRule, _ProvidedRequiredArgumentsRule.ProvidedRequiredArgumentsOnDirectivesRule]);
  exports.specifiedSDLRules = specifiedSDLRules;
});

// node_modules/graphql/validation/ValidationContext.js
var require_ValidationContext = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ValidationContext = exports.SDLValidationContext = exports.ASTValidationContext = undefined;
  var _kinds = require_kinds();
  var _visitor = require_visitor();
  var _TypeInfo = require_TypeInfo();
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }
  var ASTValidationContext = /* @__PURE__ */ function() {
    function ASTValidationContext2(ast, onError) {
      this._ast = ast;
      this._fragments = undefined;
      this._fragmentSpreads = new Map;
      this._recursivelyReferencedFragments = new Map;
      this._onError = onError;
    }
    var _proto = ASTValidationContext2.prototype;
    _proto.reportError = function reportError(error) {
      this._onError(error);
    };
    _proto.getDocument = function getDocument() {
      return this._ast;
    };
    _proto.getFragment = function getFragment(name) {
      var fragments = this._fragments;
      if (!fragments) {
        this._fragments = fragments = this.getDocument().definitions.reduce(function(frags, statement) {
          if (statement.kind === _kinds.Kind.FRAGMENT_DEFINITION) {
            frags[statement.name.value] = statement;
          }
          return frags;
        }, Object.create(null));
      }
      return fragments[name];
    };
    _proto.getFragmentSpreads = function getFragmentSpreads(node) {
      var spreads = this._fragmentSpreads.get(node);
      if (!spreads) {
        spreads = [];
        var setsToVisit = [node];
        while (setsToVisit.length !== 0) {
          var set = setsToVisit.pop();
          for (var _i2 = 0, _set$selections2 = set.selections;_i2 < _set$selections2.length; _i2++) {
            var selection = _set$selections2[_i2];
            if (selection.kind === _kinds.Kind.FRAGMENT_SPREAD) {
              spreads.push(selection);
            } else if (selection.selectionSet) {
              setsToVisit.push(selection.selectionSet);
            }
          }
        }
        this._fragmentSpreads.set(node, spreads);
      }
      return spreads;
    };
    _proto.getRecursivelyReferencedFragments = function getRecursivelyReferencedFragments(operation) {
      var fragments = this._recursivelyReferencedFragments.get(operation);
      if (!fragments) {
        fragments = [];
        var collectedNames = Object.create(null);
        var nodesToVisit = [operation.selectionSet];
        while (nodesToVisit.length !== 0) {
          var node = nodesToVisit.pop();
          for (var _i4 = 0, _this$getFragmentSpre2 = this.getFragmentSpreads(node);_i4 < _this$getFragmentSpre2.length; _i4++) {
            var spread = _this$getFragmentSpre2[_i4];
            var fragName = spread.name.value;
            if (collectedNames[fragName] !== true) {
              collectedNames[fragName] = true;
              var fragment = this.getFragment(fragName);
              if (fragment) {
                fragments.push(fragment);
                nodesToVisit.push(fragment.selectionSet);
              }
            }
          }
        }
        this._recursivelyReferencedFragments.set(operation, fragments);
      }
      return fragments;
    };
    return ASTValidationContext2;
  }();
  exports.ASTValidationContext = ASTValidationContext;
  var SDLValidationContext = /* @__PURE__ */ function(_ASTValidationContext) {
    _inheritsLoose(SDLValidationContext2, _ASTValidationContext);
    function SDLValidationContext2(ast, schema, onError) {
      var _this;
      _this = _ASTValidationContext.call(this, ast, onError) || this;
      _this._schema = schema;
      return _this;
    }
    var _proto2 = SDLValidationContext2.prototype;
    _proto2.getSchema = function getSchema() {
      return this._schema;
    };
    return SDLValidationContext2;
  }(ASTValidationContext);
  exports.SDLValidationContext = SDLValidationContext;
  var ValidationContext = /* @__PURE__ */ function(_ASTValidationContext2) {
    _inheritsLoose(ValidationContext2, _ASTValidationContext2);
    function ValidationContext2(schema, ast, typeInfo, onError) {
      var _this2;
      _this2 = _ASTValidationContext2.call(this, ast, onError) || this;
      _this2._schema = schema;
      _this2._typeInfo = typeInfo;
      _this2._variableUsages = new Map;
      _this2._recursiveVariableUsages = new Map;
      return _this2;
    }
    var _proto3 = ValidationContext2.prototype;
    _proto3.getSchema = function getSchema() {
      return this._schema;
    };
    _proto3.getVariableUsages = function getVariableUsages(node) {
      var usages = this._variableUsages.get(node);
      if (!usages) {
        var newUsages = [];
        var typeInfo = new _TypeInfo.TypeInfo(this._schema);
        (0, _visitor.visit)(node, (0, _TypeInfo.visitWithTypeInfo)(typeInfo, {
          VariableDefinition: function VariableDefinition() {
            return false;
          },
          Variable: function Variable(variable) {
            newUsages.push({
              node: variable,
              type: typeInfo.getInputType(),
              defaultValue: typeInfo.getDefaultValue()
            });
          }
        }));
        usages = newUsages;
        this._variableUsages.set(node, usages);
      }
      return usages;
    };
    _proto3.getRecursiveVariableUsages = function getRecursiveVariableUsages(operation) {
      var usages = this._recursiveVariableUsages.get(operation);
      if (!usages) {
        usages = this.getVariableUsages(operation);
        for (var _i6 = 0, _this$getRecursivelyR2 = this.getRecursivelyReferencedFragments(operation);_i6 < _this$getRecursivelyR2.length; _i6++) {
          var frag = _this$getRecursivelyR2[_i6];
          usages = usages.concat(this.getVariableUsages(frag));
        }
        this._recursiveVariableUsages.set(operation, usages);
      }
      return usages;
    };
    _proto3.getType = function getType() {
      return this._typeInfo.getType();
    };
    _proto3.getParentType = function getParentType() {
      return this._typeInfo.getParentType();
    };
    _proto3.getInputType = function getInputType() {
      return this._typeInfo.getInputType();
    };
    _proto3.getParentInputType = function getParentInputType() {
      return this._typeInfo.getParentInputType();
    };
    _proto3.getFieldDef = function getFieldDef() {
      return this._typeInfo.getFieldDef();
    };
    _proto3.getDirective = function getDirective() {
      return this._typeInfo.getDirective();
    };
    _proto3.getArgument = function getArgument() {
      return this._typeInfo.getArgument();
    };
    _proto3.getEnumValue = function getEnumValue() {
      return this._typeInfo.getEnumValue();
    };
    return ValidationContext2;
  }(ASTValidationContext);
  exports.ValidationContext = ValidationContext;
});

// node_modules/graphql/validation/validate.js
var require_validate2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.validate = validate;
  exports.validateSDL = validateSDL;
  exports.assertValidSDL = assertValidSDL;
  exports.assertValidSDLExtension = assertValidSDLExtension;
  var _devAssert = _interopRequireDefault(require_devAssert());
  var _GraphQLError = require_GraphQLError();
  var _visitor = require_visitor();
  var _validate = require_validate();
  var _TypeInfo = require_TypeInfo();
  var _specifiedRules = require_specifiedRules();
  var _ValidationContext = require_ValidationContext();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function validate(schema, documentAST) {
    var rules = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _specifiedRules.specifiedRules;
    var typeInfo = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new _TypeInfo.TypeInfo(schema);
    var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {
      maxErrors: undefined
    };
    documentAST || (0, _devAssert.default)(0, "Must provide document.");
    (0, _validate.assertValidSchema)(schema);
    var abortObj = Object.freeze({});
    var errors = [];
    var context = new _ValidationContext.ValidationContext(schema, documentAST, typeInfo, function(error) {
      if (options.maxErrors != null && errors.length >= options.maxErrors) {
        errors.push(new _GraphQLError.GraphQLError("Too many validation errors, error limit reached. Validation aborted."));
        throw abortObj;
      }
      errors.push(error);
    });
    var visitor = (0, _visitor.visitInParallel)(rules.map(function(rule) {
      return rule(context);
    }));
    try {
      (0, _visitor.visit)(documentAST, (0, _TypeInfo.visitWithTypeInfo)(typeInfo, visitor));
    } catch (e) {
      if (e !== abortObj) {
        throw e;
      }
    }
    return errors;
  }
  function validateSDL(documentAST, schemaToExtend) {
    var rules = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _specifiedRules.specifiedSDLRules;
    var errors = [];
    var context = new _ValidationContext.SDLValidationContext(documentAST, schemaToExtend, function(error) {
      errors.push(error);
    });
    var visitors = rules.map(function(rule) {
      return rule(context);
    });
    (0, _visitor.visit)(documentAST, (0, _visitor.visitInParallel)(visitors));
    return errors;
  }
  function assertValidSDL(documentAST) {
    var errors = validateSDL(documentAST);
    if (errors.length !== 0) {
      throw new Error(errors.map(function(error) {
        return error.message;
      }).join(`

`));
    }
  }
  function assertValidSDLExtension(documentAST, schema) {
    var errors = validateSDL(documentAST, schema);
    if (errors.length !== 0) {
      throw new Error(errors.map(function(error) {
        return error.message;
      }).join(`

`));
    }
  }
});

// node_modules/graphql/jsutils/memoize3.js
var require_memoize3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = memoize3;
  function memoize3(fn2) {
    var cache0;
    return function memoized(a1, a2, a3) {
      if (!cache0) {
        cache0 = new WeakMap;
      }
      var cache1 = cache0.get(a1);
      var cache2;
      if (cache1) {
        cache2 = cache1.get(a2);
        if (cache2) {
          var cachedValue = cache2.get(a3);
          if (cachedValue !== undefined) {
            return cachedValue;
          }
        }
      } else {
        cache1 = new WeakMap;
        cache0.set(a1, cache1);
      }
      if (!cache2) {
        cache2 = new WeakMap;
        cache1.set(a2, cache2);
      }
      var newValue = fn2(a1, a2, a3);
      cache2.set(a3, newValue);
      return newValue;
    };
  }
});

// node_modules/graphql/jsutils/promiseReduce.js
var require_promiseReduce = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = promiseReduce;
  var _isPromise = _interopRequireDefault(require_isPromise());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function promiseReduce(values, callback, initialValue) {
    return values.reduce(function(previous, value) {
      return (0, _isPromise.default)(previous) ? previous.then(function(resolved) {
        return callback(resolved, value);
      }) : callback(previous, value);
    }, initialValue);
  }
});

// node_modules/graphql/jsutils/promiseForObject.js
var require_promiseForObject = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = promiseForObject;
  function promiseForObject(object) {
    var keys = Object.keys(object);
    var valuesAndPromises = keys.map(function(name) {
      return object[name];
    });
    return Promise.all(valuesAndPromises).then(function(values) {
      return values.reduce(function(resolvedObject, value, i) {
        resolvedObject[keys[i]] = value;
        return resolvedObject;
      }, Object.create(null));
    });
  }
});

// node_modules/graphql/jsutils/Path.js
var require_Path = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.addPath = addPath;
  exports.pathToArray = pathToArray;
  function addPath(prev, key, typename) {
    return {
      prev,
      key,
      typename
    };
  }
  function pathToArray(path) {
    var flattened = [];
    var curr = path;
    while (curr) {
      flattened.push(curr.key);
      curr = curr.prev;
    }
    return flattened.reverse();
  }
});

// node_modules/graphql/utilities/getOperationRootType.js
var require_getOperationRootType = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getOperationRootType = getOperationRootType;
  var _GraphQLError = require_GraphQLError();
  function getOperationRootType(schema, operation) {
    if (operation.operation === "query") {
      var queryType = schema.getQueryType();
      if (!queryType) {
        throw new _GraphQLError.GraphQLError("Schema does not define the required query root type.", operation);
      }
      return queryType;
    }
    if (operation.operation === "mutation") {
      var mutationType = schema.getMutationType();
      if (!mutationType) {
        throw new _GraphQLError.GraphQLError("Schema is not configured for mutations.", operation);
      }
      return mutationType;
    }
    if (operation.operation === "subscription") {
      var subscriptionType = schema.getSubscriptionType();
      if (!subscriptionType) {
        throw new _GraphQLError.GraphQLError("Schema is not configured for subscriptions.", operation);
      }
      return subscriptionType;
    }
    throw new _GraphQLError.GraphQLError("Can only have query, mutation and subscription operations.", operation);
  }
});

// node_modules/graphql/jsutils/printPathArray.js
var require_printPathArray = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = printPathArray;
  function printPathArray(path) {
    return path.map(function(key) {
      return typeof key === "number" ? "[" + key.toString() + "]" : "." + key;
    }).join("");
  }
});

// node_modules/graphql/utilities/valueFromAST.js
var require_valueFromAST = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.valueFromAST = valueFromAST;
  var _objectValues3 = _interopRequireDefault(require_objectValues());
  var _keyMap = _interopRequireDefault(require_keyMap());
  var _inspect = _interopRequireDefault(require_inspect());
  var _invariant = _interopRequireDefault(require_invariant());
  var _kinds = require_kinds();
  var _definition = require_definition();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function valueFromAST(valueNode, type, variables) {
    if (!valueNode) {
      return;
    }
    if (valueNode.kind === _kinds.Kind.VARIABLE) {
      var variableName = valueNode.name.value;
      if (variables == null || variables[variableName] === undefined) {
        return;
      }
      var variableValue = variables[variableName];
      if (variableValue === null && (0, _definition.isNonNullType)(type)) {
        return;
      }
      return variableValue;
    }
    if ((0, _definition.isNonNullType)(type)) {
      if (valueNode.kind === _kinds.Kind.NULL) {
        return;
      }
      return valueFromAST(valueNode, type.ofType, variables);
    }
    if (valueNode.kind === _kinds.Kind.NULL) {
      return null;
    }
    if ((0, _definition.isListType)(type)) {
      var itemType = type.ofType;
      if (valueNode.kind === _kinds.Kind.LIST) {
        var coercedValues = [];
        for (var _i2 = 0, _valueNode$values2 = valueNode.values;_i2 < _valueNode$values2.length; _i2++) {
          var itemNode = _valueNode$values2[_i2];
          if (isMissingVariable(itemNode, variables)) {
            if ((0, _definition.isNonNullType)(itemType)) {
              return;
            }
            coercedValues.push(null);
          } else {
            var itemValue = valueFromAST(itemNode, itemType, variables);
            if (itemValue === undefined) {
              return;
            }
            coercedValues.push(itemValue);
          }
        }
        return coercedValues;
      }
      var coercedValue = valueFromAST(valueNode, itemType, variables);
      if (coercedValue === undefined) {
        return;
      }
      return [coercedValue];
    }
    if ((0, _definition.isInputObjectType)(type)) {
      if (valueNode.kind !== _kinds.Kind.OBJECT) {
        return;
      }
      var coercedObj = Object.create(null);
      var fieldNodes = (0, _keyMap.default)(valueNode.fields, function(field2) {
        return field2.name.value;
      });
      for (var _i4 = 0, _objectValues2 = (0, _objectValues3.default)(type.getFields());_i4 < _objectValues2.length; _i4++) {
        var field = _objectValues2[_i4];
        var fieldNode = fieldNodes[field.name];
        if (!fieldNode || isMissingVariable(fieldNode.value, variables)) {
          if (field.defaultValue !== undefined) {
            coercedObj[field.name] = field.defaultValue;
          } else if ((0, _definition.isNonNullType)(field.type)) {
            return;
          }
          continue;
        }
        var fieldValue = valueFromAST(fieldNode.value, field.type, variables);
        if (fieldValue === undefined) {
          return;
        }
        coercedObj[field.name] = fieldValue;
      }
      return coercedObj;
    }
    if ((0, _definition.isLeafType)(type)) {
      var result;
      try {
        result = type.parseLiteral(valueNode, variables);
      } catch (_error) {
        return;
      }
      if (result === undefined) {
        return;
      }
      return result;
    }
    (0, _invariant.default)(0, "Unexpected input type: " + (0, _inspect.default)(type));
  }
  function isMissingVariable(valueNode, variables) {
    return valueNode.kind === _kinds.Kind.VARIABLE && (variables == null || variables[valueNode.name.value] === undefined);
  }
});

// node_modules/graphql/utilities/coerceInputValue.js
var require_coerceInputValue = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.coerceInputValue = coerceInputValue;
  var _objectValues3 = _interopRequireDefault(require_objectValues());
  var _inspect = _interopRequireDefault(require_inspect());
  var _invariant = _interopRequireDefault(require_invariant());
  var _didYouMean = _interopRequireDefault(require_didYouMean());
  var _isObjectLike = _interopRequireDefault(require_isObjectLike());
  var _safeArrayFrom = _interopRequireDefault(require_safeArrayFrom());
  var _suggestionList = _interopRequireDefault(require_suggestionList());
  var _printPathArray = _interopRequireDefault(require_printPathArray());
  var _Path = require_Path();
  var _GraphQLError = require_GraphQLError();
  var _definition = require_definition();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function coerceInputValue(inputValue, type) {
    var onError = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultOnError;
    return coerceInputValueImpl(inputValue, type, onError);
  }
  function defaultOnError(path, invalidValue, error) {
    var errorPrefix = "Invalid value " + (0, _inspect.default)(invalidValue);
    if (path.length > 0) {
      errorPrefix += ' at "value'.concat((0, _printPathArray.default)(path), '"');
    }
    error.message = errorPrefix + ": " + error.message;
    throw error;
  }
  function coerceInputValueImpl(inputValue, type, onError, path) {
    if ((0, _definition.isNonNullType)(type)) {
      if (inputValue != null) {
        return coerceInputValueImpl(inputValue, type.ofType, onError, path);
      }
      onError((0, _Path.pathToArray)(path), inputValue, new _GraphQLError.GraphQLError('Expected non-nullable type "'.concat((0, _inspect.default)(type), '" not to be null.')));
      return;
    }
    if (inputValue == null) {
      return null;
    }
    if ((0, _definition.isListType)(type)) {
      var itemType = type.ofType;
      var coercedList = (0, _safeArrayFrom.default)(inputValue, function(itemValue, index) {
        var itemPath = (0, _Path.addPath)(path, index, undefined);
        return coerceInputValueImpl(itemValue, itemType, onError, itemPath);
      });
      if (coercedList != null) {
        return coercedList;
      }
      return [coerceInputValueImpl(inputValue, itemType, onError, path)];
    }
    if ((0, _definition.isInputObjectType)(type)) {
      if (!(0, _isObjectLike.default)(inputValue)) {
        onError((0, _Path.pathToArray)(path), inputValue, new _GraphQLError.GraphQLError('Expected type "'.concat(type.name, '" to be an object.')));
        return;
      }
      var coercedValue = {};
      var fieldDefs = type.getFields();
      for (var _i2 = 0, _objectValues2 = (0, _objectValues3.default)(fieldDefs);_i2 < _objectValues2.length; _i2++) {
        var field = _objectValues2[_i2];
        var fieldValue = inputValue[field.name];
        if (fieldValue === undefined) {
          if (field.defaultValue !== undefined) {
            coercedValue[field.name] = field.defaultValue;
          } else if ((0, _definition.isNonNullType)(field.type)) {
            var typeStr = (0, _inspect.default)(field.type);
            onError((0, _Path.pathToArray)(path), inputValue, new _GraphQLError.GraphQLError('Field "'.concat(field.name, '" of required type "').concat(typeStr, '" was not provided.')));
          }
          continue;
        }
        coercedValue[field.name] = coerceInputValueImpl(fieldValue, field.type, onError, (0, _Path.addPath)(path, field.name, type.name));
      }
      for (var _i4 = 0, _Object$keys2 = Object.keys(inputValue);_i4 < _Object$keys2.length; _i4++) {
        var fieldName = _Object$keys2[_i4];
        if (!fieldDefs[fieldName]) {
          var suggestions = (0, _suggestionList.default)(fieldName, Object.keys(type.getFields()));
          onError((0, _Path.pathToArray)(path), inputValue, new _GraphQLError.GraphQLError('Field "'.concat(fieldName, '" is not defined by type "').concat(type.name, '".') + (0, _didYouMean.default)(suggestions)));
        }
      }
      return coercedValue;
    }
    if ((0, _definition.isLeafType)(type)) {
      var parseResult;
      try {
        parseResult = type.parseValue(inputValue);
      } catch (error) {
        if (error instanceof _GraphQLError.GraphQLError) {
          onError((0, _Path.pathToArray)(path), inputValue, error);
        } else {
          onError((0, _Path.pathToArray)(path), inputValue, new _GraphQLError.GraphQLError('Expected type "'.concat(type.name, '". ') + error.message, undefined, undefined, undefined, undefined, error));
        }
        return;
      }
      if (parseResult === undefined) {
        onError((0, _Path.pathToArray)(path), inputValue, new _GraphQLError.GraphQLError('Expected type "'.concat(type.name, '".')));
      }
      return parseResult;
    }
    (0, _invariant.default)(0, "Unexpected input type: " + (0, _inspect.default)(type));
  }
});

// node_modules/graphql/execution/values.js
var require_values = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getVariableValues = getVariableValues;
  exports.getArgumentValues = getArgumentValues;
  exports.getDirectiveValues = getDirectiveValues;
  var _find = _interopRequireDefault(require_find());
  var _keyMap = _interopRequireDefault(require_keyMap());
  var _inspect = _interopRequireDefault(require_inspect());
  var _printPathArray = _interopRequireDefault(require_printPathArray());
  var _GraphQLError = require_GraphQLError();
  var _kinds = require_kinds();
  var _printer = require_printer();
  var _definition = require_definition();
  var _typeFromAST = require_typeFromAST();
  var _valueFromAST = require_valueFromAST();
  var _coerceInputValue = require_coerceInputValue();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function getVariableValues(schema, varDefNodes, inputs, options) {
    var errors = [];
    var maxErrors = options === null || options === undefined ? undefined : options.maxErrors;
    try {
      var coerced = coerceVariableValues(schema, varDefNodes, inputs, function(error) {
        if (maxErrors != null && errors.length >= maxErrors) {
          throw new _GraphQLError.GraphQLError("Too many errors processing variables, error limit reached. Execution aborted.");
        }
        errors.push(error);
      });
      if (errors.length === 0) {
        return {
          coerced
        };
      }
    } catch (error) {
      errors.push(error);
    }
    return {
      errors
    };
  }
  function coerceVariableValues(schema, varDefNodes, inputs, onError) {
    var coercedValues = {};
    var _loop = function _loop(_i22) {
      var varDefNode = varDefNodes[_i22];
      var varName = varDefNode.variable.name.value;
      var varType = (0, _typeFromAST.typeFromAST)(schema, varDefNode.type);
      if (!(0, _definition.isInputType)(varType)) {
        var varTypeStr = (0, _printer.print)(varDefNode.type);
        onError(new _GraphQLError.GraphQLError('Variable "$'.concat(varName, '" expected value of type "').concat(varTypeStr, '" which cannot be used as an input type.'), varDefNode.type));
        return "continue";
      }
      if (!hasOwnProperty(inputs, varName)) {
        if (varDefNode.defaultValue) {
          coercedValues[varName] = (0, _valueFromAST.valueFromAST)(varDefNode.defaultValue, varType);
        } else if ((0, _definition.isNonNullType)(varType)) {
          var _varTypeStr = (0, _inspect.default)(varType);
          onError(new _GraphQLError.GraphQLError('Variable "$'.concat(varName, '" of required type "').concat(_varTypeStr, '" was not provided.'), varDefNode));
        }
        return "continue";
      }
      var value = inputs[varName];
      if (value === null && (0, _definition.isNonNullType)(varType)) {
        var _varTypeStr2 = (0, _inspect.default)(varType);
        onError(new _GraphQLError.GraphQLError('Variable "$'.concat(varName, '" of non-null type "').concat(_varTypeStr2, '" must not be null.'), varDefNode));
        return "continue";
      }
      coercedValues[varName] = (0, _coerceInputValue.coerceInputValue)(value, varType, function(path, invalidValue, error) {
        var prefix = 'Variable "$'.concat(varName, '" got invalid value ') + (0, _inspect.default)(invalidValue);
        if (path.length > 0) {
          prefix += ' at "'.concat(varName).concat((0, _printPathArray.default)(path), '"');
        }
        onError(new _GraphQLError.GraphQLError(prefix + "; " + error.message, varDefNode, undefined, undefined, undefined, error.originalError));
      });
    };
    for (var _i2 = 0;_i2 < varDefNodes.length; _i2++) {
      var _ret = _loop(_i2);
      if (_ret === "continue")
        continue;
    }
    return coercedValues;
  }
  function getArgumentValues(def, node, variableValues) {
    var _node$arguments;
    var coercedValues = {};
    var argumentNodes = (_node$arguments = node.arguments) !== null && _node$arguments !== undefined ? _node$arguments : [];
    var argNodeMap = (0, _keyMap.default)(argumentNodes, function(arg) {
      return arg.name.value;
    });
    for (var _i4 = 0, _def$args2 = def.args;_i4 < _def$args2.length; _i4++) {
      var argDef = _def$args2[_i4];
      var name = argDef.name;
      var argType = argDef.type;
      var argumentNode = argNodeMap[name];
      if (!argumentNode) {
        if (argDef.defaultValue !== undefined) {
          coercedValues[name] = argDef.defaultValue;
        } else if ((0, _definition.isNonNullType)(argType)) {
          throw new _GraphQLError.GraphQLError('Argument "'.concat(name, '" of required type "').concat((0, _inspect.default)(argType), '" ') + "was not provided.", node);
        }
        continue;
      }
      var valueNode = argumentNode.value;
      var isNull = valueNode.kind === _kinds.Kind.NULL;
      if (valueNode.kind === _kinds.Kind.VARIABLE) {
        var variableName = valueNode.name.value;
        if (variableValues == null || !hasOwnProperty(variableValues, variableName)) {
          if (argDef.defaultValue !== undefined) {
            coercedValues[name] = argDef.defaultValue;
          } else if ((0, _definition.isNonNullType)(argType)) {
            throw new _GraphQLError.GraphQLError('Argument "'.concat(name, '" of required type "').concat((0, _inspect.default)(argType), '" ') + 'was provided the variable "$'.concat(variableName, '" which was not provided a runtime value.'), valueNode);
          }
          continue;
        }
        isNull = variableValues[variableName] == null;
      }
      if (isNull && (0, _definition.isNonNullType)(argType)) {
        throw new _GraphQLError.GraphQLError('Argument "'.concat(name, '" of non-null type "').concat((0, _inspect.default)(argType), '" ') + "must not be null.", valueNode);
      }
      var coercedValue = (0, _valueFromAST.valueFromAST)(valueNode, argType, variableValues);
      if (coercedValue === undefined) {
        throw new _GraphQLError.GraphQLError('Argument "'.concat(name, '" has invalid value ').concat((0, _printer.print)(valueNode), "."), valueNode);
      }
      coercedValues[name] = coercedValue;
    }
    return coercedValues;
  }
  function getDirectiveValues(directiveDef, node, variableValues) {
    var directiveNode = node.directives && (0, _find.default)(node.directives, function(directive) {
      return directive.name.value === directiveDef.name;
    });
    if (directiveNode) {
      return getArgumentValues(directiveDef, directiveNode, variableValues);
    }
  }
  function hasOwnProperty(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }
});

// node_modules/graphql/execution/execute.js
var require_execute = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.execute = execute;
  exports.executeSync = executeSync;
  exports.assertValidExecutionArguments = assertValidExecutionArguments;
  exports.buildExecutionContext = buildExecutionContext;
  exports.collectFields = collectFields;
  exports.buildResolveInfo = buildResolveInfo;
  exports.getFieldDef = getFieldDef;
  exports.defaultFieldResolver = exports.defaultTypeResolver = undefined;
  var _inspect = _interopRequireDefault(require_inspect());
  var _memoize = _interopRequireDefault(require_memoize3());
  var _invariant = _interopRequireDefault(require_invariant());
  var _devAssert = _interopRequireDefault(require_devAssert());
  var _isPromise = _interopRequireDefault(require_isPromise());
  var _isObjectLike = _interopRequireDefault(require_isObjectLike());
  var _safeArrayFrom = _interopRequireDefault(require_safeArrayFrom());
  var _promiseReduce = _interopRequireDefault(require_promiseReduce());
  var _promiseForObject = _interopRequireDefault(require_promiseForObject());
  var _Path = require_Path();
  var _GraphQLError = require_GraphQLError();
  var _locatedError = require_locatedError();
  var _kinds = require_kinds();
  var _validate = require_validate();
  var _introspection = require_introspection();
  var _directives = require_directives();
  var _definition = require_definition();
  var _typeFromAST = require_typeFromAST();
  var _getOperationRootType = require_getOperationRootType();
  var _values = require_values();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function execute(argsOrSchema, document2, rootValue, contextValue, variableValues, operationName, fieldResolver, typeResolver) {
    return arguments.length === 1 ? executeImpl(argsOrSchema) : executeImpl({
      schema: argsOrSchema,
      document: document2,
      rootValue,
      contextValue,
      variableValues,
      operationName,
      fieldResolver,
      typeResolver
    });
  }
  function executeSync(args2) {
    var result = executeImpl(args2);
    if ((0, _isPromise.default)(result)) {
      throw new Error("GraphQL execution failed to complete synchronously.");
    }
    return result;
  }
  function executeImpl(args2) {
    var { schema, document: document2, rootValue, contextValue, variableValues, operationName, fieldResolver, typeResolver } = args2;
    assertValidExecutionArguments(schema, document2, variableValues);
    var exeContext = buildExecutionContext(schema, document2, rootValue, contextValue, variableValues, operationName, fieldResolver, typeResolver);
    if (Array.isArray(exeContext)) {
      return {
        errors: exeContext
      };
    }
    var data = executeOperation(exeContext, exeContext.operation, rootValue);
    return buildResponse(exeContext, data);
  }
  function buildResponse(exeContext, data) {
    if ((0, _isPromise.default)(data)) {
      return data.then(function(resolved) {
        return buildResponse(exeContext, resolved);
      });
    }
    return exeContext.errors.length === 0 ? {
      data
    } : {
      errors: exeContext.errors,
      data
    };
  }
  function assertValidExecutionArguments(schema, document2, rawVariableValues) {
    document2 || (0, _devAssert.default)(0, "Must provide document.");
    (0, _validate.assertValidSchema)(schema);
    rawVariableValues == null || (0, _isObjectLike.default)(rawVariableValues) || (0, _devAssert.default)(0, "Variables must be provided as an Object where each property is a variable value. Perhaps look to see if an unparsed JSON string was provided.");
  }
  function buildExecutionContext(schema, document2, rootValue, contextValue, rawVariableValues, operationName, fieldResolver, typeResolver) {
    var _definition$name, _operation$variableDe;
    var operation;
    var fragments = Object.create(null);
    for (var _i2 = 0, _document$definitions2 = document2.definitions;_i2 < _document$definitions2.length; _i2++) {
      var definition = _document$definitions2[_i2];
      switch (definition.kind) {
        case _kinds.Kind.OPERATION_DEFINITION:
          if (operationName == null) {
            if (operation !== undefined) {
              return [new _GraphQLError.GraphQLError("Must provide operation name if query contains multiple operations.")];
            }
            operation = definition;
          } else if (((_definition$name = definition.name) === null || _definition$name === undefined ? undefined : _definition$name.value) === operationName) {
            operation = definition;
          }
          break;
        case _kinds.Kind.FRAGMENT_DEFINITION:
          fragments[definition.name.value] = definition;
          break;
      }
    }
    if (!operation) {
      if (operationName != null) {
        return [new _GraphQLError.GraphQLError('Unknown operation named "'.concat(operationName, '".'))];
      }
      return [new _GraphQLError.GraphQLError("Must provide an operation.")];
    }
    var variableDefinitions = (_operation$variableDe = operation.variableDefinitions) !== null && _operation$variableDe !== undefined ? _operation$variableDe : [];
    var coercedVariableValues = (0, _values.getVariableValues)(schema, variableDefinitions, rawVariableValues !== null && rawVariableValues !== undefined ? rawVariableValues : {}, {
      maxErrors: 50
    });
    if (coercedVariableValues.errors) {
      return coercedVariableValues.errors;
    }
    return {
      schema,
      fragments,
      rootValue,
      contextValue,
      operation,
      variableValues: coercedVariableValues.coerced,
      fieldResolver: fieldResolver !== null && fieldResolver !== undefined ? fieldResolver : defaultFieldResolver,
      typeResolver: typeResolver !== null && typeResolver !== undefined ? typeResolver : defaultTypeResolver,
      errors: []
    };
  }
  function executeOperation(exeContext, operation, rootValue) {
    var type = (0, _getOperationRootType.getOperationRootType)(exeContext.schema, operation);
    var fields = collectFields(exeContext, type, operation.selectionSet, Object.create(null), Object.create(null));
    var path = undefined;
    try {
      var result = operation.operation === "mutation" ? executeFieldsSerially(exeContext, type, rootValue, path, fields) : executeFields(exeContext, type, rootValue, path, fields);
      if ((0, _isPromise.default)(result)) {
        return result.then(undefined, function(error) {
          exeContext.errors.push(error);
          return Promise.resolve(null);
        });
      }
      return result;
    } catch (error) {
      exeContext.errors.push(error);
      return null;
    }
  }
  function executeFieldsSerially(exeContext, parentType, sourceValue, path, fields) {
    return (0, _promiseReduce.default)(Object.keys(fields), function(results, responseName) {
      var fieldNodes = fields[responseName];
      var fieldPath = (0, _Path.addPath)(path, responseName, parentType.name);
      var result = resolveField(exeContext, parentType, sourceValue, fieldNodes, fieldPath);
      if (result === undefined) {
        return results;
      }
      if ((0, _isPromise.default)(result)) {
        return result.then(function(resolvedResult) {
          results[responseName] = resolvedResult;
          return results;
        });
      }
      results[responseName] = result;
      return results;
    }, Object.create(null));
  }
  function executeFields(exeContext, parentType, sourceValue, path, fields) {
    var results = Object.create(null);
    var containsPromise = false;
    try {
      for (var _i4 = 0, _Object$keys2 = Object.keys(fields);_i4 < _Object$keys2.length; _i4++) {
        var responseName = _Object$keys2[_i4];
        var fieldNodes = fields[responseName];
        var fieldPath = (0, _Path.addPath)(path, responseName, parentType.name);
        var result = resolveField(exeContext, parentType, sourceValue, fieldNodes, fieldPath);
        if (result !== undefined) {
          results[responseName] = result;
          if ((0, _isPromise.default)(result)) {
            containsPromise = true;
          }
        }
      }
    } catch (error) {
      if (containsPromise) {
        return (0, _promiseForObject.default)(results).finally(function() {
          throw error;
        });
      }
      throw error;
    }
    if (!containsPromise) {
      return results;
    }
    return (0, _promiseForObject.default)(results);
  }
  function collectFields(exeContext, runtimeType, selectionSet, fields, visitedFragmentNames) {
    for (var _i6 = 0, _selectionSet$selecti2 = selectionSet.selections;_i6 < _selectionSet$selecti2.length; _i6++) {
      var selection = _selectionSet$selecti2[_i6];
      switch (selection.kind) {
        case _kinds.Kind.FIELD: {
          if (!shouldIncludeNode(exeContext, selection)) {
            continue;
          }
          var name = getFieldEntryKey(selection);
          if (!fields[name]) {
            fields[name] = [];
          }
          fields[name].push(selection);
          break;
        }
        case _kinds.Kind.INLINE_FRAGMENT: {
          if (!shouldIncludeNode(exeContext, selection) || !doesFragmentConditionMatch(exeContext, selection, runtimeType)) {
            continue;
          }
          collectFields(exeContext, runtimeType, selection.selectionSet, fields, visitedFragmentNames);
          break;
        }
        case _kinds.Kind.FRAGMENT_SPREAD: {
          var fragName = selection.name.value;
          if (visitedFragmentNames[fragName] || !shouldIncludeNode(exeContext, selection)) {
            continue;
          }
          visitedFragmentNames[fragName] = true;
          var fragment = exeContext.fragments[fragName];
          if (!fragment || !doesFragmentConditionMatch(exeContext, fragment, runtimeType)) {
            continue;
          }
          collectFields(exeContext, runtimeType, fragment.selectionSet, fields, visitedFragmentNames);
          break;
        }
      }
    }
    return fields;
  }
  function shouldIncludeNode(exeContext, node) {
    var skip = (0, _values.getDirectiveValues)(_directives.GraphQLSkipDirective, node, exeContext.variableValues);
    if ((skip === null || skip === undefined ? undefined : skip.if) === true) {
      return false;
    }
    var include = (0, _values.getDirectiveValues)(_directives.GraphQLIncludeDirective, node, exeContext.variableValues);
    if ((include === null || include === undefined ? undefined : include.if) === false) {
      return false;
    }
    return true;
  }
  function doesFragmentConditionMatch(exeContext, fragment, type) {
    var typeConditionNode = fragment.typeCondition;
    if (!typeConditionNode) {
      return true;
    }
    var conditionalType = (0, _typeFromAST.typeFromAST)(exeContext.schema, typeConditionNode);
    if (conditionalType === type) {
      return true;
    }
    if ((0, _definition.isAbstractType)(conditionalType)) {
      return exeContext.schema.isSubType(conditionalType, type);
    }
    return false;
  }
  function getFieldEntryKey(node) {
    return node.alias ? node.alias.value : node.name.value;
  }
  function resolveField(exeContext, parentType, source, fieldNodes, path) {
    var _fieldDef$resolve;
    var fieldNode = fieldNodes[0];
    var fieldName = fieldNode.name.value;
    var fieldDef = getFieldDef(exeContext.schema, parentType, fieldName);
    if (!fieldDef) {
      return;
    }
    var returnType = fieldDef.type;
    var resolveFn = (_fieldDef$resolve = fieldDef.resolve) !== null && _fieldDef$resolve !== undefined ? _fieldDef$resolve : exeContext.fieldResolver;
    var info = buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path);
    try {
      var args2 = (0, _values.getArgumentValues)(fieldDef, fieldNodes[0], exeContext.variableValues);
      var _contextValue = exeContext.contextValue;
      var result = resolveFn(source, args2, _contextValue, info);
      var completed;
      if ((0, _isPromise.default)(result)) {
        completed = result.then(function(resolved) {
          return completeValue(exeContext, returnType, fieldNodes, info, path, resolved);
        });
      } else {
        completed = completeValue(exeContext, returnType, fieldNodes, info, path, result);
      }
      if ((0, _isPromise.default)(completed)) {
        return completed.then(undefined, function(rawError) {
          var error2 = (0, _locatedError.locatedError)(rawError, fieldNodes, (0, _Path.pathToArray)(path));
          return handleFieldError(error2, returnType, exeContext);
        });
      }
      return completed;
    } catch (rawError) {
      var error = (0, _locatedError.locatedError)(rawError, fieldNodes, (0, _Path.pathToArray)(path));
      return handleFieldError(error, returnType, exeContext);
    }
  }
  function buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path) {
    return {
      fieldName: fieldDef.name,
      fieldNodes,
      returnType: fieldDef.type,
      parentType,
      path,
      schema: exeContext.schema,
      fragments: exeContext.fragments,
      rootValue: exeContext.rootValue,
      operation: exeContext.operation,
      variableValues: exeContext.variableValues
    };
  }
  function handleFieldError(error, returnType, exeContext) {
    if ((0, _definition.isNonNullType)(returnType)) {
      throw error;
    }
    exeContext.errors.push(error);
    return null;
  }
  function completeValue(exeContext, returnType, fieldNodes, info, path, result) {
    if (result instanceof Error) {
      throw result;
    }
    if ((0, _definition.isNonNullType)(returnType)) {
      var completed = completeValue(exeContext, returnType.ofType, fieldNodes, info, path, result);
      if (completed === null) {
        throw new Error("Cannot return null for non-nullable field ".concat(info.parentType.name, ".").concat(info.fieldName, "."));
      }
      return completed;
    }
    if (result == null) {
      return null;
    }
    if ((0, _definition.isListType)(returnType)) {
      return completeListValue(exeContext, returnType, fieldNodes, info, path, result);
    }
    if ((0, _definition.isLeafType)(returnType)) {
      return completeLeafValue(returnType, result);
    }
    if ((0, _definition.isAbstractType)(returnType)) {
      return completeAbstractValue(exeContext, returnType, fieldNodes, info, path, result);
    }
    if ((0, _definition.isObjectType)(returnType)) {
      return completeObjectValue(exeContext, returnType, fieldNodes, info, path, result);
    }
    (0, _invariant.default)(0, "Cannot complete value of unexpected output type: " + (0, _inspect.default)(returnType));
  }
  function completeListValue(exeContext, returnType, fieldNodes, info, path, result) {
    var itemType = returnType.ofType;
    var containsPromise = false;
    var completedResults = (0, _safeArrayFrom.default)(result, function(item, index) {
      var itemPath = (0, _Path.addPath)(path, index, undefined);
      try {
        var completedItem;
        if ((0, _isPromise.default)(item)) {
          completedItem = item.then(function(resolved) {
            return completeValue(exeContext, itemType, fieldNodes, info, itemPath, resolved);
          });
        } else {
          completedItem = completeValue(exeContext, itemType, fieldNodes, info, itemPath, item);
        }
        if ((0, _isPromise.default)(completedItem)) {
          containsPromise = true;
          return completedItem.then(undefined, function(rawError) {
            var error2 = (0, _locatedError.locatedError)(rawError, fieldNodes, (0, _Path.pathToArray)(itemPath));
            return handleFieldError(error2, itemType, exeContext);
          });
        }
        return completedItem;
      } catch (rawError) {
        var error = (0, _locatedError.locatedError)(rawError, fieldNodes, (0, _Path.pathToArray)(itemPath));
        return handleFieldError(error, itemType, exeContext);
      }
    });
    if (completedResults == null) {
      throw new _GraphQLError.GraphQLError('Expected Iterable, but did not find one for field "'.concat(info.parentType.name, ".").concat(info.fieldName, '".'));
    }
    return containsPromise ? Promise.all(completedResults) : completedResults;
  }
  function completeLeafValue(returnType, result) {
    var serializedResult = returnType.serialize(result);
    if (serializedResult === undefined) {
      throw new Error('Expected a value of type "'.concat((0, _inspect.default)(returnType), '" but ') + "received: ".concat((0, _inspect.default)(result)));
    }
    return serializedResult;
  }
  function completeAbstractValue(exeContext, returnType, fieldNodes, info, path, result) {
    var _returnType$resolveTy;
    var resolveTypeFn = (_returnType$resolveTy = returnType.resolveType) !== null && _returnType$resolveTy !== undefined ? _returnType$resolveTy : exeContext.typeResolver;
    var contextValue = exeContext.contextValue;
    var runtimeType = resolveTypeFn(result, contextValue, info, returnType);
    if ((0, _isPromise.default)(runtimeType)) {
      return runtimeType.then(function(resolvedRuntimeType) {
        return completeObjectValue(exeContext, ensureValidRuntimeType(resolvedRuntimeType, exeContext, returnType, fieldNodes, info, result), fieldNodes, info, path, result);
      });
    }
    return completeObjectValue(exeContext, ensureValidRuntimeType(runtimeType, exeContext, returnType, fieldNodes, info, result), fieldNodes, info, path, result);
  }
  function ensureValidRuntimeType(runtimeTypeOrName, exeContext, returnType, fieldNodes, info, result) {
    if (runtimeTypeOrName == null) {
      throw new _GraphQLError.GraphQLError('Abstract type "'.concat(returnType.name, '" must resolve to an Object type at runtime for field "').concat(info.parentType.name, ".").concat(info.fieldName, '". Either the "').concat(returnType.name, '" type should provide a "resolveType" function or each possible type should provide an "isTypeOf" function.'), fieldNodes);
    }
    var runtimeTypeName = (0, _definition.isNamedType)(runtimeTypeOrName) ? runtimeTypeOrName.name : runtimeTypeOrName;
    if (typeof runtimeTypeName !== "string") {
      throw new _GraphQLError.GraphQLError('Abstract type "'.concat(returnType.name, '" must resolve to an Object type at runtime for field "').concat(info.parentType.name, ".").concat(info.fieldName, '" with ') + "value ".concat((0, _inspect.default)(result), ', received "').concat((0, _inspect.default)(runtimeTypeOrName), '".'));
    }
    var runtimeType = exeContext.schema.getType(runtimeTypeName);
    if (runtimeType == null) {
      throw new _GraphQLError.GraphQLError('Abstract type "'.concat(returnType.name, '" was resolve to a type "').concat(runtimeTypeName, '" that does not exist inside schema.'), fieldNodes);
    }
    if (!(0, _definition.isObjectType)(runtimeType)) {
      throw new _GraphQLError.GraphQLError('Abstract type "'.concat(returnType.name, '" was resolve to a non-object type "').concat(runtimeTypeName, '".'), fieldNodes);
    }
    if (!exeContext.schema.isSubType(returnType, runtimeType)) {
      throw new _GraphQLError.GraphQLError('Runtime Object type "'.concat(runtimeType.name, '" is not a possible type for "').concat(returnType.name, '".'), fieldNodes);
    }
    return runtimeType;
  }
  function completeObjectValue(exeContext, returnType, fieldNodes, info, path, result) {
    if (returnType.isTypeOf) {
      var isTypeOf = returnType.isTypeOf(result, exeContext.contextValue, info);
      if ((0, _isPromise.default)(isTypeOf)) {
        return isTypeOf.then(function(resolvedIsTypeOf) {
          if (!resolvedIsTypeOf) {
            throw invalidReturnTypeError(returnType, result, fieldNodes);
          }
          return collectAndExecuteSubfields(exeContext, returnType, fieldNodes, path, result);
        });
      }
      if (!isTypeOf) {
        throw invalidReturnTypeError(returnType, result, fieldNodes);
      }
    }
    return collectAndExecuteSubfields(exeContext, returnType, fieldNodes, path, result);
  }
  function invalidReturnTypeError(returnType, result, fieldNodes) {
    return new _GraphQLError.GraphQLError('Expected value of type "'.concat(returnType.name, '" but got: ').concat((0, _inspect.default)(result), "."), fieldNodes);
  }
  function collectAndExecuteSubfields(exeContext, returnType, fieldNodes, path, result) {
    var subFieldNodes = collectSubfields(exeContext, returnType, fieldNodes);
    return executeFields(exeContext, returnType, result, path, subFieldNodes);
  }
  var collectSubfields = (0, _memoize.default)(_collectSubfields);
  function _collectSubfields(exeContext, returnType, fieldNodes) {
    var subFieldNodes = Object.create(null);
    var visitedFragmentNames = Object.create(null);
    for (var _i8 = 0;_i8 < fieldNodes.length; _i8++) {
      var node = fieldNodes[_i8];
      if (node.selectionSet) {
        subFieldNodes = collectFields(exeContext, returnType, node.selectionSet, subFieldNodes, visitedFragmentNames);
      }
    }
    return subFieldNodes;
  }
  var defaultTypeResolver = function defaultTypeResolver(value, contextValue, info, abstractType) {
    if ((0, _isObjectLike.default)(value) && typeof value.__typename === "string") {
      return value.__typename;
    }
    var possibleTypes = info.schema.getPossibleTypes(abstractType);
    var promisedIsTypeOfResults = [];
    for (var i = 0;i < possibleTypes.length; i++) {
      var type = possibleTypes[i];
      if (type.isTypeOf) {
        var isTypeOfResult = type.isTypeOf(value, contextValue, info);
        if ((0, _isPromise.default)(isTypeOfResult)) {
          promisedIsTypeOfResults[i] = isTypeOfResult;
        } else if (isTypeOfResult) {
          return type.name;
        }
      }
    }
    if (promisedIsTypeOfResults.length) {
      return Promise.all(promisedIsTypeOfResults).then(function(isTypeOfResults) {
        for (var _i9 = 0;_i9 < isTypeOfResults.length; _i9++) {
          if (isTypeOfResults[_i9]) {
            return possibleTypes[_i9].name;
          }
        }
      });
    }
  };
  exports.defaultTypeResolver = defaultTypeResolver;
  var defaultFieldResolver = function defaultFieldResolver(source, args2, contextValue, info) {
    if ((0, _isObjectLike.default)(source) || typeof source === "function") {
      var property = source[info.fieldName];
      if (typeof property === "function") {
        return source[info.fieldName](args2, contextValue, info);
      }
      return property;
    }
  };
  exports.defaultFieldResolver = defaultFieldResolver;
  function getFieldDef(schema, parentType, fieldName) {
    if (fieldName === _introspection.SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {
      return _introspection.SchemaMetaFieldDef;
    } else if (fieldName === _introspection.TypeMetaFieldDef.name && schema.getQueryType() === parentType) {
      return _introspection.TypeMetaFieldDef;
    } else if (fieldName === _introspection.TypeNameMetaFieldDef.name) {
      return _introspection.TypeNameMetaFieldDef;
    }
    return parentType.getFields()[fieldName];
  }
});

// node_modules/graphql/graphql.js
var require_graphql = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.graphql = graphql;
  exports.graphqlSync = graphqlSync;
  var _isPromise = _interopRequireDefault(require_isPromise());
  var _parser = require_parser();
  var _validate = require_validate2();
  var _validate2 = require_validate();
  var _execute = require_execute();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function graphql(argsOrSchema, source, rootValue, contextValue, variableValues, operationName, fieldResolver, typeResolver) {
    var _arguments = arguments;
    return new Promise(function(resolve) {
      return resolve(_arguments.length === 1 ? graphqlImpl(argsOrSchema) : graphqlImpl({
        schema: argsOrSchema,
        source,
        rootValue,
        contextValue,
        variableValues,
        operationName,
        fieldResolver,
        typeResolver
      }));
    });
  }
  function graphqlSync(argsOrSchema, source, rootValue, contextValue, variableValues, operationName, fieldResolver, typeResolver) {
    var result = arguments.length === 1 ? graphqlImpl(argsOrSchema) : graphqlImpl({
      schema: argsOrSchema,
      source,
      rootValue,
      contextValue,
      variableValues,
      operationName,
      fieldResolver,
      typeResolver
    });
    if ((0, _isPromise.default)(result)) {
      throw new Error("GraphQL execution failed to complete synchronously.");
    }
    return result;
  }
  function graphqlImpl(args2) {
    var { schema, source, rootValue, contextValue, variableValues, operationName, fieldResolver, typeResolver } = args2;
    var schemaValidationErrors = (0, _validate2.validateSchema)(schema);
    if (schemaValidationErrors.length > 0) {
      return {
        errors: schemaValidationErrors
      };
    }
    var document2;
    try {
      document2 = (0, _parser.parse)(source);
    } catch (syntaxError) {
      return {
        errors: [syntaxError]
      };
    }
    var validationErrors = (0, _validate.validate)(schema, document2);
    if (validationErrors.length > 0) {
      return {
        errors: validationErrors
      };
    }
    return (0, _execute.execute)({
      schema,
      document: document2,
      rootValue,
      contextValue,
      variableValues,
      operationName,
      fieldResolver,
      typeResolver
    });
  }
});

// node_modules/graphql/type/index.js
var require_type = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "isSchema", {
    enumerable: true,
    get: function get() {
      return _schema.isSchema;
    }
  });
  Object.defineProperty(exports, "assertSchema", {
    enumerable: true,
    get: function get() {
      return _schema.assertSchema;
    }
  });
  Object.defineProperty(exports, "GraphQLSchema", {
    enumerable: true,
    get: function get() {
      return _schema.GraphQLSchema;
    }
  });
  Object.defineProperty(exports, "isType", {
    enumerable: true,
    get: function get() {
      return _definition.isType;
    }
  });
  Object.defineProperty(exports, "isScalarType", {
    enumerable: true,
    get: function get() {
      return _definition.isScalarType;
    }
  });
  Object.defineProperty(exports, "isObjectType", {
    enumerable: true,
    get: function get() {
      return _definition.isObjectType;
    }
  });
  Object.defineProperty(exports, "isInterfaceType", {
    enumerable: true,
    get: function get() {
      return _definition.isInterfaceType;
    }
  });
  Object.defineProperty(exports, "isUnionType", {
    enumerable: true,
    get: function get() {
      return _definition.isUnionType;
    }
  });
  Object.defineProperty(exports, "isEnumType", {
    enumerable: true,
    get: function get() {
      return _definition.isEnumType;
    }
  });
  Object.defineProperty(exports, "isInputObjectType", {
    enumerable: true,
    get: function get() {
      return _definition.isInputObjectType;
    }
  });
  Object.defineProperty(exports, "isListType", {
    enumerable: true,
    get: function get() {
      return _definition.isListType;
    }
  });
  Object.defineProperty(exports, "isNonNullType", {
    enumerable: true,
    get: function get() {
      return _definition.isNonNullType;
    }
  });
  Object.defineProperty(exports, "isInputType", {
    enumerable: true,
    get: function get() {
      return _definition.isInputType;
    }
  });
  Object.defineProperty(exports, "isOutputType", {
    enumerable: true,
    get: function get() {
      return _definition.isOutputType;
    }
  });
  Object.defineProperty(exports, "isLeafType", {
    enumerable: true,
    get: function get() {
      return _definition.isLeafType;
    }
  });
  Object.defineProperty(exports, "isCompositeType", {
    enumerable: true,
    get: function get() {
      return _definition.isCompositeType;
    }
  });
  Object.defineProperty(exports, "isAbstractType", {
    enumerable: true,
    get: function get() {
      return _definition.isAbstractType;
    }
  });
  Object.defineProperty(exports, "isWrappingType", {
    enumerable: true,
    get: function get() {
      return _definition.isWrappingType;
    }
  });
  Object.defineProperty(exports, "isNullableType", {
    enumerable: true,
    get: function get() {
      return _definition.isNullableType;
    }
  });
  Object.defineProperty(exports, "isNamedType", {
    enumerable: true,
    get: function get() {
      return _definition.isNamedType;
    }
  });
  Object.defineProperty(exports, "isRequiredArgument", {
    enumerable: true,
    get: function get() {
      return _definition.isRequiredArgument;
    }
  });
  Object.defineProperty(exports, "isRequiredInputField", {
    enumerable: true,
    get: function get() {
      return _definition.isRequiredInputField;
    }
  });
  Object.defineProperty(exports, "assertType", {
    enumerable: true,
    get: function get() {
      return _definition.assertType;
    }
  });
  Object.defineProperty(exports, "assertScalarType", {
    enumerable: true,
    get: function get() {
      return _definition.assertScalarType;
    }
  });
  Object.defineProperty(exports, "assertObjectType", {
    enumerable: true,
    get: function get() {
      return _definition.assertObjectType;
    }
  });
  Object.defineProperty(exports, "assertInterfaceType", {
    enumerable: true,
    get: function get() {
      return _definition.assertInterfaceType;
    }
  });
  Object.defineProperty(exports, "assertUnionType", {
    enumerable: true,
    get: function get() {
      return _definition.assertUnionType;
    }
  });
  Object.defineProperty(exports, "assertEnumType", {
    enumerable: true,
    get: function get() {
      return _definition.assertEnumType;
    }
  });
  Object.defineProperty(exports, "assertInputObjectType", {
    enumerable: true,
    get: function get() {
      return _definition.assertInputObjectType;
    }
  });
  Object.defineProperty(exports, "assertListType", {
    enumerable: true,
    get: function get() {
      return _definition.assertListType;
    }
  });
  Object.defineProperty(exports, "assertNonNullType", {
    enumerable: true,
    get: function get() {
      return _definition.assertNonNullType;
    }
  });
  Object.defineProperty(exports, "assertInputType", {
    enumerable: true,
    get: function get() {
      return _definition.assertInputType;
    }
  });
  Object.defineProperty(exports, "assertOutputType", {
    enumerable: true,
    get: function get() {
      return _definition.assertOutputType;
    }
  });
  Object.defineProperty(exports, "assertLeafType", {
    enumerable: true,
    get: function get() {
      return _definition.assertLeafType;
    }
  });
  Object.defineProperty(exports, "assertCompositeType", {
    enumerable: true,
    get: function get() {
      return _definition.assertCompositeType;
    }
  });
  Object.defineProperty(exports, "assertAbstractType", {
    enumerable: true,
    get: function get() {
      return _definition.assertAbstractType;
    }
  });
  Object.defineProperty(exports, "assertWrappingType", {
    enumerable: true,
    get: function get() {
      return _definition.assertWrappingType;
    }
  });
  Object.defineProperty(exports, "assertNullableType", {
    enumerable: true,
    get: function get() {
      return _definition.assertNullableType;
    }
  });
  Object.defineProperty(exports, "assertNamedType", {
    enumerable: true,
    get: function get() {
      return _definition.assertNamedType;
    }
  });
  Object.defineProperty(exports, "getNullableType", {
    enumerable: true,
    get: function get() {
      return _definition.getNullableType;
    }
  });
  Object.defineProperty(exports, "getNamedType", {
    enumerable: true,
    get: function get() {
      return _definition.getNamedType;
    }
  });
  Object.defineProperty(exports, "GraphQLScalarType", {
    enumerable: true,
    get: function get() {
      return _definition.GraphQLScalarType;
    }
  });
  Object.defineProperty(exports, "GraphQLObjectType", {
    enumerable: true,
    get: function get() {
      return _definition.GraphQLObjectType;
    }
  });
  Object.defineProperty(exports, "GraphQLInterfaceType", {
    enumerable: true,
    get: function get() {
      return _definition.GraphQLInterfaceType;
    }
  });
  Object.defineProperty(exports, "GraphQLUnionType", {
    enumerable: true,
    get: function get() {
      return _definition.GraphQLUnionType;
    }
  });
  Object.defineProperty(exports, "GraphQLEnumType", {
    enumerable: true,
    get: function get() {
      return _definition.GraphQLEnumType;
    }
  });
  Object.defineProperty(exports, "GraphQLInputObjectType", {
    enumerable: true,
    get: function get() {
      return _definition.GraphQLInputObjectType;
    }
  });
  Object.defineProperty(exports, "GraphQLList", {
    enumerable: true,
    get: function get() {
      return _definition.GraphQLList;
    }
  });
  Object.defineProperty(exports, "GraphQLNonNull", {
    enumerable: true,
    get: function get() {
      return _definition.GraphQLNonNull;
    }
  });
  Object.defineProperty(exports, "isDirective", {
    enumerable: true,
    get: function get() {
      return _directives.isDirective;
    }
  });
  Object.defineProperty(exports, "assertDirective", {
    enumerable: true,
    get: function get() {
      return _directives.assertDirective;
    }
  });
  Object.defineProperty(exports, "GraphQLDirective", {
    enumerable: true,
    get: function get() {
      return _directives.GraphQLDirective;
    }
  });
  Object.defineProperty(exports, "isSpecifiedDirective", {
    enumerable: true,
    get: function get() {
      return _directives.isSpecifiedDirective;
    }
  });
  Object.defineProperty(exports, "specifiedDirectives", {
    enumerable: true,
    get: function get() {
      return _directives.specifiedDirectives;
    }
  });
  Object.defineProperty(exports, "GraphQLIncludeDirective", {
    enumerable: true,
    get: function get() {
      return _directives.GraphQLIncludeDirective;
    }
  });
  Object.defineProperty(exports, "GraphQLSkipDirective", {
    enumerable: true,
    get: function get() {
      return _directives.GraphQLSkipDirective;
    }
  });
  Object.defineProperty(exports, "GraphQLDeprecatedDirective", {
    enumerable: true,
    get: function get() {
      return _directives.GraphQLDeprecatedDirective;
    }
  });
  Object.defineProperty(exports, "GraphQLSpecifiedByDirective", {
    enumerable: true,
    get: function get() {
      return _directives.GraphQLSpecifiedByDirective;
    }
  });
  Object.defineProperty(exports, "DEFAULT_DEPRECATION_REASON", {
    enumerable: true,
    get: function get() {
      return _directives.DEFAULT_DEPRECATION_REASON;
    }
  });
  Object.defineProperty(exports, "isSpecifiedScalarType", {
    enumerable: true,
    get: function get() {
      return _scalars.isSpecifiedScalarType;
    }
  });
  Object.defineProperty(exports, "specifiedScalarTypes", {
    enumerable: true,
    get: function get() {
      return _scalars.specifiedScalarTypes;
    }
  });
  Object.defineProperty(exports, "GraphQLInt", {
    enumerable: true,
    get: function get() {
      return _scalars.GraphQLInt;
    }
  });
  Object.defineProperty(exports, "GraphQLFloat", {
    enumerable: true,
    get: function get() {
      return _scalars.GraphQLFloat;
    }
  });
  Object.defineProperty(exports, "GraphQLString", {
    enumerable: true,
    get: function get() {
      return _scalars.GraphQLString;
    }
  });
  Object.defineProperty(exports, "GraphQLBoolean", {
    enumerable: true,
    get: function get() {
      return _scalars.GraphQLBoolean;
    }
  });
  Object.defineProperty(exports, "GraphQLID", {
    enumerable: true,
    get: function get() {
      return _scalars.GraphQLID;
    }
  });
  Object.defineProperty(exports, "isIntrospectionType", {
    enumerable: true,
    get: function get() {
      return _introspection.isIntrospectionType;
    }
  });
  Object.defineProperty(exports, "introspectionTypes", {
    enumerable: true,
    get: function get() {
      return _introspection.introspectionTypes;
    }
  });
  Object.defineProperty(exports, "__Schema", {
    enumerable: true,
    get: function get() {
      return _introspection.__Schema;
    }
  });
  Object.defineProperty(exports, "__Directive", {
    enumerable: true,
    get: function get() {
      return _introspection.__Directive;
    }
  });
  Object.defineProperty(exports, "__DirectiveLocation", {
    enumerable: true,
    get: function get() {
      return _introspection.__DirectiveLocation;
    }
  });
  Object.defineProperty(exports, "__Type", {
    enumerable: true,
    get: function get() {
      return _introspection.__Type;
    }
  });
  Object.defineProperty(exports, "__Field", {
    enumerable: true,
    get: function get() {
      return _introspection.__Field;
    }
  });
  Object.defineProperty(exports, "__InputValue", {
    enumerable: true,
    get: function get() {
      return _introspection.__InputValue;
    }
  });
  Object.defineProperty(exports, "__EnumValue", {
    enumerable: true,
    get: function get() {
      return _introspection.__EnumValue;
    }
  });
  Object.defineProperty(exports, "__TypeKind", {
    enumerable: true,
    get: function get() {
      return _introspection.__TypeKind;
    }
  });
  Object.defineProperty(exports, "TypeKind", {
    enumerable: true,
    get: function get() {
      return _introspection.TypeKind;
    }
  });
  Object.defineProperty(exports, "SchemaMetaFieldDef", {
    enumerable: true,
    get: function get() {
      return _introspection.SchemaMetaFieldDef;
    }
  });
  Object.defineProperty(exports, "TypeMetaFieldDef", {
    enumerable: true,
    get: function get() {
      return _introspection.TypeMetaFieldDef;
    }
  });
  Object.defineProperty(exports, "TypeNameMetaFieldDef", {
    enumerable: true,
    get: function get() {
      return _introspection.TypeNameMetaFieldDef;
    }
  });
  Object.defineProperty(exports, "validateSchema", {
    enumerable: true,
    get: function get() {
      return _validate.validateSchema;
    }
  });
  Object.defineProperty(exports, "assertValidSchema", {
    enumerable: true,
    get: function get() {
      return _validate.assertValidSchema;
    }
  });
  var _schema = require_schema();
  var _definition = require_definition();
  var _directives = require_directives();
  var _scalars = require_scalars();
  var _introspection = require_introspection();
  var _validate = require_validate();
});

// node_modules/graphql/language/index.js
var require_language2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "Source", {
    enumerable: true,
    get: function get() {
      return _source.Source;
    }
  });
  Object.defineProperty(exports, "getLocation", {
    enumerable: true,
    get: function get() {
      return _location.getLocation;
    }
  });
  Object.defineProperty(exports, "printLocation", {
    enumerable: true,
    get: function get() {
      return _printLocation.printLocation;
    }
  });
  Object.defineProperty(exports, "printSourceLocation", {
    enumerable: true,
    get: function get() {
      return _printLocation.printSourceLocation;
    }
  });
  Object.defineProperty(exports, "Kind", {
    enumerable: true,
    get: function get() {
      return _kinds.Kind;
    }
  });
  Object.defineProperty(exports, "TokenKind", {
    enumerable: true,
    get: function get() {
      return _tokenKind.TokenKind;
    }
  });
  Object.defineProperty(exports, "Lexer", {
    enumerable: true,
    get: function get() {
      return _lexer.Lexer;
    }
  });
  Object.defineProperty(exports, "parse", {
    enumerable: true,
    get: function get() {
      return _parser.parse;
    }
  });
  Object.defineProperty(exports, "parseValue", {
    enumerable: true,
    get: function get() {
      return _parser.parseValue;
    }
  });
  Object.defineProperty(exports, "parseType", {
    enumerable: true,
    get: function get() {
      return _parser.parseType;
    }
  });
  Object.defineProperty(exports, "print", {
    enumerable: true,
    get: function get() {
      return _printer.print;
    }
  });
  Object.defineProperty(exports, "visit", {
    enumerable: true,
    get: function get() {
      return _visitor.visit;
    }
  });
  Object.defineProperty(exports, "visitInParallel", {
    enumerable: true,
    get: function get() {
      return _visitor.visitInParallel;
    }
  });
  Object.defineProperty(exports, "getVisitFn", {
    enumerable: true,
    get: function get() {
      return _visitor.getVisitFn;
    }
  });
  Object.defineProperty(exports, "BREAK", {
    enumerable: true,
    get: function get() {
      return _visitor.BREAK;
    }
  });
  Object.defineProperty(exports, "Location", {
    enumerable: true,
    get: function get() {
      return _ast.Location;
    }
  });
  Object.defineProperty(exports, "Token", {
    enumerable: true,
    get: function get() {
      return _ast.Token;
    }
  });
  Object.defineProperty(exports, "isDefinitionNode", {
    enumerable: true,
    get: function get() {
      return _predicates.isDefinitionNode;
    }
  });
  Object.defineProperty(exports, "isExecutableDefinitionNode", {
    enumerable: true,
    get: function get() {
      return _predicates.isExecutableDefinitionNode;
    }
  });
  Object.defineProperty(exports, "isSelectionNode", {
    enumerable: true,
    get: function get() {
      return _predicates.isSelectionNode;
    }
  });
  Object.defineProperty(exports, "isValueNode", {
    enumerable: true,
    get: function get() {
      return _predicates.isValueNode;
    }
  });
  Object.defineProperty(exports, "isTypeNode", {
    enumerable: true,
    get: function get() {
      return _predicates.isTypeNode;
    }
  });
  Object.defineProperty(exports, "isTypeSystemDefinitionNode", {
    enumerable: true,
    get: function get() {
      return _predicates.isTypeSystemDefinitionNode;
    }
  });
  Object.defineProperty(exports, "isTypeDefinitionNode", {
    enumerable: true,
    get: function get() {
      return _predicates.isTypeDefinitionNode;
    }
  });
  Object.defineProperty(exports, "isTypeSystemExtensionNode", {
    enumerable: true,
    get: function get() {
      return _predicates.isTypeSystemExtensionNode;
    }
  });
  Object.defineProperty(exports, "isTypeExtensionNode", {
    enumerable: true,
    get: function get() {
      return _predicates.isTypeExtensionNode;
    }
  });
  Object.defineProperty(exports, "DirectiveLocation", {
    enumerable: true,
    get: function get() {
      return _directiveLocation.DirectiveLocation;
    }
  });
  var _source = require_source();
  var _location = require_location();
  var _printLocation = require_printLocation();
  var _kinds = require_kinds();
  var _tokenKind = require_tokenKind();
  var _lexer = require_lexer();
  var _parser = require_parser();
  var _printer = require_printer();
  var _visitor = require_visitor();
  var _ast = require_ast();
  var _predicates = require_predicates();
  var _directiveLocation = require_directiveLocation();
});

// node_modules/graphql/execution/index.js
var require_execution = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "responsePathAsArray", {
    enumerable: true,
    get: function get() {
      return _Path.pathToArray;
    }
  });
  Object.defineProperty(exports, "execute", {
    enumerable: true,
    get: function get() {
      return _execute.execute;
    }
  });
  Object.defineProperty(exports, "executeSync", {
    enumerable: true,
    get: function get() {
      return _execute.executeSync;
    }
  });
  Object.defineProperty(exports, "defaultFieldResolver", {
    enumerable: true,
    get: function get() {
      return _execute.defaultFieldResolver;
    }
  });
  Object.defineProperty(exports, "defaultTypeResolver", {
    enumerable: true,
    get: function get() {
      return _execute.defaultTypeResolver;
    }
  });
  Object.defineProperty(exports, "getDirectiveValues", {
    enumerable: true,
    get: function get() {
      return _values.getDirectiveValues;
    }
  });
  var _Path = require_Path();
  var _execute = require_execute();
  var _values = require_values();
});

// node_modules/graphql/jsutils/isAsyncIterable.js
var require_isAsyncIterable = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isAsyncIterable;
  var _symbols = require_symbols();
  function isAsyncIterable(maybeAsyncIterable) {
    return typeof (maybeAsyncIterable === null || maybeAsyncIterable === undefined ? undefined : maybeAsyncIterable[_symbols.SYMBOL_ASYNC_ITERATOR]) === "function";
  }
});

// node_modules/graphql/subscription/mapAsyncIterator.js
var require_mapAsyncIterator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = mapAsyncIterator;
  var _symbols = require_symbols();
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function mapAsyncIterator(iterable, callback, rejectCallback) {
    var iteratorMethod = iterable[_symbols.SYMBOL_ASYNC_ITERATOR];
    var iterator = iteratorMethod.call(iterable);
    var $return;
    var abruptClose;
    if (typeof iterator.return === "function") {
      $return = iterator.return;
      abruptClose = function abruptClose(error) {
        var rethrow = function rethrow() {
          return Promise.reject(error);
        };
        return $return.call(iterator).then(rethrow, rethrow);
      };
    }
    function mapResult(result) {
      return result.done ? result : asyncMapValue(result.value, callback).then(iteratorResult, abruptClose);
    }
    var mapReject;
    if (rejectCallback) {
      var reject = rejectCallback;
      mapReject = function mapReject(error) {
        return asyncMapValue(error, reject).then(iteratorResult, abruptClose);
      };
    }
    return _defineProperty({
      next: function next() {
        return iterator.next().then(mapResult, mapReject);
      },
      return: function _return() {
        return $return ? $return.call(iterator).then(mapResult, mapReject) : Promise.resolve({
          value: undefined,
          done: true
        });
      },
      throw: function _throw(error) {
        if (typeof iterator.throw === "function") {
          return iterator.throw(error).then(mapResult, mapReject);
        }
        return Promise.reject(error).catch(abruptClose);
      }
    }, _symbols.SYMBOL_ASYNC_ITERATOR, function() {
      return this;
    });
  }
  function asyncMapValue(value, callback) {
    return new Promise(function(resolve) {
      return resolve(callback(value));
    });
  }
  function iteratorResult(value) {
    return {
      value,
      done: false
    };
  }
});

// node_modules/graphql/subscription/subscribe.js
var require_subscribe = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.subscribe = subscribe;
  exports.createSourceEventStream = createSourceEventStream;
  var _inspect = _interopRequireDefault(require_inspect());
  var _isAsyncIterable = _interopRequireDefault(require_isAsyncIterable());
  var _Path = require_Path();
  var _GraphQLError = require_GraphQLError();
  var _locatedError = require_locatedError();
  var _values = require_values();
  var _execute = require_execute();
  var _getOperationRootType = require_getOperationRootType();
  var _mapAsyncIterator = _interopRequireDefault(require_mapAsyncIterator());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function subscribe(argsOrSchema, document2, rootValue, contextValue, variableValues, operationName, fieldResolver, subscribeFieldResolver) {
    return arguments.length === 1 ? subscribeImpl(argsOrSchema) : subscribeImpl({
      schema: argsOrSchema,
      document: document2,
      rootValue,
      contextValue,
      variableValues,
      operationName,
      fieldResolver,
      subscribeFieldResolver
    });
  }
  function reportGraphQLError(error) {
    if (error instanceof _GraphQLError.GraphQLError) {
      return {
        errors: [error]
      };
    }
    throw error;
  }
  function subscribeImpl(args2) {
    var { schema, document: document2, rootValue, contextValue, variableValues, operationName, fieldResolver, subscribeFieldResolver } = args2;
    var sourcePromise = createSourceEventStream(schema, document2, rootValue, contextValue, variableValues, operationName, subscribeFieldResolver);
    var mapSourceToResponse = function mapSourceToResponse(payload) {
      return (0, _execute.execute)({
        schema,
        document: document2,
        rootValue: payload,
        contextValue,
        variableValues,
        operationName,
        fieldResolver
      });
    };
    return sourcePromise.then(function(resultOrStream) {
      return (0, _isAsyncIterable.default)(resultOrStream) ? (0, _mapAsyncIterator.default)(resultOrStream, mapSourceToResponse, reportGraphQLError) : resultOrStream;
    });
  }
  function createSourceEventStream(schema, document2, rootValue, contextValue, variableValues, operationName, fieldResolver) {
    (0, _execute.assertValidExecutionArguments)(schema, document2, variableValues);
    return new Promise(function(resolve) {
      var exeContext = (0, _execute.buildExecutionContext)(schema, document2, rootValue, contextValue, variableValues, operationName, fieldResolver);
      resolve(Array.isArray(exeContext) ? {
        errors: exeContext
      } : executeSubscription(exeContext));
    }).catch(reportGraphQLError);
  }
  function executeSubscription(exeContext) {
    var { schema, operation, variableValues, rootValue } = exeContext;
    var type = (0, _getOperationRootType.getOperationRootType)(schema, operation);
    var fields = (0, _execute.collectFields)(exeContext, type, operation.selectionSet, Object.create(null), Object.create(null));
    var responseNames = Object.keys(fields);
    var responseName = responseNames[0];
    var fieldNodes = fields[responseName];
    var fieldNode = fieldNodes[0];
    var fieldName = fieldNode.name.value;
    var fieldDef = (0, _execute.getFieldDef)(schema, type, fieldName);
    if (!fieldDef) {
      throw new _GraphQLError.GraphQLError('The subscription field "'.concat(fieldName, '" is not defined.'), fieldNodes);
    }
    var path = (0, _Path.addPath)(undefined, responseName, type.name);
    var info = (0, _execute.buildResolveInfo)(exeContext, fieldDef, fieldNodes, type, path);
    return new Promise(function(resolveResult) {
      var _fieldDef$subscribe;
      var args2 = (0, _values.getArgumentValues)(fieldDef, fieldNodes[0], variableValues);
      var contextValue = exeContext.contextValue;
      var resolveFn = (_fieldDef$subscribe = fieldDef.subscribe) !== null && _fieldDef$subscribe !== undefined ? _fieldDef$subscribe : exeContext.fieldResolver;
      resolveResult(resolveFn(rootValue, args2, contextValue, info));
    }).then(function(eventStream) {
      if (eventStream instanceof Error) {
        throw (0, _locatedError.locatedError)(eventStream, fieldNodes, (0, _Path.pathToArray)(path));
      }
      if (!(0, _isAsyncIterable.default)(eventStream)) {
        throw new Error("Subscription field must return Async Iterable. " + "Received: ".concat((0, _inspect.default)(eventStream), "."));
      }
      return eventStream;
    }, function(error) {
      throw (0, _locatedError.locatedError)(error, fieldNodes, (0, _Path.pathToArray)(path));
    });
  }
});

// node_modules/graphql/subscription/index.js
var require_subscription = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "subscribe", {
    enumerable: true,
    get: function get() {
      return _subscribe.subscribe;
    }
  });
  Object.defineProperty(exports, "createSourceEventStream", {
    enumerable: true,
    get: function get() {
      return _subscribe.createSourceEventStream;
    }
  });
  var _subscribe = require_subscribe();
});

// node_modules/graphql/validation/rules/custom/NoDeprecatedCustomRule.js
var require_NoDeprecatedCustomRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.NoDeprecatedCustomRule = NoDeprecatedCustomRule;
  var _invariant = _interopRequireDefault(require_invariant());
  var _GraphQLError = require_GraphQLError();
  var _definition = require_definition();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function NoDeprecatedCustomRule(context) {
    return {
      Field: function Field(node) {
        var fieldDef = context.getFieldDef();
        var deprecationReason = fieldDef === null || fieldDef === undefined ? undefined : fieldDef.deprecationReason;
        if (fieldDef && deprecationReason != null) {
          var parentType = context.getParentType();
          parentType != null || (0, _invariant.default)(0);
          context.reportError(new _GraphQLError.GraphQLError("The field ".concat(parentType.name, ".").concat(fieldDef.name, " is deprecated. ").concat(deprecationReason), node));
        }
      },
      Argument: function Argument(node) {
        var argDef = context.getArgument();
        var deprecationReason = argDef === null || argDef === undefined ? undefined : argDef.deprecationReason;
        if (argDef && deprecationReason != null) {
          var directiveDef = context.getDirective();
          if (directiveDef != null) {
            context.reportError(new _GraphQLError.GraphQLError('Directive "@'.concat(directiveDef.name, '" argument "').concat(argDef.name, '" is deprecated. ').concat(deprecationReason), node));
          } else {
            var parentType = context.getParentType();
            var fieldDef = context.getFieldDef();
            parentType != null && fieldDef != null || (0, _invariant.default)(0);
            context.reportError(new _GraphQLError.GraphQLError('Field "'.concat(parentType.name, ".").concat(fieldDef.name, '" argument "').concat(argDef.name, '" is deprecated. ').concat(deprecationReason), node));
          }
        }
      },
      ObjectField: function ObjectField(node) {
        var inputObjectDef = (0, _definition.getNamedType)(context.getParentInputType());
        if ((0, _definition.isInputObjectType)(inputObjectDef)) {
          var inputFieldDef = inputObjectDef.getFields()[node.name.value];
          var deprecationReason = inputFieldDef === null || inputFieldDef === undefined ? undefined : inputFieldDef.deprecationReason;
          if (deprecationReason != null) {
            context.reportError(new _GraphQLError.GraphQLError("The input field ".concat(inputObjectDef.name, ".").concat(inputFieldDef.name, " is deprecated. ").concat(deprecationReason), node));
          }
        }
      },
      EnumValue: function EnumValue(node) {
        var enumValueDef = context.getEnumValue();
        var deprecationReason = enumValueDef === null || enumValueDef === undefined ? undefined : enumValueDef.deprecationReason;
        if (enumValueDef && deprecationReason != null) {
          var enumTypeDef = (0, _definition.getNamedType)(context.getInputType());
          enumTypeDef != null || (0, _invariant.default)(0);
          context.reportError(new _GraphQLError.GraphQLError('The enum value "'.concat(enumTypeDef.name, ".").concat(enumValueDef.name, '" is deprecated. ').concat(deprecationReason), node));
        }
      }
    };
  }
});

// node_modules/graphql/validation/rules/custom/NoSchemaIntrospectionCustomRule.js
var require_NoSchemaIntrospectionCustomRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.NoSchemaIntrospectionCustomRule = NoSchemaIntrospectionCustomRule;
  var _GraphQLError = require_GraphQLError();
  var _definition = require_definition();
  var _introspection = require_introspection();
  function NoSchemaIntrospectionCustomRule(context) {
    return {
      Field: function Field(node) {
        var type = (0, _definition.getNamedType)(context.getType());
        if (type && (0, _introspection.isIntrospectionType)(type)) {
          context.reportError(new _GraphQLError.GraphQLError('GraphQL introspection has been disabled, but the requested query contained the field "'.concat(node.name.value, '".'), node));
        }
      }
    };
  }
});

// node_modules/graphql/validation/index.js
var require_validation = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "validate", {
    enumerable: true,
    get: function get() {
      return _validate.validate;
    }
  });
  Object.defineProperty(exports, "ValidationContext", {
    enumerable: true,
    get: function get() {
      return _ValidationContext.ValidationContext;
    }
  });
  Object.defineProperty(exports, "specifiedRules", {
    enumerable: true,
    get: function get() {
      return _specifiedRules.specifiedRules;
    }
  });
  Object.defineProperty(exports, "recommendedRules", {
    enumerable: true,
    get: function get() {
      return _specifiedRules.recommendedRules;
    }
  });
  Object.defineProperty(exports, "ExecutableDefinitionsRule", {
    enumerable: true,
    get: function get() {
      return _ExecutableDefinitionsRule.ExecutableDefinitionsRule;
    }
  });
  Object.defineProperty(exports, "FieldsOnCorrectTypeRule", {
    enumerable: true,
    get: function get() {
      return _FieldsOnCorrectTypeRule.FieldsOnCorrectTypeRule;
    }
  });
  Object.defineProperty(exports, "FragmentsOnCompositeTypesRule", {
    enumerable: true,
    get: function get() {
      return _FragmentsOnCompositeTypesRule.FragmentsOnCompositeTypesRule;
    }
  });
  Object.defineProperty(exports, "KnownArgumentNamesRule", {
    enumerable: true,
    get: function get() {
      return _KnownArgumentNamesRule.KnownArgumentNamesRule;
    }
  });
  Object.defineProperty(exports, "KnownDirectivesRule", {
    enumerable: true,
    get: function get() {
      return _KnownDirectivesRule.KnownDirectivesRule;
    }
  });
  Object.defineProperty(exports, "KnownFragmentNamesRule", {
    enumerable: true,
    get: function get() {
      return _KnownFragmentNamesRule.KnownFragmentNamesRule;
    }
  });
  Object.defineProperty(exports, "KnownTypeNamesRule", {
    enumerable: true,
    get: function get() {
      return _KnownTypeNamesRule.KnownTypeNamesRule;
    }
  });
  Object.defineProperty(exports, "LoneAnonymousOperationRule", {
    enumerable: true,
    get: function get() {
      return _LoneAnonymousOperationRule.LoneAnonymousOperationRule;
    }
  });
  Object.defineProperty(exports, "NoFragmentCyclesRule", {
    enumerable: true,
    get: function get() {
      return _NoFragmentCyclesRule.NoFragmentCyclesRule;
    }
  });
  Object.defineProperty(exports, "NoUndefinedVariablesRule", {
    enumerable: true,
    get: function get() {
      return _NoUndefinedVariablesRule.NoUndefinedVariablesRule;
    }
  });
  Object.defineProperty(exports, "NoUnusedFragmentsRule", {
    enumerable: true,
    get: function get() {
      return _NoUnusedFragmentsRule.NoUnusedFragmentsRule;
    }
  });
  Object.defineProperty(exports, "NoUnusedVariablesRule", {
    enumerable: true,
    get: function get() {
      return _NoUnusedVariablesRule.NoUnusedVariablesRule;
    }
  });
  Object.defineProperty(exports, "OverlappingFieldsCanBeMergedRule", {
    enumerable: true,
    get: function get() {
      return _OverlappingFieldsCanBeMergedRule.OverlappingFieldsCanBeMergedRule;
    }
  });
  Object.defineProperty(exports, "PossibleFragmentSpreadsRule", {
    enumerable: true,
    get: function get() {
      return _PossibleFragmentSpreadsRule.PossibleFragmentSpreadsRule;
    }
  });
  Object.defineProperty(exports, "ProvidedRequiredArgumentsRule", {
    enumerable: true,
    get: function get() {
      return _ProvidedRequiredArgumentsRule.ProvidedRequiredArgumentsRule;
    }
  });
  Object.defineProperty(exports, "ScalarLeafsRule", {
    enumerable: true,
    get: function get() {
      return _ScalarLeafsRule.ScalarLeafsRule;
    }
  });
  Object.defineProperty(exports, "SingleFieldSubscriptionsRule", {
    enumerable: true,
    get: function get() {
      return _SingleFieldSubscriptionsRule.SingleFieldSubscriptionsRule;
    }
  });
  Object.defineProperty(exports, "UniqueArgumentNamesRule", {
    enumerable: true,
    get: function get() {
      return _UniqueArgumentNamesRule.UniqueArgumentNamesRule;
    }
  });
  Object.defineProperty(exports, "UniqueDirectivesPerLocationRule", {
    enumerable: true,
    get: function get() {
      return _UniqueDirectivesPerLocationRule.UniqueDirectivesPerLocationRule;
    }
  });
  Object.defineProperty(exports, "UniqueFragmentNamesRule", {
    enumerable: true,
    get: function get() {
      return _UniqueFragmentNamesRule.UniqueFragmentNamesRule;
    }
  });
  Object.defineProperty(exports, "UniqueInputFieldNamesRule", {
    enumerable: true,
    get: function get() {
      return _UniqueInputFieldNamesRule.UniqueInputFieldNamesRule;
    }
  });
  Object.defineProperty(exports, "UniqueOperationNamesRule", {
    enumerable: true,
    get: function get() {
      return _UniqueOperationNamesRule.UniqueOperationNamesRule;
    }
  });
  Object.defineProperty(exports, "UniqueVariableNamesRule", {
    enumerable: true,
    get: function get() {
      return _UniqueVariableNamesRule.UniqueVariableNamesRule;
    }
  });
  Object.defineProperty(exports, "ValuesOfCorrectTypeRule", {
    enumerable: true,
    get: function get() {
      return _ValuesOfCorrectTypeRule.ValuesOfCorrectTypeRule;
    }
  });
  Object.defineProperty(exports, "VariablesAreInputTypesRule", {
    enumerable: true,
    get: function get() {
      return _VariablesAreInputTypesRule.VariablesAreInputTypesRule;
    }
  });
  Object.defineProperty(exports, "VariablesInAllowedPositionRule", {
    enumerable: true,
    get: function get() {
      return _VariablesInAllowedPositionRule.VariablesInAllowedPositionRule;
    }
  });
  Object.defineProperty(exports, "MaxIntrospectionDepthRule", {
    enumerable: true,
    get: function get() {
      return _MaxIntrospectionDepthRule.MaxIntrospectionDepthRule;
    }
  });
  Object.defineProperty(exports, "LoneSchemaDefinitionRule", {
    enumerable: true,
    get: function get() {
      return _LoneSchemaDefinitionRule.LoneSchemaDefinitionRule;
    }
  });
  Object.defineProperty(exports, "UniqueOperationTypesRule", {
    enumerable: true,
    get: function get() {
      return _UniqueOperationTypesRule.UniqueOperationTypesRule;
    }
  });
  Object.defineProperty(exports, "UniqueTypeNamesRule", {
    enumerable: true,
    get: function get() {
      return _UniqueTypeNamesRule.UniqueTypeNamesRule;
    }
  });
  Object.defineProperty(exports, "UniqueEnumValueNamesRule", {
    enumerable: true,
    get: function get() {
      return _UniqueEnumValueNamesRule.UniqueEnumValueNamesRule;
    }
  });
  Object.defineProperty(exports, "UniqueFieldDefinitionNamesRule", {
    enumerable: true,
    get: function get() {
      return _UniqueFieldDefinitionNamesRule.UniqueFieldDefinitionNamesRule;
    }
  });
  Object.defineProperty(exports, "UniqueDirectiveNamesRule", {
    enumerable: true,
    get: function get() {
      return _UniqueDirectiveNamesRule.UniqueDirectiveNamesRule;
    }
  });
  Object.defineProperty(exports, "PossibleTypeExtensionsRule", {
    enumerable: true,
    get: function get() {
      return _PossibleTypeExtensionsRule.PossibleTypeExtensionsRule;
    }
  });
  Object.defineProperty(exports, "NoDeprecatedCustomRule", {
    enumerable: true,
    get: function get() {
      return _NoDeprecatedCustomRule.NoDeprecatedCustomRule;
    }
  });
  Object.defineProperty(exports, "NoSchemaIntrospectionCustomRule", {
    enumerable: true,
    get: function get() {
      return _NoSchemaIntrospectionCustomRule.NoSchemaIntrospectionCustomRule;
    }
  });
  var _validate = require_validate2();
  var _ValidationContext = require_ValidationContext();
  var _specifiedRules = require_specifiedRules();
  var _ExecutableDefinitionsRule = require_ExecutableDefinitionsRule();
  var _FieldsOnCorrectTypeRule = require_FieldsOnCorrectTypeRule();
  var _FragmentsOnCompositeTypesRule = require_FragmentsOnCompositeTypesRule();
  var _KnownArgumentNamesRule = require_KnownArgumentNamesRule();
  var _KnownDirectivesRule = require_KnownDirectivesRule();
  var _KnownFragmentNamesRule = require_KnownFragmentNamesRule();
  var _KnownTypeNamesRule = require_KnownTypeNamesRule();
  var _LoneAnonymousOperationRule = require_LoneAnonymousOperationRule();
  var _NoFragmentCyclesRule = require_NoFragmentCyclesRule();
  var _NoUndefinedVariablesRule = require_NoUndefinedVariablesRule();
  var _NoUnusedFragmentsRule = require_NoUnusedFragmentsRule();
  var _NoUnusedVariablesRule = require_NoUnusedVariablesRule();
  var _OverlappingFieldsCanBeMergedRule = require_OverlappingFieldsCanBeMergedRule();
  var _PossibleFragmentSpreadsRule = require_PossibleFragmentSpreadsRule();
  var _ProvidedRequiredArgumentsRule = require_ProvidedRequiredArgumentsRule();
  var _ScalarLeafsRule = require_ScalarLeafsRule();
  var _SingleFieldSubscriptionsRule = require_SingleFieldSubscriptionsRule();
  var _UniqueArgumentNamesRule = require_UniqueArgumentNamesRule();
  var _UniqueDirectivesPerLocationRule = require_UniqueDirectivesPerLocationRule();
  var _UniqueFragmentNamesRule = require_UniqueFragmentNamesRule();
  var _UniqueInputFieldNamesRule = require_UniqueInputFieldNamesRule();
  var _UniqueOperationNamesRule = require_UniqueOperationNamesRule();
  var _UniqueVariableNamesRule = require_UniqueVariableNamesRule();
  var _ValuesOfCorrectTypeRule = require_ValuesOfCorrectTypeRule();
  var _VariablesAreInputTypesRule = require_VariablesAreInputTypesRule();
  var _VariablesInAllowedPositionRule = require_VariablesInAllowedPositionRule();
  var _MaxIntrospectionDepthRule = require_MaxIntrospectionDepthRule();
  var _LoneSchemaDefinitionRule = require_LoneSchemaDefinitionRule();
  var _UniqueOperationTypesRule = require_UniqueOperationTypesRule();
  var _UniqueTypeNamesRule = require_UniqueTypeNamesRule();
  var _UniqueEnumValueNamesRule = require_UniqueEnumValueNamesRule();
  var _UniqueFieldDefinitionNamesRule = require_UniqueFieldDefinitionNamesRule();
  var _UniqueDirectiveNamesRule = require_UniqueDirectiveNamesRule();
  var _PossibleTypeExtensionsRule = require_PossibleTypeExtensionsRule();
  var _NoDeprecatedCustomRule = require_NoDeprecatedCustomRule();
  var _NoSchemaIntrospectionCustomRule = require_NoSchemaIntrospectionCustomRule();
});

// node_modules/graphql/error/formatError.js
var require_formatError = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "formatError", {
    enumerable: true,
    get: function get() {
      return _GraphQLError.formatError;
    }
  });
  var _GraphQLError = require_GraphQLError();
});

// node_modules/graphql/error/index.js
var require_error = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "GraphQLError", {
    enumerable: true,
    get: function get() {
      return _GraphQLError.GraphQLError;
    }
  });
  Object.defineProperty(exports, "printError", {
    enumerable: true,
    get: function get() {
      return _GraphQLError.printError;
    }
  });
  Object.defineProperty(exports, "syntaxError", {
    enumerable: true,
    get: function get() {
      return _syntaxError.syntaxError;
    }
  });
  Object.defineProperty(exports, "locatedError", {
    enumerable: true,
    get: function get() {
      return _locatedError.locatedError;
    }
  });
  Object.defineProperty(exports, "formatError", {
    enumerable: true,
    get: function get() {
      return _formatError.formatError;
    }
  });
  var _GraphQLError = require_GraphQLError();
  var _syntaxError = require_syntaxError();
  var _locatedError = require_locatedError();
  var _formatError = require_formatError();
});

// node_modules/graphql/utilities/getIntrospectionQuery.js
var require_getIntrospectionQuery = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getIntrospectionQuery = getIntrospectionQuery;
  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread(target) {
    for (var i = 1;i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function getIntrospectionQuery(options) {
    var optionsWithDefault = _objectSpread({
      descriptions: true,
      specifiedByUrl: false,
      directiveIsRepeatable: false,
      schemaDescription: false,
      inputValueDeprecation: false
    }, options);
    var descriptions = optionsWithDefault.descriptions ? "description" : "";
    var specifiedByUrl = optionsWithDefault.specifiedByUrl ? "specifiedByUrl" : "";
    var directiveIsRepeatable = optionsWithDefault.directiveIsRepeatable ? "isRepeatable" : "";
    var schemaDescription = optionsWithDefault.schemaDescription ? descriptions : "";
    function inputDeprecation(str) {
      return optionsWithDefault.inputValueDeprecation ? str : "";
    }
    return `
    query IntrospectionQuery {
      __schema {
        `.concat(schemaDescription, `
        queryType { name }
        mutationType { name }
        subscriptionType { name }
        types {
          ...FullType
        }
        directives {
          name
          `).concat(descriptions, `
          `).concat(directiveIsRepeatable, `
          locations
          args`).concat(inputDeprecation("(includeDeprecated: true)"), ` {
            ...InputValue
          }
        }
      }
    }

    fragment FullType on __Type {
      kind
      name
      `).concat(descriptions, `
      `).concat(specifiedByUrl, `
      fields(includeDeprecated: true) {
        name
        `).concat(descriptions, `
        args`).concat(inputDeprecation("(includeDeprecated: true)"), ` {
          ...InputValue
        }
        type {
          ...TypeRef
        }
        isDeprecated
        deprecationReason
      }
      inputFields`).concat(inputDeprecation("(includeDeprecated: true)"), ` {
        ...InputValue
      }
      interfaces {
        ...TypeRef
      }
      enumValues(includeDeprecated: true) {
        name
        `).concat(descriptions, `
        isDeprecated
        deprecationReason
      }
      possibleTypes {
        ...TypeRef
      }
    }

    fragment InputValue on __InputValue {
      name
      `).concat(descriptions, `
      type { ...TypeRef }
      defaultValue
      `).concat(inputDeprecation("isDeprecated"), `
      `).concat(inputDeprecation("deprecationReason"), `
    }

    fragment TypeRef on __Type {
      kind
      name
      ofType {
        kind
        name
        ofType {
          kind
          name
          ofType {
            kind
            name
            ofType {
              kind
              name
              ofType {
                kind
                name
                ofType {
                  kind
                  name
                  ofType {
                    kind
                    name
                  }
                }
              }
            }
          }
        }
      }
    }
  `);
  }
});

// node_modules/graphql/utilities/getOperationAST.js
var require_getOperationAST = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getOperationAST = getOperationAST;
  var _kinds = require_kinds();
  function getOperationAST(documentAST, operationName) {
    var operation = null;
    for (var _i2 = 0, _documentAST$definiti2 = documentAST.definitions;_i2 < _documentAST$definiti2.length; _i2++) {
      var definition = _documentAST$definiti2[_i2];
      if (definition.kind === _kinds.Kind.OPERATION_DEFINITION) {
        var _definition$name;
        if (operationName == null) {
          if (operation) {
            return null;
          }
          operation = definition;
        } else if (((_definition$name = definition.name) === null || _definition$name === undefined ? undefined : _definition$name.value) === operationName) {
          return definition;
        }
      }
    }
    return operation;
  }
});

// node_modules/graphql/utilities/introspectionFromSchema.js
var require_introspectionFromSchema = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.introspectionFromSchema = introspectionFromSchema;
  var _invariant = _interopRequireDefault(require_invariant());
  var _parser = require_parser();
  var _execute = require_execute();
  var _getIntrospectionQuery = require_getIntrospectionQuery();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread(target) {
    for (var i = 1;i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function introspectionFromSchema(schema, options) {
    var optionsWithDefaults = _objectSpread({
      specifiedByUrl: true,
      directiveIsRepeatable: true,
      schemaDescription: true,
      inputValueDeprecation: true
    }, options);
    var document2 = (0, _parser.parse)((0, _getIntrospectionQuery.getIntrospectionQuery)(optionsWithDefaults));
    var result = (0, _execute.executeSync)({
      schema,
      document: document2
    });
    !result.errors && result.data || (0, _invariant.default)(0);
    return result.data;
  }
});

// node_modules/graphql/utilities/buildClientSchema.js
var require_buildClientSchema = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.buildClientSchema = buildClientSchema;
  var _objectValues = _interopRequireDefault(require_objectValues());
  var _inspect = _interopRequireDefault(require_inspect());
  var _devAssert = _interopRequireDefault(require_devAssert());
  var _keyValMap = _interopRequireDefault(require_keyValMap());
  var _isObjectLike = _interopRequireDefault(require_isObjectLike());
  var _parser = require_parser();
  var _schema = require_schema();
  var _directives = require_directives();
  var _scalars = require_scalars();
  var _introspection = require_introspection();
  var _definition = require_definition();
  var _valueFromAST = require_valueFromAST();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function buildClientSchema(introspection, options) {
    (0, _isObjectLike.default)(introspection) && (0, _isObjectLike.default)(introspection.__schema) || (0, _devAssert.default)(0, 'Invalid or incomplete introspection result. Ensure that you are passing "data" property of introspection response and no "errors" was returned alongside: '.concat((0, _inspect.default)(introspection), "."));
    var schemaIntrospection = introspection.__schema;
    var typeMap = (0, _keyValMap.default)(schemaIntrospection.types, function(typeIntrospection) {
      return typeIntrospection.name;
    }, function(typeIntrospection) {
      return buildType(typeIntrospection);
    });
    for (var _i2 = 0, _ref2 = [].concat(_scalars.specifiedScalarTypes, _introspection.introspectionTypes);_i2 < _ref2.length; _i2++) {
      var stdType = _ref2[_i2];
      if (typeMap[stdType.name]) {
        typeMap[stdType.name] = stdType;
      }
    }
    var queryType = schemaIntrospection.queryType ? getObjectType(schemaIntrospection.queryType) : null;
    var mutationType = schemaIntrospection.mutationType ? getObjectType(schemaIntrospection.mutationType) : null;
    var subscriptionType = schemaIntrospection.subscriptionType ? getObjectType(schemaIntrospection.subscriptionType) : null;
    var directives = schemaIntrospection.directives ? schemaIntrospection.directives.map(buildDirective) : [];
    return new _schema.GraphQLSchema({
      description: schemaIntrospection.description,
      query: queryType,
      mutation: mutationType,
      subscription: subscriptionType,
      types: (0, _objectValues.default)(typeMap),
      directives,
      assumeValid: options === null || options === undefined ? undefined : options.assumeValid
    });
    function getType(typeRef) {
      if (typeRef.kind === _introspection.TypeKind.LIST) {
        var itemRef = typeRef.ofType;
        if (!itemRef) {
          throw new Error("Decorated type deeper than introspection query.");
        }
        return new _definition.GraphQLList(getType(itemRef));
      }
      if (typeRef.kind === _introspection.TypeKind.NON_NULL) {
        var nullableRef = typeRef.ofType;
        if (!nullableRef) {
          throw new Error("Decorated type deeper than introspection query.");
        }
        var nullableType = getType(nullableRef);
        return new _definition.GraphQLNonNull((0, _definition.assertNullableType)(nullableType));
      }
      return getNamedType(typeRef);
    }
    function getNamedType(typeRef) {
      var typeName = typeRef.name;
      if (!typeName) {
        throw new Error("Unknown type reference: ".concat((0, _inspect.default)(typeRef), "."));
      }
      var type = typeMap[typeName];
      if (!type) {
        throw new Error("Invalid or incomplete schema, unknown type: ".concat(typeName, ". Ensure that a full introspection query is used in order to build a client schema."));
      }
      return type;
    }
    function getObjectType(typeRef) {
      return (0, _definition.assertObjectType)(getNamedType(typeRef));
    }
    function getInterfaceType(typeRef) {
      return (0, _definition.assertInterfaceType)(getNamedType(typeRef));
    }
    function buildType(type) {
      if (type != null && type.name != null && type.kind != null) {
        switch (type.kind) {
          case _introspection.TypeKind.SCALAR:
            return buildScalarDef(type);
          case _introspection.TypeKind.OBJECT:
            return buildObjectDef(type);
          case _introspection.TypeKind.INTERFACE:
            return buildInterfaceDef(type);
          case _introspection.TypeKind.UNION:
            return buildUnionDef(type);
          case _introspection.TypeKind.ENUM:
            return buildEnumDef(type);
          case _introspection.TypeKind.INPUT_OBJECT:
            return buildInputObjectDef(type);
        }
      }
      var typeStr = (0, _inspect.default)(type);
      throw new Error("Invalid or incomplete introspection result. Ensure that a full introspection query is used in order to build a client schema: ".concat(typeStr, "."));
    }
    function buildScalarDef(scalarIntrospection) {
      return new _definition.GraphQLScalarType({
        name: scalarIntrospection.name,
        description: scalarIntrospection.description,
        specifiedByUrl: scalarIntrospection.specifiedByUrl
      });
    }
    function buildImplementationsList(implementingIntrospection) {
      if (implementingIntrospection.interfaces === null && implementingIntrospection.kind === _introspection.TypeKind.INTERFACE) {
        return [];
      }
      if (!implementingIntrospection.interfaces) {
        var implementingIntrospectionStr = (0, _inspect.default)(implementingIntrospection);
        throw new Error("Introspection result missing interfaces: ".concat(implementingIntrospectionStr, "."));
      }
      return implementingIntrospection.interfaces.map(getInterfaceType);
    }
    function buildObjectDef(objectIntrospection) {
      return new _definition.GraphQLObjectType({
        name: objectIntrospection.name,
        description: objectIntrospection.description,
        interfaces: function interfaces() {
          return buildImplementationsList(objectIntrospection);
        },
        fields: function fields() {
          return buildFieldDefMap(objectIntrospection);
        }
      });
    }
    function buildInterfaceDef(interfaceIntrospection) {
      return new _definition.GraphQLInterfaceType({
        name: interfaceIntrospection.name,
        description: interfaceIntrospection.description,
        interfaces: function interfaces() {
          return buildImplementationsList(interfaceIntrospection);
        },
        fields: function fields() {
          return buildFieldDefMap(interfaceIntrospection);
        }
      });
    }
    function buildUnionDef(unionIntrospection) {
      if (!unionIntrospection.possibleTypes) {
        var unionIntrospectionStr = (0, _inspect.default)(unionIntrospection);
        throw new Error("Introspection result missing possibleTypes: ".concat(unionIntrospectionStr, "."));
      }
      return new _definition.GraphQLUnionType({
        name: unionIntrospection.name,
        description: unionIntrospection.description,
        types: function types() {
          return unionIntrospection.possibleTypes.map(getObjectType);
        }
      });
    }
    function buildEnumDef(enumIntrospection) {
      if (!enumIntrospection.enumValues) {
        var enumIntrospectionStr = (0, _inspect.default)(enumIntrospection);
        throw new Error("Introspection result missing enumValues: ".concat(enumIntrospectionStr, "."));
      }
      return new _definition.GraphQLEnumType({
        name: enumIntrospection.name,
        description: enumIntrospection.description,
        values: (0, _keyValMap.default)(enumIntrospection.enumValues, function(valueIntrospection) {
          return valueIntrospection.name;
        }, function(valueIntrospection) {
          return {
            description: valueIntrospection.description,
            deprecationReason: valueIntrospection.deprecationReason
          };
        })
      });
    }
    function buildInputObjectDef(inputObjectIntrospection) {
      if (!inputObjectIntrospection.inputFields) {
        var inputObjectIntrospectionStr = (0, _inspect.default)(inputObjectIntrospection);
        throw new Error("Introspection result missing inputFields: ".concat(inputObjectIntrospectionStr, "."));
      }
      return new _definition.GraphQLInputObjectType({
        name: inputObjectIntrospection.name,
        description: inputObjectIntrospection.description,
        fields: function fields() {
          return buildInputValueDefMap(inputObjectIntrospection.inputFields);
        }
      });
    }
    function buildFieldDefMap(typeIntrospection) {
      if (!typeIntrospection.fields) {
        throw new Error("Introspection result missing fields: ".concat((0, _inspect.default)(typeIntrospection), "."));
      }
      return (0, _keyValMap.default)(typeIntrospection.fields, function(fieldIntrospection) {
        return fieldIntrospection.name;
      }, buildField);
    }
    function buildField(fieldIntrospection) {
      var type = getType(fieldIntrospection.type);
      if (!(0, _definition.isOutputType)(type)) {
        var typeStr = (0, _inspect.default)(type);
        throw new Error("Introspection must provide output type for fields, but received: ".concat(typeStr, "."));
      }
      if (!fieldIntrospection.args) {
        var fieldIntrospectionStr = (0, _inspect.default)(fieldIntrospection);
        throw new Error("Introspection result missing field args: ".concat(fieldIntrospectionStr, "."));
      }
      return {
        description: fieldIntrospection.description,
        deprecationReason: fieldIntrospection.deprecationReason,
        type,
        args: buildInputValueDefMap(fieldIntrospection.args)
      };
    }
    function buildInputValueDefMap(inputValueIntrospections) {
      return (0, _keyValMap.default)(inputValueIntrospections, function(inputValue) {
        return inputValue.name;
      }, buildInputValue);
    }
    function buildInputValue(inputValueIntrospection) {
      var type = getType(inputValueIntrospection.type);
      if (!(0, _definition.isInputType)(type)) {
        var typeStr = (0, _inspect.default)(type);
        throw new Error("Introspection must provide input type for arguments, but received: ".concat(typeStr, "."));
      }
      var defaultValue = inputValueIntrospection.defaultValue != null ? (0, _valueFromAST.valueFromAST)((0, _parser.parseValue)(inputValueIntrospection.defaultValue), type) : undefined;
      return {
        description: inputValueIntrospection.description,
        type,
        defaultValue,
        deprecationReason: inputValueIntrospection.deprecationReason
      };
    }
    function buildDirective(directiveIntrospection) {
      if (!directiveIntrospection.args) {
        var directiveIntrospectionStr = (0, _inspect.default)(directiveIntrospection);
        throw new Error("Introspection result missing directive args: ".concat(directiveIntrospectionStr, "."));
      }
      if (!directiveIntrospection.locations) {
        var _directiveIntrospectionStr = (0, _inspect.default)(directiveIntrospection);
        throw new Error("Introspection result missing directive locations: ".concat(_directiveIntrospectionStr, "."));
      }
      return new _directives.GraphQLDirective({
        name: directiveIntrospection.name,
        description: directiveIntrospection.description,
        isRepeatable: directiveIntrospection.isRepeatable,
        locations: directiveIntrospection.locations.slice(),
        args: buildInputValueDefMap(directiveIntrospection.args)
      });
    }
  }
});

// node_modules/graphql/utilities/extendSchema.js
var require_extendSchema = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.extendSchema = extendSchema;
  exports.extendSchemaImpl = extendSchemaImpl;
  exports.getDescription = getDescription;
  var _objectValues = _interopRequireDefault(require_objectValues());
  var _keyMap = _interopRequireDefault(require_keyMap());
  var _inspect = _interopRequireDefault(require_inspect());
  var _mapValue = _interopRequireDefault(require_mapValue());
  var _invariant = _interopRequireDefault(require_invariant());
  var _devAssert = _interopRequireDefault(require_devAssert());
  var _kinds = require_kinds();
  var _tokenKind = require_tokenKind();
  var _blockString = require_blockString();
  var _predicates = require_predicates();
  var _validate = require_validate2();
  var _values = require_values();
  var _schema = require_schema();
  var _scalars = require_scalars();
  var _introspection = require_introspection();
  var _directives = require_directives();
  var _definition = require_definition();
  var _valueFromAST = require_valueFromAST();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread(target) {
    for (var i = 1;i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function extendSchema(schema, documentAST, options) {
    (0, _schema.assertSchema)(schema);
    documentAST != null && documentAST.kind === _kinds.Kind.DOCUMENT || (0, _devAssert.default)(0, "Must provide valid Document AST.");
    if ((options === null || options === undefined ? undefined : options.assumeValid) !== true && (options === null || options === undefined ? undefined : options.assumeValidSDL) !== true) {
      (0, _validate.assertValidSDLExtension)(documentAST, schema);
    }
    var schemaConfig = schema.toConfig();
    var extendedConfig = extendSchemaImpl(schemaConfig, documentAST, options);
    return schemaConfig === extendedConfig ? schema : new _schema.GraphQLSchema(extendedConfig);
  }
  function extendSchemaImpl(schemaConfig, documentAST, options) {
    var _schemaDef, _schemaDef$descriptio, _schemaDef2, _options$assumeValid;
    var typeDefs = [];
    var typeExtensionsMap = Object.create(null);
    var directiveDefs = [];
    var schemaDef;
    var schemaExtensions = [];
    for (var _i2 = 0, _documentAST$definiti2 = documentAST.definitions;_i2 < _documentAST$definiti2.length; _i2++) {
      var def = _documentAST$definiti2[_i2];
      if (def.kind === _kinds.Kind.SCHEMA_DEFINITION) {
        schemaDef = def;
      } else if (def.kind === _kinds.Kind.SCHEMA_EXTENSION) {
        schemaExtensions.push(def);
      } else if ((0, _predicates.isTypeDefinitionNode)(def)) {
        typeDefs.push(def);
      } else if ((0, _predicates.isTypeExtensionNode)(def)) {
        var extendedTypeName = def.name.value;
        var existingTypeExtensions = typeExtensionsMap[extendedTypeName];
        typeExtensionsMap[extendedTypeName] = existingTypeExtensions ? existingTypeExtensions.concat([def]) : [def];
      } else if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
        directiveDefs.push(def);
      }
    }
    if (Object.keys(typeExtensionsMap).length === 0 && typeDefs.length === 0 && directiveDefs.length === 0 && schemaExtensions.length === 0 && schemaDef == null) {
      return schemaConfig;
    }
    var typeMap = Object.create(null);
    for (var _i4 = 0, _schemaConfig$types2 = schemaConfig.types;_i4 < _schemaConfig$types2.length; _i4++) {
      var existingType = _schemaConfig$types2[_i4];
      typeMap[existingType.name] = extendNamedType(existingType);
    }
    for (var _i6 = 0;_i6 < typeDefs.length; _i6++) {
      var _stdTypeMap$name;
      var typeNode = typeDefs[_i6];
      var name = typeNode.name.value;
      typeMap[name] = (_stdTypeMap$name = stdTypeMap[name]) !== null && _stdTypeMap$name !== undefined ? _stdTypeMap$name : buildType(typeNode);
    }
    var operationTypes = _objectSpread(_objectSpread({
      query: schemaConfig.query && replaceNamedType(schemaConfig.query),
      mutation: schemaConfig.mutation && replaceNamedType(schemaConfig.mutation),
      subscription: schemaConfig.subscription && replaceNamedType(schemaConfig.subscription)
    }, schemaDef && getOperationTypes([schemaDef])), getOperationTypes(schemaExtensions));
    return _objectSpread(_objectSpread({
      description: (_schemaDef = schemaDef) === null || _schemaDef === undefined ? undefined : (_schemaDef$descriptio = _schemaDef.description) === null || _schemaDef$descriptio === undefined ? undefined : _schemaDef$descriptio.value
    }, operationTypes), {}, {
      types: (0, _objectValues.default)(typeMap),
      directives: [].concat(schemaConfig.directives.map(replaceDirective), directiveDefs.map(buildDirective)),
      extensions: undefined,
      astNode: (_schemaDef2 = schemaDef) !== null && _schemaDef2 !== undefined ? _schemaDef2 : schemaConfig.astNode,
      extensionASTNodes: schemaConfig.extensionASTNodes.concat(schemaExtensions),
      assumeValid: (_options$assumeValid = options === null || options === undefined ? undefined : options.assumeValid) !== null && _options$assumeValid !== undefined ? _options$assumeValid : false
    });
    function replaceType(type) {
      if ((0, _definition.isListType)(type)) {
        return new _definition.GraphQLList(replaceType(type.ofType));
      }
      if ((0, _definition.isNonNullType)(type)) {
        return new _definition.GraphQLNonNull(replaceType(type.ofType));
      }
      return replaceNamedType(type);
    }
    function replaceNamedType(type) {
      return typeMap[type.name];
    }
    function replaceDirective(directive) {
      var config = directive.toConfig();
      return new _directives.GraphQLDirective(_objectSpread(_objectSpread({}, config), {}, {
        args: (0, _mapValue.default)(config.args, extendArg)
      }));
    }
    function extendNamedType(type) {
      if ((0, _introspection.isIntrospectionType)(type) || (0, _scalars.isSpecifiedScalarType)(type)) {
        return type;
      }
      if ((0, _definition.isScalarType)(type)) {
        return extendScalarType(type);
      }
      if ((0, _definition.isObjectType)(type)) {
        return extendObjectType(type);
      }
      if ((0, _definition.isInterfaceType)(type)) {
        return extendInterfaceType(type);
      }
      if ((0, _definition.isUnionType)(type)) {
        return extendUnionType(type);
      }
      if ((0, _definition.isEnumType)(type)) {
        return extendEnumType(type);
      }
      if ((0, _definition.isInputObjectType)(type)) {
        return extendInputObjectType(type);
      }
      (0, _invariant.default)(0, "Unexpected type: " + (0, _inspect.default)(type));
    }
    function extendInputObjectType(type) {
      var _typeExtensionsMap$co;
      var config = type.toConfig();
      var extensions = (_typeExtensionsMap$co = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co !== undefined ? _typeExtensionsMap$co : [];
      return new _definition.GraphQLInputObjectType(_objectSpread(_objectSpread({}, config), {}, {
        fields: function fields() {
          return _objectSpread(_objectSpread({}, (0, _mapValue.default)(config.fields, function(field) {
            return _objectSpread(_objectSpread({}, field), {}, {
              type: replaceType(field.type)
            });
          })), buildInputFieldMap(extensions));
        },
        extensionASTNodes: config.extensionASTNodes.concat(extensions)
      }));
    }
    function extendEnumType(type) {
      var _typeExtensionsMap$ty;
      var config = type.toConfig();
      var extensions = (_typeExtensionsMap$ty = typeExtensionsMap[type.name]) !== null && _typeExtensionsMap$ty !== undefined ? _typeExtensionsMap$ty : [];
      return new _definition.GraphQLEnumType(_objectSpread(_objectSpread({}, config), {}, {
        values: _objectSpread(_objectSpread({}, config.values), buildEnumValueMap(extensions)),
        extensionASTNodes: config.extensionASTNodes.concat(extensions)
      }));
    }
    function extendScalarType(type) {
      var _typeExtensionsMap$co2;
      var config = type.toConfig();
      var extensions = (_typeExtensionsMap$co2 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co2 !== undefined ? _typeExtensionsMap$co2 : [];
      var specifiedByUrl = config.specifiedByUrl;
      for (var _i8 = 0;_i8 < extensions.length; _i8++) {
        var _getSpecifiedByUrl;
        var extensionNode = extensions[_i8];
        specifiedByUrl = (_getSpecifiedByUrl = getSpecifiedByUrl(extensionNode)) !== null && _getSpecifiedByUrl !== undefined ? _getSpecifiedByUrl : specifiedByUrl;
      }
      return new _definition.GraphQLScalarType(_objectSpread(_objectSpread({}, config), {}, {
        specifiedByUrl,
        extensionASTNodes: config.extensionASTNodes.concat(extensions)
      }));
    }
    function extendObjectType(type) {
      var _typeExtensionsMap$co3;
      var config = type.toConfig();
      var extensions = (_typeExtensionsMap$co3 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co3 !== undefined ? _typeExtensionsMap$co3 : [];
      return new _definition.GraphQLObjectType(_objectSpread(_objectSpread({}, config), {}, {
        interfaces: function interfaces() {
          return [].concat(type.getInterfaces().map(replaceNamedType), buildInterfaces(extensions));
        },
        fields: function fields() {
          return _objectSpread(_objectSpread({}, (0, _mapValue.default)(config.fields, extendField)), buildFieldMap(extensions));
        },
        extensionASTNodes: config.extensionASTNodes.concat(extensions)
      }));
    }
    function extendInterfaceType(type) {
      var _typeExtensionsMap$co4;
      var config = type.toConfig();
      var extensions = (_typeExtensionsMap$co4 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co4 !== undefined ? _typeExtensionsMap$co4 : [];
      return new _definition.GraphQLInterfaceType(_objectSpread(_objectSpread({}, config), {}, {
        interfaces: function interfaces() {
          return [].concat(type.getInterfaces().map(replaceNamedType), buildInterfaces(extensions));
        },
        fields: function fields() {
          return _objectSpread(_objectSpread({}, (0, _mapValue.default)(config.fields, extendField)), buildFieldMap(extensions));
        },
        extensionASTNodes: config.extensionASTNodes.concat(extensions)
      }));
    }
    function extendUnionType(type) {
      var _typeExtensionsMap$co5;
      var config = type.toConfig();
      var extensions = (_typeExtensionsMap$co5 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co5 !== undefined ? _typeExtensionsMap$co5 : [];
      return new _definition.GraphQLUnionType(_objectSpread(_objectSpread({}, config), {}, {
        types: function types() {
          return [].concat(type.getTypes().map(replaceNamedType), buildUnionTypes(extensions));
        },
        extensionASTNodes: config.extensionASTNodes.concat(extensions)
      }));
    }
    function extendField(field) {
      return _objectSpread(_objectSpread({}, field), {}, {
        type: replaceType(field.type),
        args: (0, _mapValue.default)(field.args, extendArg)
      });
    }
    function extendArg(arg) {
      return _objectSpread(_objectSpread({}, arg), {}, {
        type: replaceType(arg.type)
      });
    }
    function getOperationTypes(nodes) {
      var opTypes = {};
      for (var _i10 = 0;_i10 < nodes.length; _i10++) {
        var _node$operationTypes;
        var node = nodes[_i10];
        var operationTypesNodes = (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== undefined ? _node$operationTypes : [];
        for (var _i12 = 0;_i12 < operationTypesNodes.length; _i12++) {
          var operationType = operationTypesNodes[_i12];
          opTypes[operationType.operation] = getNamedType(operationType.type);
        }
      }
      return opTypes;
    }
    function getNamedType(node) {
      var _stdTypeMap$name2;
      var name2 = node.name.value;
      var type = (_stdTypeMap$name2 = stdTypeMap[name2]) !== null && _stdTypeMap$name2 !== undefined ? _stdTypeMap$name2 : typeMap[name2];
      if (type === undefined) {
        throw new Error('Unknown type: "'.concat(name2, '".'));
      }
      return type;
    }
    function getWrappedType(node) {
      if (node.kind === _kinds.Kind.LIST_TYPE) {
        return new _definition.GraphQLList(getWrappedType(node.type));
      }
      if (node.kind === _kinds.Kind.NON_NULL_TYPE) {
        return new _definition.GraphQLNonNull(getWrappedType(node.type));
      }
      return getNamedType(node);
    }
    function buildDirective(node) {
      var locations = node.locations.map(function(_ref) {
        var value = _ref.value;
        return value;
      });
      return new _directives.GraphQLDirective({
        name: node.name.value,
        description: getDescription(node, options),
        locations,
        isRepeatable: node.repeatable,
        args: buildArgumentMap(node.arguments),
        astNode: node
      });
    }
    function buildFieldMap(nodes) {
      var fieldConfigMap = Object.create(null);
      for (var _i14 = 0;_i14 < nodes.length; _i14++) {
        var _node$fields;
        var node = nodes[_i14];
        var nodeFields = (_node$fields = node.fields) !== null && _node$fields !== undefined ? _node$fields : [];
        for (var _i16 = 0;_i16 < nodeFields.length; _i16++) {
          var field = nodeFields[_i16];
          fieldConfigMap[field.name.value] = {
            type: getWrappedType(field.type),
            description: getDescription(field, options),
            args: buildArgumentMap(field.arguments),
            deprecationReason: getDeprecationReason(field),
            astNode: field
          };
        }
      }
      return fieldConfigMap;
    }
    function buildArgumentMap(args2) {
      var argsNodes = args2 !== null && args2 !== undefined ? args2 : [];
      var argConfigMap = Object.create(null);
      for (var _i18 = 0;_i18 < argsNodes.length; _i18++) {
        var arg = argsNodes[_i18];
        var type = getWrappedType(arg.type);
        argConfigMap[arg.name.value] = {
          type,
          description: getDescription(arg, options),
          defaultValue: (0, _valueFromAST.valueFromAST)(arg.defaultValue, type),
          deprecationReason: getDeprecationReason(arg),
          astNode: arg
        };
      }
      return argConfigMap;
    }
    function buildInputFieldMap(nodes) {
      var inputFieldMap = Object.create(null);
      for (var _i20 = 0;_i20 < nodes.length; _i20++) {
        var _node$fields2;
        var node = nodes[_i20];
        var fieldsNodes = (_node$fields2 = node.fields) !== null && _node$fields2 !== undefined ? _node$fields2 : [];
        for (var _i22 = 0;_i22 < fieldsNodes.length; _i22++) {
          var field = fieldsNodes[_i22];
          var type = getWrappedType(field.type);
          inputFieldMap[field.name.value] = {
            type,
            description: getDescription(field, options),
            defaultValue: (0, _valueFromAST.valueFromAST)(field.defaultValue, type),
            deprecationReason: getDeprecationReason(field),
            astNode: field
          };
        }
      }
      return inputFieldMap;
    }
    function buildEnumValueMap(nodes) {
      var enumValueMap = Object.create(null);
      for (var _i24 = 0;_i24 < nodes.length; _i24++) {
        var _node$values;
        var node = nodes[_i24];
        var valuesNodes = (_node$values = node.values) !== null && _node$values !== undefined ? _node$values : [];
        for (var _i26 = 0;_i26 < valuesNodes.length; _i26++) {
          var value = valuesNodes[_i26];
          enumValueMap[value.name.value] = {
            description: getDescription(value, options),
            deprecationReason: getDeprecationReason(value),
            astNode: value
          };
        }
      }
      return enumValueMap;
    }
    function buildInterfaces(nodes) {
      var interfaces = [];
      for (var _i28 = 0;_i28 < nodes.length; _i28++) {
        var _node$interfaces;
        var node = nodes[_i28];
        var interfacesNodes = (_node$interfaces = node.interfaces) !== null && _node$interfaces !== undefined ? _node$interfaces : [];
        for (var _i30 = 0;_i30 < interfacesNodes.length; _i30++) {
          var type = interfacesNodes[_i30];
          interfaces.push(getNamedType(type));
        }
      }
      return interfaces;
    }
    function buildUnionTypes(nodes) {
      var types = [];
      for (var _i32 = 0;_i32 < nodes.length; _i32++) {
        var _node$types;
        var node = nodes[_i32];
        var typeNodes = (_node$types = node.types) !== null && _node$types !== undefined ? _node$types : [];
        for (var _i34 = 0;_i34 < typeNodes.length; _i34++) {
          var type = typeNodes[_i34];
          types.push(getNamedType(type));
        }
      }
      return types;
    }
    function buildType(astNode) {
      var _typeExtensionsMap$na;
      var name2 = astNode.name.value;
      var description = getDescription(astNode, options);
      var extensionNodes = (_typeExtensionsMap$na = typeExtensionsMap[name2]) !== null && _typeExtensionsMap$na !== undefined ? _typeExtensionsMap$na : [];
      switch (astNode.kind) {
        case _kinds.Kind.OBJECT_TYPE_DEFINITION: {
          var extensionASTNodes = extensionNodes;
          var allNodes = [astNode].concat(extensionASTNodes);
          return new _definition.GraphQLObjectType({
            name: name2,
            description,
            interfaces: function interfaces() {
              return buildInterfaces(allNodes);
            },
            fields: function fields() {
              return buildFieldMap(allNodes);
            },
            astNode,
            extensionASTNodes
          });
        }
        case _kinds.Kind.INTERFACE_TYPE_DEFINITION: {
          var _extensionASTNodes = extensionNodes;
          var _allNodes = [astNode].concat(_extensionASTNodes);
          return new _definition.GraphQLInterfaceType({
            name: name2,
            description,
            interfaces: function interfaces() {
              return buildInterfaces(_allNodes);
            },
            fields: function fields() {
              return buildFieldMap(_allNodes);
            },
            astNode,
            extensionASTNodes: _extensionASTNodes
          });
        }
        case _kinds.Kind.ENUM_TYPE_DEFINITION: {
          var _extensionASTNodes2 = extensionNodes;
          var _allNodes2 = [astNode].concat(_extensionASTNodes2);
          return new _definition.GraphQLEnumType({
            name: name2,
            description,
            values: buildEnumValueMap(_allNodes2),
            astNode,
            extensionASTNodes: _extensionASTNodes2
          });
        }
        case _kinds.Kind.UNION_TYPE_DEFINITION: {
          var _extensionASTNodes3 = extensionNodes;
          var _allNodes3 = [astNode].concat(_extensionASTNodes3);
          return new _definition.GraphQLUnionType({
            name: name2,
            description,
            types: function types() {
              return buildUnionTypes(_allNodes3);
            },
            astNode,
            extensionASTNodes: _extensionASTNodes3
          });
        }
        case _kinds.Kind.SCALAR_TYPE_DEFINITION: {
          var _extensionASTNodes4 = extensionNodes;
          return new _definition.GraphQLScalarType({
            name: name2,
            description,
            specifiedByUrl: getSpecifiedByUrl(astNode),
            astNode,
            extensionASTNodes: _extensionASTNodes4
          });
        }
        case _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION: {
          var _extensionASTNodes5 = extensionNodes;
          var _allNodes4 = [astNode].concat(_extensionASTNodes5);
          return new _definition.GraphQLInputObjectType({
            name: name2,
            description,
            fields: function fields() {
              return buildInputFieldMap(_allNodes4);
            },
            astNode,
            extensionASTNodes: _extensionASTNodes5
          });
        }
      }
      (0, _invariant.default)(0, "Unexpected type definition node: " + (0, _inspect.default)(astNode));
    }
  }
  var stdTypeMap = (0, _keyMap.default)(_scalars.specifiedScalarTypes.concat(_introspection.introspectionTypes), function(type) {
    return type.name;
  });
  function getDeprecationReason(node) {
    var deprecated = (0, _values.getDirectiveValues)(_directives.GraphQLDeprecatedDirective, node);
    return deprecated === null || deprecated === undefined ? undefined : deprecated.reason;
  }
  function getSpecifiedByUrl(node) {
    var specifiedBy = (0, _values.getDirectiveValues)(_directives.GraphQLSpecifiedByDirective, node);
    return specifiedBy === null || specifiedBy === undefined ? undefined : specifiedBy.url;
  }
  function getDescription(node, options) {
    if (node.description) {
      return node.description.value;
    }
    if ((options === null || options === undefined ? undefined : options.commentDescriptions) === true) {
      var rawValue = getLeadingCommentBlock(node);
      if (rawValue !== undefined) {
        return (0, _blockString.dedentBlockStringValue)(`
` + rawValue);
      }
    }
  }
  function getLeadingCommentBlock(node) {
    var loc = node.loc;
    if (!loc) {
      return;
    }
    var comments = [];
    var token = loc.startToken.prev;
    while (token != null && token.kind === _tokenKind.TokenKind.COMMENT && token.next && token.prev && token.line + 1 === token.next.line && token.line !== token.prev.line) {
      var value = String(token.value);
      comments.push(value);
      token = token.prev;
    }
    return comments.length > 0 ? comments.reverse().join(`
`) : undefined;
  }
});

// node_modules/graphql/utilities/buildASTSchema.js
var require_buildASTSchema = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.buildASTSchema = buildASTSchema;
  exports.buildSchema = buildSchema;
  var _devAssert = _interopRequireDefault(require_devAssert());
  var _kinds = require_kinds();
  var _parser = require_parser();
  var _validate = require_validate2();
  var _schema = require_schema();
  var _directives = require_directives();
  var _extendSchema = require_extendSchema();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function buildASTSchema(documentAST, options) {
    documentAST != null && documentAST.kind === _kinds.Kind.DOCUMENT || (0, _devAssert.default)(0, "Must provide valid Document AST.");
    if ((options === null || options === undefined ? undefined : options.assumeValid) !== true && (options === null || options === undefined ? undefined : options.assumeValidSDL) !== true) {
      (0, _validate.assertValidSDL)(documentAST);
    }
    var emptySchemaConfig = {
      description: undefined,
      types: [],
      directives: [],
      extensions: undefined,
      extensionASTNodes: [],
      assumeValid: false
    };
    var config = (0, _extendSchema.extendSchemaImpl)(emptySchemaConfig, documentAST, options);
    if (config.astNode == null) {
      for (var _i2 = 0, _config$types2 = config.types;_i2 < _config$types2.length; _i2++) {
        var type = _config$types2[_i2];
        switch (type.name) {
          case "Query":
            config.query = type;
            break;
          case "Mutation":
            config.mutation = type;
            break;
          case "Subscription":
            config.subscription = type;
            break;
        }
      }
    }
    var directives = config.directives;
    var _loop = function _loop(_i42) {
      var stdDirective = _directives.specifiedDirectives[_i42];
      if (directives.every(function(directive) {
        return directive.name !== stdDirective.name;
      })) {
        directives.push(stdDirective);
      }
    };
    for (var _i4 = 0;_i4 < _directives.specifiedDirectives.length; _i4++) {
      _loop(_i4);
    }
    return new _schema.GraphQLSchema(config);
  }
  function buildSchema(source, options) {
    var document2 = (0, _parser.parse)(source, {
      noLocation: options === null || options === undefined ? undefined : options.noLocation,
      allowLegacySDLEmptyFields: options === null || options === undefined ? undefined : options.allowLegacySDLEmptyFields,
      allowLegacySDLImplementsInterfaces: options === null || options === undefined ? undefined : options.allowLegacySDLImplementsInterfaces,
      experimentalFragmentVariables: options === null || options === undefined ? undefined : options.experimentalFragmentVariables
    });
    return buildASTSchema(document2, {
      commentDescriptions: options === null || options === undefined ? undefined : options.commentDescriptions,
      assumeValidSDL: options === null || options === undefined ? undefined : options.assumeValidSDL,
      assumeValid: options === null || options === undefined ? undefined : options.assumeValid
    });
  }
});

// node_modules/graphql/utilities/lexicographicSortSchema.js
var require_lexicographicSortSchema = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.lexicographicSortSchema = lexicographicSortSchema;
  var _objectValues = _interopRequireDefault(require_objectValues());
  var _inspect = _interopRequireDefault(require_inspect());
  var _invariant = _interopRequireDefault(require_invariant());
  var _keyValMap = _interopRequireDefault(require_keyValMap());
  var _naturalCompare = _interopRequireDefault(require_naturalCompare());
  var _schema = require_schema();
  var _directives = require_directives();
  var _introspection = require_introspection();
  var _definition = require_definition();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread(target) {
    for (var i = 1;i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function lexicographicSortSchema(schema) {
    var schemaConfig = schema.toConfig();
    var typeMap = (0, _keyValMap.default)(sortByName(schemaConfig.types), function(type) {
      return type.name;
    }, sortNamedType);
    return new _schema.GraphQLSchema(_objectSpread(_objectSpread({}, schemaConfig), {}, {
      types: (0, _objectValues.default)(typeMap),
      directives: sortByName(schemaConfig.directives).map(sortDirective),
      query: replaceMaybeType(schemaConfig.query),
      mutation: replaceMaybeType(schemaConfig.mutation),
      subscription: replaceMaybeType(schemaConfig.subscription)
    }));
    function replaceType(type) {
      if ((0, _definition.isListType)(type)) {
        return new _definition.GraphQLList(replaceType(type.ofType));
      } else if ((0, _definition.isNonNullType)(type)) {
        return new _definition.GraphQLNonNull(replaceType(type.ofType));
      }
      return replaceNamedType(type);
    }
    function replaceNamedType(type) {
      return typeMap[type.name];
    }
    function replaceMaybeType(maybeType) {
      return maybeType && replaceNamedType(maybeType);
    }
    function sortDirective(directive) {
      var config = directive.toConfig();
      return new _directives.GraphQLDirective(_objectSpread(_objectSpread({}, config), {}, {
        locations: sortBy(config.locations, function(x) {
          return x;
        }),
        args: sortArgs(config.args)
      }));
    }
    function sortArgs(args2) {
      return sortObjMap(args2, function(arg) {
        return _objectSpread(_objectSpread({}, arg), {}, {
          type: replaceType(arg.type)
        });
      });
    }
    function sortFields(fieldsMap) {
      return sortObjMap(fieldsMap, function(field) {
        return _objectSpread(_objectSpread({}, field), {}, {
          type: replaceType(field.type),
          args: sortArgs(field.args)
        });
      });
    }
    function sortInputFields(fieldsMap) {
      return sortObjMap(fieldsMap, function(field) {
        return _objectSpread(_objectSpread({}, field), {}, {
          type: replaceType(field.type)
        });
      });
    }
    function sortTypes(arr) {
      return sortByName(arr).map(replaceNamedType);
    }
    function sortNamedType(type) {
      if ((0, _definition.isScalarType)(type) || (0, _introspection.isIntrospectionType)(type)) {
        return type;
      }
      if ((0, _definition.isObjectType)(type)) {
        var config = type.toConfig();
        return new _definition.GraphQLObjectType(_objectSpread(_objectSpread({}, config), {}, {
          interfaces: function interfaces() {
            return sortTypes(config.interfaces);
          },
          fields: function fields() {
            return sortFields(config.fields);
          }
        }));
      }
      if ((0, _definition.isInterfaceType)(type)) {
        var _config = type.toConfig();
        return new _definition.GraphQLInterfaceType(_objectSpread(_objectSpread({}, _config), {}, {
          interfaces: function interfaces() {
            return sortTypes(_config.interfaces);
          },
          fields: function fields() {
            return sortFields(_config.fields);
          }
        }));
      }
      if ((0, _definition.isUnionType)(type)) {
        var _config2 = type.toConfig();
        return new _definition.GraphQLUnionType(_objectSpread(_objectSpread({}, _config2), {}, {
          types: function types() {
            return sortTypes(_config2.types);
          }
        }));
      }
      if ((0, _definition.isEnumType)(type)) {
        var _config3 = type.toConfig();
        return new _definition.GraphQLEnumType(_objectSpread(_objectSpread({}, _config3), {}, {
          values: sortObjMap(_config3.values)
        }));
      }
      if ((0, _definition.isInputObjectType)(type)) {
        var _config4 = type.toConfig();
        return new _definition.GraphQLInputObjectType(_objectSpread(_objectSpread({}, _config4), {}, {
          fields: function fields() {
            return sortInputFields(_config4.fields);
          }
        }));
      }
      (0, _invariant.default)(0, "Unexpected type: " + (0, _inspect.default)(type));
    }
  }
  function sortObjMap(map, sortValueFn) {
    var sortedMap = Object.create(null);
    var sortedKeys = sortBy(Object.keys(map), function(x) {
      return x;
    });
    for (var _i2 = 0;_i2 < sortedKeys.length; _i2++) {
      var key = sortedKeys[_i2];
      var value = map[key];
      sortedMap[key] = sortValueFn ? sortValueFn(value) : value;
    }
    return sortedMap;
  }
  function sortByName(array) {
    return sortBy(array, function(obj) {
      return obj.name;
    });
  }
  function sortBy(array, mapToKey) {
    return array.slice().sort(function(obj1, obj2) {
      var key1 = mapToKey(obj1);
      var key2 = mapToKey(obj2);
      return (0, _naturalCompare.default)(key1, key2);
    });
  }
});

// node_modules/graphql/utilities/printSchema.js
var require_printSchema = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.printSchema = printSchema;
  exports.printIntrospectionSchema = printIntrospectionSchema;
  exports.printType = printType;
  var _objectValues = _interopRequireDefault(require_objectValues());
  var _inspect = _interopRequireDefault(require_inspect());
  var _invariant = _interopRequireDefault(require_invariant());
  var _printer = require_printer();
  var _blockString = require_blockString();
  var _introspection = require_introspection();
  var _scalars = require_scalars();
  var _directives = require_directives();
  var _definition = require_definition();
  var _astFromValue = require_astFromValue();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function printSchema(schema, options) {
    return printFilteredSchema(schema, function(n) {
      return !(0, _directives.isSpecifiedDirective)(n);
    }, isDefinedType, options);
  }
  function printIntrospectionSchema(schema, options) {
    return printFilteredSchema(schema, _directives.isSpecifiedDirective, _introspection.isIntrospectionType, options);
  }
  function isDefinedType(type) {
    return !(0, _scalars.isSpecifiedScalarType)(type) && !(0, _introspection.isIntrospectionType)(type);
  }
  function printFilteredSchema(schema, directiveFilter, typeFilter, options) {
    var directives = schema.getDirectives().filter(directiveFilter);
    var types = (0, _objectValues.default)(schema.getTypeMap()).filter(typeFilter);
    return [printSchemaDefinition(schema)].concat(directives.map(function(directive) {
      return printDirective(directive, options);
    }), types.map(function(type) {
      return printType(type, options);
    })).filter(Boolean).join(`

`) + `
`;
  }
  function printSchemaDefinition(schema) {
    if (schema.description == null && isSchemaOfCommonNames(schema)) {
      return;
    }
    var operationTypes = [];
    var queryType = schema.getQueryType();
    if (queryType) {
      operationTypes.push("  query: ".concat(queryType.name));
    }
    var mutationType = schema.getMutationType();
    if (mutationType) {
      operationTypes.push("  mutation: ".concat(mutationType.name));
    }
    var subscriptionType = schema.getSubscriptionType();
    if (subscriptionType) {
      operationTypes.push("  subscription: ".concat(subscriptionType.name));
    }
    return printDescription({}, schema) + `schema {
`.concat(operationTypes.join(`
`), `
}`);
  }
  function isSchemaOfCommonNames(schema) {
    var queryType = schema.getQueryType();
    if (queryType && queryType.name !== "Query") {
      return false;
    }
    var mutationType = schema.getMutationType();
    if (mutationType && mutationType.name !== "Mutation") {
      return false;
    }
    var subscriptionType = schema.getSubscriptionType();
    if (subscriptionType && subscriptionType.name !== "Subscription") {
      return false;
    }
    return true;
  }
  function printType(type, options) {
    if ((0, _definition.isScalarType)(type)) {
      return printScalar(type, options);
    }
    if ((0, _definition.isObjectType)(type)) {
      return printObject(type, options);
    }
    if ((0, _definition.isInterfaceType)(type)) {
      return printInterface(type, options);
    }
    if ((0, _definition.isUnionType)(type)) {
      return printUnion(type, options);
    }
    if ((0, _definition.isEnumType)(type)) {
      return printEnum(type, options);
    }
    if ((0, _definition.isInputObjectType)(type)) {
      return printInputObject(type, options);
    }
    (0, _invariant.default)(0, "Unexpected type: " + (0, _inspect.default)(type));
  }
  function printScalar(type, options) {
    return printDescription(options, type) + "scalar ".concat(type.name) + printSpecifiedByUrl(type);
  }
  function printImplementedInterfaces(type) {
    var interfaces = type.getInterfaces();
    return interfaces.length ? " implements " + interfaces.map(function(i) {
      return i.name;
    }).join(" & ") : "";
  }
  function printObject(type, options) {
    return printDescription(options, type) + "type ".concat(type.name) + printImplementedInterfaces(type) + printFields(options, type);
  }
  function printInterface(type, options) {
    return printDescription(options, type) + "interface ".concat(type.name) + printImplementedInterfaces(type) + printFields(options, type);
  }
  function printUnion(type, options) {
    var types = type.getTypes();
    var possibleTypes = types.length ? " = " + types.join(" | ") : "";
    return printDescription(options, type) + "union " + type.name + possibleTypes;
  }
  function printEnum(type, options) {
    var values = type.getValues().map(function(value, i) {
      return printDescription(options, value, "  ", !i) + "  " + value.name + printDeprecated(value.deprecationReason);
    });
    return printDescription(options, type) + "enum ".concat(type.name) + printBlock(values);
  }
  function printInputObject(type, options) {
    var fields = (0, _objectValues.default)(type.getFields()).map(function(f, i) {
      return printDescription(options, f, "  ", !i) + "  " + printInputValue(f);
    });
    return printDescription(options, type) + "input ".concat(type.name) + printBlock(fields);
  }
  function printFields(options, type) {
    var fields = (0, _objectValues.default)(type.getFields()).map(function(f, i) {
      return printDescription(options, f, "  ", !i) + "  " + f.name + printArgs(options, f.args, "  ") + ": " + String(f.type) + printDeprecated(f.deprecationReason);
    });
    return printBlock(fields);
  }
  function printBlock(items) {
    return items.length !== 0 ? ` {
` + items.join(`
`) + `
}` : "";
  }
  function printArgs(options, args2) {
    var indentation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";
    if (args2.length === 0) {
      return "";
    }
    if (args2.every(function(arg) {
      return !arg.description;
    })) {
      return "(" + args2.map(printInputValue).join(", ") + ")";
    }
    return `(
` + args2.map(function(arg, i) {
      return printDescription(options, arg, "  " + indentation, !i) + "  " + indentation + printInputValue(arg);
    }).join(`
`) + `
` + indentation + ")";
  }
  function printInputValue(arg) {
    var defaultAST = (0, _astFromValue.astFromValue)(arg.defaultValue, arg.type);
    var argDecl = arg.name + ": " + String(arg.type);
    if (defaultAST) {
      argDecl += " = ".concat((0, _printer.print)(defaultAST));
    }
    return argDecl + printDeprecated(arg.deprecationReason);
  }
  function printDirective(directive, options) {
    return printDescription(options, directive) + "directive @" + directive.name + printArgs(options, directive.args) + (directive.isRepeatable ? " repeatable" : "") + " on " + directive.locations.join(" | ");
  }
  function printDeprecated(reason) {
    if (reason == null) {
      return "";
    }
    var reasonAST = (0, _astFromValue.astFromValue)(reason, _scalars.GraphQLString);
    if (reasonAST && reason !== _directives.DEFAULT_DEPRECATION_REASON) {
      return " @deprecated(reason: " + (0, _printer.print)(reasonAST) + ")";
    }
    return " @deprecated";
  }
  function printSpecifiedByUrl(scalar) {
    if (scalar.specifiedByUrl == null) {
      return "";
    }
    var url = scalar.specifiedByUrl;
    var urlAST = (0, _astFromValue.astFromValue)(url, _scalars.GraphQLString);
    urlAST || (0, _invariant.default)(0, "Unexpected null value returned from `astFromValue` for specifiedByUrl");
    return " @specifiedBy(url: " + (0, _printer.print)(urlAST) + ")";
  }
  function printDescription(options, def) {
    var indentation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";
    var firstInBlock = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
    var description = def.description;
    if (description == null) {
      return "";
    }
    if ((options === null || options === undefined ? undefined : options.commentDescriptions) === true) {
      return printDescriptionWithComments(description, indentation, firstInBlock);
    }
    var preferMultipleLines = description.length > 70;
    var blockString = (0, _blockString.printBlockString)(description, "", preferMultipleLines);
    var prefix = indentation && !firstInBlock ? `
` + indentation : indentation;
    return prefix + blockString.replace(/\n/g, `
` + indentation) + `
`;
  }
  function printDescriptionWithComments(description, indentation, firstInBlock) {
    var prefix = indentation && !firstInBlock ? `
` : "";
    var comment = description.split(`
`).map(function(line) {
      return indentation + (line !== "" ? "# " + line : "#");
    }).join(`
`);
    return prefix + comment + `
`;
  }
});

// node_modules/graphql/utilities/concatAST.js
var require_concatAST = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.concatAST = concatAST;
  function concatAST(documents) {
    var definitions = [];
    for (var _i2 = 0;_i2 < documents.length; _i2++) {
      var doc = documents[_i2];
      definitions = definitions.concat(doc.definitions);
    }
    return {
      kind: "Document",
      definitions
    };
  }
});

// node_modules/graphql/utilities/separateOperations.js
var require_separateOperations = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.separateOperations = separateOperations;
  var _kinds = require_kinds();
  var _visitor = require_visitor();
  function separateOperations(documentAST) {
    var operations = [];
    var depGraph = Object.create(null);
    for (var _i2 = 0, _documentAST$definiti2 = documentAST.definitions;_i2 < _documentAST$definiti2.length; _i2++) {
      var definitionNode = _documentAST$definiti2[_i2];
      switch (definitionNode.kind) {
        case _kinds.Kind.OPERATION_DEFINITION:
          operations.push(definitionNode);
          break;
        case _kinds.Kind.FRAGMENT_DEFINITION:
          depGraph[definitionNode.name.value] = collectDependencies(definitionNode.selectionSet);
          break;
      }
    }
    var separatedDocumentASTs = Object.create(null);
    var _loop = function _loop(_i42) {
      var operation = operations[_i42];
      var dependencies = new Set;
      for (var _i6 = 0, _collectDependencies2 = collectDependencies(operation.selectionSet);_i6 < _collectDependencies2.length; _i6++) {
        var fragmentName = _collectDependencies2[_i6];
        collectTransitiveDependencies(dependencies, depGraph, fragmentName);
      }
      var operationName = operation.name ? operation.name.value : "";
      separatedDocumentASTs[operationName] = {
        kind: _kinds.Kind.DOCUMENT,
        definitions: documentAST.definitions.filter(function(node) {
          return node === operation || node.kind === _kinds.Kind.FRAGMENT_DEFINITION && dependencies.has(node.name.value);
        })
      };
    };
    for (var _i4 = 0;_i4 < operations.length; _i4++) {
      _loop(_i4);
    }
    return separatedDocumentASTs;
  }
  function collectTransitiveDependencies(collected, depGraph, fromName) {
    if (!collected.has(fromName)) {
      collected.add(fromName);
      var immediateDeps = depGraph[fromName];
      if (immediateDeps !== undefined) {
        for (var _i8 = 0;_i8 < immediateDeps.length; _i8++) {
          var toName = immediateDeps[_i8];
          collectTransitiveDependencies(collected, depGraph, toName);
        }
      }
    }
  }
  function collectDependencies(selectionSet) {
    var dependencies = [];
    (0, _visitor.visit)(selectionSet, {
      FragmentSpread: function FragmentSpread(node) {
        dependencies.push(node.name.value);
      }
    });
    return dependencies;
  }
});

// node_modules/graphql/utilities/stripIgnoredCharacters.js
var require_stripIgnoredCharacters = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.stripIgnoredCharacters = stripIgnoredCharacters;
  var _source = require_source();
  var _tokenKind = require_tokenKind();
  var _lexer = require_lexer();
  var _blockString = require_blockString();
  function stripIgnoredCharacters(source) {
    var sourceObj = (0, _source.isSource)(source) ? source : new _source.Source(source);
    var body = sourceObj.body;
    var lexer = new _lexer.Lexer(sourceObj);
    var strippedBody = "";
    var wasLastAddedTokenNonPunctuator = false;
    while (lexer.advance().kind !== _tokenKind.TokenKind.EOF) {
      var currentToken = lexer.token;
      var tokenKind = currentToken.kind;
      var isNonPunctuator = !(0, _lexer.isPunctuatorTokenKind)(currentToken.kind);
      if (wasLastAddedTokenNonPunctuator) {
        if (isNonPunctuator || currentToken.kind === _tokenKind.TokenKind.SPREAD) {
          strippedBody += " ";
        }
      }
      var tokenBody = body.slice(currentToken.start, currentToken.end);
      if (tokenKind === _tokenKind.TokenKind.BLOCK_STRING) {
        strippedBody += dedentBlockString(tokenBody);
      } else {
        strippedBody += tokenBody;
      }
      wasLastAddedTokenNonPunctuator = isNonPunctuator;
    }
    return strippedBody;
  }
  function dedentBlockString(blockStr) {
    var rawStr = blockStr.slice(3, -3);
    var body = (0, _blockString.dedentBlockStringValue)(rawStr);
    if ((0, _blockString.getBlockStringIndentation)(body) > 0) {
      body = `
` + body;
    }
    var lastChar = body[body.length - 1];
    var hasTrailingQuote = lastChar === '"' && body.slice(-4) !== '\\"""';
    if (hasTrailingQuote || lastChar === "\\") {
      body += `
`;
    }
    return '"""' + body + '"""';
  }
});

// node_modules/graphql/utilities/findBreakingChanges.js
var require_findBreakingChanges = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.findBreakingChanges = findBreakingChanges;
  exports.findDangerousChanges = findDangerousChanges;
  exports.DangerousChangeType = exports.BreakingChangeType = undefined;
  var _objectValues = _interopRequireDefault(require_objectValues());
  var _keyMap = _interopRequireDefault(require_keyMap());
  var _inspect = _interopRequireDefault(require_inspect());
  var _invariant = _interopRequireDefault(require_invariant());
  var _naturalCompare = _interopRequireDefault(require_naturalCompare());
  var _printer = require_printer();
  var _visitor = require_visitor();
  var _scalars = require_scalars();
  var _definition = require_definition();
  var _astFromValue = require_astFromValue();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread(target) {
    for (var i = 1;i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var BreakingChangeType = Object.freeze({
    TYPE_REMOVED: "TYPE_REMOVED",
    TYPE_CHANGED_KIND: "TYPE_CHANGED_KIND",
    TYPE_REMOVED_FROM_UNION: "TYPE_REMOVED_FROM_UNION",
    VALUE_REMOVED_FROM_ENUM: "VALUE_REMOVED_FROM_ENUM",
    REQUIRED_INPUT_FIELD_ADDED: "REQUIRED_INPUT_FIELD_ADDED",
    IMPLEMENTED_INTERFACE_REMOVED: "IMPLEMENTED_INTERFACE_REMOVED",
    FIELD_REMOVED: "FIELD_REMOVED",
    FIELD_CHANGED_KIND: "FIELD_CHANGED_KIND",
    REQUIRED_ARG_ADDED: "REQUIRED_ARG_ADDED",
    ARG_REMOVED: "ARG_REMOVED",
    ARG_CHANGED_KIND: "ARG_CHANGED_KIND",
    DIRECTIVE_REMOVED: "DIRECTIVE_REMOVED",
    DIRECTIVE_ARG_REMOVED: "DIRECTIVE_ARG_REMOVED",
    REQUIRED_DIRECTIVE_ARG_ADDED: "REQUIRED_DIRECTIVE_ARG_ADDED",
    DIRECTIVE_REPEATABLE_REMOVED: "DIRECTIVE_REPEATABLE_REMOVED",
    DIRECTIVE_LOCATION_REMOVED: "DIRECTIVE_LOCATION_REMOVED"
  });
  exports.BreakingChangeType = BreakingChangeType;
  var DangerousChangeType = Object.freeze({
    VALUE_ADDED_TO_ENUM: "VALUE_ADDED_TO_ENUM",
    TYPE_ADDED_TO_UNION: "TYPE_ADDED_TO_UNION",
    OPTIONAL_INPUT_FIELD_ADDED: "OPTIONAL_INPUT_FIELD_ADDED",
    OPTIONAL_ARG_ADDED: "OPTIONAL_ARG_ADDED",
    IMPLEMENTED_INTERFACE_ADDED: "IMPLEMENTED_INTERFACE_ADDED",
    ARG_DEFAULT_VALUE_CHANGE: "ARG_DEFAULT_VALUE_CHANGE"
  });
  exports.DangerousChangeType = DangerousChangeType;
  function findBreakingChanges(oldSchema, newSchema) {
    var breakingChanges = findSchemaChanges(oldSchema, newSchema).filter(function(change) {
      return change.type in BreakingChangeType;
    });
    return breakingChanges;
  }
  function findDangerousChanges(oldSchema, newSchema) {
    var dangerousChanges = findSchemaChanges(oldSchema, newSchema).filter(function(change) {
      return change.type in DangerousChangeType;
    });
    return dangerousChanges;
  }
  function findSchemaChanges(oldSchema, newSchema) {
    return [].concat(findTypeChanges(oldSchema, newSchema), findDirectiveChanges(oldSchema, newSchema));
  }
  function findDirectiveChanges(oldSchema, newSchema) {
    var schemaChanges = [];
    var directivesDiff = diff(oldSchema.getDirectives(), newSchema.getDirectives());
    for (var _i2 = 0, _directivesDiff$remov2 = directivesDiff.removed;_i2 < _directivesDiff$remov2.length; _i2++) {
      var oldDirective = _directivesDiff$remov2[_i2];
      schemaChanges.push({
        type: BreakingChangeType.DIRECTIVE_REMOVED,
        description: "".concat(oldDirective.name, " was removed.")
      });
    }
    for (var _i4 = 0, _directivesDiff$persi2 = directivesDiff.persisted;_i4 < _directivesDiff$persi2.length; _i4++) {
      var _ref2 = _directivesDiff$persi2[_i4];
      var _oldDirective = _ref2[0];
      var newDirective = _ref2[1];
      var argsDiff = diff(_oldDirective.args, newDirective.args);
      for (var _i6 = 0, _argsDiff$added2 = argsDiff.added;_i6 < _argsDiff$added2.length; _i6++) {
        var newArg = _argsDiff$added2[_i6];
        if ((0, _definition.isRequiredArgument)(newArg)) {
          schemaChanges.push({
            type: BreakingChangeType.REQUIRED_DIRECTIVE_ARG_ADDED,
            description: "A required arg ".concat(newArg.name, " on directive ").concat(_oldDirective.name, " was added.")
          });
        }
      }
      for (var _i8 = 0, _argsDiff$removed2 = argsDiff.removed;_i8 < _argsDiff$removed2.length; _i8++) {
        var oldArg = _argsDiff$removed2[_i8];
        schemaChanges.push({
          type: BreakingChangeType.DIRECTIVE_ARG_REMOVED,
          description: "".concat(oldArg.name, " was removed from ").concat(_oldDirective.name, ".")
        });
      }
      if (_oldDirective.isRepeatable && !newDirective.isRepeatable) {
        schemaChanges.push({
          type: BreakingChangeType.DIRECTIVE_REPEATABLE_REMOVED,
          description: "Repeatable flag was removed from ".concat(_oldDirective.name, ".")
        });
      }
      for (var _i10 = 0, _oldDirective$locatio2 = _oldDirective.locations;_i10 < _oldDirective$locatio2.length; _i10++) {
        var location = _oldDirective$locatio2[_i10];
        if (newDirective.locations.indexOf(location) === -1) {
          schemaChanges.push({
            type: BreakingChangeType.DIRECTIVE_LOCATION_REMOVED,
            description: "".concat(location, " was removed from ").concat(_oldDirective.name, ".")
          });
        }
      }
    }
    return schemaChanges;
  }
  function findTypeChanges(oldSchema, newSchema) {
    var schemaChanges = [];
    var typesDiff = diff((0, _objectValues.default)(oldSchema.getTypeMap()), (0, _objectValues.default)(newSchema.getTypeMap()));
    for (var _i12 = 0, _typesDiff$removed2 = typesDiff.removed;_i12 < _typesDiff$removed2.length; _i12++) {
      var oldType = _typesDiff$removed2[_i12];
      schemaChanges.push({
        type: BreakingChangeType.TYPE_REMOVED,
        description: (0, _scalars.isSpecifiedScalarType)(oldType) ? "Standard scalar ".concat(oldType.name, " was removed because it is not referenced anymore.") : "".concat(oldType.name, " was removed.")
      });
    }
    for (var _i14 = 0, _typesDiff$persisted2 = typesDiff.persisted;_i14 < _typesDiff$persisted2.length; _i14++) {
      var _ref4 = _typesDiff$persisted2[_i14];
      var _oldType = _ref4[0];
      var newType = _ref4[1];
      if ((0, _definition.isEnumType)(_oldType) && (0, _definition.isEnumType)(newType)) {
        schemaChanges.push.apply(schemaChanges, findEnumTypeChanges(_oldType, newType));
      } else if ((0, _definition.isUnionType)(_oldType) && (0, _definition.isUnionType)(newType)) {
        schemaChanges.push.apply(schemaChanges, findUnionTypeChanges(_oldType, newType));
      } else if ((0, _definition.isInputObjectType)(_oldType) && (0, _definition.isInputObjectType)(newType)) {
        schemaChanges.push.apply(schemaChanges, findInputObjectTypeChanges(_oldType, newType));
      } else if ((0, _definition.isObjectType)(_oldType) && (0, _definition.isObjectType)(newType)) {
        schemaChanges.push.apply(schemaChanges, findFieldChanges(_oldType, newType).concat(findImplementedInterfacesChanges(_oldType, newType)));
      } else if ((0, _definition.isInterfaceType)(_oldType) && (0, _definition.isInterfaceType)(newType)) {
        schemaChanges.push.apply(schemaChanges, findFieldChanges(_oldType, newType).concat(findImplementedInterfacesChanges(_oldType, newType)));
      } else if (_oldType.constructor !== newType.constructor) {
        schemaChanges.push({
          type: BreakingChangeType.TYPE_CHANGED_KIND,
          description: "".concat(_oldType.name, " changed from ") + "".concat(typeKindName(_oldType), " to ").concat(typeKindName(newType), ".")
        });
      }
    }
    return schemaChanges;
  }
  function findInputObjectTypeChanges(oldType, newType) {
    var schemaChanges = [];
    var fieldsDiff = diff((0, _objectValues.default)(oldType.getFields()), (0, _objectValues.default)(newType.getFields()));
    for (var _i16 = 0, _fieldsDiff$added2 = fieldsDiff.added;_i16 < _fieldsDiff$added2.length; _i16++) {
      var newField = _fieldsDiff$added2[_i16];
      if ((0, _definition.isRequiredInputField)(newField)) {
        schemaChanges.push({
          type: BreakingChangeType.REQUIRED_INPUT_FIELD_ADDED,
          description: "A required field ".concat(newField.name, " on input type ").concat(oldType.name, " was added.")
        });
      } else {
        schemaChanges.push({
          type: DangerousChangeType.OPTIONAL_INPUT_FIELD_ADDED,
          description: "An optional field ".concat(newField.name, " on input type ").concat(oldType.name, " was added.")
        });
      }
    }
    for (var _i18 = 0, _fieldsDiff$removed2 = fieldsDiff.removed;_i18 < _fieldsDiff$removed2.length; _i18++) {
      var oldField = _fieldsDiff$removed2[_i18];
      schemaChanges.push({
        type: BreakingChangeType.FIELD_REMOVED,
        description: "".concat(oldType.name, ".").concat(oldField.name, " was removed.")
      });
    }
    for (var _i20 = 0, _fieldsDiff$persisted2 = fieldsDiff.persisted;_i20 < _fieldsDiff$persisted2.length; _i20++) {
      var _ref6 = _fieldsDiff$persisted2[_i20];
      var _oldField = _ref6[0];
      var _newField = _ref6[1];
      var isSafe = isChangeSafeForInputObjectFieldOrFieldArg(_oldField.type, _newField.type);
      if (!isSafe) {
        schemaChanges.push({
          type: BreakingChangeType.FIELD_CHANGED_KIND,
          description: "".concat(oldType.name, ".").concat(_oldField.name, " changed type from ") + "".concat(String(_oldField.type), " to ").concat(String(_newField.type), ".")
        });
      }
    }
    return schemaChanges;
  }
  function findUnionTypeChanges(oldType, newType) {
    var schemaChanges = [];
    var possibleTypesDiff = diff(oldType.getTypes(), newType.getTypes());
    for (var _i22 = 0, _possibleTypesDiff$ad2 = possibleTypesDiff.added;_i22 < _possibleTypesDiff$ad2.length; _i22++) {
      var newPossibleType = _possibleTypesDiff$ad2[_i22];
      schemaChanges.push({
        type: DangerousChangeType.TYPE_ADDED_TO_UNION,
        description: "".concat(newPossibleType.name, " was added to union type ").concat(oldType.name, ".")
      });
    }
    for (var _i24 = 0, _possibleTypesDiff$re2 = possibleTypesDiff.removed;_i24 < _possibleTypesDiff$re2.length; _i24++) {
      var oldPossibleType = _possibleTypesDiff$re2[_i24];
      schemaChanges.push({
        type: BreakingChangeType.TYPE_REMOVED_FROM_UNION,
        description: "".concat(oldPossibleType.name, " was removed from union type ").concat(oldType.name, ".")
      });
    }
    return schemaChanges;
  }
  function findEnumTypeChanges(oldType, newType) {
    var schemaChanges = [];
    var valuesDiff = diff(oldType.getValues(), newType.getValues());
    for (var _i26 = 0, _valuesDiff$added2 = valuesDiff.added;_i26 < _valuesDiff$added2.length; _i26++) {
      var newValue = _valuesDiff$added2[_i26];
      schemaChanges.push({
        type: DangerousChangeType.VALUE_ADDED_TO_ENUM,
        description: "".concat(newValue.name, " was added to enum type ").concat(oldType.name, ".")
      });
    }
    for (var _i28 = 0, _valuesDiff$removed2 = valuesDiff.removed;_i28 < _valuesDiff$removed2.length; _i28++) {
      var oldValue = _valuesDiff$removed2[_i28];
      schemaChanges.push({
        type: BreakingChangeType.VALUE_REMOVED_FROM_ENUM,
        description: "".concat(oldValue.name, " was removed from enum type ").concat(oldType.name, ".")
      });
    }
    return schemaChanges;
  }
  function findImplementedInterfacesChanges(oldType, newType) {
    var schemaChanges = [];
    var interfacesDiff = diff(oldType.getInterfaces(), newType.getInterfaces());
    for (var _i30 = 0, _interfacesDiff$added2 = interfacesDiff.added;_i30 < _interfacesDiff$added2.length; _i30++) {
      var newInterface = _interfacesDiff$added2[_i30];
      schemaChanges.push({
        type: DangerousChangeType.IMPLEMENTED_INTERFACE_ADDED,
        description: "".concat(newInterface.name, " added to interfaces implemented by ").concat(oldType.name, ".")
      });
    }
    for (var _i32 = 0, _interfacesDiff$remov2 = interfacesDiff.removed;_i32 < _interfacesDiff$remov2.length; _i32++) {
      var oldInterface = _interfacesDiff$remov2[_i32];
      schemaChanges.push({
        type: BreakingChangeType.IMPLEMENTED_INTERFACE_REMOVED,
        description: "".concat(oldType.name, " no longer implements interface ").concat(oldInterface.name, ".")
      });
    }
    return schemaChanges;
  }
  function findFieldChanges(oldType, newType) {
    var schemaChanges = [];
    var fieldsDiff = diff((0, _objectValues.default)(oldType.getFields()), (0, _objectValues.default)(newType.getFields()));
    for (var _i34 = 0, _fieldsDiff$removed4 = fieldsDiff.removed;_i34 < _fieldsDiff$removed4.length; _i34++) {
      var oldField = _fieldsDiff$removed4[_i34];
      schemaChanges.push({
        type: BreakingChangeType.FIELD_REMOVED,
        description: "".concat(oldType.name, ".").concat(oldField.name, " was removed.")
      });
    }
    for (var _i36 = 0, _fieldsDiff$persisted4 = fieldsDiff.persisted;_i36 < _fieldsDiff$persisted4.length; _i36++) {
      var _ref8 = _fieldsDiff$persisted4[_i36];
      var _oldField2 = _ref8[0];
      var newField = _ref8[1];
      schemaChanges.push.apply(schemaChanges, findArgChanges(oldType, _oldField2, newField));
      var isSafe = isChangeSafeForObjectOrInterfaceField(_oldField2.type, newField.type);
      if (!isSafe) {
        schemaChanges.push({
          type: BreakingChangeType.FIELD_CHANGED_KIND,
          description: "".concat(oldType.name, ".").concat(_oldField2.name, " changed type from ") + "".concat(String(_oldField2.type), " to ").concat(String(newField.type), ".")
        });
      }
    }
    return schemaChanges;
  }
  function findArgChanges(oldType, oldField, newField) {
    var schemaChanges = [];
    var argsDiff = diff(oldField.args, newField.args);
    for (var _i38 = 0, _argsDiff$removed4 = argsDiff.removed;_i38 < _argsDiff$removed4.length; _i38++) {
      var oldArg = _argsDiff$removed4[_i38];
      schemaChanges.push({
        type: BreakingChangeType.ARG_REMOVED,
        description: "".concat(oldType.name, ".").concat(oldField.name, " arg ").concat(oldArg.name, " was removed.")
      });
    }
    for (var _i40 = 0, _argsDiff$persisted2 = argsDiff.persisted;_i40 < _argsDiff$persisted2.length; _i40++) {
      var _ref10 = _argsDiff$persisted2[_i40];
      var _oldArg = _ref10[0];
      var newArg = _ref10[1];
      var isSafe = isChangeSafeForInputObjectFieldOrFieldArg(_oldArg.type, newArg.type);
      if (!isSafe) {
        schemaChanges.push({
          type: BreakingChangeType.ARG_CHANGED_KIND,
          description: "".concat(oldType.name, ".").concat(oldField.name, " arg ").concat(_oldArg.name, " has changed type from ") + "".concat(String(_oldArg.type), " to ").concat(String(newArg.type), ".")
        });
      } else if (_oldArg.defaultValue !== undefined) {
        if (newArg.defaultValue === undefined) {
          schemaChanges.push({
            type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,
            description: "".concat(oldType.name, ".").concat(oldField.name, " arg ").concat(_oldArg.name, " defaultValue was removed.")
          });
        } else {
          var oldValueStr = stringifyValue(_oldArg.defaultValue, _oldArg.type);
          var newValueStr = stringifyValue(newArg.defaultValue, newArg.type);
          if (oldValueStr !== newValueStr) {
            schemaChanges.push({
              type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,
              description: "".concat(oldType.name, ".").concat(oldField.name, " arg ").concat(_oldArg.name, " has changed defaultValue from ").concat(oldValueStr, " to ").concat(newValueStr, ".")
            });
          }
        }
      }
    }
    for (var _i42 = 0, _argsDiff$added4 = argsDiff.added;_i42 < _argsDiff$added4.length; _i42++) {
      var _newArg = _argsDiff$added4[_i42];
      if ((0, _definition.isRequiredArgument)(_newArg)) {
        schemaChanges.push({
          type: BreakingChangeType.REQUIRED_ARG_ADDED,
          description: "A required arg ".concat(_newArg.name, " on ").concat(oldType.name, ".").concat(oldField.name, " was added.")
        });
      } else {
        schemaChanges.push({
          type: DangerousChangeType.OPTIONAL_ARG_ADDED,
          description: "An optional arg ".concat(_newArg.name, " on ").concat(oldType.name, ".").concat(oldField.name, " was added.")
        });
      }
    }
    return schemaChanges;
  }
  function isChangeSafeForObjectOrInterfaceField(oldType, newType) {
    if ((0, _definition.isListType)(oldType)) {
      return (0, _definition.isListType)(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType) || (0, _definition.isNonNullType)(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType);
    }
    if ((0, _definition.isNonNullType)(oldType)) {
      return (0, _definition.isNonNullType)(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType);
    }
    return (0, _definition.isNamedType)(newType) && oldType.name === newType.name || (0, _definition.isNonNullType)(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType);
  }
  function isChangeSafeForInputObjectFieldOrFieldArg(oldType, newType) {
    if ((0, _definition.isListType)(oldType)) {
      return (0, _definition.isListType)(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType);
    }
    if ((0, _definition.isNonNullType)(oldType)) {
      return (0, _definition.isNonNullType)(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType) || !(0, _definition.isNonNullType)(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType);
    }
    return (0, _definition.isNamedType)(newType) && oldType.name === newType.name;
  }
  function typeKindName(type) {
    if ((0, _definition.isScalarType)(type)) {
      return "a Scalar type";
    }
    if ((0, _definition.isObjectType)(type)) {
      return "an Object type";
    }
    if ((0, _definition.isInterfaceType)(type)) {
      return "an Interface type";
    }
    if ((0, _definition.isUnionType)(type)) {
      return "a Union type";
    }
    if ((0, _definition.isEnumType)(type)) {
      return "an Enum type";
    }
    if ((0, _definition.isInputObjectType)(type)) {
      return "an Input type";
    }
    (0, _invariant.default)(0, "Unexpected type: " + (0, _inspect.default)(type));
  }
  function stringifyValue(value, type) {
    var ast = (0, _astFromValue.astFromValue)(value, type);
    ast != null || (0, _invariant.default)(0);
    var sortedAST = (0, _visitor.visit)(ast, {
      ObjectValue: function ObjectValue(objectNode) {
        var fields = [].concat(objectNode.fields);
        fields.sort(function(fieldA, fieldB) {
          return (0, _naturalCompare.default)(fieldA.name.value, fieldB.name.value);
        });
        return _objectSpread(_objectSpread({}, objectNode), {}, {
          fields
        });
      }
    });
    return (0, _printer.print)(sortedAST);
  }
  function diff(oldArray, newArray) {
    var added = [];
    var removed = [];
    var persisted = [];
    var oldMap = (0, _keyMap.default)(oldArray, function(_ref11) {
      var name = _ref11.name;
      return name;
    });
    var newMap = (0, _keyMap.default)(newArray, function(_ref12) {
      var name = _ref12.name;
      return name;
    });
    for (var _i44 = 0;_i44 < oldArray.length; _i44++) {
      var oldItem = oldArray[_i44];
      var newItem = newMap[oldItem.name];
      if (newItem === undefined) {
        removed.push(oldItem);
      } else {
        persisted.push([oldItem, newItem]);
      }
    }
    for (var _i46 = 0;_i46 < newArray.length; _i46++) {
      var _newItem = newArray[_i46];
      if (oldMap[_newItem.name] === undefined) {
        added.push(_newItem);
      }
    }
    return {
      added,
      persisted,
      removed
    };
  }
});

// node_modules/graphql/utilities/findDeprecatedUsages.js
var require_findDeprecatedUsages = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.findDeprecatedUsages = findDeprecatedUsages;
  var _validate = require_validate2();
  var _NoDeprecatedCustomRule = require_NoDeprecatedCustomRule();
  function findDeprecatedUsages(schema, ast) {
    return (0, _validate.validate)(schema, ast, [_NoDeprecatedCustomRule.NoDeprecatedCustomRule]);
  }
});

// node_modules/graphql/utilities/index.js
var require_utilities = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "getIntrospectionQuery", {
    enumerable: true,
    get: function get() {
      return _getIntrospectionQuery.getIntrospectionQuery;
    }
  });
  Object.defineProperty(exports, "getOperationAST", {
    enumerable: true,
    get: function get() {
      return _getOperationAST.getOperationAST;
    }
  });
  Object.defineProperty(exports, "getOperationRootType", {
    enumerable: true,
    get: function get() {
      return _getOperationRootType.getOperationRootType;
    }
  });
  Object.defineProperty(exports, "introspectionFromSchema", {
    enumerable: true,
    get: function get() {
      return _introspectionFromSchema.introspectionFromSchema;
    }
  });
  Object.defineProperty(exports, "buildClientSchema", {
    enumerable: true,
    get: function get() {
      return _buildClientSchema.buildClientSchema;
    }
  });
  Object.defineProperty(exports, "buildASTSchema", {
    enumerable: true,
    get: function get() {
      return _buildASTSchema.buildASTSchema;
    }
  });
  Object.defineProperty(exports, "buildSchema", {
    enumerable: true,
    get: function get() {
      return _buildASTSchema.buildSchema;
    }
  });
  Object.defineProperty(exports, "extendSchema", {
    enumerable: true,
    get: function get() {
      return _extendSchema.extendSchema;
    }
  });
  Object.defineProperty(exports, "getDescription", {
    enumerable: true,
    get: function get() {
      return _extendSchema.getDescription;
    }
  });
  Object.defineProperty(exports, "lexicographicSortSchema", {
    enumerable: true,
    get: function get() {
      return _lexicographicSortSchema.lexicographicSortSchema;
    }
  });
  Object.defineProperty(exports, "printSchema", {
    enumerable: true,
    get: function get() {
      return _printSchema.printSchema;
    }
  });
  Object.defineProperty(exports, "printType", {
    enumerable: true,
    get: function get() {
      return _printSchema.printType;
    }
  });
  Object.defineProperty(exports, "printIntrospectionSchema", {
    enumerable: true,
    get: function get() {
      return _printSchema.printIntrospectionSchema;
    }
  });
  Object.defineProperty(exports, "typeFromAST", {
    enumerable: true,
    get: function get() {
      return _typeFromAST.typeFromAST;
    }
  });
  Object.defineProperty(exports, "valueFromAST", {
    enumerable: true,
    get: function get() {
      return _valueFromAST.valueFromAST;
    }
  });
  Object.defineProperty(exports, "valueFromASTUntyped", {
    enumerable: true,
    get: function get() {
      return _valueFromASTUntyped.valueFromASTUntyped;
    }
  });
  Object.defineProperty(exports, "astFromValue", {
    enumerable: true,
    get: function get() {
      return _astFromValue.astFromValue;
    }
  });
  Object.defineProperty(exports, "TypeInfo", {
    enumerable: true,
    get: function get() {
      return _TypeInfo.TypeInfo;
    }
  });
  Object.defineProperty(exports, "visitWithTypeInfo", {
    enumerable: true,
    get: function get() {
      return _TypeInfo.visitWithTypeInfo;
    }
  });
  Object.defineProperty(exports, "coerceInputValue", {
    enumerable: true,
    get: function get() {
      return _coerceInputValue.coerceInputValue;
    }
  });
  Object.defineProperty(exports, "concatAST", {
    enumerable: true,
    get: function get() {
      return _concatAST.concatAST;
    }
  });
  Object.defineProperty(exports, "separateOperations", {
    enumerable: true,
    get: function get() {
      return _separateOperations.separateOperations;
    }
  });
  Object.defineProperty(exports, "stripIgnoredCharacters", {
    enumerable: true,
    get: function get() {
      return _stripIgnoredCharacters.stripIgnoredCharacters;
    }
  });
  Object.defineProperty(exports, "isEqualType", {
    enumerable: true,
    get: function get() {
      return _typeComparators.isEqualType;
    }
  });
  Object.defineProperty(exports, "isTypeSubTypeOf", {
    enumerable: true,
    get: function get() {
      return _typeComparators.isTypeSubTypeOf;
    }
  });
  Object.defineProperty(exports, "doTypesOverlap", {
    enumerable: true,
    get: function get() {
      return _typeComparators.doTypesOverlap;
    }
  });
  Object.defineProperty(exports, "assertValidName", {
    enumerable: true,
    get: function get() {
      return _assertValidName.assertValidName;
    }
  });
  Object.defineProperty(exports, "isValidNameError", {
    enumerable: true,
    get: function get() {
      return _assertValidName.isValidNameError;
    }
  });
  Object.defineProperty(exports, "BreakingChangeType", {
    enumerable: true,
    get: function get() {
      return _findBreakingChanges.BreakingChangeType;
    }
  });
  Object.defineProperty(exports, "DangerousChangeType", {
    enumerable: true,
    get: function get() {
      return _findBreakingChanges.DangerousChangeType;
    }
  });
  Object.defineProperty(exports, "findBreakingChanges", {
    enumerable: true,
    get: function get() {
      return _findBreakingChanges.findBreakingChanges;
    }
  });
  Object.defineProperty(exports, "findDangerousChanges", {
    enumerable: true,
    get: function get() {
      return _findBreakingChanges.findDangerousChanges;
    }
  });
  Object.defineProperty(exports, "findDeprecatedUsages", {
    enumerable: true,
    get: function get() {
      return _findDeprecatedUsages.findDeprecatedUsages;
    }
  });
  var _getIntrospectionQuery = require_getIntrospectionQuery();
  var _getOperationAST = require_getOperationAST();
  var _getOperationRootType = require_getOperationRootType();
  var _introspectionFromSchema = require_introspectionFromSchema();
  var _buildClientSchema = require_buildClientSchema();
  var _buildASTSchema = require_buildASTSchema();
  var _extendSchema = require_extendSchema();
  var _lexicographicSortSchema = require_lexicographicSortSchema();
  var _printSchema = require_printSchema();
  var _typeFromAST = require_typeFromAST();
  var _valueFromAST = require_valueFromAST();
  var _valueFromASTUntyped = require_valueFromASTUntyped();
  var _astFromValue = require_astFromValue();
  var _TypeInfo = require_TypeInfo();
  var _coerceInputValue = require_coerceInputValue();
  var _concatAST = require_concatAST();
  var _separateOperations = require_separateOperations();
  var _stripIgnoredCharacters = require_stripIgnoredCharacters();
  var _typeComparators = require_typeComparators();
  var _assertValidName = require_assertValidName();
  var _findBreakingChanges = require_findBreakingChanges();
  var _findDeprecatedUsages = require_findDeprecatedUsages();
});

// node_modules/graphql/index.js
var require_graphql2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "version", {
    enumerable: true,
    get: function get() {
      return _version.version;
    }
  });
  Object.defineProperty(exports, "versionInfo", {
    enumerable: true,
    get: function get() {
      return _version.versionInfo;
    }
  });
  Object.defineProperty(exports, "graphql", {
    enumerable: true,
    get: function get() {
      return _graphql.graphql;
    }
  });
  Object.defineProperty(exports, "graphqlSync", {
    enumerable: true,
    get: function get() {
      return _graphql.graphqlSync;
    }
  });
  Object.defineProperty(exports, "GraphQLSchema", {
    enumerable: true,
    get: function get() {
      return _index.GraphQLSchema;
    }
  });
  Object.defineProperty(exports, "GraphQLDirective", {
    enumerable: true,
    get: function get() {
      return _index.GraphQLDirective;
    }
  });
  Object.defineProperty(exports, "GraphQLScalarType", {
    enumerable: true,
    get: function get() {
      return _index.GraphQLScalarType;
    }
  });
  Object.defineProperty(exports, "GraphQLObjectType", {
    enumerable: true,
    get: function get() {
      return _index.GraphQLObjectType;
    }
  });
  Object.defineProperty(exports, "GraphQLInterfaceType", {
    enumerable: true,
    get: function get() {
      return _index.GraphQLInterfaceType;
    }
  });
  Object.defineProperty(exports, "GraphQLUnionType", {
    enumerable: true,
    get: function get() {
      return _index.GraphQLUnionType;
    }
  });
  Object.defineProperty(exports, "GraphQLEnumType", {
    enumerable: true,
    get: function get() {
      return _index.GraphQLEnumType;
    }
  });
  Object.defineProperty(exports, "GraphQLInputObjectType", {
    enumerable: true,
    get: function get() {
      return _index.GraphQLInputObjectType;
    }
  });
  Object.defineProperty(exports, "GraphQLList", {
    enumerable: true,
    get: function get() {
      return _index.GraphQLList;
    }
  });
  Object.defineProperty(exports, "GraphQLNonNull", {
    enumerable: true,
    get: function get() {
      return _index.GraphQLNonNull;
    }
  });
  Object.defineProperty(exports, "specifiedScalarTypes", {
    enumerable: true,
    get: function get() {
      return _index.specifiedScalarTypes;
    }
  });
  Object.defineProperty(exports, "GraphQLInt", {
    enumerable: true,
    get: function get() {
      return _index.GraphQLInt;
    }
  });
  Object.defineProperty(exports, "GraphQLFloat", {
    enumerable: true,
    get: function get() {
      return _index.GraphQLFloat;
    }
  });
  Object.defineProperty(exports, "GraphQLString", {
    enumerable: true,
    get: function get() {
      return _index.GraphQLString;
    }
  });
  Object.defineProperty(exports, "GraphQLBoolean", {
    enumerable: true,
    get: function get() {
      return _index.GraphQLBoolean;
    }
  });
  Object.defineProperty(exports, "GraphQLID", {
    enumerable: true,
    get: function get() {
      return _index.GraphQLID;
    }
  });
  Object.defineProperty(exports, "specifiedDirectives", {
    enumerable: true,
    get: function get() {
      return _index.specifiedDirectives;
    }
  });
  Object.defineProperty(exports, "GraphQLIncludeDirective", {
    enumerable: true,
    get: function get() {
      return _index.GraphQLIncludeDirective;
    }
  });
  Object.defineProperty(exports, "GraphQLSkipDirective", {
    enumerable: true,
    get: function get() {
      return _index.GraphQLSkipDirective;
    }
  });
  Object.defineProperty(exports, "GraphQLDeprecatedDirective", {
    enumerable: true,
    get: function get() {
      return _index.GraphQLDeprecatedDirective;
    }
  });
  Object.defineProperty(exports, "GraphQLSpecifiedByDirective", {
    enumerable: true,
    get: function get() {
      return _index.GraphQLSpecifiedByDirective;
    }
  });
  Object.defineProperty(exports, "TypeKind", {
    enumerable: true,
    get: function get() {
      return _index.TypeKind;
    }
  });
  Object.defineProperty(exports, "DEFAULT_DEPRECATION_REASON", {
    enumerable: true,
    get: function get() {
      return _index.DEFAULT_DEPRECATION_REASON;
    }
  });
  Object.defineProperty(exports, "introspectionTypes", {
    enumerable: true,
    get: function get() {
      return _index.introspectionTypes;
    }
  });
  Object.defineProperty(exports, "__Schema", {
    enumerable: true,
    get: function get() {
      return _index.__Schema;
    }
  });
  Object.defineProperty(exports, "__Directive", {
    enumerable: true,
    get: function get() {
      return _index.__Directive;
    }
  });
  Object.defineProperty(exports, "__DirectiveLocation", {
    enumerable: true,
    get: function get() {
      return _index.__DirectiveLocation;
    }
  });
  Object.defineProperty(exports, "__Type", {
    enumerable: true,
    get: function get() {
      return _index.__Type;
    }
  });
  Object.defineProperty(exports, "__Field", {
    enumerable: true,
    get: function get() {
      return _index.__Field;
    }
  });
  Object.defineProperty(exports, "__InputValue", {
    enumerable: true,
    get: function get() {
      return _index.__InputValue;
    }
  });
  Object.defineProperty(exports, "__EnumValue", {
    enumerable: true,
    get: function get() {
      return _index.__EnumValue;
    }
  });
  Object.defineProperty(exports, "__TypeKind", {
    enumerable: true,
    get: function get() {
      return _index.__TypeKind;
    }
  });
  Object.defineProperty(exports, "SchemaMetaFieldDef", {
    enumerable: true,
    get: function get() {
      return _index.SchemaMetaFieldDef;
    }
  });
  Object.defineProperty(exports, "TypeMetaFieldDef", {
    enumerable: true,
    get: function get() {
      return _index.TypeMetaFieldDef;
    }
  });
  Object.defineProperty(exports, "TypeNameMetaFieldDef", {
    enumerable: true,
    get: function get() {
      return _index.TypeNameMetaFieldDef;
    }
  });
  Object.defineProperty(exports, "isSchema", {
    enumerable: true,
    get: function get() {
      return _index.isSchema;
    }
  });
  Object.defineProperty(exports, "isDirective", {
    enumerable: true,
    get: function get() {
      return _index.isDirective;
    }
  });
  Object.defineProperty(exports, "isType", {
    enumerable: true,
    get: function get() {
      return _index.isType;
    }
  });
  Object.defineProperty(exports, "isScalarType", {
    enumerable: true,
    get: function get() {
      return _index.isScalarType;
    }
  });
  Object.defineProperty(exports, "isObjectType", {
    enumerable: true,
    get: function get() {
      return _index.isObjectType;
    }
  });
  Object.defineProperty(exports, "isInterfaceType", {
    enumerable: true,
    get: function get() {
      return _index.isInterfaceType;
    }
  });
  Object.defineProperty(exports, "isUnionType", {
    enumerable: true,
    get: function get() {
      return _index.isUnionType;
    }
  });
  Object.defineProperty(exports, "isEnumType", {
    enumerable: true,
    get: function get() {
      return _index.isEnumType;
    }
  });
  Object.defineProperty(exports, "isInputObjectType", {
    enumerable: true,
    get: function get() {
      return _index.isInputObjectType;
    }
  });
  Object.defineProperty(exports, "isListType", {
    enumerable: true,
    get: function get() {
      return _index.isListType;
    }
  });
  Object.defineProperty(exports, "isNonNullType", {
    enumerable: true,
    get: function get() {
      return _index.isNonNullType;
    }
  });
  Object.defineProperty(exports, "isInputType", {
    enumerable: true,
    get: function get() {
      return _index.isInputType;
    }
  });
  Object.defineProperty(exports, "isOutputType", {
    enumerable: true,
    get: function get() {
      return _index.isOutputType;
    }
  });
  Object.defineProperty(exports, "isLeafType", {
    enumerable: true,
    get: function get() {
      return _index.isLeafType;
    }
  });
  Object.defineProperty(exports, "isCompositeType", {
    enumerable: true,
    get: function get() {
      return _index.isCompositeType;
    }
  });
  Object.defineProperty(exports, "isAbstractType", {
    enumerable: true,
    get: function get() {
      return _index.isAbstractType;
    }
  });
  Object.defineProperty(exports, "isWrappingType", {
    enumerable: true,
    get: function get() {
      return _index.isWrappingType;
    }
  });
  Object.defineProperty(exports, "isNullableType", {
    enumerable: true,
    get: function get() {
      return _index.isNullableType;
    }
  });
  Object.defineProperty(exports, "isNamedType", {
    enumerable: true,
    get: function get() {
      return _index.isNamedType;
    }
  });
  Object.defineProperty(exports, "isRequiredArgument", {
    enumerable: true,
    get: function get() {
      return _index.isRequiredArgument;
    }
  });
  Object.defineProperty(exports, "isRequiredInputField", {
    enumerable: true,
    get: function get() {
      return _index.isRequiredInputField;
    }
  });
  Object.defineProperty(exports, "isSpecifiedScalarType", {
    enumerable: true,
    get: function get() {
      return _index.isSpecifiedScalarType;
    }
  });
  Object.defineProperty(exports, "isIntrospectionType", {
    enumerable: true,
    get: function get() {
      return _index.isIntrospectionType;
    }
  });
  Object.defineProperty(exports, "isSpecifiedDirective", {
    enumerable: true,
    get: function get() {
      return _index.isSpecifiedDirective;
    }
  });
  Object.defineProperty(exports, "assertSchema", {
    enumerable: true,
    get: function get() {
      return _index.assertSchema;
    }
  });
  Object.defineProperty(exports, "assertDirective", {
    enumerable: true,
    get: function get() {
      return _index.assertDirective;
    }
  });
  Object.defineProperty(exports, "assertType", {
    enumerable: true,
    get: function get() {
      return _index.assertType;
    }
  });
  Object.defineProperty(exports, "assertScalarType", {
    enumerable: true,
    get: function get() {
      return _index.assertScalarType;
    }
  });
  Object.defineProperty(exports, "assertObjectType", {
    enumerable: true,
    get: function get() {
      return _index.assertObjectType;
    }
  });
  Object.defineProperty(exports, "assertInterfaceType", {
    enumerable: true,
    get: function get() {
      return _index.assertInterfaceType;
    }
  });
  Object.defineProperty(exports, "assertUnionType", {
    enumerable: true,
    get: function get() {
      return _index.assertUnionType;
    }
  });
  Object.defineProperty(exports, "assertEnumType", {
    enumerable: true,
    get: function get() {
      return _index.assertEnumType;
    }
  });
  Object.defineProperty(exports, "assertInputObjectType", {
    enumerable: true,
    get: function get() {
      return _index.assertInputObjectType;
    }
  });
  Object.defineProperty(exports, "assertListType", {
    enumerable: true,
    get: function get() {
      return _index.assertListType;
    }
  });
  Object.defineProperty(exports, "assertNonNullType", {
    enumerable: true,
    get: function get() {
      return _index.assertNonNullType;
    }
  });
  Object.defineProperty(exports, "assertInputType", {
    enumerable: true,
    get: function get() {
      return _index.assertInputType;
    }
  });
  Object.defineProperty(exports, "assertOutputType", {
    enumerable: true,
    get: function get() {
      return _index.assertOutputType;
    }
  });
  Object.defineProperty(exports, "assertLeafType", {
    enumerable: true,
    get: function get() {
      return _index.assertLeafType;
    }
  });
  Object.defineProperty(exports, "assertCompositeType", {
    enumerable: true,
    get: function get() {
      return _index.assertCompositeType;
    }
  });
  Object.defineProperty(exports, "assertAbstractType", {
    enumerable: true,
    get: function get() {
      return _index.assertAbstractType;
    }
  });
  Object.defineProperty(exports, "assertWrappingType", {
    enumerable: true,
    get: function get() {
      return _index.assertWrappingType;
    }
  });
  Object.defineProperty(exports, "assertNullableType", {
    enumerable: true,
    get: function get() {
      return _index.assertNullableType;
    }
  });
  Object.defineProperty(exports, "assertNamedType", {
    enumerable: true,
    get: function get() {
      return _index.assertNamedType;
    }
  });
  Object.defineProperty(exports, "getNullableType", {
    enumerable: true,
    get: function get() {
      return _index.getNullableType;
    }
  });
  Object.defineProperty(exports, "getNamedType", {
    enumerable: true,
    get: function get() {
      return _index.getNamedType;
    }
  });
  Object.defineProperty(exports, "validateSchema", {
    enumerable: true,
    get: function get() {
      return _index.validateSchema;
    }
  });
  Object.defineProperty(exports, "assertValidSchema", {
    enumerable: true,
    get: function get() {
      return _index.assertValidSchema;
    }
  });
  Object.defineProperty(exports, "Token", {
    enumerable: true,
    get: function get() {
      return _index2.Token;
    }
  });
  Object.defineProperty(exports, "Source", {
    enumerable: true,
    get: function get() {
      return _index2.Source;
    }
  });
  Object.defineProperty(exports, "Location", {
    enumerable: true,
    get: function get() {
      return _index2.Location;
    }
  });
  Object.defineProperty(exports, "getLocation", {
    enumerable: true,
    get: function get() {
      return _index2.getLocation;
    }
  });
  Object.defineProperty(exports, "printLocation", {
    enumerable: true,
    get: function get() {
      return _index2.printLocation;
    }
  });
  Object.defineProperty(exports, "printSourceLocation", {
    enumerable: true,
    get: function get() {
      return _index2.printSourceLocation;
    }
  });
  Object.defineProperty(exports, "Lexer", {
    enumerable: true,
    get: function get() {
      return _index2.Lexer;
    }
  });
  Object.defineProperty(exports, "TokenKind", {
    enumerable: true,
    get: function get() {
      return _index2.TokenKind;
    }
  });
  Object.defineProperty(exports, "parse", {
    enumerable: true,
    get: function get() {
      return _index2.parse;
    }
  });
  Object.defineProperty(exports, "parseValue", {
    enumerable: true,
    get: function get() {
      return _index2.parseValue;
    }
  });
  Object.defineProperty(exports, "parseType", {
    enumerable: true,
    get: function get() {
      return _index2.parseType;
    }
  });
  Object.defineProperty(exports, "print", {
    enumerable: true,
    get: function get() {
      return _index2.print;
    }
  });
  Object.defineProperty(exports, "visit", {
    enumerable: true,
    get: function get() {
      return _index2.visit;
    }
  });
  Object.defineProperty(exports, "visitInParallel", {
    enumerable: true,
    get: function get() {
      return _index2.visitInParallel;
    }
  });
  Object.defineProperty(exports, "getVisitFn", {
    enumerable: true,
    get: function get() {
      return _index2.getVisitFn;
    }
  });
  Object.defineProperty(exports, "BREAK", {
    enumerable: true,
    get: function get() {
      return _index2.BREAK;
    }
  });
  Object.defineProperty(exports, "Kind", {
    enumerable: true,
    get: function get() {
      return _index2.Kind;
    }
  });
  Object.defineProperty(exports, "DirectiveLocation", {
    enumerable: true,
    get: function get() {
      return _index2.DirectiveLocation;
    }
  });
  Object.defineProperty(exports, "isDefinitionNode", {
    enumerable: true,
    get: function get() {
      return _index2.isDefinitionNode;
    }
  });
  Object.defineProperty(exports, "isExecutableDefinitionNode", {
    enumerable: true,
    get: function get() {
      return _index2.isExecutableDefinitionNode;
    }
  });
  Object.defineProperty(exports, "isSelectionNode", {
    enumerable: true,
    get: function get() {
      return _index2.isSelectionNode;
    }
  });
  Object.defineProperty(exports, "isValueNode", {
    enumerable: true,
    get: function get() {
      return _index2.isValueNode;
    }
  });
  Object.defineProperty(exports, "isTypeNode", {
    enumerable: true,
    get: function get() {
      return _index2.isTypeNode;
    }
  });
  Object.defineProperty(exports, "isTypeSystemDefinitionNode", {
    enumerable: true,
    get: function get() {
      return _index2.isTypeSystemDefinitionNode;
    }
  });
  Object.defineProperty(exports, "isTypeDefinitionNode", {
    enumerable: true,
    get: function get() {
      return _index2.isTypeDefinitionNode;
    }
  });
  Object.defineProperty(exports, "isTypeSystemExtensionNode", {
    enumerable: true,
    get: function get() {
      return _index2.isTypeSystemExtensionNode;
    }
  });
  Object.defineProperty(exports, "isTypeExtensionNode", {
    enumerable: true,
    get: function get() {
      return _index2.isTypeExtensionNode;
    }
  });
  Object.defineProperty(exports, "execute", {
    enumerable: true,
    get: function get() {
      return _index3.execute;
    }
  });
  Object.defineProperty(exports, "executeSync", {
    enumerable: true,
    get: function get() {
      return _index3.executeSync;
    }
  });
  Object.defineProperty(exports, "defaultFieldResolver", {
    enumerable: true,
    get: function get() {
      return _index3.defaultFieldResolver;
    }
  });
  Object.defineProperty(exports, "defaultTypeResolver", {
    enumerable: true,
    get: function get() {
      return _index3.defaultTypeResolver;
    }
  });
  Object.defineProperty(exports, "responsePathAsArray", {
    enumerable: true,
    get: function get() {
      return _index3.responsePathAsArray;
    }
  });
  Object.defineProperty(exports, "getDirectiveValues", {
    enumerable: true,
    get: function get() {
      return _index3.getDirectiveValues;
    }
  });
  Object.defineProperty(exports, "subscribe", {
    enumerable: true,
    get: function get() {
      return _index4.subscribe;
    }
  });
  Object.defineProperty(exports, "createSourceEventStream", {
    enumerable: true,
    get: function get() {
      return _index4.createSourceEventStream;
    }
  });
  Object.defineProperty(exports, "validate", {
    enumerable: true,
    get: function get() {
      return _index5.validate;
    }
  });
  Object.defineProperty(exports, "ValidationContext", {
    enumerable: true,
    get: function get() {
      return _index5.ValidationContext;
    }
  });
  Object.defineProperty(exports, "specifiedRules", {
    enumerable: true,
    get: function get() {
      return _index5.specifiedRules;
    }
  });
  Object.defineProperty(exports, "recommendedRules", {
    enumerable: true,
    get: function get() {
      return _index5.recommendedRules;
    }
  });
  Object.defineProperty(exports, "ExecutableDefinitionsRule", {
    enumerable: true,
    get: function get() {
      return _index5.ExecutableDefinitionsRule;
    }
  });
  Object.defineProperty(exports, "FieldsOnCorrectTypeRule", {
    enumerable: true,
    get: function get() {
      return _index5.FieldsOnCorrectTypeRule;
    }
  });
  Object.defineProperty(exports, "FragmentsOnCompositeTypesRule", {
    enumerable: true,
    get: function get() {
      return _index5.FragmentsOnCompositeTypesRule;
    }
  });
  Object.defineProperty(exports, "KnownArgumentNamesRule", {
    enumerable: true,
    get: function get() {
      return _index5.KnownArgumentNamesRule;
    }
  });
  Object.defineProperty(exports, "KnownDirectivesRule", {
    enumerable: true,
    get: function get() {
      return _index5.KnownDirectivesRule;
    }
  });
  Object.defineProperty(exports, "KnownFragmentNamesRule", {
    enumerable: true,
    get: function get() {
      return _index5.KnownFragmentNamesRule;
    }
  });
  Object.defineProperty(exports, "KnownTypeNamesRule", {
    enumerable: true,
    get: function get() {
      return _index5.KnownTypeNamesRule;
    }
  });
  Object.defineProperty(exports, "LoneAnonymousOperationRule", {
    enumerable: true,
    get: function get() {
      return _index5.LoneAnonymousOperationRule;
    }
  });
  Object.defineProperty(exports, "NoFragmentCyclesRule", {
    enumerable: true,
    get: function get() {
      return _index5.NoFragmentCyclesRule;
    }
  });
  Object.defineProperty(exports, "NoUndefinedVariablesRule", {
    enumerable: true,
    get: function get() {
      return _index5.NoUndefinedVariablesRule;
    }
  });
  Object.defineProperty(exports, "NoUnusedFragmentsRule", {
    enumerable: true,
    get: function get() {
      return _index5.NoUnusedFragmentsRule;
    }
  });
  Object.defineProperty(exports, "NoUnusedVariablesRule", {
    enumerable: true,
    get: function get() {
      return _index5.NoUnusedVariablesRule;
    }
  });
  Object.defineProperty(exports, "OverlappingFieldsCanBeMergedRule", {
    enumerable: true,
    get: function get() {
      return _index5.OverlappingFieldsCanBeMergedRule;
    }
  });
  Object.defineProperty(exports, "PossibleFragmentSpreadsRule", {
    enumerable: true,
    get: function get() {
      return _index5.PossibleFragmentSpreadsRule;
    }
  });
  Object.defineProperty(exports, "ProvidedRequiredArgumentsRule", {
    enumerable: true,
    get: function get() {
      return _index5.ProvidedRequiredArgumentsRule;
    }
  });
  Object.defineProperty(exports, "ScalarLeafsRule", {
    enumerable: true,
    get: function get() {
      return _index5.ScalarLeafsRule;
    }
  });
  Object.defineProperty(exports, "SingleFieldSubscriptionsRule", {
    enumerable: true,
    get: function get() {
      return _index5.SingleFieldSubscriptionsRule;
    }
  });
  Object.defineProperty(exports, "UniqueArgumentNamesRule", {
    enumerable: true,
    get: function get() {
      return _index5.UniqueArgumentNamesRule;
    }
  });
  Object.defineProperty(exports, "UniqueDirectivesPerLocationRule", {
    enumerable: true,
    get: function get() {
      return _index5.UniqueDirectivesPerLocationRule;
    }
  });
  Object.defineProperty(exports, "UniqueFragmentNamesRule", {
    enumerable: true,
    get: function get() {
      return _index5.UniqueFragmentNamesRule;
    }
  });
  Object.defineProperty(exports, "UniqueInputFieldNamesRule", {
    enumerable: true,
    get: function get() {
      return _index5.UniqueInputFieldNamesRule;
    }
  });
  Object.defineProperty(exports, "UniqueOperationNamesRule", {
    enumerable: true,
    get: function get() {
      return _index5.UniqueOperationNamesRule;
    }
  });
  Object.defineProperty(exports, "UniqueVariableNamesRule", {
    enumerable: true,
    get: function get() {
      return _index5.UniqueVariableNamesRule;
    }
  });
  Object.defineProperty(exports, "ValuesOfCorrectTypeRule", {
    enumerable: true,
    get: function get() {
      return _index5.ValuesOfCorrectTypeRule;
    }
  });
  Object.defineProperty(exports, "VariablesAreInputTypesRule", {
    enumerable: true,
    get: function get() {
      return _index5.VariablesAreInputTypesRule;
    }
  });
  Object.defineProperty(exports, "VariablesInAllowedPositionRule", {
    enumerable: true,
    get: function get() {
      return _index5.VariablesInAllowedPositionRule;
    }
  });
  Object.defineProperty(exports, "MaxIntrospectionDepthRule", {
    enumerable: true,
    get: function get() {
      return _index5.MaxIntrospectionDepthRule;
    }
  });
  Object.defineProperty(exports, "LoneSchemaDefinitionRule", {
    enumerable: true,
    get: function get() {
      return _index5.LoneSchemaDefinitionRule;
    }
  });
  Object.defineProperty(exports, "UniqueOperationTypesRule", {
    enumerable: true,
    get: function get() {
      return _index5.UniqueOperationTypesRule;
    }
  });
  Object.defineProperty(exports, "UniqueTypeNamesRule", {
    enumerable: true,
    get: function get() {
      return _index5.UniqueTypeNamesRule;
    }
  });
  Object.defineProperty(exports, "UniqueEnumValueNamesRule", {
    enumerable: true,
    get: function get() {
      return _index5.UniqueEnumValueNamesRule;
    }
  });
  Object.defineProperty(exports, "UniqueFieldDefinitionNamesRule", {
    enumerable: true,
    get: function get() {
      return _index5.UniqueFieldDefinitionNamesRule;
    }
  });
  Object.defineProperty(exports, "UniqueDirectiveNamesRule", {
    enumerable: true,
    get: function get() {
      return _index5.UniqueDirectiveNamesRule;
    }
  });
  Object.defineProperty(exports, "PossibleTypeExtensionsRule", {
    enumerable: true,
    get: function get() {
      return _index5.PossibleTypeExtensionsRule;
    }
  });
  Object.defineProperty(exports, "NoDeprecatedCustomRule", {
    enumerable: true,
    get: function get() {
      return _index5.NoDeprecatedCustomRule;
    }
  });
  Object.defineProperty(exports, "NoSchemaIntrospectionCustomRule", {
    enumerable: true,
    get: function get() {
      return _index5.NoSchemaIntrospectionCustomRule;
    }
  });
  Object.defineProperty(exports, "GraphQLError", {
    enumerable: true,
    get: function get() {
      return _index6.GraphQLError;
    }
  });
  Object.defineProperty(exports, "syntaxError", {
    enumerable: true,
    get: function get() {
      return _index6.syntaxError;
    }
  });
  Object.defineProperty(exports, "locatedError", {
    enumerable: true,
    get: function get() {
      return _index6.locatedError;
    }
  });
  Object.defineProperty(exports, "printError", {
    enumerable: true,
    get: function get() {
      return _index6.printError;
    }
  });
  Object.defineProperty(exports, "formatError", {
    enumerable: true,
    get: function get() {
      return _index6.formatError;
    }
  });
  Object.defineProperty(exports, "getIntrospectionQuery", {
    enumerable: true,
    get: function get() {
      return _index7.getIntrospectionQuery;
    }
  });
  Object.defineProperty(exports, "getOperationAST", {
    enumerable: true,
    get: function get() {
      return _index7.getOperationAST;
    }
  });
  Object.defineProperty(exports, "getOperationRootType", {
    enumerable: true,
    get: function get() {
      return _index7.getOperationRootType;
    }
  });
  Object.defineProperty(exports, "introspectionFromSchema", {
    enumerable: true,
    get: function get() {
      return _index7.introspectionFromSchema;
    }
  });
  Object.defineProperty(exports, "buildClientSchema", {
    enumerable: true,
    get: function get() {
      return _index7.buildClientSchema;
    }
  });
  Object.defineProperty(exports, "buildASTSchema", {
    enumerable: true,
    get: function get() {
      return _index7.buildASTSchema;
    }
  });
  Object.defineProperty(exports, "buildSchema", {
    enumerable: true,
    get: function get() {
      return _index7.buildSchema;
    }
  });
  Object.defineProperty(exports, "getDescription", {
    enumerable: true,
    get: function get() {
      return _index7.getDescription;
    }
  });
  Object.defineProperty(exports, "extendSchema", {
    enumerable: true,
    get: function get() {
      return _index7.extendSchema;
    }
  });
  Object.defineProperty(exports, "lexicographicSortSchema", {
    enumerable: true,
    get: function get() {
      return _index7.lexicographicSortSchema;
    }
  });
  Object.defineProperty(exports, "printSchema", {
    enumerable: true,
    get: function get() {
      return _index7.printSchema;
    }
  });
  Object.defineProperty(exports, "printType", {
    enumerable: true,
    get: function get() {
      return _index7.printType;
    }
  });
  Object.defineProperty(exports, "printIntrospectionSchema", {
    enumerable: true,
    get: function get() {
      return _index7.printIntrospectionSchema;
    }
  });
  Object.defineProperty(exports, "typeFromAST", {
    enumerable: true,
    get: function get() {
      return _index7.typeFromAST;
    }
  });
  Object.defineProperty(exports, "valueFromAST", {
    enumerable: true,
    get: function get() {
      return _index7.valueFromAST;
    }
  });
  Object.defineProperty(exports, "valueFromASTUntyped", {
    enumerable: true,
    get: function get() {
      return _index7.valueFromASTUntyped;
    }
  });
  Object.defineProperty(exports, "astFromValue", {
    enumerable: true,
    get: function get() {
      return _index7.astFromValue;
    }
  });
  Object.defineProperty(exports, "TypeInfo", {
    enumerable: true,
    get: function get() {
      return _index7.TypeInfo;
    }
  });
  Object.defineProperty(exports, "visitWithTypeInfo", {
    enumerable: true,
    get: function get() {
      return _index7.visitWithTypeInfo;
    }
  });
  Object.defineProperty(exports, "coerceInputValue", {
    enumerable: true,
    get: function get() {
      return _index7.coerceInputValue;
    }
  });
  Object.defineProperty(exports, "concatAST", {
    enumerable: true,
    get: function get() {
      return _index7.concatAST;
    }
  });
  Object.defineProperty(exports, "separateOperations", {
    enumerable: true,
    get: function get() {
      return _index7.separateOperations;
    }
  });
  Object.defineProperty(exports, "stripIgnoredCharacters", {
    enumerable: true,
    get: function get() {
      return _index7.stripIgnoredCharacters;
    }
  });
  Object.defineProperty(exports, "isEqualType", {
    enumerable: true,
    get: function get() {
      return _index7.isEqualType;
    }
  });
  Object.defineProperty(exports, "isTypeSubTypeOf", {
    enumerable: true,
    get: function get() {
      return _index7.isTypeSubTypeOf;
    }
  });
  Object.defineProperty(exports, "doTypesOverlap", {
    enumerable: true,
    get: function get() {
      return _index7.doTypesOverlap;
    }
  });
  Object.defineProperty(exports, "assertValidName", {
    enumerable: true,
    get: function get() {
      return _index7.assertValidName;
    }
  });
  Object.defineProperty(exports, "isValidNameError", {
    enumerable: true,
    get: function get() {
      return _index7.isValidNameError;
    }
  });
  Object.defineProperty(exports, "BreakingChangeType", {
    enumerable: true,
    get: function get() {
      return _index7.BreakingChangeType;
    }
  });
  Object.defineProperty(exports, "DangerousChangeType", {
    enumerable: true,
    get: function get() {
      return _index7.DangerousChangeType;
    }
  });
  Object.defineProperty(exports, "findBreakingChanges", {
    enumerable: true,
    get: function get() {
      return _index7.findBreakingChanges;
    }
  });
  Object.defineProperty(exports, "findDangerousChanges", {
    enumerable: true,
    get: function get() {
      return _index7.findDangerousChanges;
    }
  });
  Object.defineProperty(exports, "findDeprecatedUsages", {
    enumerable: true,
    get: function get() {
      return _index7.findDeprecatedUsages;
    }
  });
  var _version = require_version();
  var _graphql = require_graphql();
  var _index = require_type();
  var _index2 = require_language2();
  var _index3 = require_execution();
  var _index4 = require_subscription();
  var _index5 = require_validation();
  var _index6 = require_error();
  var _index7 = require_utilities();
});

// node_modules/apollo-server-errors/dist/index.js
var require_dist2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.formatApolloErrors = exports.UserInputError = exports.PersistedQueryNotSupportedError = exports.PersistedQueryNotFoundError = exports.ForbiddenError = exports.AuthenticationError = exports.ValidationError = exports.SyntaxError = exports.fromGraphQLError = exports.toApolloError = exports.ApolloError = undefined;
  var graphql_1 = require_graphql2();

  class ApolloError extends Error {
    constructor(message2, code, extensions) {
      super(message2);
      if (!this.name) {
        Object.defineProperty(this, "name", { value: "ApolloError" });
      }
      if (extensions === null || extensions === undefined ? undefined : extensions.extensions) {
        throw Error("Pass extensions directly as the third argument of the ApolloError constructor: `new " + "ApolloError(message, code, {myExt: value})`, not `new ApolloError(message, code, " + "{extensions: {myExt: value}})`");
      }
      this.extensions = { ...extensions, code };
    }
    toJSON() {
      return (0, graphql_1.formatError)(toGraphQLError(this));
    }
    toString() {
      return (0, graphql_1.printError)(toGraphQLError(this));
    }
    get [Symbol.toStringTag]() {
      return this.name;
    }
  }
  exports.ApolloError = ApolloError;
  function toGraphQLError(error) {
    return new graphql_1.GraphQLError(error.message, error.nodes, error.source, error.positions, error.path, error.originalError, error.extensions);
  }
  function enrichError(error, debug = false) {
    var _a, _b, _c;
    const expanded = Object.create(Object.getPrototypeOf(error), {
      name: {
        value: error.name
      },
      message: {
        value: error.message,
        enumerable: true,
        writable: true
      },
      locations: {
        value: error.locations || undefined,
        enumerable: true
      },
      path: {
        value: error.path || undefined,
        enumerable: true
      },
      nodes: {
        value: error.nodes || undefined
      },
      source: {
        value: error.source || undefined
      },
      positions: {
        value: error.positions || undefined
      },
      originalError: {
        value: error.originalError
      }
    });
    expanded.extensions = {
      ...error.extensions,
      code: ((_a = error.extensions) === null || _a === undefined ? undefined : _a.code) || "INTERNAL_SERVER_ERROR",
      exception: {
        ...(_b = error.extensions) === null || _b === undefined ? undefined : _b.exception,
        ...error.originalError
      }
    };
    delete expanded.extensions.exception.extensions;
    if (debug && !expanded.extensions.exception.stacktrace) {
      const stack2 = ((_c = error.originalError) === null || _c === undefined ? undefined : _c.stack) || error.stack;
      expanded.extensions.exception.stacktrace = stack2 === null || stack2 === undefined ? undefined : stack2.split(`
`);
    }
    if (Object.keys(expanded.extensions.exception).length === 0) {
      delete expanded.extensions.exception;
    }
    return expanded;
  }
  function toApolloError(error, code = "INTERNAL_SERVER_ERROR") {
    let err = error;
    if (err.extensions) {
      err.extensions.code = code;
    } else {
      err.extensions = { code };
    }
    return err;
  }
  exports.toApolloError = toApolloError;
  function fromGraphQLError(error, options) {
    const copy = (options === null || options === undefined ? undefined : options.errorClass) ? new options.errorClass(error.message) : new ApolloError(error.message);
    Object.entries(error).forEach(([key, value]) => {
      if (key === "extensions") {
        return;
      }
      copy[key] = value;
    });
    copy.extensions = {
      ...copy.extensions,
      ...error.extensions
    };
    if (!copy.extensions.code) {
      copy.extensions.code = (options === null || options === undefined ? undefined : options.code) || "INTERNAL_SERVER_ERROR";
    }
    Object.defineProperty(copy, "originalError", { value: {} });
    Object.getOwnPropertyNames(error).forEach((key) => {
      Object.defineProperty(copy.originalError, key, {
        value: error[key]
      });
    });
    return copy;
  }
  exports.fromGraphQLError = fromGraphQLError;

  class SyntaxError2 extends ApolloError {
    constructor(message2) {
      super(message2, "GRAPHQL_PARSE_FAILED");
      Object.defineProperty(this, "name", { value: "SyntaxError" });
    }
  }
  exports.SyntaxError = SyntaxError2;

  class ValidationError extends ApolloError {
    constructor(message2) {
      super(message2, "GRAPHQL_VALIDATION_FAILED");
      Object.defineProperty(this, "name", { value: "ValidationError" });
    }
  }
  exports.ValidationError = ValidationError;

  class AuthenticationError extends ApolloError {
    constructor(message2, extensions) {
      super(message2, "UNAUTHENTICATED", extensions);
      Object.defineProperty(this, "name", { value: "AuthenticationError" });
    }
  }
  exports.AuthenticationError = AuthenticationError;

  class ForbiddenError extends ApolloError {
    constructor(message2, extensions) {
      super(message2, "FORBIDDEN", extensions);
      Object.defineProperty(this, "name", { value: "ForbiddenError" });
    }
  }
  exports.ForbiddenError = ForbiddenError;

  class PersistedQueryNotFoundError extends ApolloError {
    constructor() {
      super("PersistedQueryNotFound", "PERSISTED_QUERY_NOT_FOUND");
      Object.defineProperty(this, "name", {
        value: "PersistedQueryNotFoundError"
      });
    }
  }
  exports.PersistedQueryNotFoundError = PersistedQueryNotFoundError;

  class PersistedQueryNotSupportedError extends ApolloError {
    constructor() {
      super("PersistedQueryNotSupported", "PERSISTED_QUERY_NOT_SUPPORTED");
      Object.defineProperty(this, "name", {
        value: "PersistedQueryNotSupportedError"
      });
    }
  }
  exports.PersistedQueryNotSupportedError = PersistedQueryNotSupportedError;

  class UserInputError extends ApolloError {
    constructor(message2, extensions) {
      super(message2, "BAD_USER_INPUT", extensions);
      Object.defineProperty(this, "name", { value: "UserInputError" });
    }
  }
  exports.UserInputError = UserInputError;
  function formatApolloErrors(errors, options) {
    if (!options) {
      return errors.map((error) => enrichError(error));
    }
    const { formatter, debug } = options;
    const enrichedErrors = errors.map((error) => enrichError(error, debug));
    const makePrintable = (error) => {
      if (error instanceof Error) {
        const graphQLError = error;
        return {
          message: graphQLError.message,
          ...graphQLError.locations && { locations: graphQLError.locations },
          ...graphQLError.path && { path: graphQLError.path },
          ...graphQLError.extensions && { extensions: graphQLError.extensions }
        };
      }
      return error;
    };
    if (!formatter) {
      return enrichedErrors;
    }
    return enrichedErrors.map((error) => {
      try {
        return makePrintable(formatter(error));
      } catch (err) {
        if (debug) {
          return enrichError(err, debug);
        } else {
          const newError = fromGraphQLError(new graphql_1.GraphQLError("Internal server error"));
          return enrichError(newError, debug);
        }
      }
    });
  }
  exports.formatApolloErrors = formatApolloErrors;
});

// node_modules/whatwg-mimetype/lib/utils.js
var require_utils4 = __commonJS((exports) => {
  exports.removeLeadingAndTrailingHTTPWhitespace = (string) => {
    return string.replace(/^[ \t\n\r]+/u, "").replace(/[ \t\n\r]+$/u, "");
  };
  exports.removeTrailingHTTPWhitespace = (string) => {
    return string.replace(/[ \t\n\r]+$/u, "");
  };
  exports.isHTTPWhitespaceChar = (char) => {
    return char === " " || char === "\t" || char === `
` || char === "\r";
  };
  exports.solelyContainsHTTPTokenCodePoints = (string) => {
    return /^[-!#$%&'*+.^_`|~A-Za-z0-9]*$/u.test(string);
  };
  exports.soleyContainsHTTPQuotedStringTokenCodePoints = (string) => {
    return /^[\t\u0020-\u007E\u0080-\u00FF]*$/u.test(string);
  };
  exports.asciiLowercase = (string) => {
    return string.replace(/[A-Z]/ug, (l) => l.toLowerCase());
  };
  exports.collectAnHTTPQuotedString = (input, position) => {
    let value = "";
    position++;
    while (true) {
      while (position < input.length && input[position] !== '"' && input[position] !== "\\") {
        value += input[position];
        ++position;
      }
      if (position >= input.length) {
        break;
      }
      const quoteOrBackslash = input[position];
      ++position;
      if (quoteOrBackslash === "\\") {
        if (position >= input.length) {
          value += "\\";
          break;
        }
        value += input[position];
        ++position;
      } else {
        break;
      }
    }
    return [value, position];
  };
});

// node_modules/whatwg-mimetype/lib/mime-type-parameters.js
var require_mime_type_parameters = __commonJS((exports, module) => {
  var {
    asciiLowercase,
    solelyContainsHTTPTokenCodePoints,
    soleyContainsHTTPQuotedStringTokenCodePoints
  } = require_utils4();
  module.exports = class MIMETypeParameters {
    constructor(map) {
      this._map = map;
    }
    get size() {
      return this._map.size;
    }
    get(name) {
      name = asciiLowercase(String(name));
      return this._map.get(name);
    }
    has(name) {
      name = asciiLowercase(String(name));
      return this._map.has(name);
    }
    set(name, value) {
      name = asciiLowercase(String(name));
      value = String(value);
      if (!solelyContainsHTTPTokenCodePoints(name)) {
        throw new Error(`Invalid MIME type parameter name "${name}": only HTTP token code points are valid.`);
      }
      if (!soleyContainsHTTPQuotedStringTokenCodePoints(value)) {
        throw new Error(`Invalid MIME type parameter value "${value}": only HTTP quoted-string token code points are ` + `valid.`);
      }
      return this._map.set(name, value);
    }
    clear() {
      this._map.clear();
    }
    delete(name) {
      name = asciiLowercase(String(name));
      return this._map.delete(name);
    }
    forEach(callbackFn, thisArg) {
      this._map.forEach(callbackFn, thisArg);
    }
    keys() {
      return this._map.keys();
    }
    values() {
      return this._map.values();
    }
    entries() {
      return this._map.entries();
    }
    [Symbol.iterator]() {
      return this._map[Symbol.iterator]();
    }
  };
});

// node_modules/whatwg-mimetype/lib/parser.js
var require_parser2 = __commonJS((exports, module) => {
  var {
    removeLeadingAndTrailingHTTPWhitespace,
    removeTrailingHTTPWhitespace,
    isHTTPWhitespaceChar,
    solelyContainsHTTPTokenCodePoints,
    soleyContainsHTTPQuotedStringTokenCodePoints,
    asciiLowercase,
    collectAnHTTPQuotedString
  } = require_utils4();
  module.exports = (input) => {
    input = removeLeadingAndTrailingHTTPWhitespace(input);
    let position = 0;
    let type = "";
    while (position < input.length && input[position] !== "/") {
      type += input[position];
      ++position;
    }
    if (type.length === 0 || !solelyContainsHTTPTokenCodePoints(type)) {
      return null;
    }
    if (position >= input.length) {
      return null;
    }
    ++position;
    let subtype = "";
    while (position < input.length && input[position] !== ";") {
      subtype += input[position];
      ++position;
    }
    subtype = removeTrailingHTTPWhitespace(subtype);
    if (subtype.length === 0 || !solelyContainsHTTPTokenCodePoints(subtype)) {
      return null;
    }
    const mimeType = {
      type: asciiLowercase(type),
      subtype: asciiLowercase(subtype),
      parameters: new Map
    };
    while (position < input.length) {
      ++position;
      while (isHTTPWhitespaceChar(input[position])) {
        ++position;
      }
      let parameterName = "";
      while (position < input.length && input[position] !== ";" && input[position] !== "=") {
        parameterName += input[position];
        ++position;
      }
      parameterName = asciiLowercase(parameterName);
      if (position < input.length) {
        if (input[position] === ";") {
          continue;
        }
        ++position;
      }
      let parameterValue = null;
      if (input[position] === '"') {
        [parameterValue, position] = collectAnHTTPQuotedString(input, position);
        while (position < input.length && input[position] !== ";") {
          ++position;
        }
      } else {
        parameterValue = "";
        while (position < input.length && input[position] !== ";") {
          parameterValue += input[position];
          ++position;
        }
        parameterValue = removeTrailingHTTPWhitespace(parameterValue);
        if (parameterValue === "") {
          continue;
        }
      }
      if (parameterName.length > 0 && solelyContainsHTTPTokenCodePoints(parameterName) && soleyContainsHTTPQuotedStringTokenCodePoints(parameterValue) && !mimeType.parameters.has(parameterName)) {
        mimeType.parameters.set(parameterName, parameterValue);
      }
    }
    return mimeType;
  };
});

// node_modules/whatwg-mimetype/lib/serializer.js
var require_serializer = __commonJS((exports, module) => {
  var { solelyContainsHTTPTokenCodePoints } = require_utils4();
  module.exports = (mimeType) => {
    let serialization = `${mimeType.type}/${mimeType.subtype}`;
    if (mimeType.parameters.size === 0) {
      return serialization;
    }
    for (let [name, value] of mimeType.parameters) {
      serialization += ";";
      serialization += name;
      serialization += "=";
      if (!solelyContainsHTTPTokenCodePoints(value) || value.length === 0) {
        value = value.replace(/(["\\])/ug, "\\$1");
        value = `"${value}"`;
      }
      serialization += value;
    }
    return serialization;
  };
});

// node_modules/whatwg-mimetype/lib/mime-type.js
var require_mime_type = __commonJS((exports, module) => {
  var MIMETypeParameters = require_mime_type_parameters();
  var parse = require_parser2();
  var serialize = require_serializer();
  var {
    asciiLowercase,
    solelyContainsHTTPTokenCodePoints
  } = require_utils4();
  module.exports = class MIMEType {
    constructor(string) {
      string = String(string);
      const result = parse(string);
      if (result === null) {
        throw new Error(`Could not parse MIME type string "${string}"`);
      }
      this._type = result.type;
      this._subtype = result.subtype;
      this._parameters = new MIMETypeParameters(result.parameters);
    }
    static parse(string) {
      try {
        return new this(string);
      } catch (e) {
        return null;
      }
    }
    get essence() {
      return `${this.type}/${this.subtype}`;
    }
    get type() {
      return this._type;
    }
    set type(value) {
      value = asciiLowercase(String(value));
      if (value.length === 0) {
        throw new Error("Invalid type: must be a non-empty string");
      }
      if (!solelyContainsHTTPTokenCodePoints(value)) {
        throw new Error(`Invalid type ${value}: must contain only HTTP token code points`);
      }
      this._type = value;
    }
    get subtype() {
      return this._subtype;
    }
    set subtype(value) {
      value = asciiLowercase(String(value));
      if (value.length === 0) {
        throw new Error("Invalid subtype: must be a non-empty string");
      }
      if (!solelyContainsHTTPTokenCodePoints(value)) {
        throw new Error(`Invalid subtype ${value}: must contain only HTTP token code points`);
      }
      this._subtype = value;
    }
    get parameters() {
      return this._parameters;
    }
    toString() {
      return serialize(this);
    }
    isJavaScript({ prohibitParameters = false } = {}) {
      switch (this._type) {
        case "text": {
          switch (this._subtype) {
            case "ecmascript":
            case "javascript":
            case "javascript1.0":
            case "javascript1.1":
            case "javascript1.2":
            case "javascript1.3":
            case "javascript1.4":
            case "javascript1.5":
            case "jscript":
            case "livescript":
            case "x-ecmascript":
            case "x-javascript": {
              return !prohibitParameters || this._parameters.size === 0;
            }
            default: {
              return false;
            }
          }
        }
        case "application": {
          switch (this._subtype) {
            case "ecmascript":
            case "javascript":
            case "x-ecmascript":
            case "x-javascript": {
              return !prohibitParameters || this._parameters.size === 0;
            }
            default: {
              return false;
            }
          }
        }
        default: {
          return false;
        }
      }
    }
    isXML() {
      return this._subtype === "xml" && (this._type === "text" || this._type === "application") || this._subtype.endsWith("+xml");
    }
    isHTML() {
      return this._subtype === "html" && this._type === "text";
    }
  };
});

// node_modules/apollo-server-types/dist/index.js
var require_dist3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CacheScope = undefined;
  var CacheScope;
  (function(CacheScope2) {
    CacheScope2["Public"] = "PUBLIC";
    CacheScope2["Private"] = "PRIVATE";
  })(CacheScope = exports.CacheScope || (exports.CacheScope = {}));
});

// node_modules/apollo-server-core/dist/cachePolicy.js
var require_cachePolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.newCachePolicy = undefined;
  var apollo_server_types_1 = require_dist3();
  function newCachePolicy() {
    return {
      maxAge: undefined,
      scope: undefined,
      restrict(hint) {
        if (hint.maxAge !== undefined && (this.maxAge === undefined || hint.maxAge < this.maxAge)) {
          this.maxAge = hint.maxAge;
        }
        if (hint.scope !== undefined && this.scope !== apollo_server_types_1.CacheScope.Private) {
          this.scope = hint.scope;
        }
      },
      replace(hint) {
        if (hint.maxAge !== undefined) {
          this.maxAge = hint.maxAge;
        }
        if (hint.scope !== undefined) {
          this.scope = hint.scope;
        }
      },
      policyIfCacheable() {
        var _a;
        if (this.maxAge === undefined || this.maxAge === 0) {
          return null;
        }
        return { maxAge: this.maxAge, scope: (_a = this.scope) !== null && _a !== undefined ? _a : apollo_server_types_1.CacheScope.Public };
      }
    };
  }
  exports.newCachePolicy = newCachePolicy;
});

// node_modules/apollo-server-core/dist/graphqlOptions.js
var require_graphqlOptions = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.resolveGraphqlOptions = undefined;
  async function resolveGraphqlOptions(options, ...args2) {
    if (typeof options === "function") {
      return await options(...args2);
    } else {
      return options;
    }
  }
  exports.resolveGraphqlOptions = resolveGraphqlOptions;
});

// node_modules/apollo-server-core/dist/utils/schemaInstrumentation.js
var require_schemaInstrumentation = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.whenResultIsFinished = exports.pluginsEnabledForSchemaResolvers = exports.enablePluginsForSchemaResolvers = exports.symbolUserFieldResolver = exports.symbolExecutionDispatcherWillResolveField = undefined;
  var type_1 = require_type();
  var execution_1 = require_execution();
  exports.symbolExecutionDispatcherWillResolveField = Symbol("apolloServerExecutionDispatcherWillResolveField");
  exports.symbolUserFieldResolver = Symbol("apolloServerUserFieldResolver");
  var symbolPluginsEnabled = Symbol("apolloServerPluginsEnabled");
  function enablePluginsForSchemaResolvers(schema) {
    if (pluginsEnabledForSchemaResolvers(schema)) {
      return schema;
    }
    Object.defineProperty(schema, symbolPluginsEnabled, {
      value: true
    });
    forEachField(schema, wrapField);
    return schema;
  }
  exports.enablePluginsForSchemaResolvers = enablePluginsForSchemaResolvers;
  function pluginsEnabledForSchemaResolvers(schema) {
    return !!schema[symbolPluginsEnabled];
  }
  exports.pluginsEnabledForSchemaResolvers = pluginsEnabledForSchemaResolvers;
  function wrapField(field) {
    const originalFieldResolve = field.resolve;
    field.resolve = (source, args2, context, info) => {
      const parentPath = info.path.prev;
      const willResolveField = context === null || context === undefined ? undefined : context[exports.symbolExecutionDispatcherWillResolveField];
      const userFieldResolver = context === null || context === undefined ? undefined : context[exports.symbolUserFieldResolver];
      const didResolveField = typeof willResolveField === "function" && willResolveField({ source, args: args2, context, info });
      const resolveObject = info.parentType.resolveObject;
      let whenObjectResolved;
      if (parentPath && resolveObject) {
        if (!parentPath.__fields) {
          parentPath.__fields = {};
        }
        parentPath.__fields[info.fieldName] = info.fieldNodes;
        whenObjectResolved = parentPath.__whenObjectResolved;
        if (!whenObjectResolved) {
          whenObjectResolved = Promise.resolve().then(() => {
            return resolveObject(source, parentPath.__fields, context, info);
          });
          parentPath.__whenObjectResolved = whenObjectResolved;
        }
      }
      const fieldResolver = originalFieldResolve || userFieldResolver || execution_1.defaultFieldResolver;
      try {
        let result;
        if (whenObjectResolved) {
          result = whenObjectResolved.then((resolvedObject) => {
            return fieldResolver(resolvedObject, args2, context, info);
          });
        } else {
          result = fieldResolver(source, args2, context, info);
        }
        if (typeof didResolveField === "function") {
          whenResultIsFinished(result, didResolveField);
        }
        return result;
      } catch (error) {
        if (typeof didResolveField === "function") {
          didResolveField(error);
        }
        throw error;
      }
    };
  }
  function isPromise(x) {
    return x && typeof x.then === "function";
  }
  function whenResultIsFinished(result, callback) {
    if (isPromise(result)) {
      result.then((r) => callback(null, r), (err) => callback(err));
    } else if (Array.isArray(result)) {
      if (result.some(isPromise)) {
        Promise.all(result).then((r) => callback(null, r), (err) => callback(err));
      } else {
        callback(null, result);
      }
    } else {
      callback(null, result);
    }
  }
  exports.whenResultIsFinished = whenResultIsFinished;
  function forEachField(schema, fn2) {
    const typeMap = schema.getTypeMap();
    Object.entries(typeMap).forEach(([typeName, type]) => {
      if (!(0, type_1.getNamedType)(type).name.startsWith("__") && type instanceof type_1.GraphQLObjectType) {
        const fields = type.getFields();
        Object.entries(fields).forEach(([fieldName, field]) => {
          fn2(field, typeName, fieldName);
        });
      }
    });
  }
});

// node_modules/apollo-server-core/dist/utils/dispatcher.js
var require_dispatcher = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Dispatcher = undefined;

  class Dispatcher {
    constructor(targets) {
      this.targets = targets;
    }
    callTargets(methodName, ...args2) {
      return this.targets.map((target) => {
        const method = target[methodName];
        if (typeof method === "function") {
          return method.apply(target, args2);
        }
      });
    }
    hasHook(methodName) {
      return this.targets.some((target) => typeof target[methodName] === "function");
    }
    async invokeHook(methodName, ...args2) {
      return Promise.all(this.callTargets(methodName, ...args2));
    }
    async invokeHooksUntilNonNull(methodName, ...args2) {
      for (const target of this.targets) {
        const method = target[methodName];
        if (typeof method !== "function") {
          continue;
        }
        const value = await method.apply(target, args2);
        if (value !== null) {
          return value;
        }
      }
      return null;
    }
    async invokeDidStartHook(methodName, ...args2) {
      const hookReturnValues = await Promise.all(this.callTargets(methodName, ...args2));
      const didEndHooks = hookReturnValues.filter((hook) => !!hook);
      didEndHooks.reverse();
      return async (...args3) => {
        await Promise.all(didEndHooks.map((hook) => hook(...args3)));
      };
    }
    invokeSyncDidStartHook(methodName, ...args2) {
      const didEndHooks = [];
      for (const target of this.targets) {
        const method = target[methodName];
        if (typeof method === "function") {
          const didEndHook = method.apply(target, args2);
          if (didEndHook) {
            didEndHooks.push(didEndHook);
          }
        }
      }
      didEndHooks.reverse();
      return (...args3) => {
        for (const didEndHook of didEndHooks) {
          didEndHook(...args3);
        }
      };
    }
  }
  exports.Dispatcher = Dispatcher;
});

// node_modules/@apollo/utils.keyvaluecache/dist/PrefixingKeyValueCache.js
var require_PrefixingKeyValueCache = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PrefixingKeyValueCache = undefined;

  class PrefixingKeyValueCache {
    constructor(wrapped, prefix) {
      this.wrapped = wrapped;
      this.prefix = prefix;
    }
    get(key) {
      return this.wrapped.get(this.prefix + key);
    }
    set(key, value, options) {
      return this.wrapped.set(this.prefix + key, value, options);
    }
    delete(key) {
      return this.wrapped.delete(this.prefix + key);
    }
  }
  exports.PrefixingKeyValueCache = PrefixingKeyValueCache;
});

// node_modules/@apollo/utils.keyvaluecache/node_modules/lru-cache/index.js
var require_lru_cache = __commonJS((exports, module) => {
  var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
  var hasAbortController = typeof AbortController === "function";
  var AC = hasAbortController ? AbortController : class AbortController2 {
    constructor() {
      this.signal = new AS;
    }
    abort() {
      this.signal.dispatchEvent("abort");
    }
  };
  var hasAbortSignal = typeof AbortSignal === "function";
  var hasACAbortSignal = typeof AC.AbortSignal === "function";
  var AS = hasAbortSignal ? AbortSignal : hasACAbortSignal ? AC.AbortController : class AbortSignal2 {
    constructor() {
      this.aborted = false;
      this._listeners = [];
    }
    dispatchEvent(type) {
      if (type === "abort") {
        this.aborted = true;
        const e = { type, target: this };
        this.onabort(e);
        this._listeners.forEach((f) => f(e), this);
      }
    }
    onabort() {}
    addEventListener(ev, fn2) {
      if (ev === "abort") {
        this._listeners.push(fn2);
      }
    }
    removeEventListener(ev, fn2) {
      if (ev === "abort") {
        this._listeners = this._listeners.filter((f) => f !== fn2);
      }
    }
  };
  var warned = new Set;
  var deprecatedOption = (opt, instead) => {
    const code = `LRU_CACHE_OPTION_${opt}`;
    if (shouldWarn(code)) {
      warn(code, `${opt} option`, `options.${instead}`, LRUCache);
    }
  };
  var deprecatedMethod = (method, instead) => {
    const code = `LRU_CACHE_METHOD_${method}`;
    if (shouldWarn(code)) {
      const { prototype } = LRUCache;
      const { get } = Object.getOwnPropertyDescriptor(prototype, method);
      warn(code, `${method} method`, `cache.${instead}()`, get);
    }
  };
  var deprecatedProperty = (field, instead) => {
    const code = `LRU_CACHE_PROPERTY_${field}`;
    if (shouldWarn(code)) {
      const { prototype } = LRUCache;
      const { get } = Object.getOwnPropertyDescriptor(prototype, field);
      warn(code, `${field} property`, `cache.${instead}`, get);
    }
  };
  var emitWarning = (...a) => {
    typeof process === "object" && process && typeof process.emitWarning === "function" ? process.emitWarning(...a) : console.error(...a);
  };
  var shouldWarn = (code) => !warned.has(code);
  var warn = (code, what, instead, fn2) => {
    warned.add(code);
    const msg = `The ${what} is deprecated. Please use ${instead} instead.`;
    emitWarning(msg, "DeprecationWarning", code, fn2);
  };
  var isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
  var getUintArray = (max) => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;

  class ZeroArray extends Array {
    constructor(size) {
      super(size);
      this.fill(0);
    }
  }

  class Stack {
    constructor(max) {
      if (max === 0) {
        return [];
      }
      const UintArray = getUintArray(max);
      this.heap = new UintArray(max);
      this.length = 0;
    }
    push(n) {
      this.heap[this.length++] = n;
    }
    pop() {
      return this.heap[--this.length];
    }
  }

  class LRUCache {
    constructor(options = {}) {
      const {
        max = 0,
        ttl,
        ttlResolution = 1,
        ttlAutopurge,
        updateAgeOnGet,
        updateAgeOnHas,
        allowStale,
        dispose,
        disposeAfter,
        noDisposeOnSet,
        noUpdateTTL,
        maxSize = 0,
        sizeCalculation,
        fetchMethod,
        fetchContext,
        noDeleteOnFetchRejection,
        noDeleteOnStaleGet
      } = options;
      const { length, maxAge, stale } = options instanceof LRUCache ? {} : options;
      if (max !== 0 && !isPosInt(max)) {
        throw new TypeError("max option must be a nonnegative integer");
      }
      const UintArray = max ? getUintArray(max) : Array;
      if (!UintArray) {
        throw new Error("invalid max value: " + max);
      }
      this.max = max;
      this.maxSize = maxSize;
      this.sizeCalculation = sizeCalculation || length;
      if (this.sizeCalculation) {
        if (!this.maxSize) {
          throw new TypeError("cannot set sizeCalculation without setting maxSize");
        }
        if (typeof this.sizeCalculation !== "function") {
          throw new TypeError("sizeCalculation set to non-function");
        }
      }
      this.fetchMethod = fetchMethod || null;
      if (this.fetchMethod && typeof this.fetchMethod !== "function") {
        throw new TypeError("fetchMethod must be a function if specified");
      }
      this.fetchContext = fetchContext;
      if (!this.fetchMethod && fetchContext !== undefined) {
        throw new TypeError("cannot set fetchContext without fetchMethod");
      }
      this.keyMap = new Map;
      this.keyList = new Array(max).fill(null);
      this.valList = new Array(max).fill(null);
      this.next = new UintArray(max);
      this.prev = new UintArray(max);
      this.head = 0;
      this.tail = 0;
      this.free = new Stack(max);
      this.initialFill = 1;
      this.size = 0;
      if (typeof dispose === "function") {
        this.dispose = dispose;
      }
      if (typeof disposeAfter === "function") {
        this.disposeAfter = disposeAfter;
        this.disposed = [];
      } else {
        this.disposeAfter = null;
        this.disposed = null;
      }
      this.noDisposeOnSet = !!noDisposeOnSet;
      this.noUpdateTTL = !!noUpdateTTL;
      this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
      if (this.maxSize !== 0) {
        if (!isPosInt(this.maxSize)) {
          throw new TypeError("maxSize must be a positive integer if specified");
        }
        this.initializeSizeTracking();
      }
      this.allowStale = !!allowStale || !!stale;
      this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
      this.updateAgeOnGet = !!updateAgeOnGet;
      this.updateAgeOnHas = !!updateAgeOnHas;
      this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
      this.ttlAutopurge = !!ttlAutopurge;
      this.ttl = ttl || maxAge || 0;
      if (this.ttl) {
        if (!isPosInt(this.ttl)) {
          throw new TypeError("ttl must be a positive integer if specified");
        }
        this.initializeTTLTracking();
      }
      if (this.max === 0 && this.ttl === 0 && this.maxSize === 0) {
        throw new TypeError("At least one of max, maxSize, or ttl is required");
      }
      if (!this.ttlAutopurge && !this.max && !this.maxSize) {
        const code = "LRU_CACHE_UNBOUNDED";
        if (shouldWarn(code)) {
          warned.add(code);
          const msg = "TTL caching without ttlAutopurge, max, or maxSize can " + "result in unbounded memory consumption.";
          emitWarning(msg, "UnboundedCacheWarning", code, LRUCache);
        }
      }
      if (stale) {
        deprecatedOption("stale", "allowStale");
      }
      if (maxAge) {
        deprecatedOption("maxAge", "ttl");
      }
      if (length) {
        deprecatedOption("length", "sizeCalculation");
      }
    }
    getRemainingTTL(key) {
      return this.has(key, { updateAgeOnHas: false }) ? Infinity : 0;
    }
    initializeTTLTracking() {
      this.ttls = new ZeroArray(this.max);
      this.starts = new ZeroArray(this.max);
      this.setItemTTL = (index, ttl, start = perf.now()) => {
        this.starts[index] = ttl !== 0 ? start : 0;
        this.ttls[index] = ttl;
        if (ttl !== 0 && this.ttlAutopurge) {
          const t = setTimeout(() => {
            if (this.isStale(index)) {
              this.delete(this.keyList[index]);
            }
          }, ttl + 1);
          if (t.unref) {
            t.unref();
          }
        }
      };
      this.updateItemAge = (index) => {
        this.starts[index] = this.ttls[index] !== 0 ? perf.now() : 0;
      };
      let cachedNow = 0;
      const getNow = () => {
        const n = perf.now();
        if (this.ttlResolution > 0) {
          cachedNow = n;
          const t = setTimeout(() => cachedNow = 0, this.ttlResolution);
          if (t.unref) {
            t.unref();
          }
        }
        return n;
      };
      this.getRemainingTTL = (key) => {
        const index = this.keyMap.get(key);
        if (index === undefined) {
          return 0;
        }
        return this.ttls[index] === 0 || this.starts[index] === 0 ? Infinity : this.starts[index] + this.ttls[index] - (cachedNow || getNow());
      };
      this.isStale = (index) => {
        return this.ttls[index] !== 0 && this.starts[index] !== 0 && (cachedNow || getNow()) - this.starts[index] > this.ttls[index];
      };
    }
    updateItemAge(index) {}
    setItemTTL(index, ttl, start) {}
    isStale(index) {
      return false;
    }
    initializeSizeTracking() {
      this.calculatedSize = 0;
      this.sizes = new ZeroArray(this.max);
      this.removeItemSize = (index) => {
        this.calculatedSize -= this.sizes[index];
        this.sizes[index] = 0;
      };
      this.requireSize = (k, v, size, sizeCalculation) => {
        if (!isPosInt(size)) {
          if (sizeCalculation) {
            if (typeof sizeCalculation !== "function") {
              throw new TypeError("sizeCalculation must be a function");
            }
            size = sizeCalculation(v, k);
            if (!isPosInt(size)) {
              throw new TypeError("sizeCalculation return invalid (expect positive integer)");
            }
          } else {
            throw new TypeError("invalid size value (must be positive integer)");
          }
        }
        return size;
      };
      this.addItemSize = (index, size) => {
        this.sizes[index] = size;
        const maxSize = this.maxSize - this.sizes[index];
        while (this.calculatedSize > maxSize) {
          this.evict(true);
        }
        this.calculatedSize += this.sizes[index];
      };
    }
    removeItemSize(index) {}
    addItemSize(index, size) {}
    requireSize(k, v, size, sizeCalculation) {
      if (size || sizeCalculation) {
        throw new TypeError("cannot set size without setting maxSize on cache");
      }
    }
    *indexes({ allowStale = this.allowStale } = {}) {
      if (this.size) {
        for (let i = this.tail;; ) {
          if (!this.isValidIndex(i)) {
            break;
          }
          if (allowStale || !this.isStale(i)) {
            yield i;
          }
          if (i === this.head) {
            break;
          } else {
            i = this.prev[i];
          }
        }
      }
    }
    *rindexes({ allowStale = this.allowStale } = {}) {
      if (this.size) {
        for (let i = this.head;; ) {
          if (!this.isValidIndex(i)) {
            break;
          }
          if (allowStale || !this.isStale(i)) {
            yield i;
          }
          if (i === this.tail) {
            break;
          } else {
            i = this.next[i];
          }
        }
      }
    }
    isValidIndex(index) {
      return this.keyMap.get(this.keyList[index]) === index;
    }
    *entries() {
      for (const i of this.indexes()) {
        yield [this.keyList[i], this.valList[i]];
      }
    }
    *rentries() {
      for (const i of this.rindexes()) {
        yield [this.keyList[i], this.valList[i]];
      }
    }
    *keys() {
      for (const i of this.indexes()) {
        yield this.keyList[i];
      }
    }
    *rkeys() {
      for (const i of this.rindexes()) {
        yield this.keyList[i];
      }
    }
    *values() {
      for (const i of this.indexes()) {
        yield this.valList[i];
      }
    }
    *rvalues() {
      for (const i of this.rindexes()) {
        yield this.valList[i];
      }
    }
    [Symbol.iterator]() {
      return this.entries();
    }
    find(fn2, getOptions = {}) {
      for (const i of this.indexes()) {
        if (fn2(this.valList[i], this.keyList[i], this)) {
          return this.get(this.keyList[i], getOptions);
        }
      }
    }
    forEach(fn2, thisp = this) {
      for (const i of this.indexes()) {
        fn2.call(thisp, this.valList[i], this.keyList[i], this);
      }
    }
    rforEach(fn2, thisp = this) {
      for (const i of this.rindexes()) {
        fn2.call(thisp, this.valList[i], this.keyList[i], this);
      }
    }
    get prune() {
      deprecatedMethod("prune", "purgeStale");
      return this.purgeStale;
    }
    purgeStale() {
      let deleted = false;
      for (const i of this.rindexes({ allowStale: true })) {
        if (this.isStale(i)) {
          this.delete(this.keyList[i]);
          deleted = true;
        }
      }
      return deleted;
    }
    dump() {
      const arr = [];
      for (const i of this.indexes({ allowStale: true })) {
        const key = this.keyList[i];
        const v = this.valList[i];
        const value = this.isBackgroundFetch(v) ? v.__staleWhileFetching : v;
        const entry = { value };
        if (this.ttls) {
          entry.ttl = this.ttls[i];
          const age = perf.now() - this.starts[i];
          entry.start = Math.floor(Date.now() - age);
        }
        if (this.sizes) {
          entry.size = this.sizes[i];
        }
        arr.unshift([key, entry]);
      }
      return arr;
    }
    load(arr) {
      this.clear();
      for (const [key, entry] of arr) {
        if (entry.start) {
          const age = Date.now() - entry.start;
          entry.start = perf.now() - age;
        }
        this.set(key, entry.value, entry);
      }
    }
    dispose(v, k, reason) {}
    set(k, v, {
      ttl = this.ttl,
      start,
      noDisposeOnSet = this.noDisposeOnSet,
      size = 0,
      sizeCalculation = this.sizeCalculation,
      noUpdateTTL = this.noUpdateTTL
    } = {}) {
      size = this.requireSize(k, v, size, sizeCalculation);
      if (this.maxSize && size > this.maxSize) {
        return this;
      }
      let index = this.size === 0 ? undefined : this.keyMap.get(k);
      if (index === undefined) {
        index = this.newIndex();
        this.keyList[index] = k;
        this.valList[index] = v;
        this.keyMap.set(k, index);
        this.next[this.tail] = index;
        this.prev[index] = this.tail;
        this.tail = index;
        this.size++;
        this.addItemSize(index, size);
        noUpdateTTL = false;
      } else {
        const oldVal = this.valList[index];
        if (v !== oldVal) {
          if (this.isBackgroundFetch(oldVal)) {
            oldVal.__abortController.abort();
          } else {
            if (!noDisposeOnSet) {
              this.dispose(oldVal, k, "set");
              if (this.disposeAfter) {
                this.disposed.push([oldVal, k, "set"]);
              }
            }
          }
          this.removeItemSize(index);
          this.valList[index] = v;
          this.addItemSize(index, size);
        }
        this.moveToTail(index);
      }
      if (ttl !== 0 && this.ttl === 0 && !this.ttls) {
        this.initializeTTLTracking();
      }
      if (!noUpdateTTL) {
        this.setItemTTL(index, ttl, start);
      }
      if (this.disposeAfter) {
        while (this.disposed.length) {
          this.disposeAfter(...this.disposed.shift());
        }
      }
      return this;
    }
    newIndex() {
      if (this.size === 0) {
        return this.tail;
      }
      if (this.size === this.max && this.max !== 0) {
        return this.evict(false);
      }
      if (this.free.length !== 0) {
        return this.free.pop();
      }
      return this.initialFill++;
    }
    pop() {
      if (this.size) {
        const val = this.valList[this.head];
        this.evict(true);
        return val;
      }
    }
    evict(free) {
      const head = this.head;
      const k = this.keyList[head];
      const v = this.valList[head];
      if (this.isBackgroundFetch(v)) {
        v.__abortController.abort();
      } else {
        this.dispose(v, k, "evict");
        if (this.disposeAfter) {
          this.disposed.push([v, k, "evict"]);
        }
      }
      this.removeItemSize(head);
      if (free) {
        this.keyList[head] = null;
        this.valList[head] = null;
        this.free.push(head);
      }
      this.head = this.next[head];
      this.keyMap.delete(k);
      this.size--;
      return head;
    }
    has(k, { updateAgeOnHas = this.updateAgeOnHas } = {}) {
      const index = this.keyMap.get(k);
      if (index !== undefined) {
        if (!this.isStale(index)) {
          if (updateAgeOnHas) {
            this.updateItemAge(index);
          }
          return true;
        }
      }
      return false;
    }
    peek(k, { allowStale = this.allowStale } = {}) {
      const index = this.keyMap.get(k);
      if (index !== undefined && (allowStale || !this.isStale(index))) {
        const v = this.valList[index];
        return this.isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      }
    }
    backgroundFetch(k, index, options, context) {
      const v = index === undefined ? undefined : this.valList[index];
      if (this.isBackgroundFetch(v)) {
        return v;
      }
      const ac = new AC;
      const fetchOpts = {
        signal: ac.signal,
        options,
        context
      };
      const cb = (v2) => {
        if (!ac.signal.aborted) {
          this.set(k, v2, fetchOpts.options);
        }
        return v2;
      };
      const eb = (er) => {
        if (this.valList[index] === p) {
          const del = !options.noDeleteOnFetchRejection || p.__staleWhileFetching === undefined;
          if (del) {
            this.delete(k);
          } else {
            this.valList[index] = p.__staleWhileFetching;
          }
        }
        if (p.__returned === p) {
          throw er;
        }
      };
      const pcall = (res) => res(this.fetchMethod(k, v, fetchOpts));
      const p = new Promise(pcall).then(cb, eb);
      p.__abortController = ac;
      p.__staleWhileFetching = v;
      p.__returned = null;
      if (index === undefined) {
        this.set(k, p, fetchOpts.options);
        index = this.keyMap.get(k);
      } else {
        this.valList[index] = p;
      }
      return p;
    }
    isBackgroundFetch(p) {
      return p && typeof p === "object" && typeof p.then === "function" && Object.prototype.hasOwnProperty.call(p, "__staleWhileFetching") && Object.prototype.hasOwnProperty.call(p, "__returned") && (p.__returned === p || p.__returned === null);
    }
    async fetch(k, {
      allowStale = this.allowStale,
      updateAgeOnGet = this.updateAgeOnGet,
      noDeleteOnStaleGet = this.noDeleteOnStaleGet,
      ttl = this.ttl,
      noDisposeOnSet = this.noDisposeOnSet,
      size = 0,
      sizeCalculation = this.sizeCalculation,
      noUpdateTTL = this.noUpdateTTL,
      noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
      fetchContext = this.fetchContext,
      forceRefresh = false
    } = {}) {
      if (!this.fetchMethod) {
        return this.get(k, {
          allowStale,
          updateAgeOnGet,
          noDeleteOnStaleGet
        });
      }
      const options = {
        allowStale,
        updateAgeOnGet,
        noDeleteOnStaleGet,
        ttl,
        noDisposeOnSet,
        size,
        sizeCalculation,
        noUpdateTTL,
        noDeleteOnFetchRejection
      };
      let index = this.keyMap.get(k);
      if (index === undefined) {
        const p = this.backgroundFetch(k, index, options, fetchContext);
        return p.__returned = p;
      } else {
        const v = this.valList[index];
        if (this.isBackgroundFetch(v)) {
          return allowStale && v.__staleWhileFetching !== undefined ? v.__staleWhileFetching : v.__returned = v;
        }
        if (!forceRefresh && !this.isStale(index)) {
          this.moveToTail(index);
          if (updateAgeOnGet) {
            this.updateItemAge(index);
          }
          return v;
        }
        const p = this.backgroundFetch(k, index, options, fetchContext);
        return allowStale && p.__staleWhileFetching !== undefined ? p.__staleWhileFetching : p.__returned = p;
      }
    }
    get(k, {
      allowStale = this.allowStale,
      updateAgeOnGet = this.updateAgeOnGet,
      noDeleteOnStaleGet = this.noDeleteOnStaleGet
    } = {}) {
      const index = this.keyMap.get(k);
      if (index !== undefined) {
        const value = this.valList[index];
        const fetching = this.isBackgroundFetch(value);
        if (this.isStale(index)) {
          if (!fetching) {
            if (!noDeleteOnStaleGet) {
              this.delete(k);
            }
            return allowStale ? value : undefined;
          } else {
            return allowStale ? value.__staleWhileFetching : undefined;
          }
        } else {
          if (fetching) {
            return;
          }
          this.moveToTail(index);
          if (updateAgeOnGet) {
            this.updateItemAge(index);
          }
          return value;
        }
      }
    }
    connect(p, n) {
      this.prev[n] = p;
      this.next[p] = n;
    }
    moveToTail(index) {
      if (index !== this.tail) {
        if (index === this.head) {
          this.head = this.next[index];
        } else {
          this.connect(this.prev[index], this.next[index]);
        }
        this.connect(this.tail, index);
        this.tail = index;
      }
    }
    get del() {
      deprecatedMethod("del", "delete");
      return this.delete;
    }
    delete(k) {
      let deleted = false;
      if (this.size !== 0) {
        const index = this.keyMap.get(k);
        if (index !== undefined) {
          deleted = true;
          if (this.size === 1) {
            this.clear();
          } else {
            this.removeItemSize(index);
            const v = this.valList[index];
            if (this.isBackgroundFetch(v)) {
              v.__abortController.abort();
            } else {
              this.dispose(v, k, "delete");
              if (this.disposeAfter) {
                this.disposed.push([v, k, "delete"]);
              }
            }
            this.keyMap.delete(k);
            this.keyList[index] = null;
            this.valList[index] = null;
            if (index === this.tail) {
              this.tail = this.prev[index];
            } else if (index === this.head) {
              this.head = this.next[index];
            } else {
              this.next[this.prev[index]] = this.next[index];
              this.prev[this.next[index]] = this.prev[index];
            }
            this.size--;
            this.free.push(index);
          }
        }
      }
      if (this.disposed) {
        while (this.disposed.length) {
          this.disposeAfter(...this.disposed.shift());
        }
      }
      return deleted;
    }
    clear() {
      for (const index of this.rindexes({ allowStale: true })) {
        const v = this.valList[index];
        if (this.isBackgroundFetch(v)) {
          v.__abortController.abort();
        } else {
          const k = this.keyList[index];
          this.dispose(v, k, "delete");
          if (this.disposeAfter) {
            this.disposed.push([v, k, "delete"]);
          }
        }
      }
      this.keyMap.clear();
      this.valList.fill(null);
      this.keyList.fill(null);
      if (this.ttls) {
        this.ttls.fill(0);
        this.starts.fill(0);
      }
      if (this.sizes) {
        this.sizes.fill(0);
      }
      this.head = 0;
      this.tail = 0;
      this.initialFill = 1;
      this.free.length = 0;
      this.calculatedSize = 0;
      this.size = 0;
      if (this.disposed) {
        while (this.disposed.length) {
          this.disposeAfter(...this.disposed.shift());
        }
      }
    }
    get reset() {
      deprecatedMethod("reset", "clear");
      return this.clear;
    }
    get length() {
      deprecatedProperty("length", "size");
      return this.size;
    }
    static get AbortController() {
      return AC;
    }
    static get AbortSignal() {
      return AS;
    }
  }
  module.exports = LRUCache;
});

// node_modules/@apollo/utils.keyvaluecache/dist/InMemoryLRUCache.js
var require_InMemoryLRUCache = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InMemoryLRUCache = undefined;
  var lru_cache_1 = __importDefault(require_lru_cache());

  class InMemoryLRUCache {
    constructor(lruCacheOpts) {
      this.cache = new lru_cache_1.default({
        sizeCalculation: InMemoryLRUCache.sizeCalculation,
        maxSize: Math.pow(2, 20) * 30,
        ...lruCacheOpts
      });
    }
    static sizeCalculation(item) {
      if (typeof item === "string") {
        return item.length;
      }
      if (typeof item === "object") {
        return Buffer.byteLength(JSON.stringify(item), "utf8");
      }
      return 1;
    }
    async set(key, value, options) {
      if (options === null || options === undefined ? undefined : options.ttl) {
        this.cache.set(key, value, { ttl: options.ttl * 1000 });
      } else {
        this.cache.set(key, value);
      }
    }
    async get(key) {
      return this.cache.get(key);
    }
    async delete(key) {
      return this.cache.delete(key);
    }
    clear() {
      this.cache.clear();
    }
    keys() {
      return [...this.cache.keys()];
    }
  }
  exports.InMemoryLRUCache = InMemoryLRUCache;
});

// node_modules/@apollo/utils.keyvaluecache/dist/ErrorsAreMissesCache.js
var require_ErrorsAreMissesCache = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ErrorsAreMissesCache = undefined;

  class ErrorsAreMissesCache {
    constructor(cache, logger) {
      this.cache = cache;
      this.logger = logger;
    }
    async get(key) {
      try {
        return await this.cache.get(key);
      } catch (e) {
        if (this.logger) {
          if (e instanceof Error) {
            this.logger.error(e.message);
          } else {
            this.logger.error(e);
          }
        }
        return;
      }
    }
    async set(key, value, opts) {
      return this.cache.set(key, value, opts);
    }
    async delete(key) {
      return this.cache.delete(key);
    }
  }
  exports.ErrorsAreMissesCache = ErrorsAreMissesCache;
});

// node_modules/@apollo/utils.keyvaluecache/dist/index.js
var require_dist4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ErrorsAreMissesCache = exports.InMemoryLRUCache = exports.PrefixingKeyValueCache = undefined;
  var PrefixingKeyValueCache_1 = require_PrefixingKeyValueCache();
  Object.defineProperty(exports, "PrefixingKeyValueCache", { enumerable: true, get: function() {
    return PrefixingKeyValueCache_1.PrefixingKeyValueCache;
  } });
  var InMemoryLRUCache_1 = require_InMemoryLRUCache();
  Object.defineProperty(exports, "InMemoryLRUCache", { enumerable: true, get: function() {
    return InMemoryLRUCache_1.InMemoryLRUCache;
  } });
  var ErrorsAreMissesCache_1 = require_ErrorsAreMissesCache();
  Object.defineProperty(exports, "ErrorsAreMissesCache", { enumerable: true, get: function() {
    return ErrorsAreMissesCache_1.ErrorsAreMissesCache;
  } });
});

// node_modules/apollo-server-core/dist/utils/isNodeLike.js
var require_isNodeLike = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = typeof process === "object" && process && process.release && process.versions && typeof process.versions.node === "string";
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser2 = __commonJS((exports, module) => {
  if (typeof Object.create === "function") {
    module.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    module.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {};
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor;
        ctor.prototype.constructor = ctor;
      }
    };
  }
});

// node_modules/inherits/inherits.js
var require_inherits2 = __commonJS((exports, module) => {
  try {
    util = __require("util");
    if (typeof util.inherits !== "function")
      throw "";
    module.exports = util.inherits;
  } catch (e) {
    module.exports = require_inherits_browser2();
  }
  var util;
});

// node_modules/sha.js/node_modules/safe-buffer/index.js
var require_safe_buffer3 = __commonJS((exports, module) => {
  /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
  var buffer = __require("buffer");
  var Buffer2 = buffer.Buffer;
  function copyProps(src, dst) {
    for (var key in src) {
      dst[key] = src[key];
    }
  }
  if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
    module.exports = buffer;
  } else {
    copyProps(buffer, exports);
    exports.Buffer = SafeBuffer;
  }
  function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer2(arg, encodingOrOffset, length);
  }
  SafeBuffer.prototype = Object.create(Buffer2.prototype);
  copyProps(Buffer2, SafeBuffer);
  SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      throw new TypeError("Argument must not be a number");
    }
    return Buffer2(arg, encodingOrOffset, length);
  };
  SafeBuffer.alloc = function(size, fill, encoding) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    var buf = Buffer2(size);
    if (fill !== undefined) {
      if (typeof encoding === "string") {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
    } else {
      buf.fill(0);
    }
    return buf;
  };
  SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return Buffer2(size);
  };
  SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return buffer.SlowBuffer(size);
  };
});

// node_modules/sha.js/hash.js
var require_hash = __commonJS((exports, module) => {
  var Buffer2 = require_safe_buffer3().Buffer;
  function Hash(blockSize, finalSize) {
    this._block = Buffer2.alloc(blockSize);
    this._finalSize = finalSize;
    this._blockSize = blockSize;
    this._len = 0;
  }
  Hash.prototype.update = function(data, enc) {
    if (typeof data === "string") {
      enc = enc || "utf8";
      data = Buffer2.from(data, enc);
    }
    var block = this._block;
    var blockSize = this._blockSize;
    var length = data.length;
    var accum = this._len;
    for (var offset = 0;offset < length; ) {
      var assigned = accum % blockSize;
      var remainder = Math.min(length - offset, blockSize - assigned);
      for (var i = 0;i < remainder; i++) {
        block[assigned + i] = data[offset + i];
      }
      accum += remainder;
      offset += remainder;
      if (accum % blockSize === 0) {
        this._update(block);
      }
    }
    this._len += length;
    return this;
  };
  Hash.prototype.digest = function(enc) {
    var rem = this._len % this._blockSize;
    this._block[rem] = 128;
    this._block.fill(0, rem + 1);
    if (rem >= this._finalSize) {
      this._update(this._block);
      this._block.fill(0);
    }
    var bits = this._len * 8;
    if (bits <= 4294967295) {
      this._block.writeUInt32BE(bits, this._blockSize - 4);
    } else {
      var lowBits = (bits & 4294967295) >>> 0;
      var highBits = (bits - lowBits) / 4294967296;
      this._block.writeUInt32BE(highBits, this._blockSize - 8);
      this._block.writeUInt32BE(lowBits, this._blockSize - 4);
    }
    this._update(this._block);
    var hash = this._hash();
    return enc ? hash.toString(enc) : hash;
  };
  Hash.prototype._update = function() {
    throw new Error("_update must be implemented by subclass");
  };
  module.exports = Hash;
});

// node_modules/sha.js/sha.js
var require_sha = __commonJS((exports, module) => {
  var inherits = require_inherits2();
  var Hash = require_hash();
  var Buffer2 = require_safe_buffer3().Buffer;
  var K = [
    1518500249,
    1859775393,
    2400959708 | 0,
    3395469782 | 0
  ];
  var W = new Array(80);
  function Sha() {
    this.init();
    this._w = W;
    Hash.call(this, 64, 56);
  }
  inherits(Sha, Hash);
  Sha.prototype.init = function() {
    this._a = 1732584193;
    this._b = 4023233417;
    this._c = 2562383102;
    this._d = 271733878;
    this._e = 3285377520;
    return this;
  };
  function rotl5(num) {
    return num << 5 | num >>> 27;
  }
  function rotl30(num) {
    return num << 30 | num >>> 2;
  }
  function ft(s, b, c, d) {
    if (s === 0)
      return b & c | ~b & d;
    if (s === 2)
      return b & c | b & d | c & d;
    return b ^ c ^ d;
  }
  Sha.prototype._update = function(M) {
    var W2 = this._w;
    var a = this._a | 0;
    var b = this._b | 0;
    var c = this._c | 0;
    var d = this._d | 0;
    var e = this._e | 0;
    for (var i = 0;i < 16; ++i)
      W2[i] = M.readInt32BE(i * 4);
    for (;i < 80; ++i)
      W2[i] = W2[i - 3] ^ W2[i - 8] ^ W2[i - 14] ^ W2[i - 16];
    for (var j = 0;j < 80; ++j) {
      var s = ~~(j / 20);
      var t = rotl5(a) + ft(s, b, c, d) + e + W2[j] + K[s] | 0;
      e = d;
      d = c;
      c = rotl30(b);
      b = a;
      a = t;
    }
    this._a = a + this._a | 0;
    this._b = b + this._b | 0;
    this._c = c + this._c | 0;
    this._d = d + this._d | 0;
    this._e = e + this._e | 0;
  };
  Sha.prototype._hash = function() {
    var H = Buffer2.allocUnsafe(20);
    H.writeInt32BE(this._a | 0, 0);
    H.writeInt32BE(this._b | 0, 4);
    H.writeInt32BE(this._c | 0, 8);
    H.writeInt32BE(this._d | 0, 12);
    H.writeInt32BE(this._e | 0, 16);
    return H;
  };
  module.exports = Sha;
});

// node_modules/sha.js/sha1.js
var require_sha1 = __commonJS((exports, module) => {
  var inherits = require_inherits2();
  var Hash = require_hash();
  var Buffer2 = require_safe_buffer3().Buffer;
  var K = [
    1518500249,
    1859775393,
    2400959708 | 0,
    3395469782 | 0
  ];
  var W = new Array(80);
  function Sha1() {
    this.init();
    this._w = W;
    Hash.call(this, 64, 56);
  }
  inherits(Sha1, Hash);
  Sha1.prototype.init = function() {
    this._a = 1732584193;
    this._b = 4023233417;
    this._c = 2562383102;
    this._d = 271733878;
    this._e = 3285377520;
    return this;
  };
  function rotl1(num) {
    return num << 1 | num >>> 31;
  }
  function rotl5(num) {
    return num << 5 | num >>> 27;
  }
  function rotl30(num) {
    return num << 30 | num >>> 2;
  }
  function ft(s, b, c, d) {
    if (s === 0)
      return b & c | ~b & d;
    if (s === 2)
      return b & c | b & d | c & d;
    return b ^ c ^ d;
  }
  Sha1.prototype._update = function(M) {
    var W2 = this._w;
    var a = this._a | 0;
    var b = this._b | 0;
    var c = this._c | 0;
    var d = this._d | 0;
    var e = this._e | 0;
    for (var i = 0;i < 16; ++i)
      W2[i] = M.readInt32BE(i * 4);
    for (;i < 80; ++i)
      W2[i] = rotl1(W2[i - 3] ^ W2[i - 8] ^ W2[i - 14] ^ W2[i - 16]);
    for (var j = 0;j < 80; ++j) {
      var s = ~~(j / 20);
      var t = rotl5(a) + ft(s, b, c, d) + e + W2[j] + K[s] | 0;
      e = d;
      d = c;
      c = rotl30(b);
      b = a;
      a = t;
    }
    this._a = a + this._a | 0;
    this._b = b + this._b | 0;
    this._c = c + this._c | 0;
    this._d = d + this._d | 0;
    this._e = e + this._e | 0;
  };
  Sha1.prototype._hash = function() {
    var H = Buffer2.allocUnsafe(20);
    H.writeInt32BE(this._a | 0, 0);
    H.writeInt32BE(this._b | 0, 4);
    H.writeInt32BE(this._c | 0, 8);
    H.writeInt32BE(this._d | 0, 12);
    H.writeInt32BE(this._e | 0, 16);
    return H;
  };
  module.exports = Sha1;
});

// node_modules/sha.js/sha256.js
var require_sha256 = __commonJS((exports, module) => {
  var inherits = require_inherits2();
  var Hash = require_hash();
  var Buffer2 = require_safe_buffer3().Buffer;
  var K = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ];
  var W = new Array(64);
  function Sha256() {
    this.init();
    this._w = W;
    Hash.call(this, 64, 56);
  }
  inherits(Sha256, Hash);
  Sha256.prototype.init = function() {
    this._a = 1779033703;
    this._b = 3144134277;
    this._c = 1013904242;
    this._d = 2773480762;
    this._e = 1359893119;
    this._f = 2600822924;
    this._g = 528734635;
    this._h = 1541459225;
    return this;
  };
  function ch(x, y, z) {
    return z ^ x & (y ^ z);
  }
  function maj(x, y, z) {
    return x & y | z & (x | y);
  }
  function sigma0(x) {
    return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10);
  }
  function sigma1(x) {
    return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7);
  }
  function gamma0(x) {
    return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ x >>> 3;
  }
  function gamma1(x) {
    return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ x >>> 10;
  }
  Sha256.prototype._update = function(M) {
    var W2 = this._w;
    var a = this._a | 0;
    var b = this._b | 0;
    var c = this._c | 0;
    var d = this._d | 0;
    var e = this._e | 0;
    var f = this._f | 0;
    var g = this._g | 0;
    var h = this._h | 0;
    for (var i = 0;i < 16; ++i)
      W2[i] = M.readInt32BE(i * 4);
    for (;i < 64; ++i)
      W2[i] = gamma1(W2[i - 2]) + W2[i - 7] + gamma0(W2[i - 15]) + W2[i - 16] | 0;
    for (var j = 0;j < 64; ++j) {
      var T1 = h + sigma1(e) + ch(e, f, g) + K[j] + W2[j] | 0;
      var T2 = sigma0(a) + maj(a, b, c) | 0;
      h = g;
      g = f;
      f = e;
      e = d + T1 | 0;
      d = c;
      c = b;
      b = a;
      a = T1 + T2 | 0;
    }
    this._a = a + this._a | 0;
    this._b = b + this._b | 0;
    this._c = c + this._c | 0;
    this._d = d + this._d | 0;
    this._e = e + this._e | 0;
    this._f = f + this._f | 0;
    this._g = g + this._g | 0;
    this._h = h + this._h | 0;
  };
  Sha256.prototype._hash = function() {
    var H = Buffer2.allocUnsafe(32);
    H.writeInt32BE(this._a, 0);
    H.writeInt32BE(this._b, 4);
    H.writeInt32BE(this._c, 8);
    H.writeInt32BE(this._d, 12);
    H.writeInt32BE(this._e, 16);
    H.writeInt32BE(this._f, 20);
    H.writeInt32BE(this._g, 24);
    H.writeInt32BE(this._h, 28);
    return H;
  };
  module.exports = Sha256;
});

// node_modules/sha.js/sha224.js
var require_sha224 = __commonJS((exports, module) => {
  var inherits = require_inherits2();
  var Sha256 = require_sha256();
  var Hash = require_hash();
  var Buffer2 = require_safe_buffer3().Buffer;
  var W = new Array(64);
  function Sha224() {
    this.init();
    this._w = W;
    Hash.call(this, 64, 56);
  }
  inherits(Sha224, Sha256);
  Sha224.prototype.init = function() {
    this._a = 3238371032;
    this._b = 914150663;
    this._c = 812702999;
    this._d = 4144912697;
    this._e = 4290775857;
    this._f = 1750603025;
    this._g = 1694076839;
    this._h = 3204075428;
    return this;
  };
  Sha224.prototype._hash = function() {
    var H = Buffer2.allocUnsafe(28);
    H.writeInt32BE(this._a, 0);
    H.writeInt32BE(this._b, 4);
    H.writeInt32BE(this._c, 8);
    H.writeInt32BE(this._d, 12);
    H.writeInt32BE(this._e, 16);
    H.writeInt32BE(this._f, 20);
    H.writeInt32BE(this._g, 24);
    return H;
  };
  module.exports = Sha224;
});

// node_modules/sha.js/sha512.js
var require_sha512 = __commonJS((exports, module) => {
  var inherits = require_inherits2();
  var Hash = require_hash();
  var Buffer2 = require_safe_buffer3().Buffer;
  var K = [
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ];
  var W = new Array(160);
  function Sha512() {
    this.init();
    this._w = W;
    Hash.call(this, 128, 112);
  }
  inherits(Sha512, Hash);
  Sha512.prototype.init = function() {
    this._ah = 1779033703;
    this._bh = 3144134277;
    this._ch = 1013904242;
    this._dh = 2773480762;
    this._eh = 1359893119;
    this._fh = 2600822924;
    this._gh = 528734635;
    this._hh = 1541459225;
    this._al = 4089235720;
    this._bl = 2227873595;
    this._cl = 4271175723;
    this._dl = 1595750129;
    this._el = 2917565137;
    this._fl = 725511199;
    this._gl = 4215389547;
    this._hl = 327033209;
    return this;
  };
  function Ch(x, y, z) {
    return z ^ x & (y ^ z);
  }
  function maj(x, y, z) {
    return x & y | z & (x | y);
  }
  function sigma0(x, xl) {
    return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25);
  }
  function sigma1(x, xl) {
    return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23);
  }
  function Gamma0(x, xl) {
    return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ x >>> 7;
  }
  function Gamma0l(x, xl) {
    return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25);
  }
  function Gamma1(x, xl) {
    return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ x >>> 6;
  }
  function Gamma1l(x, xl) {
    return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26);
  }
  function getCarry(a, b) {
    return a >>> 0 < b >>> 0 ? 1 : 0;
  }
  Sha512.prototype._update = function(M) {
    var W2 = this._w;
    var ah = this._ah | 0;
    var bh = this._bh | 0;
    var ch = this._ch | 0;
    var dh = this._dh | 0;
    var eh = this._eh | 0;
    var fh = this._fh | 0;
    var gh = this._gh | 0;
    var hh = this._hh | 0;
    var al = this._al | 0;
    var bl = this._bl | 0;
    var cl = this._cl | 0;
    var dl = this._dl | 0;
    var el = this._el | 0;
    var fl = this._fl | 0;
    var gl = this._gl | 0;
    var hl = this._hl | 0;
    for (var i = 0;i < 32; i += 2) {
      W2[i] = M.readInt32BE(i * 4);
      W2[i + 1] = M.readInt32BE(i * 4 + 4);
    }
    for (;i < 160; i += 2) {
      var xh = W2[i - 15 * 2];
      var xl = W2[i - 15 * 2 + 1];
      var gamma0 = Gamma0(xh, xl);
      var gamma0l = Gamma0l(xl, xh);
      xh = W2[i - 2 * 2];
      xl = W2[i - 2 * 2 + 1];
      var gamma1 = Gamma1(xh, xl);
      var gamma1l = Gamma1l(xl, xh);
      var Wi7h = W2[i - 7 * 2];
      var Wi7l = W2[i - 7 * 2 + 1];
      var Wi16h = W2[i - 16 * 2];
      var Wi16l = W2[i - 16 * 2 + 1];
      var Wil = gamma0l + Wi7l | 0;
      var Wih = gamma0 + Wi7h + getCarry(Wil, gamma0l) | 0;
      Wil = Wil + gamma1l | 0;
      Wih = Wih + gamma1 + getCarry(Wil, gamma1l) | 0;
      Wil = Wil + Wi16l | 0;
      Wih = Wih + Wi16h + getCarry(Wil, Wi16l) | 0;
      W2[i] = Wih;
      W2[i + 1] = Wil;
    }
    for (var j = 0;j < 160; j += 2) {
      Wih = W2[j];
      Wil = W2[j + 1];
      var majh = maj(ah, bh, ch);
      var majl = maj(al, bl, cl);
      var sigma0h = sigma0(ah, al);
      var sigma0l = sigma0(al, ah);
      var sigma1h = sigma1(eh, el);
      var sigma1l = sigma1(el, eh);
      var Kih = K[j];
      var Kil = K[j + 1];
      var chh = Ch(eh, fh, gh);
      var chl = Ch(el, fl, gl);
      var t1l = hl + sigma1l | 0;
      var t1h = hh + sigma1h + getCarry(t1l, hl) | 0;
      t1l = t1l + chl | 0;
      t1h = t1h + chh + getCarry(t1l, chl) | 0;
      t1l = t1l + Kil | 0;
      t1h = t1h + Kih + getCarry(t1l, Kil) | 0;
      t1l = t1l + Wil | 0;
      t1h = t1h + Wih + getCarry(t1l, Wil) | 0;
      var t2l = sigma0l + majl | 0;
      var t2h = sigma0h + majh + getCarry(t2l, sigma0l) | 0;
      hh = gh;
      hl = gl;
      gh = fh;
      gl = fl;
      fh = eh;
      fl = el;
      el = dl + t1l | 0;
      eh = dh + t1h + getCarry(el, dl) | 0;
      dh = ch;
      dl = cl;
      ch = bh;
      cl = bl;
      bh = ah;
      bl = al;
      al = t1l + t2l | 0;
      ah = t1h + t2h + getCarry(al, t1l) | 0;
    }
    this._al = this._al + al | 0;
    this._bl = this._bl + bl | 0;
    this._cl = this._cl + cl | 0;
    this._dl = this._dl + dl | 0;
    this._el = this._el + el | 0;
    this._fl = this._fl + fl | 0;
    this._gl = this._gl + gl | 0;
    this._hl = this._hl + hl | 0;
    this._ah = this._ah + ah + getCarry(this._al, al) | 0;
    this._bh = this._bh + bh + getCarry(this._bl, bl) | 0;
    this._ch = this._ch + ch + getCarry(this._cl, cl) | 0;
    this._dh = this._dh + dh + getCarry(this._dl, dl) | 0;
    this._eh = this._eh + eh + getCarry(this._el, el) | 0;
    this._fh = this._fh + fh + getCarry(this._fl, fl) | 0;
    this._gh = this._gh + gh + getCarry(this._gl, gl) | 0;
    this._hh = this._hh + hh + getCarry(this._hl, hl) | 0;
  };
  Sha512.prototype._hash = function() {
    var H = Buffer2.allocUnsafe(64);
    function writeInt64BE(h, l, offset) {
      H.writeInt32BE(h, offset);
      H.writeInt32BE(l, offset + 4);
    }
    writeInt64BE(this._ah, this._al, 0);
    writeInt64BE(this._bh, this._bl, 8);
    writeInt64BE(this._ch, this._cl, 16);
    writeInt64BE(this._dh, this._dl, 24);
    writeInt64BE(this._eh, this._el, 32);
    writeInt64BE(this._fh, this._fl, 40);
    writeInt64BE(this._gh, this._gl, 48);
    writeInt64BE(this._hh, this._hl, 56);
    return H;
  };
  module.exports = Sha512;
});

// node_modules/sha.js/sha384.js
var require_sha384 = __commonJS((exports, module) => {
  var inherits = require_inherits2();
  var SHA512 = require_sha512();
  var Hash = require_hash();
  var Buffer2 = require_safe_buffer3().Buffer;
  var W = new Array(160);
  function Sha384() {
    this.init();
    this._w = W;
    Hash.call(this, 128, 112);
  }
  inherits(Sha384, SHA512);
  Sha384.prototype.init = function() {
    this._ah = 3418070365;
    this._bh = 1654270250;
    this._ch = 2438529370;
    this._dh = 355462360;
    this._eh = 1731405415;
    this._fh = 2394180231;
    this._gh = 3675008525;
    this._hh = 1203062813;
    this._al = 3238371032;
    this._bl = 914150663;
    this._cl = 812702999;
    this._dl = 4144912697;
    this._el = 4290775857;
    this._fl = 1750603025;
    this._gl = 1694076839;
    this._hl = 3204075428;
    return this;
  };
  Sha384.prototype._hash = function() {
    var H = Buffer2.allocUnsafe(48);
    function writeInt64BE(h, l, offset) {
      H.writeInt32BE(h, offset);
      H.writeInt32BE(l, offset + 4);
    }
    writeInt64BE(this._ah, this._al, 0);
    writeInt64BE(this._bh, this._bl, 8);
    writeInt64BE(this._ch, this._cl, 16);
    writeInt64BE(this._dh, this._dl, 24);
    writeInt64BE(this._eh, this._el, 32);
    writeInt64BE(this._fh, this._fl, 40);
    return H;
  };
  module.exports = Sha384;
});

// node_modules/sha.js/index.js
var require_sha2 = __commonJS((exports, module) => {
  var exports = module.exports = function SHA(algorithm) {
    algorithm = algorithm.toLowerCase();
    var Algorithm = exports[algorithm];
    if (!Algorithm)
      throw new Error(algorithm + " is not supported (we accept pull requests)");
    return new Algorithm;
  };
  exports.sha = require_sha();
  exports.sha1 = require_sha1();
  exports.sha224 = require_sha224();
  exports.sha256 = require_sha256();
  exports.sha384 = require_sha384();
  exports.sha512 = require_sha512();
});

// node_modules/apollo-server-core/dist/utils/createSHA.js
var require_createSHA = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var isNodeLike_1 = __importDefault(require_isNodeLike());
  function default_1(kind) {
    if (isNodeLike_1.default) {
      return __require("crypto").createHash(kind);
    }
    return require_sha2()(kind);
  }
  exports.default = default_1;
});

// node_modules/apollo-server-core/dist/requestPipeline.js
var require_requestPipeline = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.processGraphQLRequest = exports.APQ_CACHE_PREFIX = undefined;
  var graphql_1 = require_graphql2();
  var schemaInstrumentation_1 = require_schemaInstrumentation();
  var apollo_server_errors_1 = require_dist2();
  var dispatcher_1 = require_dispatcher();
  var utils_keyvaluecache_1 = require_dist4();
  var createSHA_1 = __importDefault(require_createSHA());
  var runHttpQuery_1 = require_runHttpQuery();
  var apollo_server_env_1 = require_dist();
  exports.APQ_CACHE_PREFIX = "apq:";
  function computeQueryHash(query) {
    return (0, createSHA_1.default)("sha256").update(query).digest("hex");
  }
  function isBadUserInputGraphQLError(error) {
    var _a;
    return ((_a = error.nodes) === null || _a === undefined ? undefined : _a.length) === 1 && error.nodes[0].kind === graphql_1.Kind.VARIABLE_DEFINITION && (error.message.startsWith(`Variable "$${error.nodes[0].variable.name.value}" got invalid value `) || error.message.startsWith(`Variable "$${error.nodes[0].variable.name.value}" of required type `) || error.message.startsWith(`Variable "$${error.nodes[0].variable.name.value}" of non-null type `));
  }
  async function processGraphQLRequest(config, requestContext) {
    var _a, _b;
    const logger = requestContext.logger || console;
    const metrics = requestContext.metrics = requestContext.metrics || Object.create(null);
    const dispatcher = await initializeRequestListenerDispatcher();
    await initializeDataSources();
    const request = requestContext.request;
    let { query, extensions } = request;
    let queryHash;
    let persistedQueryCache;
    metrics.persistedQueryHit = false;
    metrics.persistedQueryRegister = false;
    if (extensions === null || extensions === undefined ? undefined : extensions.persistedQuery) {
      if (!config.persistedQueries || !config.persistedQueries.cache) {
        return await sendErrorResponse(new apollo_server_errors_1.PersistedQueryNotSupportedError);
      } else if (extensions.persistedQuery.version !== 1) {
        return await sendErrorResponse(new graphql_1.GraphQLError("Unsupported persisted query version"));
      }
      persistedQueryCache = config.persistedQueries.cache;
      if (!(persistedQueryCache instanceof utils_keyvaluecache_1.PrefixingKeyValueCache)) {
        persistedQueryCache = new utils_keyvaluecache_1.PrefixingKeyValueCache(persistedQueryCache, exports.APQ_CACHE_PREFIX);
      }
      queryHash = extensions.persistedQuery.sha256Hash;
      if (query === undefined) {
        query = await persistedQueryCache.get(queryHash);
        if (query) {
          metrics.persistedQueryHit = true;
        } else {
          return await sendErrorResponse(new apollo_server_errors_1.PersistedQueryNotFoundError);
        }
      } else {
        const computedQueryHash = computeQueryHash(query);
        if (queryHash !== computedQueryHash) {
          return await sendErrorResponse(new graphql_1.GraphQLError("provided sha does not match query"));
        }
        metrics.persistedQueryRegister = true;
      }
    } else if (query) {
      queryHash = computeQueryHash(query);
    } else {
      return await sendErrorResponse(new graphql_1.GraphQLError("GraphQL operations must contain a non-empty `query` or a `persistedQuery` extension."));
    }
    requestContext.queryHash = queryHash;
    requestContext.source = query;
    await dispatcher.invokeHook("didResolveSource", requestContext);
    if (config.documentStore) {
      try {
        requestContext.document = await config.documentStore.get(queryHash);
      } catch (err) {
        logger.warn("An error occurred while attempting to read from the documentStore. " + (err === null || err === undefined ? undefined : err.message) || err);
      }
    }
    if (!requestContext.document) {
      const parsingDidEnd = await dispatcher.invokeDidStartHook("parsingDidStart", requestContext);
      try {
        requestContext.document = parse(query, config.parseOptions);
        await parsingDidEnd();
      } catch (syntaxError) {
        await parsingDidEnd(syntaxError);
        return await sendErrorResponse(syntaxError, apollo_server_errors_1.SyntaxError);
      }
      if (config.dangerouslyDisableValidation !== true) {
        const validationDidEnd = await dispatcher.invokeDidStartHook("validationDidStart", requestContext);
        const validationErrors = validate(requestContext.document);
        if (validationErrors.length === 0) {
          await validationDidEnd();
        } else {
          await validationDidEnd(validationErrors);
          return await sendErrorResponse(validationErrors, apollo_server_errors_1.ValidationError);
        }
      }
      if (config.documentStore) {
        Promise.resolve(config.documentStore.set(queryHash, requestContext.document)).catch((err) => logger.warn("Could not store validated document. " + (err === null || err === undefined ? undefined : err.message) || err));
      }
    }
    const operation = (0, graphql_1.getOperationAST)(requestContext.document, request.operationName);
    requestContext.operation = operation || undefined;
    requestContext.operationName = ((_a = operation === null || operation === undefined ? undefined : operation.name) === null || _a === undefined ? undefined : _a.value) || null;
    try {
      await dispatcher.invokeHook("didResolveOperation", requestContext);
    } catch (err) {
      return await sendErrorResponse(err);
    }
    if (metrics.persistedQueryRegister && persistedQueryCache) {
      Promise.resolve(persistedQueryCache.set(queryHash, query, config.persistedQueries && typeof config.persistedQueries.ttl !== "undefined" ? {
        ttl: config.persistedQueries.ttl
      } : Object.create(null))).catch(logger.warn);
    }
    let response = await dispatcher.invokeHooksUntilNonNull("responseForOperation", requestContext);
    if (response == null) {
      const executionListeners = [];
      (await dispatcher.invokeHook("executionDidStart", requestContext)).forEach((executionListener) => {
        if (executionListener) {
          executionListeners.push(executionListener);
        }
      });
      executionListeners.reverse();
      const executionDispatcher = new dispatcher_1.Dispatcher(executionListeners);
      if (executionDispatcher.hasHook("willResolveField")) {
        const invokeWillResolveField = (...args2) => executionDispatcher.invokeSyncDidStartHook("willResolveField", ...args2);
        Object.defineProperty(requestContext.context, schemaInstrumentation_1.symbolExecutionDispatcherWillResolveField, { value: invokeWillResolveField });
        if (config.fieldResolver) {
          Object.defineProperty(requestContext.context, schemaInstrumentation_1.symbolUserFieldResolver, {
            value: config.fieldResolver
          });
        }
        (0, schemaInstrumentation_1.enablePluginsForSchemaResolvers)(config.schema);
      }
      try {
        const result = await execute(requestContext);
        const resultErrors = (_b = result.errors) === null || _b === undefined ? undefined : _b.map((e) => {
          if (isBadUserInputGraphQLError(e)) {
            return (0, apollo_server_errors_1.fromGraphQLError)(e, {
              errorClass: apollo_server_errors_1.UserInputError
            });
          }
          return e;
        });
        if (resultErrors) {
          await didEncounterErrors(resultErrors);
        }
        response = {
          ...result,
          errors: resultErrors ? formatErrors(resultErrors) : undefined
        };
        await executionDispatcher.invokeHook("executionDidEnd");
      } catch (executionError) {
        await executionDispatcher.invokeHook("executionDidEnd", executionError);
        return await sendErrorResponse(executionError);
      }
    }
    if (config.formatResponse) {
      const formattedResponse = config.formatResponse(response, requestContext);
      if (formattedResponse != null) {
        response = formattedResponse;
      }
    }
    return sendResponse(response);
    function parse(query2, parseOptions) {
      return (0, graphql_1.parse)(query2, parseOptions);
    }
    function validate(document2) {
      let rules = graphql_1.specifiedRules;
      if (config.validationRules) {
        rules = rules.concat(config.validationRules);
      }
      return (0, graphql_1.validate)(config.schema, document2, rules);
    }
    async function execute(requestContext2) {
      const { request: request2, document: document2 } = requestContext2;
      const executionArgs = {
        schema: config.schema,
        document: document2,
        rootValue: typeof config.rootValue === "function" ? config.rootValue(document2) : config.rootValue,
        contextValue: requestContext2.context,
        variableValues: request2.variables,
        operationName: request2.operationName,
        fieldResolver: config.fieldResolver
      };
      if (config.executor) {
        return await config.executor(requestContext2);
      } else {
        return await (0, graphql_1.execute)(executionArgs);
      }
    }
    async function sendResponse(response2) {
      requestContext.response = {
        ...requestContext.response,
        errors: response2.errors,
        data: response2.data,
        extensions: response2.extensions
      };
      if (response2.http) {
        if (!requestContext.response.http) {
          requestContext.response.http = {
            headers: new apollo_server_env_1.Headers
          };
        }
        if (response2.http.status) {
          requestContext.response.http.status = response2.http.status;
        }
        for (const [name, value] of response2.http.headers) {
          requestContext.response.http.headers.set(name, value);
        }
      }
      await dispatcher.invokeHook("willSendResponse", requestContext);
      return requestContext.response;
    }
    async function didEncounterErrors(errors) {
      requestContext.errors = errors;
      return await dispatcher.invokeHook("didEncounterErrors", requestContext);
    }
    async function sendErrorResponse(errorOrErrors, errorClass) {
      const errors = Array.isArray(errorOrErrors) ? errorOrErrors : [errorOrErrors];
      await didEncounterErrors(errors);
      const response2 = {
        errors: formatErrors(errors.map((err) => err instanceof apollo_server_errors_1.ApolloError && !errorClass ? err : (0, apollo_server_errors_1.fromGraphQLError)(err, errorClass && {
          errorClass
        })))
      };
      if (errors.every((err) => err instanceof apollo_server_errors_1.PersistedQueryNotSupportedError || err instanceof apollo_server_errors_1.PersistedQueryNotFoundError)) {
        response2.http = {
          status: 200,
          headers: new apollo_server_env_1.Headers({
            "Cache-Control": "private, no-cache, must-revalidate"
          })
        };
      } else if (errors.length === 1 && errors[0] instanceof runHttpQuery_1.HttpQueryError) {
        response2.http = {
          status: errors[0].statusCode,
          headers: new apollo_server_env_1.Headers(errors[0].headers)
        };
      }
      return sendResponse(response2);
    }
    function formatErrors(errors) {
      return (0, apollo_server_errors_1.formatApolloErrors)(errors, {
        formatter: config.formatError,
        debug: requestContext.debug
      });
    }
    async function initializeRequestListenerDispatcher() {
      const requestListeners = [];
      if (config.plugins) {
        for (const plugin of config.plugins) {
          if (!plugin.requestDidStart)
            continue;
          const listener = await plugin.requestDidStart(requestContext);
          if (listener) {
            requestListeners.push(listener);
          }
        }
      }
      return new dispatcher_1.Dispatcher(requestListeners);
    }
    async function initializeDataSources() {
      if (config.dataSources) {
        const context = requestContext.context;
        const dataSources = config.dataSources();
        const initializers = [];
        for (const dataSource of Object.values(dataSources)) {
          if (dataSource.initialize) {
            initializers.push(dataSource.initialize({
              context,
              cache: requestContext.cache
            }));
          }
        }
        await Promise.all(initializers);
        if ("dataSources" in context) {
          throw new Error("Please use the dataSources config option instead of putting dataSources on the context yourself.");
        }
        context.dataSources = dataSources;
      }
    }
  }
  exports.processGraphQLRequest = processGraphQLRequest;
});

// node_modules/apollo-server-core/dist/runHttpQuery.js
var require_runHttpQuery = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
  };
  var _a;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.cloneObject = exports.processHTTPRequest = exports.runHttpQuery = exports.throwHttpGraphQLError = exports.isHttpQueryError = exports.HttpQueryError = undefined;
  var apollo_server_env_1 = require_dist();
  var apollo_server_errors_1 = require_dist2();
  var whatwg_mimetype_1 = __importDefault(require_mime_type());
  var cachePolicy_1 = require_cachePolicy();
  var graphqlOptions_1 = require_graphqlOptions();
  var requestPipeline_1 = require_requestPipeline();

  class HttpQueryError extends Error {
    constructor(statusCode, message2, isGraphQLError = false, headers) {
      super(message2);
      this.name = "HttpQueryError";
      this.statusCode = statusCode;
      this.isGraphQLError = isGraphQLError;
      this.headers = headers;
    }
  }
  exports.HttpQueryError = HttpQueryError;
  function isHttpQueryError(e) {
    return (e === null || e === undefined ? undefined : e.name) === "HttpQueryError";
  }
  exports.isHttpQueryError = isHttpQueryError;
  function throwHttpGraphQLError(statusCode, errors, options, extensions, headers) {
    const allHeaders = {
      "Content-Type": "application/json"
    };
    if (headers) {
      for (const [name, value] of headers) {
        allHeaders[name] = value;
      }
    }
    const result = {
      errors: options ? (0, apollo_server_errors_1.formatApolloErrors)(errors, {
        debug: options.debug,
        formatter: options.formatError
      }) : errors
    };
    if (extensions) {
      result.extensions = extensions;
    }
    throw new HttpQueryError(statusCode, prettyJSONStringify(result), true, allHeaders);
  }
  exports.throwHttpGraphQLError = throwHttpGraphQLError;
  var NODE_ENV = (_a = "development") !== null && _a !== undefined ? _a : "";
  var NON_PREFLIGHTED_CONTENT_TYPES = [
    "application/x-www-form-urlencoded",
    "multipart/form-data",
    "text/plain"
  ];
  function preventCsrf(headers, csrfPreventionRequestHeaders) {
    const contentType = headers.get("content-type");
    if (contentType !== null) {
      const contentTypeParsed = whatwg_mimetype_1.default.parse(contentType);
      if (contentTypeParsed === null) {
        return;
      }
      if (!NON_PREFLIGHTED_CONTENT_TYPES.includes(contentTypeParsed.essence)) {
        return;
      }
    }
    if (csrfPreventionRequestHeaders.some((header) => {
      const value = headers.get(header);
      return value !== null && value.length > 0;
    })) {
      return;
    }
    throw new HttpQueryError(400, `This operation has been blocked as a potential Cross-Site Request Forgery ` + `(CSRF). Please either specify a 'content-type' header (with a type that ` + `is not one of ${NON_PREFLIGHTED_CONTENT_TYPES.join(", ")}) or provide ` + `a non-empty value for one of the following headers: ${csrfPreventionRequestHeaders.join(", ")}
`);
  }
  async function runHttpQuery(handlerArguments, request, csrfPreventionRequestHeaders) {
    function debugFromNodeEnv(nodeEnv = NODE_ENV) {
      return nodeEnv !== "production" && nodeEnv !== "test";
    }
    if (csrfPreventionRequestHeaders) {
      preventCsrf(request.request.headers, csrfPreventionRequestHeaders);
    }
    let options;
    try {
      options = await (0, graphqlOptions_1.resolveGraphqlOptions)(request.options, ...handlerArguments);
    } catch (e) {
      return throwHttpGraphQLError(500, [e], {
        debug: debugFromNodeEnv()
      });
    }
    if (options.debug === undefined) {
      options.debug = debugFromNodeEnv(options.nodeEnv);
    }
    if (typeof options.context === "function") {
      try {
        options.context();
      } catch (e) {
        e.message = `Context creation failed: ${e.message}`;
        if (e.extensions && e.extensions.code && e.extensions.code !== "INTERNAL_SERVER_ERROR") {
          return throwHttpGraphQLError(400, [e], options);
        } else {
          return throwHttpGraphQLError(500, [e], options);
        }
      }
    }
    const config = {
      schema: options.schema,
      schemaHash: options.schemaHash,
      logger: options.logger,
      rootValue: options.rootValue,
      context: options.context || {},
      validationRules: options.validationRules,
      executor: options.executor,
      fieldResolver: options.fieldResolver,
      cache: options.cache,
      dataSources: options.dataSources,
      dangerouslyDisableValidation: options.dangerouslyDisableValidation,
      documentStore: options.documentStore,
      persistedQueries: options.persistedQueries,
      formatError: options.formatError,
      formatResponse: options.formatResponse,
      debug: options.debug,
      plugins: options.plugins || [],
      allowBatchedHttpRequests: options.allowBatchedHttpRequests
    };
    return processHTTPRequest(config, request);
  }
  exports.runHttpQuery = runHttpQuery;
  async function processHTTPRequest(options, httpRequest) {
    var _a2, _b;
    let requestPayload;
    switch (httpRequest.method) {
      case "POST":
        if (!httpRequest.query || typeof httpRequest.query === "string" || Buffer.isBuffer(httpRequest.query) || Object.keys(httpRequest.query).length === 0) {
          throw new HttpQueryError(400, "POST body missing, invalid Content-Type, or JSON object has no keys.");
        }
        requestPayload = httpRequest.query;
        break;
      case "GET":
        if (!httpRequest.query || Object.keys(httpRequest.query).length === 0) {
          throw new HttpQueryError(400, "GET query missing.");
        }
        requestPayload = httpRequest.query;
        break;
      default:
        throw new HttpQueryError(405, "Apollo Server supports only GET/POST requests.", false, {
          Allow: "GET, POST"
        });
    }
    options = {
      ...options,
      plugins: [checkOperationPlugin, ...options.plugins]
    };
    function buildRequestContext(request, requestIsBatched) {
      const context = cloneObject(options.context);
      return {
        logger: options.logger || console,
        schema: options.schema,
        schemaHash: options.schemaHash,
        request,
        response: {
          http: {
            headers: new apollo_server_env_1.Headers
          }
        },
        context,
        cache: options.cache,
        debug: options.debug,
        metrics: {},
        overallCachePolicy: (0, cachePolicy_1.newCachePolicy)(),
        requestIsBatched
      };
    }
    const responseInit = {
      headers: {
        "Content-Type": "application/json"
      }
    };
    let body;
    try {
      if (Array.isArray(requestPayload)) {
        if (options.allowBatchedHttpRequests === false) {
          return throwHttpGraphQLError(400, [new Error("Operation batching disabled.")], options);
        }
        const requests = requestPayload.map((requestParams) => parseGraphQLRequest(httpRequest.request, requestParams));
        const responses = await Promise.all(requests.map(async (request) => {
          try {
            const requestContext = buildRequestContext(request, true);
            const response = await (0, requestPipeline_1.processGraphQLRequest)(options, requestContext);
            if (response.http) {
              for (const [name, value] of response.http.headers) {
                responseInit.headers[name] = value;
              }
              if (response.http.status) {
                responseInit.status = response.http.status;
              }
            }
            return response;
          } catch (error) {
            return {
              errors: (0, apollo_server_errors_1.formatApolloErrors)([error], options)
            };
          }
        }));
        body = prettyJSONStringify(responses.map(serializeGraphQLResponse));
      } else {
        const request = parseGraphQLRequest(httpRequest.request, requestPayload);
        const requestContext = buildRequestContext(request, false);
        const response = await (0, requestPipeline_1.processGraphQLRequest)(options, requestContext);
        if (response.errors && typeof response.data === "undefined") {
          return throwHttpGraphQLError(((_a2 = response.http) === null || _a2 === undefined ? undefined : _a2.status) || 400, response.errors, undefined, response.extensions, (_b = response.http) === null || _b === undefined ? undefined : _b.headers);
        }
        if (response.http) {
          for (const [name, value] of response.http.headers) {
            responseInit.headers[name] = value;
          }
          if (response.http.status) {
            responseInit.status = response.http.status;
          }
        }
        body = prettyJSONStringify(serializeGraphQLResponse(response));
      }
    } catch (error) {
      if (error instanceof HttpQueryError) {
        throw error;
      }
      return throwHttpGraphQLError(500, [error], options);
    }
    responseInit.headers["Content-Length"] = Buffer.byteLength(body, "utf8").toString();
    return {
      graphqlResponse: body,
      responseInit
    };
  }
  exports.processHTTPRequest = processHTTPRequest;
  function parseGraphQLRequest(httpRequest, requestParams) {
    let queryString = requestParams.query;
    let extensions = requestParams.extensions;
    if (typeof extensions === "string" && extensions !== "") {
      try {
        extensions = JSON.parse(extensions);
      } catch (error) {
        throw new HttpQueryError(400, "Extensions are invalid JSON.");
      }
    }
    if (queryString && typeof queryString !== "string") {
      if (queryString.kind === "Document") {
        throw new HttpQueryError(400, "GraphQL queries must be strings. It looks like you're sending the " + "internal graphql-js representation of a parsed query in your " + "request instead of a request in the GraphQL query language. You " + "can convert an AST to a string using the `print` function from " + "`graphql`, or use a client like `apollo-client` which converts " + "the internal representation to a string for you.");
      } else {
        throw new HttpQueryError(400, "GraphQL queries must be strings.");
      }
    }
    const operationName = requestParams.operationName;
    let variables = requestParams.variables;
    if (typeof variables === "string" && variables !== "") {
      try {
        variables = JSON.parse(variables);
      } catch (error) {
        throw new HttpQueryError(400, "Variables are invalid JSON.");
      }
    }
    return {
      query: queryString,
      operationName,
      variables,
      extensions,
      http: httpRequest
    };
  }
  var checkOperationPlugin = {
    async requestDidStart() {
      return {
        async didResolveOperation({ request, operation }) {
          if (!request.http)
            return;
          if (request.http.method === "GET" && operation.operation !== "query") {
            throw new HttpQueryError(405, `GET supports only query operation`, false, {
              Allow: "POST"
            });
          }
        }
      };
    }
  };
  function serializeGraphQLResponse(response) {
    return {
      errors: response.errors,
      data: response.data,
      extensions: response.extensions
    };
  }
  function prettyJSONStringify(value) {
    return JSON.stringify(value) + `
`;
  }
  function cloneObject(object) {
    return Object.assign(Object.create(Object.getPrototypeOf(object)), object);
  }
  exports.cloneObject = cloneObject;
});

// node_modules/apollo-server-core/dist/nodeHttpToRequest.js
var require_nodeHttpToRequest = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.convertNodeHttpToRequest = undefined;
  var apollo_server_env_1 = require_dist();
  function convertNodeHttpToRequest(req) {
    const headers = new apollo_server_env_1.Headers;
    Object.keys(req.headers).forEach((key) => {
      const values = req.headers[key];
      if (Array.isArray(values)) {
        values.forEach((value) => headers.append(key, value));
      } else {
        headers.append(key, values);
      }
    });
    return new apollo_server_env_1.Request(req.url, {
      headers,
      method: req.method
    });
  }
  exports.convertNodeHttpToRequest = convertNodeHttpToRequest;
});

// node_modules/fast-json-stable-stringify/index.js
var require_fast_json_stable_stringify = __commonJS((exports, module) => {
  module.exports = function(data, opts) {
    if (!opts)
      opts = {};
    if (typeof opts === "function")
      opts = { cmp: opts };
    var cycles = typeof opts.cycles === "boolean" ? opts.cycles : false;
    var cmp = opts.cmp && function(f) {
      return function(node) {
        return function(a, b) {
          var aobj = { key: a, value: node[a] };
          var bobj = { key: b, value: node[b] };
          return f(aobj, bobj);
        };
      };
    }(opts.cmp);
    var seen = [];
    return function stringify(node) {
      if (node && node.toJSON && typeof node.toJSON === "function") {
        node = node.toJSON();
      }
      if (node === undefined)
        return;
      if (typeof node == "number")
        return isFinite(node) ? "" + node : "null";
      if (typeof node !== "object")
        return JSON.stringify(node);
      var i, out;
      if (Array.isArray(node)) {
        out = "[";
        for (i = 0;i < node.length; i++) {
          if (i)
            out += ",";
          out += stringify(node[i]) || "null";
        }
        return out + "]";
      }
      if (node === null)
        return "null";
      if (seen.indexOf(node) !== -1) {
        if (cycles)
          return JSON.stringify("__cycle__");
        throw new TypeError("Converting circular structure to JSON");
      }
      var seenIndex = seen.push(node) - 1;
      var keys = Object.keys(node).sort(cmp && cmp(node));
      out = "";
      for (i = 0;i < keys.length; i++) {
        var key = keys[i];
        var value = stringify(node[key]);
        if (!value)
          continue;
        if (out)
          out += ",";
        out += JSON.stringify(key) + ":" + value;
      }
      seen.splice(seenIndex, 1);
      return "{" + out + "}";
    }(data);
  };
});

// node_modules/@graphql-tools/mock/node_modules/@graphql-tools/utils/index.js
var require_utils5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var graphql = require_graphql2();
  var asArray = (fns) => Array.isArray(fns) ? fns : fns ? [fns] : [];
  var invalidDocRegex = /\.[a-z0-9]+$/i;
  function isDocumentString(str) {
    if (typeof str !== "string") {
      return false;
    }
    if (invalidDocRegex.test(str)) {
      return false;
    }
    try {
      graphql.parse(str);
      return true;
    } catch (e) {}
    return false;
  }
  var invalidPathRegex = /[!%&^<=>`]/;
  function isValidPath(str) {
    return typeof str === "string" && !invalidPathRegex.test(str);
  }
  function compareStrings(a, b) {
    if (String(a) < String(b)) {
      return -1;
    }
    if (String(a) > String(b)) {
      return 1;
    }
    return 0;
  }
  function nodeToString(a) {
    var _a, _b;
    let name;
    if ("alias" in a) {
      name = (_a = a.alias) === null || _a === undefined ? undefined : _a.value;
    }
    if (name == null && "name" in a) {
      name = (_b = a.name) === null || _b === undefined ? undefined : _b.value;
    }
    if (name == null) {
      name = a.kind;
    }
    return name;
  }
  function compareNodes(a, b, customFn) {
    const aStr = nodeToString(a);
    const bStr = nodeToString(b);
    if (typeof customFn === "function") {
      return customFn(aStr, bStr);
    }
    return compareStrings(aStr, bStr);
  }
  function isSome(input) {
    return input != null;
  }
  function assertSome(input, message2 = "Value should be something") {
    if (input == null) {
      throw new Error(message2);
    }
  }
  var MAX_ARRAY_LENGTH = 10;
  var MAX_RECURSIVE_DEPTH = 2;
  function inspect(value) {
    return formatValue(value, []);
  }
  function formatValue(value, seenValues) {
    switch (typeof value) {
      case "string":
        return JSON.stringify(value);
      case "function":
        return value.name ? `[function ${value.name}]` : "[function]";
      case "object":
        return formatObjectValue(value, seenValues);
      default:
        return String(value);
    }
  }
  function formatObjectValue(value, previouslySeenValues) {
    if (value === null) {
      return "null";
    }
    if (previouslySeenValues.includes(value)) {
      return "[Circular]";
    }
    const seenValues = [...previouslySeenValues, value];
    if (isJSONable(value)) {
      const jsonValue = value.toJSON();
      if (jsonValue !== value) {
        return typeof jsonValue === "string" ? jsonValue : formatValue(jsonValue, seenValues);
      }
    } else if (Array.isArray(value)) {
      return formatArray(value, seenValues);
    }
    return formatObject(value, seenValues);
  }
  function isJSONable(value) {
    return typeof value.toJSON === "function";
  }
  function formatObject(object, seenValues) {
    const entries = Object.entries(object);
    if (entries.length === 0) {
      return "{}";
    }
    if (seenValues.length > MAX_RECURSIVE_DEPTH) {
      return "[" + getObjectTag(object) + "]";
    }
    const properties = entries.map(([key, value]) => key + ": " + formatValue(value, seenValues));
    return "{ " + properties.join(", ") + " }";
  }
  function formatArray(array, seenValues) {
    if (array.length === 0) {
      return "[]";
    }
    if (seenValues.length > MAX_RECURSIVE_DEPTH) {
      return "[Array]";
    }
    const len = Math.min(MAX_ARRAY_LENGTH, array.length);
    const remaining = array.length - len;
    const items = [];
    for (let i = 0;i < len; ++i) {
      items.push(formatValue(array[i], seenValues));
    }
    if (remaining === 1) {
      items.push("... 1 more item");
    } else if (remaining > 1) {
      items.push(`... ${remaining} more items`);
    }
    return "[" + items.join(", ") + "]";
  }
  function getObjectTag(object) {
    const tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
    if (tag === "Object" && typeof object.constructor === "function") {
      const name = object.constructor.name;
      if (typeof name === "string" && name !== "") {
        return name;
      }
    }
    return tag;
  }
  function getArgumentValues(def, node, variableValues = {}) {
    var _a;
    const variableMap = Object.entries(variableValues).reduce((prev, [key, value]) => ({
      ...prev,
      [key]: value
    }), {});
    const coercedValues = {};
    const argumentNodes = (_a = node.arguments) !== null && _a !== undefined ? _a : [];
    const argNodeMap = argumentNodes.reduce((prev, arg) => ({
      ...prev,
      [arg.name.value]: arg
    }), {});
    for (const { name, type: argType, defaultValue } of def.args) {
      const argumentNode = argNodeMap[name];
      if (!argumentNode) {
        if (defaultValue !== undefined) {
          coercedValues[name] = defaultValue;
        } else if (graphql.isNonNullType(argType)) {
          throw new graphql.GraphQLError(`Argument "${name}" of required type "${inspect(argType)}" ` + "was not provided.", node);
        }
        continue;
      }
      const valueNode = argumentNode.value;
      let isNull = valueNode.kind === graphql.Kind.NULL;
      if (valueNode.kind === graphql.Kind.VARIABLE) {
        const variableName = valueNode.name.value;
        if (variableValues == null || !variableMap[variableName]) {
          if (defaultValue !== undefined) {
            coercedValues[name] = defaultValue;
          } else if (graphql.isNonNullType(argType)) {
            throw new graphql.GraphQLError(`Argument "${name}" of required type "${inspect(argType)}" ` + `was provided the variable "$${variableName}" which was not provided a runtime value.`, valueNode);
          }
          continue;
        }
        isNull = variableValues[variableName] == null;
      }
      if (isNull && graphql.isNonNullType(argType)) {
        throw new graphql.GraphQLError(`Argument "${name}" of non-null type "${inspect(argType)}" ` + "must not be null.", valueNode);
      }
      const coercedValue = graphql.valueFromAST(valueNode, argType, variableValues);
      if (coercedValue === undefined) {
        throw new graphql.GraphQLError(`Argument "${name}" has invalid value ${graphql.print(valueNode)}.`, valueNode);
      }
      coercedValues[name] = coercedValue;
    }
    return coercedValues;
  }
  function getDirectivesInExtensions(node, pathToDirectivesInExtensions = ["directives"]) {
    return pathToDirectivesInExtensions.reduce((acc, pathSegment) => acc == null ? acc : acc[pathSegment], node === null || node === undefined ? undefined : node.extensions);
  }
  function _getDirectiveInExtensions(directivesInExtensions, directiveName) {
    const directiveInExtensions = directivesInExtensions.filter((directiveAnnotation) => directiveAnnotation.name === directiveName);
    if (!directiveInExtensions.length) {
      return;
    }
    return directiveInExtensions.map((directive) => {
      var _a;
      return (_a = directive.args) !== null && _a !== undefined ? _a : {};
    });
  }
  function getDirectiveInExtensions(node, directiveName, pathToDirectivesInExtensions = ["directives"]) {
    const directivesInExtensions = pathToDirectivesInExtensions.reduce((acc, pathSegment) => acc == null ? acc : acc[pathSegment], node === null || node === undefined ? undefined : node.extensions);
    if (directivesInExtensions === undefined) {
      return;
    }
    if (Array.isArray(directivesInExtensions)) {
      return _getDirectiveInExtensions(directivesInExtensions, directiveName);
    }
    const reformattedDirectivesInExtensions = [];
    for (const [name, argsOrArrayOfArgs] of Object.entries(directivesInExtensions)) {
      if (Array.isArray(argsOrArrayOfArgs)) {
        for (const args2 of argsOrArrayOfArgs) {
          reformattedDirectivesInExtensions.push({ name, args: args2 });
        }
      } else {
        reformattedDirectivesInExtensions.push({ name, args: argsOrArrayOfArgs });
      }
    }
    return _getDirectiveInExtensions(reformattedDirectivesInExtensions, directiveName);
  }
  function getDirectives(schema, node, pathToDirectivesInExtensions = ["directives"]) {
    const directivesInExtensions = getDirectivesInExtensions(node, pathToDirectivesInExtensions);
    if (directivesInExtensions != null && directivesInExtensions.length > 0) {
      return directivesInExtensions;
    }
    const schemaDirectives = schema && schema.getDirectives ? schema.getDirectives() : [];
    const schemaDirectiveMap = schemaDirectives.reduce((schemaDirectiveMap2, schemaDirective) => {
      schemaDirectiveMap2[schemaDirective.name] = schemaDirective;
      return schemaDirectiveMap2;
    }, {});
    let astNodes = [];
    if (node.astNode) {
      astNodes.push(node.astNode);
    }
    if ("extensionASTNodes" in node && node.extensionASTNodes) {
      astNodes = [...astNodes, ...node.extensionASTNodes];
    }
    const result = [];
    for (const astNode of astNodes) {
      if (astNode.directives) {
        for (const directiveNode of astNode.directives) {
          const schemaDirective = schemaDirectiveMap[directiveNode.name.value];
          if (schemaDirective) {
            result.push({ name: directiveNode.name.value, args: getArgumentValues(schemaDirective, directiveNode) });
          }
        }
      }
    }
    return result;
  }
  function getDirective(schema, node, directiveName, pathToDirectivesInExtensions = ["directives"]) {
    const directiveInExtensions = getDirectiveInExtensions(node, directiveName, pathToDirectivesInExtensions);
    if (directiveInExtensions != null) {
      return directiveInExtensions;
    }
    const schemaDirective = schema && schema.getDirective ? schema.getDirective(directiveName) : undefined;
    if (schemaDirective == null) {
      return;
    }
    let astNodes = [];
    if (node.astNode) {
      astNodes.push(node.astNode);
    }
    if ("extensionASTNodes" in node && node.extensionASTNodes) {
      astNodes = [...astNodes, ...node.extensionASTNodes];
    }
    const result = [];
    for (const astNode of astNodes) {
      if (astNode.directives) {
        for (const directiveNode of astNode.directives) {
          if (directiveNode.name.value === directiveName) {
            result.push(getArgumentValues(schemaDirective, directiveNode));
          }
        }
      }
    }
    if (!result.length) {
      return;
    }
    return result;
  }
  function parseDirectiveValue(value) {
    switch (value.kind) {
      case graphql.Kind.INT:
        return parseInt(value.value);
      case graphql.Kind.FLOAT:
        return parseFloat(value.value);
      case graphql.Kind.BOOLEAN:
        return Boolean(value.value);
      case graphql.Kind.STRING:
      case graphql.Kind.ENUM:
        return value.value;
      case graphql.Kind.LIST:
        return value.values.map((v) => parseDirectiveValue(v));
      case graphql.Kind.OBJECT:
        return value.fields.reduce((prev, v) => ({ ...prev, [v.name.value]: parseDirectiveValue(v.value) }), {});
      case graphql.Kind.NULL:
        return null;
      default:
        return null;
    }
  }
  function getFieldsWithDirectives(documentNode, options = {}) {
    const result = {};
    let selected = ["ObjectTypeDefinition", "ObjectTypeExtension"];
    if (options.includeInputTypes) {
      selected = [...selected, "InputObjectTypeDefinition", "InputObjectTypeExtension"];
    }
    const allTypes = documentNode.definitions.filter((obj) => selected.includes(obj.kind));
    for (const type of allTypes) {
      const typeName = type.name.value;
      if (type.fields == null) {
        continue;
      }
      for (const field of type.fields) {
        if (field.directives && field.directives.length > 0) {
          const fieldName = field.name.value;
          const key = `${typeName}.${fieldName}`;
          const directives = field.directives.map((d) => ({
            name: d.name.value,
            args: (d.arguments || []).reduce((prev, arg) => ({ ...prev, [arg.name.value]: parseDirectiveValue(arg.value) }), {})
          }));
          result[key] = directives;
        }
      }
    }
    return result;
  }
  function getImplementingTypes(interfaceName, schema) {
    const allTypesMap = schema.getTypeMap();
    const result = [];
    for (const graphqlTypeName in allTypesMap) {
      const graphqlType = allTypesMap[graphqlTypeName];
      if (graphql.isObjectType(graphqlType)) {
        const allInterfaces = graphqlType.getInterfaces();
        if (allInterfaces.find((int) => int.name === interfaceName)) {
          result.push(graphqlType.name);
        }
      }
    }
    return result;
  }
  function astFromType(type) {
    if (graphql.isNonNullType(type)) {
      const innerType = astFromType(type.ofType);
      if (innerType.kind === graphql.Kind.NON_NULL_TYPE) {
        throw new Error(`Invalid type node ${inspect(type)}. Inner type of non-null type cannot be a non-null type.`);
      }
      return {
        kind: graphql.Kind.NON_NULL_TYPE,
        type: innerType
      };
    } else if (graphql.isListType(type)) {
      return {
        kind: graphql.Kind.LIST_TYPE,
        type: astFromType(type.ofType)
      };
    }
    return {
      kind: graphql.Kind.NAMED_TYPE,
      name: {
        kind: graphql.Kind.NAME,
        value: type.name
      }
    };
  }
  function astFromValueUntyped(value) {
    if (value === null) {
      return { kind: graphql.Kind.NULL };
    }
    if (value === undefined) {
      return null;
    }
    if (Array.isArray(value)) {
      const valuesNodes = [];
      for (const item of value) {
        const itemNode = astFromValueUntyped(item);
        if (itemNode != null) {
          valuesNodes.push(itemNode);
        }
      }
      return { kind: graphql.Kind.LIST, values: valuesNodes };
    }
    if (typeof value === "object") {
      const fieldNodes = [];
      for (const fieldName in value) {
        const fieldValue = value[fieldName];
        const ast = astFromValueUntyped(fieldValue);
        if (ast) {
          fieldNodes.push({
            kind: graphql.Kind.OBJECT_FIELD,
            name: { kind: graphql.Kind.NAME, value: fieldName },
            value: ast
          });
        }
      }
      return { kind: graphql.Kind.OBJECT, fields: fieldNodes };
    }
    if (typeof value === "boolean") {
      return { kind: graphql.Kind.BOOLEAN, value };
    }
    if (typeof value === "number" && isFinite(value)) {
      const stringNum = String(value);
      return integerStringRegExp.test(stringNum) ? { kind: graphql.Kind.INT, value: stringNum } : { kind: graphql.Kind.FLOAT, value: stringNum };
    }
    if (typeof value === "string") {
      return { kind: graphql.Kind.STRING, value };
    }
    throw new TypeError(`Cannot convert value to AST: ${value}.`);
  }
  var integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;
  function memoize1(fn2) {
    const memoize1cache = new WeakMap;
    return function memoized(a1) {
      const cachedValue = memoize1cache.get(a1);
      if (cachedValue === undefined) {
        const newValue = fn2(a1);
        memoize1cache.set(a1, newValue);
        return newValue;
      }
      return cachedValue;
    };
  }
  function memoize2(fn2) {
    const memoize2cache = new WeakMap;
    return function memoized(a1, a2) {
      let cache2 = memoize2cache.get(a1);
      if (!cache2) {
        cache2 = new WeakMap;
        memoize2cache.set(a1, cache2);
        const newValue = fn2(a1, a2);
        cache2.set(a2, newValue);
        return newValue;
      }
      const cachedValue = cache2.get(a2);
      if (cachedValue === undefined) {
        const newValue = fn2(a1, a2);
        cache2.set(a2, newValue);
        return newValue;
      }
      return cachedValue;
    };
  }
  function memoize3(fn2) {
    const memoize3Cache = new WeakMap;
    return function memoized(a1, a2, a3) {
      let cache2 = memoize3Cache.get(a1);
      if (!cache2) {
        cache2 = new WeakMap;
        memoize3Cache.set(a1, cache2);
        const cache32 = new WeakMap;
        cache2.set(a2, cache32);
        const newValue = fn2(a1, a2, a3);
        cache32.set(a3, newValue);
        return newValue;
      }
      let cache3 = cache2.get(a2);
      if (!cache3) {
        cache3 = new WeakMap;
        cache2.set(a2, cache3);
        const newValue = fn2(a1, a2, a3);
        cache3.set(a3, newValue);
        return newValue;
      }
      const cachedValue = cache3.get(a3);
      if (cachedValue === undefined) {
        const newValue = fn2(a1, a2, a3);
        cache3.set(a3, newValue);
        return newValue;
      }
      return cachedValue;
    };
  }
  function memoize4(fn2) {
    const memoize4Cache = new WeakMap;
    return function memoized(a1, a2, a3, a4) {
      let cache2 = memoize4Cache.get(a1);
      if (!cache2) {
        cache2 = new WeakMap;
        memoize4Cache.set(a1, cache2);
        const cache32 = new WeakMap;
        cache2.set(a2, cache32);
        const cache42 = new WeakMap;
        cache32.set(a3, cache42);
        const newValue = fn2(a1, a2, a3, a4);
        cache42.set(a4, newValue);
        return newValue;
      }
      let cache3 = cache2.get(a2);
      if (!cache3) {
        cache3 = new WeakMap;
        cache2.set(a2, cache3);
        const cache42 = new WeakMap;
        cache3.set(a3, cache42);
        const newValue = fn2(a1, a2, a3, a4);
        cache42.set(a4, newValue);
        return newValue;
      }
      const cache4 = cache3.get(a3);
      if (!cache4) {
        const cache42 = new WeakMap;
        cache3.set(a3, cache42);
        const newValue = fn2(a1, a2, a3, a4);
        cache42.set(a4, newValue);
        return newValue;
      }
      const cachedValue = cache4.get(a4);
      if (cachedValue === undefined) {
        const newValue = fn2(a1, a2, a3, a4);
        cache4.set(a4, newValue);
        return newValue;
      }
      return cachedValue;
    };
  }
  function memoize5(fn2) {
    const memoize5Cache = new WeakMap;
    return function memoized(a1, a2, a3, a4, a5) {
      let cache2 = memoize5Cache.get(a1);
      if (!cache2) {
        cache2 = new WeakMap;
        memoize5Cache.set(a1, cache2);
        const cache32 = new WeakMap;
        cache2.set(a2, cache32);
        const cache42 = new WeakMap;
        cache32.set(a3, cache42);
        const cache52 = new WeakMap;
        cache42.set(a4, cache52);
        const newValue = fn2(a1, a2, a3, a4, a5);
        cache52.set(a5, newValue);
        return newValue;
      }
      let cache3 = cache2.get(a2);
      if (!cache3) {
        cache3 = new WeakMap;
        cache2.set(a2, cache3);
        const cache42 = new WeakMap;
        cache3.set(a3, cache42);
        const cache52 = new WeakMap;
        cache42.set(a4, cache52);
        const newValue = fn2(a1, a2, a3, a4, a5);
        cache52.set(a5, newValue);
        return newValue;
      }
      let cache4 = cache3.get(a3);
      if (!cache4) {
        cache4 = new WeakMap;
        cache3.set(a3, cache4);
        const cache52 = new WeakMap;
        cache4.set(a4, cache52);
        const newValue = fn2(a1, a2, a3, a4, a5);
        cache52.set(a5, newValue);
        return newValue;
      }
      let cache5 = cache4.get(a4);
      if (!cache5) {
        cache5 = new WeakMap;
        cache4.set(a4, cache5);
        const newValue = fn2(a1, a2, a3, a4, a5);
        cache5.set(a5, newValue);
        return newValue;
      }
      const cachedValue = cache5.get(a5);
      if (cachedValue === undefined) {
        const newValue = fn2(a1, a2, a3, a4, a5);
        cache5.set(a5, newValue);
        return newValue;
      }
      return cachedValue;
    };
  }
  var memoize2of4cache = new WeakMap;
  function memoize2of4(fn2) {
    return function memoized(a1, a2, a3, a4) {
      let cache2 = memoize2of4cache.get(a1);
      if (!cache2) {
        cache2 = new WeakMap;
        memoize2of4cache.set(a1, cache2);
        const newValue = fn2(a1, a2, a3, a4);
        cache2.set(a2, newValue);
        return newValue;
      }
      const cachedValue = cache2.get(a2);
      if (cachedValue === undefined) {
        const newValue = fn2(a1, a2, a3, a4);
        cache2.set(a2, newValue);
        return newValue;
      }
      return cachedValue;
    };
  }
  function getDefinedRootType(schema, operation) {
    const rootTypeMap = getRootTypeMap(schema);
    const rootType = rootTypeMap.get(operation);
    if (rootType == null) {
      throw new Error(`Root type for operation "${operation}" not defined by the given schema.`);
    }
    return rootType;
  }
  var getRootTypeNames = memoize1(function getRootTypeNames(schema) {
    const rootTypes = getRootTypes(schema);
    return new Set([...rootTypes].map((type) => type.name));
  });
  var getRootTypes = memoize1(function getRootTypes(schema) {
    const rootTypeMap = getRootTypeMap(schema);
    return new Set(rootTypeMap.values());
  });
  var getRootTypeMap = memoize1(function getRootTypeMap(schema) {
    const rootTypeMap = new Map;
    const queryType = schema.getQueryType();
    if (queryType) {
      rootTypeMap.set("query", queryType);
    }
    const mutationType = schema.getMutationType();
    if (mutationType) {
      rootTypeMap.set("mutation", mutationType);
    }
    const subscriptionType = schema.getSubscriptionType();
    if (subscriptionType) {
      rootTypeMap.set("subscription", subscriptionType);
    }
    return rootTypeMap;
  });
  function getDocumentNodeFromSchema(schema, options = {}) {
    const pathToDirectivesInExtensions = options.pathToDirectivesInExtensions;
    const typesMap = schema.getTypeMap();
    const schemaNode = astFromSchema(schema, pathToDirectivesInExtensions);
    const definitions = schemaNode != null ? [schemaNode] : [];
    const directives = schema.getDirectives();
    for (const directive of directives) {
      if (graphql.isSpecifiedDirective(directive)) {
        continue;
      }
      definitions.push(astFromDirective(directive, schema, pathToDirectivesInExtensions));
    }
    for (const typeName in typesMap) {
      const type = typesMap[typeName];
      const isPredefinedScalar = graphql.isSpecifiedScalarType(type);
      const isIntrospection = graphql.isIntrospectionType(type);
      if (isPredefinedScalar || isIntrospection) {
        continue;
      }
      if (graphql.isObjectType(type)) {
        definitions.push(astFromObjectType(type, schema, pathToDirectivesInExtensions));
      } else if (graphql.isInterfaceType(type)) {
        definitions.push(astFromInterfaceType(type, schema, pathToDirectivesInExtensions));
      } else if (graphql.isUnionType(type)) {
        definitions.push(astFromUnionType(type, schema, pathToDirectivesInExtensions));
      } else if (graphql.isInputObjectType(type)) {
        definitions.push(astFromInputObjectType(type, schema, pathToDirectivesInExtensions));
      } else if (graphql.isEnumType(type)) {
        definitions.push(astFromEnumType(type, schema, pathToDirectivesInExtensions));
      } else if (graphql.isScalarType(type)) {
        definitions.push(astFromScalarType(type, schema, pathToDirectivesInExtensions));
      } else {
        throw new Error(`Unknown type ${type}.`);
      }
    }
    return {
      kind: graphql.Kind.DOCUMENT,
      definitions
    };
  }
  function printSchemaWithDirectives(schema, options = {}) {
    const documentNode = getDocumentNodeFromSchema(schema, options);
    return graphql.print(documentNode);
  }
  function astFromSchema(schema, pathToDirectivesInExtensions) {
    var _a, _b;
    const operationTypeMap = new Map([
      ["query", undefined],
      ["mutation", undefined],
      ["subscription", undefined]
    ]);
    const nodes = [];
    if (schema.astNode != null) {
      nodes.push(schema.astNode);
    }
    if (schema.extensionASTNodes != null) {
      for (const extensionASTNode of schema.extensionASTNodes) {
        nodes.push(extensionASTNode);
      }
    }
    for (const node of nodes) {
      if (node.operationTypes) {
        for (const operationTypeDefinitionNode of node.operationTypes) {
          operationTypeMap.set(operationTypeDefinitionNode.operation, operationTypeDefinitionNode);
        }
      }
    }
    const rootTypeMap = getRootTypeMap(schema);
    for (const [operationTypeNode, operationTypeDefinitionNode] of operationTypeMap) {
      const rootType = rootTypeMap.get(operationTypeNode);
      if (rootType != null) {
        const rootTypeAST = astFromType(rootType);
        if (operationTypeDefinitionNode != null) {
          operationTypeDefinitionNode.type = rootTypeAST;
        } else {
          operationTypeMap.set(operationTypeNode, {
            kind: graphql.Kind.OPERATION_TYPE_DEFINITION,
            operation: operationTypeNode,
            type: rootTypeAST
          });
        }
      }
    }
    const operationTypes = [...operationTypeMap.values()].filter(isSome);
    const directives = getDirectiveNodes(schema, schema, pathToDirectivesInExtensions);
    if (!operationTypes.length && !directives.length) {
      return null;
    }
    const schemaNode = {
      kind: operationTypes != null ? graphql.Kind.SCHEMA_DEFINITION : graphql.Kind.SCHEMA_EXTENSION,
      operationTypes,
      directives
    };
    schemaNode.description = ((_b = (_a = schema.astNode) === null || _a === undefined ? undefined : _a.description) !== null && _b !== undefined ? _b : schema.description != null) ? {
      kind: graphql.Kind.STRING,
      value: schema.description,
      block: true
    } : undefined;
    return schemaNode;
  }
  function astFromDirective(directive, schema, pathToDirectivesInExtensions) {
    var _a, _b, _c, _d;
    return {
      kind: graphql.Kind.DIRECTIVE_DEFINITION,
      description: (_b = (_a = directive.astNode) === null || _a === undefined ? undefined : _a.description) !== null && _b !== undefined ? _b : directive.description ? {
        kind: graphql.Kind.STRING,
        value: directive.description
      } : undefined,
      name: {
        kind: graphql.Kind.NAME,
        value: directive.name
      },
      arguments: (_c = directive.args) === null || _c === undefined ? undefined : _c.map((arg) => astFromArg(arg, schema, pathToDirectivesInExtensions)),
      repeatable: directive.isRepeatable,
      locations: ((_d = directive.locations) === null || _d === undefined ? undefined : _d.map((location) => ({
        kind: graphql.Kind.NAME,
        value: location
      }))) || []
    };
  }
  function getDirectiveNodes(entity, schema, pathToDirectivesInExtensions) {
    const directivesInExtensions = getDirectivesInExtensions(entity, pathToDirectivesInExtensions);
    let nodes = [];
    if (entity.astNode != null) {
      nodes.push(entity.astNode);
    }
    if ("extensionASTNodes" in entity && entity.extensionASTNodes != null) {
      nodes = nodes.concat(entity.extensionASTNodes);
    }
    let directives;
    if (directivesInExtensions != null) {
      directives = makeDirectiveNodes(schema, directivesInExtensions);
    } else {
      directives = [];
      for (const node of nodes) {
        if (node.directives) {
          directives.push(...node.directives);
        }
      }
    }
    return directives;
  }
  function getDeprecatableDirectiveNodes(entity, schema, pathToDirectivesInExtensions) {
    var _a, _b;
    let directiveNodesBesidesDeprecated = [];
    let deprecatedDirectiveNode = null;
    const directivesInExtensions = getDirectivesInExtensions(entity, pathToDirectivesInExtensions);
    let directives;
    if (directivesInExtensions != null) {
      directives = makeDirectiveNodes(schema, directivesInExtensions);
    } else {
      directives = (_a = entity.astNode) === null || _a === undefined ? undefined : _a.directives;
    }
    if (directives != null) {
      directiveNodesBesidesDeprecated = directives.filter((directive) => directive.name.value !== "deprecated");
      if (entity.deprecationReason != null) {
        deprecatedDirectiveNode = (_b = directives.filter((directive) => directive.name.value === "deprecated")) === null || _b === undefined ? undefined : _b[0];
      }
    }
    if (entity.deprecationReason != null && deprecatedDirectiveNode == null) {
      deprecatedDirectiveNode = makeDeprecatedDirective(entity.deprecationReason);
    }
    return deprecatedDirectiveNode == null ? directiveNodesBesidesDeprecated : [deprecatedDirectiveNode].concat(directiveNodesBesidesDeprecated);
  }
  function astFromArg(arg, schema, pathToDirectivesInExtensions) {
    var _a, _b, _c;
    return {
      kind: graphql.Kind.INPUT_VALUE_DEFINITION,
      description: (_b = (_a = arg.astNode) === null || _a === undefined ? undefined : _a.description) !== null && _b !== undefined ? _b : arg.description ? {
        kind: graphql.Kind.STRING,
        value: arg.description,
        block: true
      } : undefined,
      name: {
        kind: graphql.Kind.NAME,
        value: arg.name
      },
      type: astFromType(arg.type),
      defaultValue: arg.defaultValue !== undefined ? (_c = graphql.astFromValue(arg.defaultValue, arg.type)) !== null && _c !== undefined ? _c : undefined : undefined,
      directives: getDeprecatableDirectiveNodes(arg, schema, pathToDirectivesInExtensions)
    };
  }
  function astFromObjectType(type, schema, pathToDirectivesInExtensions) {
    var _a, _b;
    return {
      kind: graphql.Kind.OBJECT_TYPE_DEFINITION,
      description: (_b = (_a = type.astNode) === null || _a === undefined ? undefined : _a.description) !== null && _b !== undefined ? _b : type.description ? {
        kind: graphql.Kind.STRING,
        value: type.description,
        block: true
      } : undefined,
      name: {
        kind: graphql.Kind.NAME,
        value: type.name
      },
      fields: Object.values(type.getFields()).map((field) => astFromField(field, schema, pathToDirectivesInExtensions)),
      interfaces: Object.values(type.getInterfaces()).map((iFace) => astFromType(iFace)),
      directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions)
    };
  }
  function astFromInterfaceType(type, schema, pathToDirectivesInExtensions) {
    var _a, _b;
    const node = {
      kind: graphql.Kind.INTERFACE_TYPE_DEFINITION,
      description: (_b = (_a = type.astNode) === null || _a === undefined ? undefined : _a.description) !== null && _b !== undefined ? _b : type.description ? {
        kind: graphql.Kind.STRING,
        value: type.description,
        block: true
      } : undefined,
      name: {
        kind: graphql.Kind.NAME,
        value: type.name
      },
      fields: Object.values(type.getFields()).map((field) => astFromField(field, schema, pathToDirectivesInExtensions)),
      directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions)
    };
    if ("getInterfaces" in type) {
      node.interfaces = Object.values(type.getInterfaces()).map((iFace) => astFromType(iFace));
    }
    return node;
  }
  function astFromUnionType(type, schema, pathToDirectivesInExtensions) {
    var _a, _b;
    return {
      kind: graphql.Kind.UNION_TYPE_DEFINITION,
      description: (_b = (_a = type.astNode) === null || _a === undefined ? undefined : _a.description) !== null && _b !== undefined ? _b : type.description ? {
        kind: graphql.Kind.STRING,
        value: type.description,
        block: true
      } : undefined,
      name: {
        kind: graphql.Kind.NAME,
        value: type.name
      },
      directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions),
      types: type.getTypes().map((type2) => astFromType(type2))
    };
  }
  function astFromInputObjectType(type, schema, pathToDirectivesInExtensions) {
    var _a, _b;
    return {
      kind: graphql.Kind.INPUT_OBJECT_TYPE_DEFINITION,
      description: (_b = (_a = type.astNode) === null || _a === undefined ? undefined : _a.description) !== null && _b !== undefined ? _b : type.description ? {
        kind: graphql.Kind.STRING,
        value: type.description,
        block: true
      } : undefined,
      name: {
        kind: graphql.Kind.NAME,
        value: type.name
      },
      fields: Object.values(type.getFields()).map((field) => astFromInputField(field, schema, pathToDirectivesInExtensions)),
      directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions)
    };
  }
  function astFromEnumType(type, schema, pathToDirectivesInExtensions) {
    var _a, _b;
    return {
      kind: graphql.Kind.ENUM_TYPE_DEFINITION,
      description: (_b = (_a = type.astNode) === null || _a === undefined ? undefined : _a.description) !== null && _b !== undefined ? _b : type.description ? {
        kind: graphql.Kind.STRING,
        value: type.description,
        block: true
      } : undefined,
      name: {
        kind: graphql.Kind.NAME,
        value: type.name
      },
      values: Object.values(type.getValues()).map((value) => astFromEnumValue(value, schema, pathToDirectivesInExtensions)),
      directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions)
    };
  }
  function astFromScalarType(type, schema, pathToDirectivesInExtensions) {
    var _a, _b, _c;
    const directivesInExtensions = getDirectivesInExtensions(type, pathToDirectivesInExtensions);
    const directives = directivesInExtensions ? makeDirectiveNodes(schema, directivesInExtensions) : ((_a = type.astNode) === null || _a === undefined ? undefined : _a.directives) || [];
    if (type["specifiedByUrl"] && !directives.some((directiveNode) => directiveNode.name.value === "specifiedBy")) {
      const specifiedByArgs = {
        url: type["specifiedByUrl"]
      };
      directives.push(makeDirectiveNode("specifiedBy", specifiedByArgs));
    }
    return {
      kind: graphql.Kind.SCALAR_TYPE_DEFINITION,
      description: (_c = (_b = type.astNode) === null || _b === undefined ? undefined : _b.description) !== null && _c !== undefined ? _c : type.description ? {
        kind: graphql.Kind.STRING,
        value: type.description,
        block: true
      } : undefined,
      name: {
        kind: graphql.Kind.NAME,
        value: type.name
      },
      directives
    };
  }
  function astFromField(field, schema, pathToDirectivesInExtensions) {
    var _a, _b;
    return {
      kind: graphql.Kind.FIELD_DEFINITION,
      description: (_b = (_a = field.astNode) === null || _a === undefined ? undefined : _a.description) !== null && _b !== undefined ? _b : field.description ? {
        kind: graphql.Kind.STRING,
        value: field.description,
        block: true
      } : undefined,
      name: {
        kind: graphql.Kind.NAME,
        value: field.name
      },
      arguments: field.args.map((arg) => astFromArg(arg, schema, pathToDirectivesInExtensions)),
      type: astFromType(field.type),
      directives: getDeprecatableDirectiveNodes(field, schema, pathToDirectivesInExtensions)
    };
  }
  function astFromInputField(field, schema, pathToDirectivesInExtensions) {
    var _a, _b, _c;
    return {
      kind: graphql.Kind.INPUT_VALUE_DEFINITION,
      description: (_b = (_a = field.astNode) === null || _a === undefined ? undefined : _a.description) !== null && _b !== undefined ? _b : field.description ? {
        kind: graphql.Kind.STRING,
        value: field.description,
        block: true
      } : undefined,
      name: {
        kind: graphql.Kind.NAME,
        value: field.name
      },
      type: astFromType(field.type),
      directives: getDeprecatableDirectiveNodes(field, schema, pathToDirectivesInExtensions),
      defaultValue: (_c = graphql.astFromValue(field.defaultValue, field.type)) !== null && _c !== undefined ? _c : undefined
    };
  }
  function astFromEnumValue(value, schema, pathToDirectivesInExtensions) {
    var _a, _b;
    return {
      kind: graphql.Kind.ENUM_VALUE_DEFINITION,
      description: (_b = (_a = value.astNode) === null || _a === undefined ? undefined : _a.description) !== null && _b !== undefined ? _b : value.description ? {
        kind: graphql.Kind.STRING,
        value: value.description,
        block: true
      } : undefined,
      name: {
        kind: graphql.Kind.NAME,
        value: value.name
      },
      directives: getDirectiveNodes(value, schema, pathToDirectivesInExtensions)
    };
  }
  function makeDeprecatedDirective(deprecationReason) {
    return makeDirectiveNode("deprecated", { reason: deprecationReason }, graphql.GraphQLDeprecatedDirective);
  }
  function makeDirectiveNode(name, args2, directive) {
    const directiveArguments = [];
    if (directive != null) {
      for (const arg of directive.args) {
        const argName = arg.name;
        const argValue = args2[argName];
        if (argValue !== undefined) {
          const value = graphql.astFromValue(argValue, arg.type);
          if (value) {
            directiveArguments.push({
              kind: graphql.Kind.ARGUMENT,
              name: {
                kind: graphql.Kind.NAME,
                value: argName
              },
              value
            });
          }
        }
      }
    } else {
      for (const argName in args2) {
        const argValue = args2[argName];
        const value = astFromValueUntyped(argValue);
        if (value) {
          directiveArguments.push({
            kind: graphql.Kind.ARGUMENT,
            name: {
              kind: graphql.Kind.NAME,
              value: argName
            },
            value
          });
        }
      }
    }
    return {
      kind: graphql.Kind.DIRECTIVE,
      name: {
        kind: graphql.Kind.NAME,
        value: name
      },
      arguments: directiveArguments
    };
  }
  function makeDirectiveNodes(schema, directiveValues) {
    const directiveNodes = [];
    for (const directiveName in directiveValues) {
      const arrayOrSingleValue = directiveValues[directiveName];
      const directive = schema === null || schema === undefined ? undefined : schema.getDirective(directiveName);
      if (Array.isArray(arrayOrSingleValue)) {
        for (const value of arrayOrSingleValue) {
          directiveNodes.push(makeDirectiveNode(directiveName, value, directive));
        }
      } else {
        directiveNodes.push(makeDirectiveNode(directiveName, arrayOrSingleValue, directive));
      }
    }
    return directiveNodes;
  }
  exports.AggregateError = globalThis.AggregateError;
  if (typeof exports.AggregateError === "undefined") {

    class AggregateErrorClass extends Error {
      constructor(errors, message2 = "") {
        super(message2);
        this.errors = errors;
        this.name = "AggregateError";
        Error.captureStackTrace(this, AggregateErrorClass);
      }
    }
    exports.AggregateError = function(errors, message2) {
      return new AggregateErrorClass(errors, message2);
    };
  }
  async function validateGraphQlDocuments(schema, documentFiles, effectiveRules) {
    effectiveRules = effectiveRules || createDefaultRules();
    const allFragmentMap = new Map;
    const documentFileObjectsToValidate = [];
    for (const documentFile of documentFiles) {
      if (documentFile.document) {
        const definitionsToValidate = [];
        for (const definitionNode of documentFile.document.definitions) {
          if (definitionNode.kind === graphql.Kind.FRAGMENT_DEFINITION) {
            allFragmentMap.set(definitionNode.name.value, definitionNode);
          } else {
            definitionsToValidate.push(definitionNode);
          }
        }
        documentFileObjectsToValidate.push({
          location: documentFile.location,
          document: {
            kind: graphql.Kind.DOCUMENT,
            definitions: definitionsToValidate
          }
        });
      }
    }
    const allErrors = [];
    const allFragmentsDocument = {
      kind: graphql.Kind.DOCUMENT,
      definitions: [...allFragmentMap.values()]
    };
    await Promise.all(documentFileObjectsToValidate.map(async (documentFile) => {
      const documentToValidate = graphql.concatAST([allFragmentsDocument, documentFile.document]);
      const errors = graphql.validate(schema, documentToValidate, effectiveRules);
      if (errors.length > 0) {
        allErrors.push({
          filePath: documentFile.location,
          errors
        });
      }
    }));
    return allErrors;
  }
  function checkValidationErrors(loadDocumentErrors) {
    if (loadDocumentErrors.length > 0) {
      const errors = [];
      for (const loadDocumentError of loadDocumentErrors) {
        for (const graphQLError of loadDocumentError.errors) {
          const error = new Error;
          error.name = "GraphQLDocumentError";
          error.message = `${error.name}: ${graphQLError.message}`;
          error.stack = error.message;
          if (graphQLError.locations) {
            for (const location of graphQLError.locations) {
              error.stack += `
    at ${loadDocumentError.filePath}:${location.line}:${location.column}`;
            }
          }
          errors.push(error);
        }
      }
      throw new exports.AggregateError(errors, `GraphQL Document Validation failed with ${errors.length} errors;
  ${errors.map((error, index) => `Error ${index}: ${error.stack}`).join(`

`)}`);
    }
  }
  function createDefaultRules() {
    const ignored = ["NoUnusedFragmentsRule", "NoUnusedVariablesRule", "KnownDirectivesRule"];
    const v4ignored = ignored.map((rule) => rule.replace(/Rule$/, ""));
    return graphql.specifiedRules.filter((f) => !ignored.includes(f.name) && !v4ignored.includes(f.name));
  }
  function stripBOM(content) {
    content = content.toString();
    if (content.charCodeAt(0) === 65279) {
      content = content.slice(1);
    }
    return content;
  }
  function parseBOM(content) {
    return JSON.parse(stripBOM(content));
  }
  function parseGraphQLJSON(location, jsonContent, options) {
    let parsedJson = parseBOM(jsonContent);
    if (parsedJson.data) {
      parsedJson = parsedJson.data;
    }
    if (parsedJson.kind === "Document") {
      return {
        location,
        document: parsedJson
      };
    } else if (parsedJson.__schema) {
      const schema = graphql.buildClientSchema(parsedJson, options);
      return {
        location,
        schema
      };
    } else if (typeof parsedJson === "string") {
      return {
        location,
        rawSDL: parsedJson
      };
    }
    throw new Error(`Not valid JSON content`);
  }
  var MAX_LINE_LENGTH = 80;
  var commentsRegistry = {};
  function resetComments() {
    commentsRegistry = {};
  }
  function collectComment(node) {
    var _a;
    const entityName = (_a = node.name) === null || _a === undefined ? undefined : _a.value;
    if (entityName == null) {
      return;
    }
    pushComment(node, entityName);
    switch (node.kind) {
      case "EnumTypeDefinition":
        if (node.values) {
          for (const value of node.values) {
            pushComment(value, entityName, value.name.value);
          }
        }
        break;
      case "ObjectTypeDefinition":
      case "InputObjectTypeDefinition":
      case "InterfaceTypeDefinition":
        if (node.fields) {
          for (const field of node.fields) {
            pushComment(field, entityName, field.name.value);
            if (isFieldDefinitionNode(field) && field.arguments) {
              for (const arg of field.arguments) {
                pushComment(arg, entityName, field.name.value, arg.name.value);
              }
            }
          }
        }
        break;
    }
  }
  function pushComment(node, entity, field, argument) {
    const comment = getComment(node);
    if (typeof comment !== "string" || comment.length === 0) {
      return;
    }
    const keys = [entity];
    if (field) {
      keys.push(field);
      if (argument) {
        keys.push(argument);
      }
    }
    const path = keys.join(".");
    if (!commentsRegistry[path]) {
      commentsRegistry[path] = [];
    }
    commentsRegistry[path].push(comment);
  }
  function printComment(comment) {
    return `
# ` + comment.replace(/\n/g, `
# `);
  }
  function join(maybeArray, separator) {
    return maybeArray ? maybeArray.filter((x) => x).join(separator || "") : "";
  }
  function hasMultilineItems(maybeArray) {
    var _a;
    return (_a = maybeArray === null || maybeArray === undefined ? undefined : maybeArray.some((str) => str.includes(`
`))) !== null && _a !== undefined ? _a : false;
  }
  function addDescription(cb) {
    return (node, _key, _parent, path, ancestors) => {
      var _a;
      const keys = [];
      const parent = path.reduce((prev, key2) => {
        if (["fields", "arguments", "values"].includes(key2) && prev.name) {
          keys.push(prev.name.value);
        }
        return prev[key2];
      }, ancestors[0]);
      const key = [...keys, (_a = parent === null || parent === undefined ? undefined : parent.name) === null || _a === undefined ? undefined : _a.value].filter(Boolean).join(".");
      const items = [];
      if (node.kind.includes("Definition") && commentsRegistry[key]) {
        items.push(...commentsRegistry[key]);
      }
      return join([...items.map(printComment), node.description, cb(node, _key, _parent, path, ancestors)], `
`);
    };
  }
  function indent(maybeString) {
    return maybeString && `  ${maybeString.replace(/\n/g, `
  `)}`;
  }
  function block(array) {
    return array && array.length !== 0 ? `{
${indent(join(array, `
`))}
}` : "";
  }
  function wrap(start, maybeString, end) {
    return maybeString ? start + maybeString + (end || "") : "";
  }
  function printBlockString(value, isDescription = false) {
    const escaped = value.replace(/"""/g, '\\"""');
    return (value[0] === " " || value[0] === "\t") && value.indexOf(`
`) === -1 ? `"""${escaped.replace(/"$/, `"
`)}"""` : `"""
${isDescription ? escaped : indent(escaped)}
"""`;
  }
  var printDocASTReducer = {
    Name: { leave: (node) => node.value },
    Variable: { leave: (node) => "$" + node.name },
    Document: {
      leave: (node) => join(node.definitions, `

`)
    },
    OperationDefinition: {
      leave: (node) => {
        const varDefs = wrap("(", join(node.variableDefinitions, ", "), ")");
        const prefix = join([node.operation, join([node.name, varDefs]), join(node.directives, " ")], " ");
        return prefix + " " + node.selectionSet;
      }
    },
    VariableDefinition: {
      leave: ({ variable, type, defaultValue, directives }) => variable + ": " + type + wrap(" = ", defaultValue) + wrap(" ", join(directives, " "))
    },
    SelectionSet: { leave: ({ selections }) => block(selections) },
    Field: {
      leave({ alias, name, arguments: args2, directives, selectionSet }) {
        const prefix = wrap("", alias, ": ") + name;
        let argsLine = prefix + wrap("(", join(args2, ", "), ")");
        if (argsLine.length > MAX_LINE_LENGTH) {
          argsLine = prefix + wrap(`(
`, indent(join(args2, `
`)), `
)`);
        }
        return join([argsLine, join(directives, " "), selectionSet], " ");
      }
    },
    Argument: { leave: ({ name, value }) => name + ": " + value },
    FragmentSpread: {
      leave: ({ name, directives }) => "..." + name + wrap(" ", join(directives, " "))
    },
    InlineFragment: {
      leave: ({ typeCondition, directives, selectionSet }) => join(["...", wrap("on ", typeCondition), join(directives, " "), selectionSet], " ")
    },
    FragmentDefinition: {
      leave: ({ name, typeCondition, variableDefinitions, directives, selectionSet }) => `fragment ${name}${wrap("(", join(variableDefinitions, ", "), ")")} ` + `on ${typeCondition} ${wrap("", join(directives, " "), " ")}` + selectionSet
    },
    IntValue: { leave: ({ value }) => value },
    FloatValue: { leave: ({ value }) => value },
    StringValue: {
      leave: ({ value, block: isBlockString }) => {
        if (isBlockString) {
          return printBlockString(value);
        }
        return JSON.stringify(value);
      }
    },
    BooleanValue: { leave: ({ value }) => value ? "true" : "false" },
    NullValue: { leave: () => "null" },
    EnumValue: { leave: ({ value }) => value },
    ListValue: { leave: ({ values }) => "[" + join(values, ", ") + "]" },
    ObjectValue: { leave: ({ fields }) => "{" + join(fields, ", ") + "}" },
    ObjectField: { leave: ({ name, value }) => name + ": " + value },
    Directive: {
      leave: ({ name, arguments: args2 }) => "@" + name + wrap("(", join(args2, ", "), ")")
    },
    NamedType: { leave: ({ name }) => name },
    ListType: { leave: ({ type }) => "[" + type + "]" },
    NonNullType: { leave: ({ type }) => type + "!" },
    SchemaDefinition: {
      leave: ({ directives, operationTypes }) => join(["schema", join(directives, " "), block(operationTypes)], " ")
    },
    OperationTypeDefinition: {
      leave: ({ operation, type }) => operation + ": " + type
    },
    ScalarTypeDefinition: {
      leave: ({ name, directives }) => join(["scalar", name, join(directives, " ")], " ")
    },
    ObjectTypeDefinition: {
      leave: ({ name, interfaces, directives, fields }) => join(["type", name, wrap("implements ", join(interfaces, " & ")), join(directives, " "), block(fields)], " ")
    },
    FieldDefinition: {
      leave: ({ name, arguments: args2, type, directives }) => name + (hasMultilineItems(args2) ? wrap(`(
`, indent(join(args2, `
`)), `
)`) : wrap("(", join(args2, ", "), ")")) + ": " + type + wrap(" ", join(directives, " "))
    },
    InputValueDefinition: {
      leave: ({ name, type, defaultValue, directives }) => join([name + ": " + type, wrap("= ", defaultValue), join(directives, " ")], " ")
    },
    InterfaceTypeDefinition: {
      leave: ({ name, interfaces, directives, fields }) => join(["interface", name, wrap("implements ", join(interfaces, " & ")), join(directives, " "), block(fields)], " ")
    },
    UnionTypeDefinition: {
      leave: ({ name, directives, types }) => join(["union", name, join(directives, " "), wrap("= ", join(types, " | "))], " ")
    },
    EnumTypeDefinition: {
      leave: ({ name, directives, values }) => join(["enum", name, join(directives, " "), block(values)], " ")
    },
    EnumValueDefinition: {
      leave: ({ name, directives }) => join([name, join(directives, " ")], " ")
    },
    InputObjectTypeDefinition: {
      leave: ({ name, directives, fields }) => join(["input", name, join(directives, " "), block(fields)], " ")
    },
    DirectiveDefinition: {
      leave: ({ name, arguments: args2, repeatable, locations }) => "directive @" + name + (hasMultilineItems(args2) ? wrap(`(
`, indent(join(args2, `
`)), `
)`) : wrap("(", join(args2, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join(locations, " | ")
    },
    SchemaExtension: {
      leave: ({ directives, operationTypes }) => join(["extend schema", join(directives, " "), block(operationTypes)], " ")
    },
    ScalarTypeExtension: {
      leave: ({ name, directives }) => join(["extend scalar", name, join(directives, " ")], " ")
    },
    ObjectTypeExtension: {
      leave: ({ name, interfaces, directives, fields }) => join(["extend type", name, wrap("implements ", join(interfaces, " & ")), join(directives, " "), block(fields)], " ")
    },
    InterfaceTypeExtension: {
      leave: ({ name, interfaces, directives, fields }) => join(["extend interface", name, wrap("implements ", join(interfaces, " & ")), join(directives, " "), block(fields)], " ")
    },
    UnionTypeExtension: {
      leave: ({ name, directives, types }) => join(["extend union", name, join(directives, " "), wrap("= ", join(types, " | "))], " ")
    },
    EnumTypeExtension: {
      leave: ({ name, directives, values }) => join(["extend enum", name, join(directives, " "), block(values)], " ")
    },
    InputObjectTypeExtension: {
      leave: ({ name, directives, fields }) => join(["extend input", name, join(directives, " "), block(fields)], " ")
    }
  };
  var printDocASTReducerWithComments = Object.keys(printDocASTReducer).reduce((prev, key) => ({
    ...prev,
    [key]: {
      leave: addDescription(printDocASTReducer[key].leave)
    }
  }), {});
  function printWithComments(ast) {
    return graphql.visit(ast, printDocASTReducerWithComments);
  }
  function isFieldDefinitionNode(node) {
    return node.kind === "FieldDefinition";
  }
  function getDescription(node, options) {
    if (node.description != null) {
      return node.description.value;
    }
    if (options === null || options === undefined ? undefined : options.commentDescriptions) {
      return getComment(node);
    }
  }
  function getComment(node) {
    const rawValue = getLeadingCommentBlock(node);
    if (rawValue !== undefined) {
      return dedentBlockStringValue(`
${rawValue}`);
    }
  }
  function getLeadingCommentBlock(node) {
    const loc = node.loc;
    if (!loc) {
      return;
    }
    const comments = [];
    let token = loc.startToken.prev;
    while (token != null && token.kind === graphql.TokenKind.COMMENT && token.next != null && token.prev != null && token.line + 1 === token.next.line && token.line !== token.prev.line) {
      const value = String(token.value);
      comments.push(value);
      token = token.prev;
    }
    return comments.length > 0 ? comments.reverse().join(`
`) : undefined;
  }
  function dedentBlockStringValue(rawString) {
    const lines = rawString.split(/\r\n|[\n\r]/g);
    const commonIndent = getBlockStringIndentation(lines);
    if (commonIndent !== 0) {
      for (let i = 1;i < lines.length; i++) {
        lines[i] = lines[i].slice(commonIndent);
      }
    }
    while (lines.length > 0 && isBlank(lines[0])) {
      lines.shift();
    }
    while (lines.length > 0 && isBlank(lines[lines.length - 1])) {
      lines.pop();
    }
    return lines.join(`
`);
  }
  function getBlockStringIndentation(lines) {
    let commonIndent = null;
    for (let i = 1;i < lines.length; i++) {
      const line = lines[i];
      const indent2 = leadingWhitespace(line);
      if (indent2 === line.length) {
        continue;
      }
      if (commonIndent === null || indent2 < commonIndent) {
        commonIndent = indent2;
        if (commonIndent === 0) {
          break;
        }
      }
    }
    return commonIndent === null ? 0 : commonIndent;
  }
  function leadingWhitespace(str) {
    let i = 0;
    while (i < str.length && (str[i] === " " || str[i] === "\t")) {
      i++;
    }
    return i;
  }
  function isBlank(str) {
    return leadingWhitespace(str) === str.length;
  }
  function parseGraphQLSDL(location, rawSDL, options = {}) {
    let document2;
    try {
      if (options.commentDescriptions && rawSDL.includes("#")) {
        document2 = transformCommentsToDescriptions(rawSDL, options);
        if (options.noLocation) {
          document2 = graphql.parse(graphql.print(document2), options);
        }
      } else {
        document2 = graphql.parse(new graphql.Source(rawSDL, location), options);
      }
    } catch (e) {
      if (e.message.includes("EOF") && rawSDL.replace(/(\#[^*]*)/g, "").trim() === "") {
        document2 = {
          kind: graphql.Kind.DOCUMENT,
          definitions: []
        };
      } else {
        throw e;
      }
    }
    return {
      location,
      document: document2
    };
  }
  function transformCommentsToDescriptions(sourceSdl, options = {}) {
    const parsedDoc = graphql.parse(sourceSdl, {
      ...options,
      noLocation: false
    });
    const modifiedDoc = graphql.visit(parsedDoc, {
      leave: (node) => {
        if (isDescribable(node)) {
          const rawValue = getLeadingCommentBlock(node);
          if (rawValue !== undefined) {
            const commentsBlock = dedentBlockStringValue(`
` + rawValue);
            const isBlock = commentsBlock.includes(`
`);
            if (!node.description) {
              return {
                ...node,
                description: {
                  kind: graphql.Kind.STRING,
                  value: commentsBlock,
                  block: isBlock
                }
              };
            } else {
              return {
                ...node,
                description: {
                  ...node.description,
                  value: node.description.value + `
` + commentsBlock,
                  block: true
                }
              };
            }
          }
        }
      }
    });
    return modifiedDoc;
  }
  function isDescribable(node) {
    return graphql.isTypeSystemDefinitionNode(node) || node.kind === graphql.Kind.FIELD_DEFINITION || node.kind === graphql.Kind.INPUT_VALUE_DEFINITION || node.kind === graphql.Kind.ENUM_VALUE_DEFINITION;
  }
  var operationVariables = [];
  var fieldTypeMap = new Map;
  function addOperationVariable(variable) {
    operationVariables.push(variable);
  }
  function resetOperationVariables() {
    operationVariables = [];
  }
  function resetFieldMap() {
    fieldTypeMap = new Map;
  }
  function buildOperationNodeForField({ schema, kind, field, models, ignore = [], depthLimit, circularReferenceDepth, argNames, selectedFields = true }) {
    resetOperationVariables();
    resetFieldMap();
    const rootTypeNames = getRootTypeNames(schema);
    const operationNode = buildOperationAndCollectVariables({
      schema,
      fieldName: field,
      kind,
      models: models || [],
      ignore,
      depthLimit: depthLimit || Infinity,
      circularReferenceDepth: circularReferenceDepth || 1,
      argNames,
      selectedFields,
      rootTypeNames
    });
    operationNode.variableDefinitions = [...operationVariables];
    resetOperationVariables();
    resetFieldMap();
    return operationNode;
  }
  function buildOperationAndCollectVariables({ schema, fieldName, kind, models, ignore, depthLimit, circularReferenceDepth, argNames, selectedFields, rootTypeNames }) {
    const type = getDefinedRootType(schema, kind);
    const field = type.getFields()[fieldName];
    const operationName = `${fieldName}_${kind}`;
    if (field.args) {
      for (const arg of field.args) {
        const argName = arg.name;
        if (!argNames || argNames.includes(argName)) {
          addOperationVariable(resolveVariable(arg, argName));
        }
      }
    }
    return {
      kind: graphql.Kind.OPERATION_DEFINITION,
      operation: kind,
      name: {
        kind: "Name",
        value: operationName
      },
      variableDefinitions: [],
      selectionSet: {
        kind: graphql.Kind.SELECTION_SET,
        selections: [
          resolveField({
            type,
            field,
            models,
            firstCall: true,
            path: [],
            ancestors: [],
            ignore,
            depthLimit,
            circularReferenceDepth,
            schema,
            depth: 0,
            argNames,
            selectedFields,
            rootTypeNames
          })
        ]
      }
    };
  }
  function resolveSelectionSet({ parent, type, models, firstCall, path, ancestors, ignore, depthLimit, circularReferenceDepth, schema, depth, argNames, selectedFields, rootTypeNames }) {
    if (typeof selectedFields === "boolean" && depth > depthLimit) {
      return;
    }
    if (graphql.isUnionType(type)) {
      const types = type.getTypes();
      return {
        kind: graphql.Kind.SELECTION_SET,
        selections: types.filter((t) => !hasCircularRef([...ancestors, t], {
          depth: circularReferenceDepth
        })).map((t) => {
          return {
            kind: graphql.Kind.INLINE_FRAGMENT,
            typeCondition: {
              kind: graphql.Kind.NAMED_TYPE,
              name: {
                kind: graphql.Kind.NAME,
                value: t.name
              }
            },
            selectionSet: resolveSelectionSet({
              parent: type,
              type: t,
              models,
              path,
              ancestors,
              ignore,
              depthLimit,
              circularReferenceDepth,
              schema,
              depth,
              argNames,
              selectedFields,
              rootTypeNames
            })
          };
        }).filter((fragmentNode) => {
          var _a, _b;
          return ((_b = (_a = fragmentNode === null || fragmentNode === undefined ? undefined : fragmentNode.selectionSet) === null || _a === undefined ? undefined : _a.selections) === null || _b === undefined ? undefined : _b.length) > 0;
        })
      };
    }
    if (graphql.isInterfaceType(type)) {
      const types = Object.values(schema.getTypeMap()).filter((t) => graphql.isObjectType(t) && t.getInterfaces().includes(type));
      return {
        kind: graphql.Kind.SELECTION_SET,
        selections: types.filter((t) => !hasCircularRef([...ancestors, t], {
          depth: circularReferenceDepth
        })).map((t) => {
          return {
            kind: graphql.Kind.INLINE_FRAGMENT,
            typeCondition: {
              kind: graphql.Kind.NAMED_TYPE,
              name: {
                kind: graphql.Kind.NAME,
                value: t.name
              }
            },
            selectionSet: resolveSelectionSet({
              parent: type,
              type: t,
              models,
              path,
              ancestors,
              ignore,
              depthLimit,
              circularReferenceDepth,
              schema,
              depth,
              argNames,
              selectedFields,
              rootTypeNames
            })
          };
        }).filter((fragmentNode) => {
          var _a, _b;
          return ((_b = (_a = fragmentNode === null || fragmentNode === undefined ? undefined : fragmentNode.selectionSet) === null || _a === undefined ? undefined : _a.selections) === null || _b === undefined ? undefined : _b.length) > 0;
        })
      };
    }
    if (graphql.isObjectType(type) && !rootTypeNames.has(type.name)) {
      const isIgnored = ignore.includes(type.name) || ignore.includes(`${parent.name}.${path[path.length - 1]}`);
      const isModel = models.includes(type.name);
      if (!firstCall && isModel && !isIgnored) {
        return {
          kind: graphql.Kind.SELECTION_SET,
          selections: [
            {
              kind: graphql.Kind.FIELD,
              name: {
                kind: graphql.Kind.NAME,
                value: "id"
              }
            }
          ]
        };
      }
      const fields = type.getFields();
      return {
        kind: graphql.Kind.SELECTION_SET,
        selections: Object.keys(fields).filter((fieldName) => {
          return !hasCircularRef([...ancestors, graphql.getNamedType(fields[fieldName].type)], {
            depth: circularReferenceDepth
          });
        }).map((fieldName) => {
          const selectedSubFields = typeof selectedFields === "object" ? selectedFields[fieldName] : true;
          if (selectedSubFields) {
            return resolveField({
              type,
              field: fields[fieldName],
              models,
              path: [...path, fieldName],
              ancestors,
              ignore,
              depthLimit,
              circularReferenceDepth,
              schema,
              depth,
              argNames,
              selectedFields: selectedSubFields,
              rootTypeNames
            });
          }
          return null;
        }).filter((f) => {
          var _a, _b;
          if (f == null) {
            return false;
          } else if ("selectionSet" in f) {
            return !!((_b = (_a = f.selectionSet) === null || _a === undefined ? undefined : _a.selections) === null || _b === undefined ? undefined : _b.length);
          }
          return true;
        })
      };
    }
  }
  function resolveVariable(arg, name) {
    function resolveVariableType(type) {
      if (graphql.isListType(type)) {
        return {
          kind: graphql.Kind.LIST_TYPE,
          type: resolveVariableType(type.ofType)
        };
      }
      if (graphql.isNonNullType(type)) {
        return {
          kind: graphql.Kind.NON_NULL_TYPE,
          type: resolveVariableType(type.ofType)
        };
      }
      return {
        kind: graphql.Kind.NAMED_TYPE,
        name: {
          kind: graphql.Kind.NAME,
          value: type.name
        }
      };
    }
    return {
      kind: graphql.Kind.VARIABLE_DEFINITION,
      variable: {
        kind: graphql.Kind.VARIABLE,
        name: {
          kind: graphql.Kind.NAME,
          value: name || arg.name
        }
      },
      type: resolveVariableType(arg.type)
    };
  }
  function getArgumentName(name, path) {
    return [...path, name].join("_");
  }
  function resolveField({ type, field, models, firstCall, path, ancestors, ignore, depthLimit, circularReferenceDepth, schema, depth, argNames, selectedFields, rootTypeNames }) {
    const namedType = graphql.getNamedType(field.type);
    let args2 = [];
    let removeField = false;
    if (field.args && field.args.length) {
      args2 = field.args.map((arg) => {
        const argumentName = getArgumentName(arg.name, path);
        if (argNames && !argNames.includes(argumentName)) {
          if (graphql.isNonNullType(arg.type)) {
            removeField = true;
          }
          return null;
        }
        if (!firstCall) {
          addOperationVariable(resolveVariable(arg, argumentName));
        }
        return {
          kind: graphql.Kind.ARGUMENT,
          name: {
            kind: graphql.Kind.NAME,
            value: arg.name
          },
          value: {
            kind: graphql.Kind.VARIABLE,
            name: {
              kind: graphql.Kind.NAME,
              value: getArgumentName(arg.name, path)
            }
          }
        };
      }).filter(Boolean);
    }
    if (removeField) {
      return null;
    }
    const fieldPath = [...path, field.name];
    const fieldPathStr = fieldPath.join(".");
    let fieldName = field.name;
    if (fieldTypeMap.has(fieldPathStr) && fieldTypeMap.get(fieldPathStr) !== field.type.toString()) {
      fieldName += field.type.toString().replace("!", "NonNull");
    }
    fieldTypeMap.set(fieldPathStr, field.type.toString());
    if (!graphql.isScalarType(namedType) && !graphql.isEnumType(namedType)) {
      return {
        kind: graphql.Kind.FIELD,
        name: {
          kind: graphql.Kind.NAME,
          value: field.name
        },
        ...fieldName !== field.name && { alias: { kind: graphql.Kind.NAME, value: fieldName } },
        selectionSet: resolveSelectionSet({
          parent: type,
          type: namedType,
          models,
          firstCall,
          path: fieldPath,
          ancestors: [...ancestors, type],
          ignore,
          depthLimit,
          circularReferenceDepth,
          schema,
          depth: depth + 1,
          argNames,
          selectedFields,
          rootTypeNames
        }) || undefined,
        arguments: args2
      };
    }
    return {
      kind: graphql.Kind.FIELD,
      name: {
        kind: graphql.Kind.NAME,
        value: field.name
      },
      ...fieldName !== field.name && { alias: { kind: graphql.Kind.NAME, value: fieldName } },
      arguments: args2
    };
  }
  function hasCircularRef(types, config = {
    depth: 1
  }) {
    const type = types[types.length - 1];
    if (graphql.isScalarType(type)) {
      return false;
    }
    const size = types.filter((t) => t.name === type.name).length;
    return size > config.depth;
  }
  (function(MapperKind) {
    MapperKind["TYPE"] = "MapperKind.TYPE";
    MapperKind["SCALAR_TYPE"] = "MapperKind.SCALAR_TYPE";
    MapperKind["ENUM_TYPE"] = "MapperKind.ENUM_TYPE";
    MapperKind["COMPOSITE_TYPE"] = "MapperKind.COMPOSITE_TYPE";
    MapperKind["OBJECT_TYPE"] = "MapperKind.OBJECT_TYPE";
    MapperKind["INPUT_OBJECT_TYPE"] = "MapperKind.INPUT_OBJECT_TYPE";
    MapperKind["ABSTRACT_TYPE"] = "MapperKind.ABSTRACT_TYPE";
    MapperKind["UNION_TYPE"] = "MapperKind.UNION_TYPE";
    MapperKind["INTERFACE_TYPE"] = "MapperKind.INTERFACE_TYPE";
    MapperKind["ROOT_OBJECT"] = "MapperKind.ROOT_OBJECT";
    MapperKind["QUERY"] = "MapperKind.QUERY";
    MapperKind["MUTATION"] = "MapperKind.MUTATION";
    MapperKind["SUBSCRIPTION"] = "MapperKind.SUBSCRIPTION";
    MapperKind["DIRECTIVE"] = "MapperKind.DIRECTIVE";
    MapperKind["FIELD"] = "MapperKind.FIELD";
    MapperKind["COMPOSITE_FIELD"] = "MapperKind.COMPOSITE_FIELD";
    MapperKind["OBJECT_FIELD"] = "MapperKind.OBJECT_FIELD";
    MapperKind["ROOT_FIELD"] = "MapperKind.ROOT_FIELD";
    MapperKind["QUERY_ROOT_FIELD"] = "MapperKind.QUERY_ROOT_FIELD";
    MapperKind["MUTATION_ROOT_FIELD"] = "MapperKind.MUTATION_ROOT_FIELD";
    MapperKind["SUBSCRIPTION_ROOT_FIELD"] = "MapperKind.SUBSCRIPTION_ROOT_FIELD";
    MapperKind["INTERFACE_FIELD"] = "MapperKind.INTERFACE_FIELD";
    MapperKind["INPUT_OBJECT_FIELD"] = "MapperKind.INPUT_OBJECT_FIELD";
    MapperKind["ARGUMENT"] = "MapperKind.ARGUMENT";
    MapperKind["ENUM_VALUE"] = "MapperKind.ENUM_VALUE";
  })(exports.MapperKind || (exports.MapperKind = {}));
  function getObjectTypeFromTypeMap(typeMap, type) {
    if (type) {
      const maybeObjectType = typeMap[type.name];
      if (graphql.isObjectType(maybeObjectType)) {
        return maybeObjectType;
      }
    }
  }
  function createNamedStub(name, type) {
    let constructor;
    if (type === "object") {
      constructor = graphql.GraphQLObjectType;
    } else if (type === "interface") {
      constructor = graphql.GraphQLInterfaceType;
    } else {
      constructor = graphql.GraphQLInputObjectType;
    }
    return new constructor({
      name,
      fields: {
        _fake: {
          type: graphql.GraphQLString
        }
      }
    });
  }
  function createStub(node, type) {
    switch (node.kind) {
      case graphql.Kind.LIST_TYPE:
        return new graphql.GraphQLList(createStub(node.type, type));
      case graphql.Kind.NON_NULL_TYPE:
        return new graphql.GraphQLNonNull(createStub(node.type, type));
      default:
        if (type === "output") {
          return createNamedStub(node.name.value, "object");
        }
        return createNamedStub(node.name.value, "input");
    }
  }
  function isNamedStub(type) {
    if ("getFields" in type) {
      const fields = type.getFields();
      for (const fieldName in fields) {
        const field = fields[fieldName];
        return field.name === "_fake";
      }
    }
    return false;
  }
  function getBuiltInForStub(type) {
    switch (type.name) {
      case graphql.GraphQLInt.name:
        return graphql.GraphQLInt;
      case graphql.GraphQLFloat.name:
        return graphql.GraphQLFloat;
      case graphql.GraphQLString.name:
        return graphql.GraphQLString;
      case graphql.GraphQLBoolean.name:
        return graphql.GraphQLBoolean;
      case graphql.GraphQLID.name:
        return graphql.GraphQLID;
      default:
        return type;
    }
  }
  function rewireTypes(originalTypeMap, directives) {
    const referenceTypeMap = Object.create(null);
    for (const typeName in originalTypeMap) {
      referenceTypeMap[typeName] = originalTypeMap[typeName];
    }
    const newTypeMap = Object.create(null);
    for (const typeName in referenceTypeMap) {
      const namedType = referenceTypeMap[typeName];
      if (namedType == null || typeName.startsWith("__")) {
        continue;
      }
      const newName = namedType.name;
      if (newName.startsWith("__")) {
        continue;
      }
      if (newTypeMap[newName] != null) {
        throw new Error(`Duplicate schema type name ${newName}`);
      }
      newTypeMap[newName] = namedType;
    }
    for (const typeName in newTypeMap) {
      newTypeMap[typeName] = rewireNamedType(newTypeMap[typeName]);
    }
    const newDirectives = directives.map((directive) => rewireDirective(directive));
    return {
      typeMap: newTypeMap,
      directives: newDirectives
    };
    function rewireDirective(directive) {
      if (graphql.isSpecifiedDirective(directive)) {
        return directive;
      }
      const directiveConfig = directive.toConfig();
      directiveConfig.args = rewireArgs(directiveConfig.args);
      return new graphql.GraphQLDirective(directiveConfig);
    }
    function rewireArgs(args2) {
      const rewiredArgs = {};
      for (const argName in args2) {
        const arg = args2[argName];
        const rewiredArgType = rewireType(arg.type);
        if (rewiredArgType != null) {
          arg.type = rewiredArgType;
          rewiredArgs[argName] = arg;
        }
      }
      return rewiredArgs;
    }
    function rewireNamedType(type) {
      if (graphql.isObjectType(type)) {
        const config = type.toConfig();
        const newConfig = {
          ...config,
          fields: () => rewireFields(config.fields),
          interfaces: () => rewireNamedTypes(config.interfaces)
        };
        return new graphql.GraphQLObjectType(newConfig);
      } else if (graphql.isInterfaceType(type)) {
        const config = type.toConfig();
        const newConfig = {
          ...config,
          fields: () => rewireFields(config.fields)
        };
        if ("interfaces" in newConfig) {
          newConfig.interfaces = () => rewireNamedTypes(config.interfaces);
        }
        return new graphql.GraphQLInterfaceType(newConfig);
      } else if (graphql.isUnionType(type)) {
        const config = type.toConfig();
        const newConfig = {
          ...config,
          types: () => rewireNamedTypes(config.types)
        };
        return new graphql.GraphQLUnionType(newConfig);
      } else if (graphql.isInputObjectType(type)) {
        const config = type.toConfig();
        const newConfig = {
          ...config,
          fields: () => rewireInputFields(config.fields)
        };
        return new graphql.GraphQLInputObjectType(newConfig);
      } else if (graphql.isEnumType(type)) {
        const enumConfig = type.toConfig();
        return new graphql.GraphQLEnumType(enumConfig);
      } else if (graphql.isScalarType(type)) {
        if (graphql.isSpecifiedScalarType(type)) {
          return type;
        }
        const scalarConfig = type.toConfig();
        return new graphql.GraphQLScalarType(scalarConfig);
      }
      throw new Error(`Unexpected schema type: ${type}`);
    }
    function rewireFields(fields) {
      const rewiredFields = {};
      for (const fieldName in fields) {
        const field = fields[fieldName];
        const rewiredFieldType = rewireType(field.type);
        if (rewiredFieldType != null && field.args) {
          field.type = rewiredFieldType;
          field.args = rewireArgs(field.args);
          rewiredFields[fieldName] = field;
        }
      }
      return rewiredFields;
    }
    function rewireInputFields(fields) {
      const rewiredFields = {};
      for (const fieldName in fields) {
        const field = fields[fieldName];
        const rewiredFieldType = rewireType(field.type);
        if (rewiredFieldType != null) {
          field.type = rewiredFieldType;
          rewiredFields[fieldName] = field;
        }
      }
      return rewiredFields;
    }
    function rewireNamedTypes(namedTypes) {
      const rewiredTypes = [];
      for (const namedType of namedTypes) {
        const rewiredType = rewireType(namedType);
        if (rewiredType != null) {
          rewiredTypes.push(rewiredType);
        }
      }
      return rewiredTypes;
    }
    function rewireType(type) {
      if (graphql.isListType(type)) {
        const rewiredType = rewireType(type.ofType);
        return rewiredType != null ? new graphql.GraphQLList(rewiredType) : null;
      } else if (graphql.isNonNullType(type)) {
        const rewiredType = rewireType(type.ofType);
        return rewiredType != null ? new graphql.GraphQLNonNull(rewiredType) : null;
      } else if (graphql.isNamedType(type)) {
        let rewiredType = referenceTypeMap[type.name];
        if (rewiredType === undefined) {
          rewiredType = isNamedStub(type) ? getBuiltInForStub(type) : rewireNamedType(type);
          newTypeMap[rewiredType.name] = referenceTypeMap[type.name] = rewiredType;
        }
        return rewiredType != null ? newTypeMap[rewiredType.name] : null;
      }
      return null;
    }
  }
  function transformInputValue(type, value, inputLeafValueTransformer = null, inputObjectValueTransformer = null) {
    if (value == null) {
      return value;
    }
    const nullableType = graphql.getNullableType(type);
    if (graphql.isLeafType(nullableType)) {
      return inputLeafValueTransformer != null ? inputLeafValueTransformer(nullableType, value) : value;
    } else if (graphql.isListType(nullableType)) {
      return value.map((listMember) => transformInputValue(nullableType.ofType, listMember, inputLeafValueTransformer, inputObjectValueTransformer));
    } else if (graphql.isInputObjectType(nullableType)) {
      const fields = nullableType.getFields();
      const newValue = {};
      for (const key in value) {
        const field = fields[key];
        if (field != null) {
          newValue[key] = transformInputValue(field.type, value[key], inputLeafValueTransformer, inputObjectValueTransformer);
        }
      }
      return inputObjectValueTransformer != null ? inputObjectValueTransformer(nullableType, newValue) : newValue;
    }
  }
  function serializeInputValue(type, value) {
    return transformInputValue(type, value, (t, v) => t.serialize(v));
  }
  function parseInputValue(type, value) {
    return transformInputValue(type, value, (t, v) => t.parseValue(v));
  }
  function parseInputValueLiteral(type, value) {
    return transformInputValue(type, value, (t, v) => t.parseLiteral(v, {}));
  }
  function mapSchema(schema, schemaMapper = {}) {
    const newTypeMap = mapArguments(mapFields(mapTypes(mapDefaultValues(mapEnumValues(mapTypes(mapDefaultValues(schema.getTypeMap(), schema, serializeInputValue), schema, schemaMapper, (type) => graphql.isLeafType(type)), schema, schemaMapper), schema, parseInputValue), schema, schemaMapper, (type) => !graphql.isLeafType(type)), schema, schemaMapper), schema, schemaMapper);
    const originalDirectives = schema.getDirectives();
    const newDirectives = mapDirectives(originalDirectives, schema, schemaMapper);
    const { typeMap, directives } = rewireTypes(newTypeMap, newDirectives);
    return new graphql.GraphQLSchema({
      ...schema.toConfig(),
      query: getObjectTypeFromTypeMap(typeMap, getObjectTypeFromTypeMap(newTypeMap, schema.getQueryType())),
      mutation: getObjectTypeFromTypeMap(typeMap, getObjectTypeFromTypeMap(newTypeMap, schema.getMutationType())),
      subscription: getObjectTypeFromTypeMap(typeMap, getObjectTypeFromTypeMap(newTypeMap, schema.getSubscriptionType())),
      types: Object.values(typeMap),
      directives
    });
  }
  function mapTypes(originalTypeMap, schema, schemaMapper, testFn = () => true) {
    const newTypeMap = {};
    for (const typeName in originalTypeMap) {
      if (!typeName.startsWith("__")) {
        const originalType = originalTypeMap[typeName];
        if (originalType == null || !testFn(originalType)) {
          newTypeMap[typeName] = originalType;
          continue;
        }
        const typeMapper = getTypeMapper(schema, schemaMapper, typeName);
        if (typeMapper == null) {
          newTypeMap[typeName] = originalType;
          continue;
        }
        const maybeNewType = typeMapper(originalType, schema);
        if (maybeNewType === undefined) {
          newTypeMap[typeName] = originalType;
          continue;
        }
        newTypeMap[typeName] = maybeNewType;
      }
    }
    return newTypeMap;
  }
  function mapEnumValues(originalTypeMap, schema, schemaMapper) {
    const enumValueMapper = getEnumValueMapper(schemaMapper);
    if (!enumValueMapper) {
      return originalTypeMap;
    }
    return mapTypes(originalTypeMap, schema, {
      [exports.MapperKind.ENUM_TYPE]: (type) => {
        const config = type.toConfig();
        const originalEnumValueConfigMap = config.values;
        const newEnumValueConfigMap = {};
        for (const externalValue in originalEnumValueConfigMap) {
          const originalEnumValueConfig = originalEnumValueConfigMap[externalValue];
          const mappedEnumValue = enumValueMapper(originalEnumValueConfig, type.name, schema, externalValue);
          if (mappedEnumValue === undefined) {
            newEnumValueConfigMap[externalValue] = originalEnumValueConfig;
          } else if (Array.isArray(mappedEnumValue)) {
            const [newExternalValue, newEnumValueConfig] = mappedEnumValue;
            newEnumValueConfigMap[newExternalValue] = newEnumValueConfig === undefined ? originalEnumValueConfig : newEnumValueConfig;
          } else if (mappedEnumValue !== null) {
            newEnumValueConfigMap[externalValue] = mappedEnumValue;
          }
        }
        return correctASTNodes(new graphql.GraphQLEnumType({
          ...config,
          values: newEnumValueConfigMap
        }));
      }
    }, (type) => graphql.isEnumType(type));
  }
  function mapDefaultValues(originalTypeMap, schema, fn2) {
    const newTypeMap = mapArguments(originalTypeMap, schema, {
      [exports.MapperKind.ARGUMENT]: (argumentConfig) => {
        if (argumentConfig.defaultValue === undefined) {
          return argumentConfig;
        }
        const maybeNewType = getNewType(originalTypeMap, argumentConfig.type);
        if (maybeNewType != null) {
          return {
            ...argumentConfig,
            defaultValue: fn2(maybeNewType, argumentConfig.defaultValue)
          };
        }
      }
    });
    return mapFields(newTypeMap, schema, {
      [exports.MapperKind.INPUT_OBJECT_FIELD]: (inputFieldConfig) => {
        if (inputFieldConfig.defaultValue === undefined) {
          return inputFieldConfig;
        }
        const maybeNewType = getNewType(newTypeMap, inputFieldConfig.type);
        if (maybeNewType != null) {
          return {
            ...inputFieldConfig,
            defaultValue: fn2(maybeNewType, inputFieldConfig.defaultValue)
          };
        }
      }
    });
  }
  function getNewType(newTypeMap, type) {
    if (graphql.isListType(type)) {
      const newType = getNewType(newTypeMap, type.ofType);
      return newType != null ? new graphql.GraphQLList(newType) : null;
    } else if (graphql.isNonNullType(type)) {
      const newType = getNewType(newTypeMap, type.ofType);
      return newType != null ? new graphql.GraphQLNonNull(newType) : null;
    } else if (graphql.isNamedType(type)) {
      const newType = newTypeMap[type.name];
      return newType != null ? newType : null;
    }
    return null;
  }
  function mapFields(originalTypeMap, schema, schemaMapper) {
    const newTypeMap = {};
    for (const typeName in originalTypeMap) {
      if (!typeName.startsWith("__")) {
        const originalType = originalTypeMap[typeName];
        if (!graphql.isObjectType(originalType) && !graphql.isInterfaceType(originalType) && !graphql.isInputObjectType(originalType)) {
          newTypeMap[typeName] = originalType;
          continue;
        }
        const fieldMapper = getFieldMapper(schema, schemaMapper, typeName);
        if (fieldMapper == null) {
          newTypeMap[typeName] = originalType;
          continue;
        }
        const config = originalType.toConfig();
        const originalFieldConfigMap = config.fields;
        const newFieldConfigMap = {};
        for (const fieldName in originalFieldConfigMap) {
          const originalFieldConfig = originalFieldConfigMap[fieldName];
          const mappedField = fieldMapper(originalFieldConfig, fieldName, typeName, schema);
          if (mappedField === undefined) {
            newFieldConfigMap[fieldName] = originalFieldConfig;
          } else if (Array.isArray(mappedField)) {
            const [newFieldName, newFieldConfig] = mappedField;
            if (newFieldConfig.astNode != null) {
              newFieldConfig.astNode = {
                ...newFieldConfig.astNode,
                name: {
                  ...newFieldConfig.astNode.name,
                  value: newFieldName
                }
              };
            }
            newFieldConfigMap[newFieldName] = newFieldConfig === undefined ? originalFieldConfig : newFieldConfig;
          } else if (mappedField !== null) {
            newFieldConfigMap[fieldName] = mappedField;
          }
        }
        if (graphql.isObjectType(originalType)) {
          newTypeMap[typeName] = correctASTNodes(new graphql.GraphQLObjectType({
            ...config,
            fields: newFieldConfigMap
          }));
        } else if (graphql.isInterfaceType(originalType)) {
          newTypeMap[typeName] = correctASTNodes(new graphql.GraphQLInterfaceType({
            ...config,
            fields: newFieldConfigMap
          }));
        } else {
          newTypeMap[typeName] = correctASTNodes(new graphql.GraphQLInputObjectType({
            ...config,
            fields: newFieldConfigMap
          }));
        }
      }
    }
    return newTypeMap;
  }
  function mapArguments(originalTypeMap, schema, schemaMapper) {
    const newTypeMap = {};
    for (const typeName in originalTypeMap) {
      if (!typeName.startsWith("__")) {
        const originalType = originalTypeMap[typeName];
        if (!graphql.isObjectType(originalType) && !graphql.isInterfaceType(originalType)) {
          newTypeMap[typeName] = originalType;
          continue;
        }
        const argumentMapper = getArgumentMapper(schemaMapper);
        if (argumentMapper == null) {
          newTypeMap[typeName] = originalType;
          continue;
        }
        const config = originalType.toConfig();
        const originalFieldConfigMap = config.fields;
        const newFieldConfigMap = {};
        for (const fieldName in originalFieldConfigMap) {
          const originalFieldConfig = originalFieldConfigMap[fieldName];
          const originalArgumentConfigMap = originalFieldConfig.args;
          if (originalArgumentConfigMap == null) {
            newFieldConfigMap[fieldName] = originalFieldConfig;
            continue;
          }
          const argumentNames = Object.keys(originalArgumentConfigMap);
          if (!argumentNames.length) {
            newFieldConfigMap[fieldName] = originalFieldConfig;
            continue;
          }
          const newArgumentConfigMap = {};
          for (const argumentName of argumentNames) {
            const originalArgumentConfig = originalArgumentConfigMap[argumentName];
            const mappedArgument = argumentMapper(originalArgumentConfig, fieldName, typeName, schema);
            if (mappedArgument === undefined) {
              newArgumentConfigMap[argumentName] = originalArgumentConfig;
            } else if (Array.isArray(mappedArgument)) {
              const [newArgumentName, newArgumentConfig] = mappedArgument;
              newArgumentConfigMap[newArgumentName] = newArgumentConfig;
            } else if (mappedArgument !== null) {
              newArgumentConfigMap[argumentName] = mappedArgument;
            }
          }
          newFieldConfigMap[fieldName] = {
            ...originalFieldConfig,
            args: newArgumentConfigMap
          };
        }
        if (graphql.isObjectType(originalType)) {
          newTypeMap[typeName] = new graphql.GraphQLObjectType({
            ...config,
            fields: newFieldConfigMap
          });
        } else if (graphql.isInterfaceType(originalType)) {
          newTypeMap[typeName] = new graphql.GraphQLInterfaceType({
            ...config,
            fields: newFieldConfigMap
          });
        } else {
          newTypeMap[typeName] = new graphql.GraphQLInputObjectType({
            ...config,
            fields: newFieldConfigMap
          });
        }
      }
    }
    return newTypeMap;
  }
  function mapDirectives(originalDirectives, schema, schemaMapper) {
    const directiveMapper = getDirectiveMapper(schemaMapper);
    if (directiveMapper == null) {
      return originalDirectives.slice();
    }
    const newDirectives = [];
    for (const directive of originalDirectives) {
      const mappedDirective = directiveMapper(directive, schema);
      if (mappedDirective === undefined) {
        newDirectives.push(directive);
      } else if (mappedDirective !== null) {
        newDirectives.push(mappedDirective);
      }
    }
    return newDirectives;
  }
  function getTypeSpecifiers(schema, typeName) {
    var _a, _b, _c;
    const type = schema.getType(typeName);
    const specifiers = [exports.MapperKind.TYPE];
    if (graphql.isObjectType(type)) {
      specifiers.push(exports.MapperKind.COMPOSITE_TYPE, exports.MapperKind.OBJECT_TYPE);
      if (typeName === ((_a = schema.getQueryType()) === null || _a === undefined ? undefined : _a.name)) {
        specifiers.push(exports.MapperKind.ROOT_OBJECT, exports.MapperKind.QUERY);
      } else if (typeName === ((_b = schema.getMutationType()) === null || _b === undefined ? undefined : _b.name)) {
        specifiers.push(exports.MapperKind.ROOT_OBJECT, exports.MapperKind.MUTATION);
      } else if (typeName === ((_c = schema.getSubscriptionType()) === null || _c === undefined ? undefined : _c.name)) {
        specifiers.push(exports.MapperKind.ROOT_OBJECT, exports.MapperKind.SUBSCRIPTION);
      }
    } else if (graphql.isInputObjectType(type)) {
      specifiers.push(exports.MapperKind.INPUT_OBJECT_TYPE);
    } else if (graphql.isInterfaceType(type)) {
      specifiers.push(exports.MapperKind.COMPOSITE_TYPE, exports.MapperKind.ABSTRACT_TYPE, exports.MapperKind.INTERFACE_TYPE);
    } else if (graphql.isUnionType(type)) {
      specifiers.push(exports.MapperKind.COMPOSITE_TYPE, exports.MapperKind.ABSTRACT_TYPE, exports.MapperKind.UNION_TYPE);
    } else if (graphql.isEnumType(type)) {
      specifiers.push(exports.MapperKind.ENUM_TYPE);
    } else if (graphql.isScalarType(type)) {
      specifiers.push(exports.MapperKind.SCALAR_TYPE);
    }
    return specifiers;
  }
  function getTypeMapper(schema, schemaMapper, typeName) {
    const specifiers = getTypeSpecifiers(schema, typeName);
    let typeMapper;
    const stack2 = [...specifiers];
    while (!typeMapper && stack2.length > 0) {
      const next = stack2.pop();
      typeMapper = schemaMapper[next];
    }
    return typeMapper != null ? typeMapper : null;
  }
  function getFieldSpecifiers(schema, typeName) {
    var _a, _b, _c;
    const type = schema.getType(typeName);
    const specifiers = [exports.MapperKind.FIELD];
    if (graphql.isObjectType(type)) {
      specifiers.push(exports.MapperKind.COMPOSITE_FIELD, exports.MapperKind.OBJECT_FIELD);
      if (typeName === ((_a = schema.getQueryType()) === null || _a === undefined ? undefined : _a.name)) {
        specifiers.push(exports.MapperKind.ROOT_FIELD, exports.MapperKind.QUERY_ROOT_FIELD);
      } else if (typeName === ((_b = schema.getMutationType()) === null || _b === undefined ? undefined : _b.name)) {
        specifiers.push(exports.MapperKind.ROOT_FIELD, exports.MapperKind.MUTATION_ROOT_FIELD);
      } else if (typeName === ((_c = schema.getSubscriptionType()) === null || _c === undefined ? undefined : _c.name)) {
        specifiers.push(exports.MapperKind.ROOT_FIELD, exports.MapperKind.SUBSCRIPTION_ROOT_FIELD);
      }
    } else if (graphql.isInterfaceType(type)) {
      specifiers.push(exports.MapperKind.COMPOSITE_FIELD, exports.MapperKind.INTERFACE_FIELD);
    } else if (graphql.isInputObjectType(type)) {
      specifiers.push(exports.MapperKind.INPUT_OBJECT_FIELD);
    }
    return specifiers;
  }
  function getFieldMapper(schema, schemaMapper, typeName) {
    const specifiers = getFieldSpecifiers(schema, typeName);
    let fieldMapper;
    const stack2 = [...specifiers];
    while (!fieldMapper && stack2.length > 0) {
      const next = stack2.pop();
      fieldMapper = schemaMapper[next];
    }
    return fieldMapper !== null && fieldMapper !== undefined ? fieldMapper : null;
  }
  function getArgumentMapper(schemaMapper) {
    const argumentMapper = schemaMapper[exports.MapperKind.ARGUMENT];
    return argumentMapper != null ? argumentMapper : null;
  }
  function getDirectiveMapper(schemaMapper) {
    const directiveMapper = schemaMapper[exports.MapperKind.DIRECTIVE];
    return directiveMapper != null ? directiveMapper : null;
  }
  function getEnumValueMapper(schemaMapper) {
    const enumValueMapper = schemaMapper[exports.MapperKind.ENUM_VALUE];
    return enumValueMapper != null ? enumValueMapper : null;
  }
  function correctASTNodes(type) {
    if (graphql.isObjectType(type)) {
      const config = type.toConfig();
      if (config.astNode != null) {
        const fields = [];
        for (const fieldName in config.fields) {
          const fieldConfig = config.fields[fieldName];
          if (fieldConfig.astNode != null) {
            fields.push(fieldConfig.astNode);
          }
        }
        config.astNode = {
          ...config.astNode,
          kind: graphql.Kind.OBJECT_TYPE_DEFINITION,
          fields
        };
      }
      if (config.extensionASTNodes != null) {
        config.extensionASTNodes = config.extensionASTNodes.map((node) => ({
          ...node,
          kind: graphql.Kind.OBJECT_TYPE_EXTENSION,
          fields: undefined
        }));
      }
      return new graphql.GraphQLObjectType(config);
    } else if (graphql.isInterfaceType(type)) {
      const config = type.toConfig();
      if (config.astNode != null) {
        const fields = [];
        for (const fieldName in config.fields) {
          const fieldConfig = config.fields[fieldName];
          if (fieldConfig.astNode != null) {
            fields.push(fieldConfig.astNode);
          }
        }
        config.astNode = {
          ...config.astNode,
          kind: graphql.Kind.INTERFACE_TYPE_DEFINITION,
          fields
        };
      }
      if (config.extensionASTNodes != null) {
        config.extensionASTNodes = config.extensionASTNodes.map((node) => ({
          ...node,
          kind: graphql.Kind.INTERFACE_TYPE_EXTENSION,
          fields: undefined
        }));
      }
      return new graphql.GraphQLInterfaceType(config);
    } else if (graphql.isInputObjectType(type)) {
      const config = type.toConfig();
      if (config.astNode != null) {
        const fields = [];
        for (const fieldName in config.fields) {
          const fieldConfig = config.fields[fieldName];
          if (fieldConfig.astNode != null) {
            fields.push(fieldConfig.astNode);
          }
        }
        config.astNode = {
          ...config.astNode,
          kind: graphql.Kind.INPUT_OBJECT_TYPE_DEFINITION,
          fields
        };
      }
      if (config.extensionASTNodes != null) {
        config.extensionASTNodes = config.extensionASTNodes.map((node) => ({
          ...node,
          kind: graphql.Kind.INPUT_OBJECT_TYPE_EXTENSION,
          fields: undefined
        }));
      }
      return new graphql.GraphQLInputObjectType(config);
    } else if (graphql.isEnumType(type)) {
      const config = type.toConfig();
      if (config.astNode != null) {
        const values = [];
        for (const enumKey in config.values) {
          const enumValueConfig = config.values[enumKey];
          if (enumValueConfig.astNode != null) {
            values.push(enumValueConfig.astNode);
          }
        }
        config.astNode = {
          ...config.astNode,
          values
        };
      }
      if (config.extensionASTNodes != null) {
        config.extensionASTNodes = config.extensionASTNodes.map((node) => ({
          ...node,
          values: undefined
        }));
      }
      return new graphql.GraphQLEnumType(config);
    } else {
      return type;
    }
  }
  function filterSchema({ schema, typeFilter = () => true, fieldFilter = undefined, rootFieldFilter = undefined, objectFieldFilter = undefined, interfaceFieldFilter = undefined, inputObjectFieldFilter = undefined, argumentFilter = undefined }) {
    const filteredSchema = mapSchema(schema, {
      [exports.MapperKind.QUERY]: (type) => filterRootFields(type, "Query", rootFieldFilter, argumentFilter),
      [exports.MapperKind.MUTATION]: (type) => filterRootFields(type, "Mutation", rootFieldFilter, argumentFilter),
      [exports.MapperKind.SUBSCRIPTION]: (type) => filterRootFields(type, "Subscription", rootFieldFilter, argumentFilter),
      [exports.MapperKind.OBJECT_TYPE]: (type) => typeFilter(type.name, type) ? filterElementFields(graphql.GraphQLObjectType, type, objectFieldFilter || fieldFilter, argumentFilter) : null,
      [exports.MapperKind.INTERFACE_TYPE]: (type) => typeFilter(type.name, type) ? filterElementFields(graphql.GraphQLInterfaceType, type, interfaceFieldFilter || fieldFilter, argumentFilter) : null,
      [exports.MapperKind.INPUT_OBJECT_TYPE]: (type) => typeFilter(type.name, type) ? filterElementFields(graphql.GraphQLInputObjectType, type, inputObjectFieldFilter || fieldFilter) : null,
      [exports.MapperKind.UNION_TYPE]: (type) => typeFilter(type.name, type) ? undefined : null,
      [exports.MapperKind.ENUM_TYPE]: (type) => typeFilter(type.name, type) ? undefined : null,
      [exports.MapperKind.SCALAR_TYPE]: (type) => typeFilter(type.name, type) ? undefined : null
    });
    return filteredSchema;
  }
  function filterRootFields(type, operation, rootFieldFilter, argumentFilter) {
    if (rootFieldFilter || argumentFilter) {
      const config = type.toConfig();
      for (const fieldName in config.fields) {
        const field = config.fields[fieldName];
        if (rootFieldFilter && !rootFieldFilter(operation, fieldName, config.fields[fieldName])) {
          delete config.fields[fieldName];
        } else if (argumentFilter && field.args) {
          for (const argName in field.args) {
            if (!argumentFilter(operation, fieldName, argName, field.args[argName])) {
              delete field.args[argName];
            }
          }
        }
      }
      return new graphql.GraphQLObjectType(config);
    }
    return type;
  }
  function filterElementFields(ElementConstructor, type, fieldFilter, argumentFilter) {
    if (fieldFilter || argumentFilter) {
      const config = type.toConfig();
      for (const fieldName in config.fields) {
        const field = config.fields[fieldName];
        if (fieldFilter && !fieldFilter(type.name, fieldName, config.fields[fieldName])) {
          delete config.fields[fieldName];
        } else if (argumentFilter && "args" in field) {
          for (const argName in field.args) {
            if (!argumentFilter(type.name, fieldName, argName, field.args[argName])) {
              delete field.args[argName];
            }
          }
        }
      }
      return new ElementConstructor(config);
    }
  }
  function healSchema(schema) {
    healTypes(schema.getTypeMap(), schema.getDirectives());
    return schema;
  }
  function healTypes(originalTypeMap, directives) {
    const actualNamedTypeMap = Object.create(null);
    for (const typeName in originalTypeMap) {
      const namedType = originalTypeMap[typeName];
      if (namedType == null || typeName.startsWith("__")) {
        continue;
      }
      const actualName = namedType.name;
      if (actualName.startsWith("__")) {
        continue;
      }
      if (actualName in actualNamedTypeMap) {
        throw new Error(`Duplicate schema type name ${actualName}`);
      }
      actualNamedTypeMap[actualName] = namedType;
    }
    for (const typeName in actualNamedTypeMap) {
      const namedType = actualNamedTypeMap[typeName];
      originalTypeMap[typeName] = namedType;
    }
    for (const decl of directives) {
      decl.args = decl.args.filter((arg) => {
        arg.type = healType(arg.type);
        return arg.type !== null;
      });
    }
    for (const typeName in originalTypeMap) {
      const namedType = originalTypeMap[typeName];
      if (!typeName.startsWith("__") && typeName in actualNamedTypeMap) {
        if (namedType != null) {
          healNamedType(namedType);
        }
      }
    }
    for (const typeName in originalTypeMap) {
      if (!typeName.startsWith("__") && !(typeName in actualNamedTypeMap)) {
        delete originalTypeMap[typeName];
      }
    }
    function healNamedType(type) {
      if (graphql.isObjectType(type)) {
        healFields(type);
        healInterfaces(type);
        return;
      } else if (graphql.isInterfaceType(type)) {
        healFields(type);
        if ("getInterfaces" in type) {
          healInterfaces(type);
        }
        return;
      } else if (graphql.isUnionType(type)) {
        healUnderlyingTypes(type);
        return;
      } else if (graphql.isInputObjectType(type)) {
        healInputFields(type);
        return;
      } else if (graphql.isLeafType(type)) {
        return;
      }
      throw new Error(`Unexpected schema type: ${type}`);
    }
    function healFields(type) {
      const fieldMap = type.getFields();
      for (const [key, field] of Object.entries(fieldMap)) {
        field.args.map((arg) => {
          arg.type = healType(arg.type);
          return arg.type === null ? null : arg;
        }).filter(Boolean);
        field.type = healType(field.type);
        if (field.type === null) {
          delete fieldMap[key];
        }
      }
    }
    function healInterfaces(type) {
      if ("getInterfaces" in type) {
        const interfaces = type.getInterfaces();
        interfaces.push(...interfaces.splice(0).map((iface) => healType(iface)).filter(Boolean));
      }
    }
    function healInputFields(type) {
      const fieldMap = type.getFields();
      for (const [key, field] of Object.entries(fieldMap)) {
        field.type = healType(field.type);
        if (field.type === null) {
          delete fieldMap[key];
        }
      }
    }
    function healUnderlyingTypes(type) {
      const types = type.getTypes();
      types.push(...types.splice(0).map((t) => healType(t)).filter(Boolean));
    }
    function healType(type) {
      if (graphql.isListType(type)) {
        const healedType = healType(type.ofType);
        return healedType != null ? new graphql.GraphQLList(healedType) : null;
      } else if (graphql.isNonNullType(type)) {
        const healedType = healType(type.ofType);
        return healedType != null ? new graphql.GraphQLNonNull(healedType) : null;
      } else if (graphql.isNamedType(type)) {
        const officialType = originalTypeMap[type.name];
        if (officialType && type !== officialType) {
          return officialType;
        }
      }
      return type;
    }
  }
  function getResolversFromSchema(schema) {
    var _a, _b;
    const resolvers = Object.create(null);
    const typeMap = schema.getTypeMap();
    for (const typeName in typeMap) {
      if (!typeName.startsWith("__")) {
        const type = typeMap[typeName];
        if (graphql.isScalarType(type)) {
          if (!graphql.isSpecifiedScalarType(type)) {
            const config = type.toConfig();
            delete config.astNode;
            resolvers[typeName] = new graphql.GraphQLScalarType(config);
          }
        } else if (graphql.isEnumType(type)) {
          resolvers[typeName] = {};
          const values = type.getValues();
          for (const value of values) {
            resolvers[typeName][value.name] = value.value;
          }
        } else if (graphql.isInterfaceType(type)) {
          if (type.resolveType != null) {
            resolvers[typeName] = {
              __resolveType: type.resolveType
            };
          }
        } else if (graphql.isUnionType(type)) {
          if (type.resolveType != null) {
            resolvers[typeName] = {
              __resolveType: type.resolveType
            };
          }
        } else if (graphql.isObjectType(type)) {
          resolvers[typeName] = {};
          if (type.isTypeOf != null) {
            resolvers[typeName].__isTypeOf = type.isTypeOf;
          }
          const fields = type.getFields();
          for (const fieldName in fields) {
            const field = fields[fieldName];
            if (field.subscribe != null) {
              resolvers[typeName][fieldName] = resolvers[typeName][fieldName] || {};
              resolvers[typeName][fieldName].subscribe = field.subscribe;
            }
            if (field.resolve != null && ((_a = field.resolve) === null || _a === undefined ? undefined : _a.name) !== "defaultFieldResolver" && ((_b = field.resolve) === null || _b === undefined ? undefined : _b.name) !== "defaultMergedResolver") {
              resolvers[typeName][fieldName] = resolvers[typeName][fieldName] || {};
              resolvers[typeName][fieldName].resolve = field.resolve;
            }
          }
        }
      }
    }
    return resolvers;
  }
  function forEachField(schema, fn2) {
    const typeMap = schema.getTypeMap();
    for (const typeName in typeMap) {
      const type = typeMap[typeName];
      if (!graphql.getNamedType(type).name.startsWith("__") && graphql.isObjectType(type)) {
        const fields = type.getFields();
        for (const fieldName in fields) {
          const field = fields[fieldName];
          fn2(field, typeName, fieldName);
        }
      }
    }
  }
  function forEachDefaultValue(schema, fn2) {
    const typeMap = schema.getTypeMap();
    for (const typeName in typeMap) {
      const type = typeMap[typeName];
      if (!graphql.getNamedType(type).name.startsWith("__")) {
        if (graphql.isObjectType(type)) {
          const fields = type.getFields();
          for (const fieldName in fields) {
            const field = fields[fieldName];
            for (const arg of field.args) {
              arg.defaultValue = fn2(arg.type, arg.defaultValue);
            }
          }
        } else if (graphql.isInputObjectType(type)) {
          const fields = type.getFields();
          for (const fieldName in fields) {
            const field = fields[fieldName];
            field.defaultValue = fn2(field.type, field.defaultValue);
          }
        }
      }
    }
  }
  function addTypes(schema, newTypesOrDirectives) {
    const config = schema.toConfig();
    const originalTypeMap = {};
    for (const type of config.types) {
      originalTypeMap[type.name] = type;
    }
    const originalDirectiveMap = {};
    for (const directive of config.directives) {
      originalDirectiveMap[directive.name] = directive;
    }
    for (const newTypeOrDirective of newTypesOrDirectives) {
      if (graphql.isNamedType(newTypeOrDirective)) {
        originalTypeMap[newTypeOrDirective.name] = newTypeOrDirective;
      } else if (graphql.isDirective(newTypeOrDirective)) {
        originalDirectiveMap[newTypeOrDirective.name] = newTypeOrDirective;
      }
    }
    const { typeMap, directives } = rewireTypes(originalTypeMap, Object.values(originalDirectiveMap));
    return new graphql.GraphQLSchema({
      ...config,
      query: getObjectTypeFromTypeMap(typeMap, schema.getQueryType()),
      mutation: getObjectTypeFromTypeMap(typeMap, schema.getMutationType()),
      subscription: getObjectTypeFromTypeMap(typeMap, schema.getSubscriptionType()),
      types: Object.values(typeMap),
      directives
    });
  }
  function pruneSchema(schema, options = {}) {
    const pruningContext = {
      schema,
      unusedTypes: Object.create(null),
      implementations: Object.create(null)
    };
    for (const typeName in schema.getTypeMap()) {
      const type = schema.getType(typeName);
      if (type && "getInterfaces" in type) {
        for (const iface of type.getInterfaces()) {
          const implementations = getImplementations(pruningContext, iface);
          if (implementations == null) {
            pruningContext.implementations[iface.name] = Object.create(null);
          }
          pruningContext.implementations[iface.name][type.name] = true;
        }
      }
    }
    visitTypes(pruningContext, schema);
    return mapSchema(schema, {
      [exports.MapperKind.TYPE]: (type) => {
        if (options.skipPruning && options.skipPruning(type)) {
          return type;
        }
        if (graphql.isObjectType(type) || graphql.isInputObjectType(type)) {
          if (!Object.keys(type.getFields()).length && !options.skipEmptyCompositeTypePruning || pruningContext.unusedTypes[type.name] && !options.skipUnusedTypesPruning) {
            return null;
          }
        } else if (graphql.isUnionType(type)) {
          if (!type.getTypes().length && !options.skipEmptyUnionPruning || pruningContext.unusedTypes[type.name] && !options.skipUnusedTypesPruning) {
            return null;
          }
        } else if (graphql.isInterfaceType(type)) {
          const implementations = getImplementations(pruningContext, type);
          if (!Object.keys(type.getFields()).length && !options.skipEmptyCompositeTypePruning || implementations && !Object.keys(implementations).length && !options.skipUnimplementedInterfacesPruning || pruningContext.unusedTypes[type.name] && !options.skipUnusedTypesPruning) {
            return null;
          }
        } else {
          if (pruningContext.unusedTypes[type.name] && !options.skipUnusedTypesPruning) {
            return null;
          }
        }
      }
    });
  }
  function visitOutputType(visitedTypes, pruningContext, type) {
    if (visitedTypes[type.name]) {
      return;
    }
    visitedTypes[type.name] = true;
    pruningContext.unusedTypes[type.name] = false;
    if (graphql.isObjectType(type) || graphql.isInterfaceType(type)) {
      const fields = type.getFields();
      for (const fieldName in fields) {
        const field = fields[fieldName];
        const namedType = graphql.getNamedType(field.type);
        visitOutputType(visitedTypes, pruningContext, namedType);
        for (const arg of field.args) {
          const type2 = graphql.getNamedType(arg.type);
          visitInputType(visitedTypes, pruningContext, type2);
        }
      }
      if (graphql.isInterfaceType(type)) {
        const implementations = getImplementations(pruningContext, type);
        if (implementations) {
          for (const typeName in implementations) {
            visitOutputType(visitedTypes, pruningContext, pruningContext.schema.getType(typeName));
          }
        }
      }
      if ("getInterfaces" in type) {
        for (const iFace of type.getInterfaces()) {
          visitOutputType(visitedTypes, pruningContext, iFace);
        }
      }
    } else if (graphql.isUnionType(type)) {
      const types = type.getTypes();
      for (const type2 of types) {
        visitOutputType(visitedTypes, pruningContext, type2);
      }
    }
  }
  function getImplementations(pruningContext, type) {
    return pruningContext.implementations[type.name];
  }
  function visitInputType(visitedTypes, pruningContext, type) {
    if (visitedTypes[type.name]) {
      return;
    }
    pruningContext.unusedTypes[type.name] = false;
    visitedTypes[type.name] = true;
    if (graphql.isInputObjectType(type)) {
      const fields = type.getFields();
      for (const fieldName in fields) {
        const field = fields[fieldName];
        const namedType = graphql.getNamedType(field.type);
        visitInputType(visitedTypes, pruningContext, namedType);
      }
    }
  }
  function visitTypes(pruningContext, schema) {
    for (const typeName in schema.getTypeMap()) {
      if (!typeName.startsWith("__")) {
        pruningContext.unusedTypes[typeName] = true;
      }
    }
    const visitedTypes = Object.create(null);
    const rootTypes = getRootTypes(schema);
    for (const rootType of rootTypes) {
      visitOutputType(visitedTypes, pruningContext, rootType);
    }
    for (const directive of schema.getDirectives()) {
      for (const arg of directive.args) {
        const type = graphql.getNamedType(arg.type);
        visitInputType(visitedTypes, pruningContext, type);
      }
    }
  }
  function mergeDeep(sources, respectPrototype = false) {
    const target = sources[0] || {};
    const output = {};
    if (respectPrototype) {
      Object.setPrototypeOf(output, Object.create(Object.getPrototypeOf(target)));
    }
    for (const source of sources) {
      if (isObject(target) && isObject(source)) {
        if (respectPrototype) {
          const outputPrototype = Object.getPrototypeOf(output);
          const sourcePrototype = Object.getPrototypeOf(source);
          if (sourcePrototype) {
            for (const key of Object.getOwnPropertyNames(sourcePrototype)) {
              const descriptor = Object.getOwnPropertyDescriptor(sourcePrototype, key);
              if (isSome(descriptor)) {
                Object.defineProperty(outputPrototype, key, descriptor);
              }
            }
          }
        }
        for (const key in source) {
          if (isObject(source[key])) {
            if (!(key in output)) {
              Object.assign(output, { [key]: source[key] });
            } else {
              output[key] = mergeDeep([output[key], source[key]], respectPrototype);
            }
          } else {
            Object.assign(output, { [key]: source[key] });
          }
        }
      }
    }
    return output;
  }
  function isObject(item) {
    return item && typeof item === "object" && !Array.isArray(item);
  }
  function parseSelectionSet(selectionSet, options) {
    const query = graphql.parse(selectionSet, options).definitions[0];
    return query.selectionSet;
  }
  function getResponseKeyFromInfo(info) {
    return info.fieldNodes[0].alias != null ? info.fieldNodes[0].alias.value : info.fieldName;
  }
  function appendObjectFields(schema, typeName, additionalFields) {
    if (schema.getType(typeName) == null) {
      return addTypes(schema, [
        new graphql.GraphQLObjectType({
          name: typeName,
          fields: additionalFields
        })
      ]);
    }
    return mapSchema(schema, {
      [exports.MapperKind.OBJECT_TYPE]: (type) => {
        if (type.name === typeName) {
          const config = type.toConfig();
          const originalFieldConfigMap = config.fields;
          const newFieldConfigMap = {};
          for (const fieldName in originalFieldConfigMap) {
            newFieldConfigMap[fieldName] = originalFieldConfigMap[fieldName];
          }
          for (const fieldName in additionalFields) {
            newFieldConfigMap[fieldName] = additionalFields[fieldName];
          }
          return correctASTNodes(new graphql.GraphQLObjectType({
            ...config,
            fields: newFieldConfigMap
          }));
        }
      }
    });
  }
  function removeObjectFields(schema, typeName, testFn) {
    const removedFields = {};
    const newSchema = mapSchema(schema, {
      [exports.MapperKind.OBJECT_TYPE]: (type) => {
        if (type.name === typeName) {
          const config = type.toConfig();
          const originalFieldConfigMap = config.fields;
          const newFieldConfigMap = {};
          for (const fieldName in originalFieldConfigMap) {
            const originalFieldConfig = originalFieldConfigMap[fieldName];
            if (testFn(fieldName, originalFieldConfig)) {
              removedFields[fieldName] = originalFieldConfig;
            } else {
              newFieldConfigMap[fieldName] = originalFieldConfig;
            }
          }
          return correctASTNodes(new graphql.GraphQLObjectType({
            ...config,
            fields: newFieldConfigMap
          }));
        }
      }
    });
    return [newSchema, removedFields];
  }
  function selectObjectFields(schema, typeName, testFn) {
    const selectedFields = {};
    mapSchema(schema, {
      [exports.MapperKind.OBJECT_TYPE]: (type) => {
        if (type.name === typeName) {
          const config = type.toConfig();
          const originalFieldConfigMap = config.fields;
          for (const fieldName in originalFieldConfigMap) {
            const originalFieldConfig = originalFieldConfigMap[fieldName];
            if (testFn(fieldName, originalFieldConfig)) {
              selectedFields[fieldName] = originalFieldConfig;
            }
          }
        }
        return;
      }
    });
    return selectedFields;
  }
  function modifyObjectFields(schema, typeName, testFn, newFields) {
    const removedFields = {};
    const newSchema = mapSchema(schema, {
      [exports.MapperKind.OBJECT_TYPE]: (type) => {
        if (type.name === typeName) {
          const config = type.toConfig();
          const originalFieldConfigMap = config.fields;
          const newFieldConfigMap = {};
          for (const fieldName in originalFieldConfigMap) {
            const originalFieldConfig = originalFieldConfigMap[fieldName];
            if (testFn(fieldName, originalFieldConfig)) {
              removedFields[fieldName] = originalFieldConfig;
            } else {
              newFieldConfigMap[fieldName] = originalFieldConfig;
            }
          }
          for (const fieldName in newFields) {
            const fieldConfig = newFields[fieldName];
            newFieldConfigMap[fieldName] = fieldConfig;
          }
          return correctASTNodes(new graphql.GraphQLObjectType({
            ...config,
            fields: newFieldConfigMap
          }));
        }
      }
    });
    return [newSchema, removedFields];
  }
  function renameType(type, newTypeName) {
    if (graphql.isObjectType(type)) {
      return new graphql.GraphQLObjectType({
        ...type.toConfig(),
        name: newTypeName,
        astNode: type.astNode == null ? type.astNode : {
          ...type.astNode,
          name: {
            ...type.astNode.name,
            value: newTypeName
          }
        },
        extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map((node) => ({
          ...node,
          name: {
            ...node.name,
            value: newTypeName
          }
        }))
      });
    } else if (graphql.isInterfaceType(type)) {
      return new graphql.GraphQLInterfaceType({
        ...type.toConfig(),
        name: newTypeName,
        astNode: type.astNode == null ? type.astNode : {
          ...type.astNode,
          name: {
            ...type.astNode.name,
            value: newTypeName
          }
        },
        extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map((node) => ({
          ...node,
          name: {
            ...node.name,
            value: newTypeName
          }
        }))
      });
    } else if (graphql.isUnionType(type)) {
      return new graphql.GraphQLUnionType({
        ...type.toConfig(),
        name: newTypeName,
        astNode: type.astNode == null ? type.astNode : {
          ...type.astNode,
          name: {
            ...type.astNode.name,
            value: newTypeName
          }
        },
        extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map((node) => ({
          ...node,
          name: {
            ...node.name,
            value: newTypeName
          }
        }))
      });
    } else if (graphql.isInputObjectType(type)) {
      return new graphql.GraphQLInputObjectType({
        ...type.toConfig(),
        name: newTypeName,
        astNode: type.astNode == null ? type.astNode : {
          ...type.astNode,
          name: {
            ...type.astNode.name,
            value: newTypeName
          }
        },
        extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map((node) => ({
          ...node,
          name: {
            ...node.name,
            value: newTypeName
          }
        }))
      });
    } else if (graphql.isEnumType(type)) {
      return new graphql.GraphQLEnumType({
        ...type.toConfig(),
        name: newTypeName,
        astNode: type.astNode == null ? type.astNode : {
          ...type.astNode,
          name: {
            ...type.astNode.name,
            value: newTypeName
          }
        },
        extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map((node) => ({
          ...node,
          name: {
            ...node.name,
            value: newTypeName
          }
        }))
      });
    } else if (graphql.isScalarType(type)) {
      return new graphql.GraphQLScalarType({
        ...type.toConfig(),
        name: newTypeName,
        astNode: type.astNode == null ? type.astNode : {
          ...type.astNode,
          name: {
            ...type.astNode.name,
            value: newTypeName
          }
        },
        extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map((node) => ({
          ...node,
          name: {
            ...node.name,
            value: newTypeName
          }
        }))
      });
    }
    throw new Error(`Unknown type ${type}.`);
  }
  function mapAsyncIterator(iterator, callback, rejectCallback) {
    let $return;
    let abruptClose;
    if (typeof iterator.return === "function") {
      $return = iterator.return;
      abruptClose = (error) => {
        const rethrow = () => Promise.reject(error);
        return $return.call(iterator).then(rethrow, rethrow);
      };
    }
    function mapResult(result) {
      return result.done ? result : asyncMapValue(result.value, callback).then(iteratorResult, abruptClose);
    }
    let mapReject;
    if (rejectCallback) {
      const reject = rejectCallback;
      mapReject = (error) => asyncMapValue(error, reject).then(iteratorResult, abruptClose);
    }
    return {
      next() {
        return iterator.next().then(mapResult, mapReject);
      },
      return() {
        return $return ? $return.call(iterator).then(mapResult, mapReject) : Promise.resolve({ value: undefined, done: true });
      },
      throw(error) {
        if (typeof iterator.throw === "function") {
          return iterator.throw(error).then(mapResult, mapReject);
        }
        return Promise.reject(error).catch(abruptClose);
      },
      [Symbol.asyncIterator]() {
        return this;
      }
    };
  }
  function asyncMapValue(value, callback) {
    return new Promise((resolve) => resolve(callback(value)));
  }
  function iteratorResult(value) {
    return { value, done: false };
  }
  function updateArgument(argumentNodes, variableDefinitionsMap, variableValues, argName, varName, type, value) {
    argumentNodes[argName] = {
      kind: graphql.Kind.ARGUMENT,
      name: {
        kind: graphql.Kind.NAME,
        value: argName
      },
      value: {
        kind: graphql.Kind.VARIABLE,
        name: {
          kind: graphql.Kind.NAME,
          value: varName
        }
      }
    };
    variableDefinitionsMap[varName] = {
      kind: graphql.Kind.VARIABLE_DEFINITION,
      variable: {
        kind: graphql.Kind.VARIABLE,
        name: {
          kind: graphql.Kind.NAME,
          value: varName
        }
      },
      type: astFromType(type)
    };
    if (value !== undefined) {
      variableValues[varName] = value;
      return;
    }
    if (varName in variableValues) {
      delete variableValues[varName];
    }
  }
  function createVariableNameGenerator(variableDefinitionMap) {
    let varCounter = 0;
    return (argName) => {
      let varName;
      do {
        varName = `_v${(varCounter++).toString()}_${argName}`;
      } while (varName in variableDefinitionMap);
      return varName;
    };
  }
  function implementsAbstractType(schema, typeA, typeB) {
    if (typeB == null || typeA == null) {
      return false;
    } else if (typeA === typeB) {
      return true;
    } else if (graphql.isCompositeType(typeA) && graphql.isCompositeType(typeB)) {
      return graphql.doTypesOverlap(schema, typeA, typeB);
    }
    return false;
  }
  function relocatedError(originalError, path) {
    return new graphql.GraphQLError(originalError.message, originalError.nodes, originalError.source, originalError.positions, path === null ? undefined : path === undefined ? originalError.path : path, originalError.originalError, originalError.extensions);
  }
  function observableToAsyncIterable(observable) {
    const pullQueue = [];
    const pushQueue = [];
    let listening = true;
    const pushValue = (value) => {
      if (pullQueue.length !== 0) {
        pullQueue.shift()({ value, done: false });
      } else {
        pushQueue.push({ value, done: false });
      }
    };
    const pushError = (error) => {
      if (pullQueue.length !== 0) {
        pullQueue.shift()({ value: { errors: [error] }, done: false });
      } else {
        pushQueue.push({ value: { errors: [error] }, done: false });
      }
    };
    const pushDone = () => {
      if (pullQueue.length !== 0) {
        pullQueue.shift()({ done: true });
      } else {
        pushQueue.push({ done: true });
      }
    };
    const pullValue = () => new Promise((resolve) => {
      if (pushQueue.length !== 0) {
        const element = pushQueue.shift();
        resolve(element);
      } else {
        pullQueue.push(resolve);
      }
    });
    const subscription = observable.subscribe({
      next(value) {
        pushValue(value);
      },
      error(err) {
        pushError(err);
      },
      complete() {
        pushDone();
      }
    });
    const emptyQueue = () => {
      if (listening) {
        listening = false;
        subscription.unsubscribe();
        for (const resolve of pullQueue) {
          resolve({ value: undefined, done: true });
        }
        pullQueue.length = 0;
        pushQueue.length = 0;
      }
    };
    return {
      next() {
        return listening ? pullValue() : this.return();
      },
      return() {
        emptyQueue();
        return Promise.resolve({ value: undefined, done: true });
      },
      throw(error) {
        emptyQueue();
        return Promise.reject(error);
      },
      [Symbol.asyncIterator]() {
        return this;
      }
    };
  }
  function collectFields(schema, fragments, variableValues, runtimeType, selectionSet, fields, visitedFragmentNames) {
    for (const selection of selectionSet.selections) {
      switch (selection.kind) {
        case graphql.Kind.FIELD: {
          if (!shouldIncludeNode(variableValues, selection)) {
            continue;
          }
          const name = getFieldEntryKey(selection);
          const fieldList = fields.get(name);
          if (fieldList !== undefined) {
            fieldList.push(selection);
          } else {
            fields.set(name, [selection]);
          }
          break;
        }
        case graphql.Kind.INLINE_FRAGMENT: {
          if (!shouldIncludeNode(variableValues, selection) || !doesFragmentConditionMatch(schema, selection, runtimeType)) {
            continue;
          }
          collectFields(schema, fragments, variableValues, runtimeType, selection.selectionSet, fields, visitedFragmentNames);
          break;
        }
        case graphql.Kind.FRAGMENT_SPREAD: {
          const fragName = selection.name.value;
          if (visitedFragmentNames.has(fragName) || !shouldIncludeNode(variableValues, selection)) {
            continue;
          }
          visitedFragmentNames.add(fragName);
          const fragment = fragments[fragName];
          if (!fragment || !doesFragmentConditionMatch(schema, fragment, runtimeType)) {
            continue;
          }
          collectFields(schema, fragments, variableValues, runtimeType, fragment.selectionSet, fields, visitedFragmentNames);
          break;
        }
      }
    }
    return fields;
  }
  function shouldIncludeNode(variableValues, node) {
    const skip = graphql.getDirectiveValues(graphql.GraphQLSkipDirective, node, variableValues);
    if ((skip === null || skip === undefined ? undefined : skip["if"]) === true) {
      return false;
    }
    const include = graphql.getDirectiveValues(graphql.GraphQLIncludeDirective, node, variableValues);
    if ((include === null || include === undefined ? undefined : include["if"]) === false) {
      return false;
    }
    return true;
  }
  function doesFragmentConditionMatch(schema, fragment, type) {
    const typeConditionNode = fragment.typeCondition;
    if (!typeConditionNode) {
      return true;
    }
    const conditionalType = graphql.typeFromAST(schema, typeConditionNode);
    if (conditionalType === type) {
      return true;
    }
    if (graphql.isAbstractType(conditionalType)) {
      const possibleTypes = schema.getPossibleTypes(conditionalType);
      return possibleTypes.includes(type);
    }
    return false;
  }
  function getFieldEntryKey(node) {
    return node.alias ? node.alias.value : node.name.value;
  }
  var collectSubFields = memoize5(function collectSubFields(schema, fragments, variableValues, type, fieldNodes) {
    const subFieldNodes = new Map;
    const visitedFragmentNames = new Set;
    for (const fieldNode of fieldNodes) {
      if (fieldNode.selectionSet) {
        collectFields(schema, fragments, variableValues, type, fieldNode.selectionSet, subFieldNodes, visitedFragmentNames);
      }
    }
    return subFieldNodes;
  });
  function visitData(data, enter, leave) {
    if (Array.isArray(data)) {
      return data.map((value) => visitData(value, enter, leave));
    } else if (typeof data === "object") {
      const newData = enter != null ? enter(data) : data;
      if (newData != null) {
        for (const key in newData) {
          const value = newData[key];
          newData[key] = visitData(value, enter, leave);
        }
      }
      return leave != null ? leave(newData) : newData;
    }
    return data;
  }
  function visitErrors(errors, visitor) {
    return errors.map((error) => visitor(error));
  }
  function visitResult(result, request, schema, resultVisitorMap, errorVisitorMap) {
    const fragments = request.document.definitions.reduce((acc, def) => {
      if (def.kind === graphql.Kind.FRAGMENT_DEFINITION) {
        acc[def.name.value] = def;
      }
      return acc;
    }, {});
    const variableValues = request.variables || {};
    const errorInfo = {
      segmentInfoMap: new Map,
      unpathedErrors: new Set
    };
    const data = result.data;
    const errors = result.errors;
    const visitingErrors = errors != null && errorVisitorMap != null;
    const operationDocumentNode = graphql.getOperationAST(request.document, undefined);
    if (data != null && operationDocumentNode != null) {
      result.data = visitRoot(data, operationDocumentNode, schema, fragments, variableValues, resultVisitorMap, visitingErrors ? errors : undefined, errorInfo);
    }
    if (errors != null && errorVisitorMap) {
      result.errors = visitErrorsByType(errors, errorVisitorMap, errorInfo);
    }
    return result;
  }
  function visitErrorsByType(errors, errorVisitorMap, errorInfo) {
    const segmentInfoMap = errorInfo.segmentInfoMap;
    const unpathedErrors = errorInfo.unpathedErrors;
    const unpathedErrorVisitor = errorVisitorMap["__unpathed"];
    return errors.map((originalError) => {
      const pathSegmentsInfo = segmentInfoMap.get(originalError);
      const newError = pathSegmentsInfo == null ? originalError : pathSegmentsInfo.reduceRight((acc, segmentInfo) => {
        const typeName = segmentInfo.type.name;
        const typeVisitorMap = errorVisitorMap[typeName];
        if (typeVisitorMap == null) {
          return acc;
        }
        const errorVisitor = typeVisitorMap[segmentInfo.fieldName];
        return errorVisitor == null ? acc : errorVisitor(acc, segmentInfo.pathIndex);
      }, originalError);
      if (unpathedErrorVisitor && unpathedErrors.has(originalError)) {
        return unpathedErrorVisitor(newError);
      }
      return newError;
    });
  }
  function visitRoot(root, operation, schema, fragments, variableValues, resultVisitorMap, errors, errorInfo) {
    const operationRootType = graphql.getOperationRootType(schema, operation);
    const collectedFields = collectFields(schema, fragments, variableValues, operationRootType, operation.selectionSet, new Map, new Set);
    return visitObjectValue(root, operationRootType, collectedFields, schema, fragments, variableValues, resultVisitorMap, 0, errors, errorInfo);
  }
  function visitObjectValue(object, type, fieldNodeMap, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo) {
    const fieldMap = type.getFields();
    const typeVisitorMap = resultVisitorMap === null || resultVisitorMap === undefined ? undefined : resultVisitorMap[type.name];
    const enterObject = typeVisitorMap === null || typeVisitorMap === undefined ? undefined : typeVisitorMap.__enter;
    const newObject = enterObject != null ? enterObject(object) : object;
    let sortedErrors;
    let errorMap = null;
    if (errors != null) {
      sortedErrors = sortErrorsByPathSegment(errors, pathIndex);
      errorMap = sortedErrors.errorMap;
      for (const error of sortedErrors.unpathedErrors) {
        errorInfo.unpathedErrors.add(error);
      }
    }
    for (const [responseKey, subFieldNodes] of fieldNodeMap) {
      const fieldName = subFieldNodes[0].name.value;
      const fieldType = fieldName === "__typename" ? graphql.TypeNameMetaFieldDef.type : fieldMap[fieldName].type;
      const newPathIndex = pathIndex + 1;
      let fieldErrors;
      if (errorMap) {
        fieldErrors = errorMap[responseKey];
        if (fieldErrors != null) {
          delete errorMap[responseKey];
        }
        addPathSegmentInfo(type, fieldName, newPathIndex, fieldErrors, errorInfo);
      }
      const newValue = visitFieldValue(object[responseKey], fieldType, subFieldNodes, schema, fragments, variableValues, resultVisitorMap, newPathIndex, fieldErrors, errorInfo);
      updateObject(newObject, responseKey, newValue, typeVisitorMap, fieldName);
    }
    const oldTypename = newObject.__typename;
    if (oldTypename != null) {
      updateObject(newObject, "__typename", oldTypename, typeVisitorMap, "__typename");
    }
    if (errorMap) {
      for (const errorsKey in errorMap) {
        const errors2 = errorMap[errorsKey];
        for (const error of errors2) {
          errorInfo.unpathedErrors.add(error);
        }
      }
    }
    const leaveObject = typeVisitorMap === null || typeVisitorMap === undefined ? undefined : typeVisitorMap.__leave;
    return leaveObject != null ? leaveObject(newObject) : newObject;
  }
  function updateObject(object, responseKey, newValue, typeVisitorMap, fieldName) {
    if (typeVisitorMap == null) {
      object[responseKey] = newValue;
      return;
    }
    const fieldVisitor = typeVisitorMap[fieldName];
    if (fieldVisitor == null) {
      object[responseKey] = newValue;
      return;
    }
    const visitedValue = fieldVisitor(newValue);
    if (visitedValue === undefined) {
      delete object[responseKey];
      return;
    }
    object[responseKey] = visitedValue;
  }
  function visitListValue(list, returnType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo) {
    return list.map((listMember) => visitFieldValue(listMember, returnType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex + 1, errors, errorInfo));
  }
  function visitFieldValue(value, returnType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors = [], errorInfo) {
    if (value == null) {
      return value;
    }
    const nullableType = graphql.getNullableType(returnType);
    if (graphql.isListType(nullableType)) {
      return visitListValue(value, nullableType.ofType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo);
    } else if (graphql.isAbstractType(nullableType)) {
      const finalType = schema.getType(value.__typename);
      const collectedFields = collectSubFields(schema, fragments, variableValues, finalType, fieldNodes);
      return visitObjectValue(value, finalType, collectedFields, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo);
    } else if (graphql.isObjectType(nullableType)) {
      const collectedFields = collectSubFields(schema, fragments, variableValues, nullableType, fieldNodes);
      return visitObjectValue(value, nullableType, collectedFields, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo);
    }
    const typeVisitorMap = resultVisitorMap === null || resultVisitorMap === undefined ? undefined : resultVisitorMap[nullableType.name];
    if (typeVisitorMap == null) {
      return value;
    }
    const visitedValue = typeVisitorMap(value);
    return visitedValue === undefined ? value : visitedValue;
  }
  function sortErrorsByPathSegment(errors, pathIndex) {
    var _a;
    const errorMap = Object.create(null);
    const unpathedErrors = new Set;
    for (const error of errors) {
      const pathSegment = (_a = error.path) === null || _a === undefined ? undefined : _a[pathIndex];
      if (pathSegment == null) {
        unpathedErrors.add(error);
        continue;
      }
      if (pathSegment in errorMap) {
        errorMap[pathSegment].push(error);
      } else {
        errorMap[pathSegment] = [error];
      }
    }
    return {
      errorMap,
      unpathedErrors
    };
  }
  function addPathSegmentInfo(type, fieldName, pathIndex, errors = [], errorInfo) {
    for (const error of errors) {
      const segmentInfo = {
        type,
        fieldName,
        pathIndex
      };
      const pathSegmentsInfo = errorInfo.segmentInfoMap.get(error);
      if (pathSegmentsInfo == null) {
        errorInfo.segmentInfoMap.set(error, [segmentInfo]);
      } else {
        pathSegmentsInfo.push(segmentInfo);
      }
    }
  }
  function valueMatchesCriteria(value, criteria) {
    if (value == null) {
      return value === criteria;
    } else if (Array.isArray(value)) {
      return Array.isArray(criteria) && value.every((val, index) => valueMatchesCriteria(val, criteria[index]));
    } else if (typeof value === "object") {
      return typeof criteria === "object" && criteria && Object.keys(criteria).every((propertyName) => valueMatchesCriteria(value[propertyName], criteria[propertyName]));
    } else if (criteria instanceof RegExp) {
      return criteria.test(value);
    }
    return value === criteria;
  }
  function isAsyncIterable(value) {
    return typeof value === "object" && value != null && Symbol.asyncIterator in value;
  }
  function isDocumentNode(object) {
    return object && typeof object === "object" && "kind" in object && object.kind === graphql.Kind.DOCUMENT;
  }
  function withCancel(asyncIteratorLike, onCancel) {
    const asyncIterator = asyncIteratorLike[Symbol.asyncIterator]();
    if (!asyncIterator.return) {
      asyncIterator.return = () => Promise.resolve({ value: undefined, done: true });
    }
    const savedReturn = asyncIterator.return.bind(asyncIterator);
    asyncIterator.return = () => {
      onCancel();
      return savedReturn();
    };
    return asyncIterator;
  }
  function buildFixedSchema(schema, options) {
    const document2 = getDocumentNodeFromSchema(schema);
    return graphql.buildASTSchema(document2, {
      ...options || {}
    });
  }
  function fixSchemaAst(schema, options) {
    let schemaWithValidAst = undefined;
    if (!schema.astNode || !schema.extensionASTNodes) {
      schemaWithValidAst = buildFixedSchema(schema, options);
    }
    if (!schema.astNode && (schemaWithValidAst === null || schemaWithValidAst === undefined ? undefined : schemaWithValidAst.astNode)) {
      schema.astNode = schemaWithValidAst.astNode;
    }
    if (!schema.extensionASTNodes && (schemaWithValidAst === null || schemaWithValidAst === undefined ? undefined : schemaWithValidAst.astNode)) {
      schema.extensionASTNodes = schemaWithValidAst.extensionASTNodes;
    }
    return schema;
  }
  exports.addTypes = addTypes;
  exports.appendObjectFields = appendObjectFields;
  exports.asArray = asArray;
  exports.assertSome = assertSome;
  exports.astFromArg = astFromArg;
  exports.astFromDirective = astFromDirective;
  exports.astFromEnumType = astFromEnumType;
  exports.astFromEnumValue = astFromEnumValue;
  exports.astFromField = astFromField;
  exports.astFromInputField = astFromInputField;
  exports.astFromInputObjectType = astFromInputObjectType;
  exports.astFromInterfaceType = astFromInterfaceType;
  exports.astFromObjectType = astFromObjectType;
  exports.astFromScalarType = astFromScalarType;
  exports.astFromSchema = astFromSchema;
  exports.astFromUnionType = astFromUnionType;
  exports.astFromValueUntyped = astFromValueUntyped;
  exports.buildOperationNodeForField = buildOperationNodeForField;
  exports.checkValidationErrors = checkValidationErrors;
  exports.collectComment = collectComment;
  exports.collectFields = collectFields;
  exports.collectSubFields = collectSubFields;
  exports.compareNodes = compareNodes;
  exports.compareStrings = compareStrings;
  exports.correctASTNodes = correctASTNodes;
  exports.createNamedStub = createNamedStub;
  exports.createStub = createStub;
  exports.createVariableNameGenerator = createVariableNameGenerator;
  exports.dedentBlockStringValue = dedentBlockStringValue;
  exports.filterSchema = filterSchema;
  exports.fixSchemaAst = fixSchemaAst;
  exports.forEachDefaultValue = forEachDefaultValue;
  exports.forEachField = forEachField;
  exports.getArgumentValues = getArgumentValues;
  exports.getBlockStringIndentation = getBlockStringIndentation;
  exports.getBuiltInForStub = getBuiltInForStub;
  exports.getComment = getComment;
  exports.getDefinedRootType = getDefinedRootType;
  exports.getDeprecatableDirectiveNodes = getDeprecatableDirectiveNodes;
  exports.getDescription = getDescription;
  exports.getDirective = getDirective;
  exports.getDirectiveInExtensions = getDirectiveInExtensions;
  exports.getDirectiveNodes = getDirectiveNodes;
  exports.getDirectives = getDirectives;
  exports.getDirectivesInExtensions = getDirectivesInExtensions;
  exports.getDocumentNodeFromSchema = getDocumentNodeFromSchema;
  exports.getFieldsWithDirectives = getFieldsWithDirectives;
  exports.getImplementingTypes = getImplementingTypes;
  exports.getLeadingCommentBlock = getLeadingCommentBlock;
  exports.getResolversFromSchema = getResolversFromSchema;
  exports.getResponseKeyFromInfo = getResponseKeyFromInfo;
  exports.getRootTypeMap = getRootTypeMap;
  exports.getRootTypeNames = getRootTypeNames;
  exports.getRootTypes = getRootTypes;
  exports.healSchema = healSchema;
  exports.healTypes = healTypes;
  exports.implementsAbstractType = implementsAbstractType;
  exports.inspect = inspect;
  exports.isAsyncIterable = isAsyncIterable;
  exports.isDescribable = isDescribable;
  exports.isDocumentNode = isDocumentNode;
  exports.isDocumentString = isDocumentString;
  exports.isNamedStub = isNamedStub;
  exports.isSome = isSome;
  exports.isValidPath = isValidPath;
  exports.makeDeprecatedDirective = makeDeprecatedDirective;
  exports.makeDirectiveNode = makeDirectiveNode;
  exports.makeDirectiveNodes = makeDirectiveNodes;
  exports.mapAsyncIterator = mapAsyncIterator;
  exports.mapSchema = mapSchema;
  exports.memoize1 = memoize1;
  exports.memoize2 = memoize2;
  exports.memoize2of4 = memoize2of4;
  exports.memoize3 = memoize3;
  exports.memoize4 = memoize4;
  exports.memoize5 = memoize5;
  exports.mergeDeep = mergeDeep;
  exports.modifyObjectFields = modifyObjectFields;
  exports.nodeToString = nodeToString;
  exports.observableToAsyncIterable = observableToAsyncIterable;
  exports.parseGraphQLJSON = parseGraphQLJSON;
  exports.parseGraphQLSDL = parseGraphQLSDL;
  exports.parseInputValue = parseInputValue;
  exports.parseInputValueLiteral = parseInputValueLiteral;
  exports.parseSelectionSet = parseSelectionSet;
  exports.printComment = printComment;
  exports.printSchemaWithDirectives = printSchemaWithDirectives;
  exports.printWithComments = printWithComments;
  exports.pruneSchema = pruneSchema;
  exports.pushComment = pushComment;
  exports.relocatedError = relocatedError;
  exports.removeObjectFields = removeObjectFields;
  exports.renameType = renameType;
  exports.resetComments = resetComments;
  exports.rewireTypes = rewireTypes;
  exports.selectObjectFields = selectObjectFields;
  exports.serializeInputValue = serializeInputValue;
  exports.transformCommentsToDescriptions = transformCommentsToDescriptions;
  exports.transformInputValue = transformInputValue;
  exports.updateArgument = updateArgument;
  exports.validateGraphQlDocuments = validateGraphQlDocuments;
  exports.valueMatchesCriteria = valueMatchesCriteria;
  exports.visitData = visitData;
  exports.visitErrors = visitErrors;
  exports.visitResult = visitResult;
  exports.withCancel = withCancel;
});

// node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/node_modules/@graphql-tools/merge/index.js
var require_merge = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils = require_utils5();
  var graphql = require_graphql2();
  function mergeResolvers(resolversDefinitions, options) {
    if (!resolversDefinitions || Array.isArray(resolversDefinitions) && resolversDefinitions.length === 0) {
      return {};
    }
    if (!Array.isArray(resolversDefinitions)) {
      return resolversDefinitions;
    }
    if (resolversDefinitions.length === 1) {
      return resolversDefinitions[0] || {};
    }
    const resolvers = new Array;
    for (let resolversDefinition of resolversDefinitions) {
      if (Array.isArray(resolversDefinition)) {
        resolversDefinition = mergeResolvers(resolversDefinition);
      }
      if (typeof resolversDefinition === "object" && resolversDefinition) {
        resolvers.push(resolversDefinition);
      }
    }
    const result = utils.mergeDeep(resolvers, true);
    if (options === null || options === undefined ? undefined : options.exclusions) {
      for (const exclusion of options.exclusions) {
        const [typeName, fieldName] = exclusion.split(".");
        if (!fieldName || fieldName === "*") {
          delete result[typeName];
        } else if (result[typeName]) {
          delete result[typeName][fieldName];
        }
      }
    }
    return result;
  }
  function mergeArguments(args1, args2, config) {
    const result = deduplicateArguments([...args2, ...args1].filter(utils.isSome));
    if (config && config.sort) {
      result.sort(utils.compareNodes);
    }
    return result;
  }
  function deduplicateArguments(args2) {
    return args2.reduce((acc, current) => {
      const dup = acc.find((arg) => arg.name.value === current.name.value);
      if (!dup) {
        return acc.concat([current]);
      }
      return acc;
    }, []);
  }
  function directiveAlreadyExists(directivesArr, otherDirective) {
    return !!directivesArr.find((directive) => directive.name.value === otherDirective.name.value);
  }
  function nameAlreadyExists(name, namesArr) {
    return namesArr.some(({ value }) => value === name.value);
  }
  function mergeArguments$1(a1, a2) {
    const result = [...a2];
    for (const argument of a1) {
      const existingIndex = result.findIndex((a) => a.name.value === argument.name.value);
      if (existingIndex > -1) {
        const existingArg = result[existingIndex];
        if (existingArg.value.kind === "ListValue") {
          const source = existingArg.value.values;
          const target = argument.value.values;
          existingArg.value.values = deduplicateLists(source, target, (targetVal, source2) => {
            const value = targetVal.value;
            return !value || !source2.some((sourceVal) => sourceVal.value === value);
          });
        } else {
          existingArg.value = argument.value;
        }
      } else {
        result.push(argument);
      }
    }
    return result;
  }
  function deduplicateDirectives(directives) {
    return directives.map((directive, i, all) => {
      const firstAt = all.findIndex((d) => d.name.value === directive.name.value);
      if (firstAt !== i) {
        const dup = all[firstAt];
        directive.arguments = mergeArguments$1(directive.arguments, dup.arguments);
        return null;
      }
      return directive;
    }).filter(utils.isSome);
  }
  function mergeDirectives(d1 = [], d2 = [], config) {
    const reverseOrder = config && config.reverseDirectives;
    const asNext = reverseOrder ? d1 : d2;
    const asFirst = reverseOrder ? d2 : d1;
    const result = deduplicateDirectives([...asNext]);
    for (const directive of asFirst) {
      if (directiveAlreadyExists(result, directive)) {
        const existingDirectiveIndex = result.findIndex((d) => d.name.value === directive.name.value);
        const existingDirective = result[existingDirectiveIndex];
        result[existingDirectiveIndex].arguments = mergeArguments$1(directive.arguments || [], existingDirective.arguments || []);
      } else {
        result.push(directive);
      }
    }
    return result;
  }
  function validateInputs(node, existingNode) {
    const printedNode = graphql.print({
      ...node,
      description: undefined
    });
    const printedExistingNode = graphql.print({
      ...existingNode,
      description: undefined
    });
    const leaveInputs = new RegExp("(directive @w*d*)|( on .*$)", "g");
    const sameArguments = printedNode.replace(leaveInputs, "") === printedExistingNode.replace(leaveInputs, "");
    if (!sameArguments) {
      throw new Error(`Unable to merge GraphQL directive "${node.name.value}". 
Existing directive:  
	${printedExistingNode} 
Received directive: 
	${printedNode}`);
    }
  }
  function mergeDirective(node, existingNode) {
    if (existingNode) {
      validateInputs(node, existingNode);
      return {
        ...node,
        locations: [
          ...existingNode.locations,
          ...node.locations.filter((name) => !nameAlreadyExists(name, existingNode.locations))
        ]
      };
    }
    return node;
  }
  function deduplicateLists(source, target, filterFn) {
    return source.concat(target.filter((val) => filterFn(val, source)));
  }
  function mergeEnumValues(first, second, config) {
    if (config === null || config === undefined ? undefined : config.consistentEnumMerge) {
      const reversed = [];
      if (first) {
        reversed.push(...first);
      }
      first = second;
      second = reversed;
    }
    const enumValueMap = new Map;
    if (first) {
      for (const firstValue of first) {
        enumValueMap.set(firstValue.name.value, firstValue);
      }
    }
    if (second) {
      for (const secondValue of second) {
        const enumValue = secondValue.name.value;
        if (enumValueMap.has(enumValue)) {
          const firstValue = enumValueMap.get(enumValue);
          firstValue.description = secondValue.description || firstValue.description;
          firstValue.directives = mergeDirectives(secondValue.directives, firstValue.directives);
        } else {
          enumValueMap.set(enumValue, secondValue);
        }
      }
    }
    const result = [...enumValueMap.values()];
    if (config && config.sort) {
      result.sort(utils.compareNodes);
    }
    return result;
  }
  function mergeEnum(e1, e2, config) {
    if (e2) {
      return {
        name: e1.name,
        description: e1["description"] || e2["description"],
        kind: (config === null || config === undefined ? undefined : config.convertExtensions) || e1.kind === "EnumTypeDefinition" || e2.kind === "EnumTypeDefinition" ? "EnumTypeDefinition" : "EnumTypeExtension",
        loc: e1.loc,
        directives: mergeDirectives(e1.directives, e2.directives, config),
        values: mergeEnumValues(e1.values, e2.values, config)
      };
    }
    return (config === null || config === undefined ? undefined : config.convertExtensions) ? {
      ...e1,
      kind: "EnumTypeDefinition"
    } : e1;
  }
  function isStringTypes(types) {
    return typeof types === "string";
  }
  function isSourceTypes(types) {
    return types instanceof graphql.Source;
  }
  function extractType(type) {
    let visitedType = type;
    while (visitedType.kind === graphql.Kind.LIST_TYPE || visitedType.kind === "NonNullType") {
      visitedType = visitedType.type;
    }
    return visitedType;
  }
  function isWrappingTypeNode(type) {
    return type.kind !== graphql.Kind.NAMED_TYPE;
  }
  function isListTypeNode(type) {
    return type.kind === graphql.Kind.LIST_TYPE;
  }
  function isNonNullTypeNode(type) {
    return type.kind === graphql.Kind.NON_NULL_TYPE;
  }
  function printTypeNode(type) {
    if (isListTypeNode(type)) {
      return `[${printTypeNode(type.type)}]`;
    }
    if (isNonNullTypeNode(type)) {
      return `${printTypeNode(type.type)}!`;
    }
    return type.name.value;
  }
  (function(CompareVal) {
    CompareVal[CompareVal["A_SMALLER_THAN_B"] = -1] = "A_SMALLER_THAN_B";
    CompareVal[CompareVal["A_EQUALS_B"] = 0] = "A_EQUALS_B";
    CompareVal[CompareVal["A_GREATER_THAN_B"] = 1] = "A_GREATER_THAN_B";
  })(exports.CompareVal || (exports.CompareVal = {}));
  function defaultStringComparator(a, b) {
    if (a == null && b == null) {
      return exports.CompareVal.A_EQUALS_B;
    }
    if (a == null) {
      return exports.CompareVal.A_SMALLER_THAN_B;
    }
    if (b == null) {
      return exports.CompareVal.A_GREATER_THAN_B;
    }
    if (a < b)
      return exports.CompareVal.A_SMALLER_THAN_B;
    if (a > b)
      return exports.CompareVal.A_GREATER_THAN_B;
    return exports.CompareVal.A_EQUALS_B;
  }
  function fieldAlreadyExists(fieldsArr, otherField, config) {
    const result = fieldsArr.find((field) => field.name.value === otherField.name.value);
    if (result && !(config === null || config === undefined ? undefined : config.ignoreFieldConflicts)) {
      const t1 = extractType(result.type);
      const t2 = extractType(otherField.type);
      if (t1.name.value !== t2.name.value) {
        throw new Error(`Field "${otherField.name.value}" already defined with a different type. Declared as "${t1.name.value}", but you tried to override with "${t2.name.value}"`);
      }
    }
    return !!result;
  }
  function mergeFields(type, f1, f2, config) {
    const result = [];
    if (f2 != null) {
      result.push(...f2);
    }
    if (f1 != null) {
      for (const field of f1) {
        if (fieldAlreadyExists(result, field, config)) {
          const existing = result.find((f) => f.name.value === field.name.value);
          if (!(config === null || config === undefined ? undefined : config.ignoreFieldConflicts)) {
            if (config === null || config === undefined ? undefined : config.throwOnConflict) {
              preventConflicts(type, existing, field, false);
            } else {
              preventConflicts(type, existing, field, true);
            }
            if (isNonNullTypeNode(field.type) && !isNonNullTypeNode(existing.type)) {
              existing.type = field.type;
            }
          }
          existing.arguments = mergeArguments(field["arguments"] || [], existing.arguments || [], config);
          existing.directives = mergeDirectives(field.directives, existing.directives, config);
          existing.description = field.description || existing.description;
        } else {
          result.push(field);
        }
      }
    }
    if (config && config.sort) {
      result.sort(utils.compareNodes);
    }
    if (config && config.exclusions) {
      const exclusions = config.exclusions;
      return result.filter((field) => !exclusions.includes(`${type.name.value}.${field.name.value}`));
    }
    return result;
  }
  function preventConflicts(type, a, b, ignoreNullability = false) {
    const aType = printTypeNode(a.type);
    const bType = printTypeNode(b.type);
    if (aType !== bType && !safeChangeForFieldType(a.type, b.type, ignoreNullability)) {
      throw new Error(`Field '${type.name.value}.${a.name.value}' changed type from '${aType}' to '${bType}'`);
    }
  }
  function safeChangeForFieldType(oldType, newType, ignoreNullability = false) {
    if (!isWrappingTypeNode(oldType) && !isWrappingTypeNode(newType)) {
      return oldType.toString() === newType.toString();
    }
    if (isNonNullTypeNode(newType)) {
      const ofType = isNonNullTypeNode(oldType) ? oldType.type : oldType;
      return safeChangeForFieldType(ofType, newType.type);
    }
    if (isNonNullTypeNode(oldType)) {
      return safeChangeForFieldType(newType, oldType, ignoreNullability);
    }
    if (isListTypeNode(oldType)) {
      return isListTypeNode(newType) && safeChangeForFieldType(oldType.type, newType.type) || isNonNullTypeNode(newType) && safeChangeForFieldType(oldType, newType["type"]);
    }
    return false;
  }
  function mergeInputType(node, existingNode, config) {
    if (existingNode) {
      try {
        return {
          name: node.name,
          description: node["description"] || existingNode["description"],
          kind: (config === null || config === undefined ? undefined : config.convertExtensions) || node.kind === "InputObjectTypeDefinition" || existingNode.kind === "InputObjectTypeDefinition" ? "InputObjectTypeDefinition" : "InputObjectTypeExtension",
          loc: node.loc,
          fields: mergeFields(node, node.fields, existingNode.fields, config),
          directives: mergeDirectives(node.directives, existingNode.directives, config)
        };
      } catch (e) {
        throw new Error(`Unable to merge GraphQL input type "${node.name.value}": ${e.message}`);
      }
    }
    return (config === null || config === undefined ? undefined : config.convertExtensions) ? {
      ...node,
      kind: "InputObjectTypeDefinition"
    } : node;
  }
  function mergeInterface(node, existingNode, config) {
    if (existingNode) {
      try {
        return {
          name: node.name,
          description: node["description"] || existingNode["description"],
          kind: (config === null || config === undefined ? undefined : config.convertExtensions) || node.kind === "InterfaceTypeDefinition" || existingNode.kind === "InterfaceTypeDefinition" ? "InterfaceTypeDefinition" : "InterfaceTypeExtension",
          loc: node.loc,
          fields: mergeFields(node, node.fields, existingNode.fields, config),
          directives: mergeDirectives(node.directives, existingNode.directives, config)
        };
      } catch (e) {
        throw new Error(`Unable to merge GraphQL interface "${node.name.value}": ${e.message}`);
      }
    }
    return (config === null || config === undefined ? undefined : config.convertExtensions) ? {
      ...node,
      kind: "InterfaceTypeDefinition"
    } : node;
  }
  function alreadyExists(arr, other) {
    return !!arr.find((i) => i.name.value === other.name.value);
  }
  function mergeNamedTypeArray(first = [], second = [], config = {}) {
    const result = [...second, ...first.filter((d) => !alreadyExists(second, d))];
    if (config && config.sort) {
      result.sort(utils.compareNodes);
    }
    return result;
  }
  function mergeType(node, existingNode, config) {
    if (existingNode) {
      try {
        return {
          name: node.name,
          description: node["description"] || existingNode["description"],
          kind: (config === null || config === undefined ? undefined : config.convertExtensions) || node.kind === "ObjectTypeDefinition" || existingNode.kind === "ObjectTypeDefinition" ? "ObjectTypeDefinition" : "ObjectTypeExtension",
          loc: node.loc,
          fields: mergeFields(node, node.fields, existingNode.fields, config),
          directives: mergeDirectives(node.directives, existingNode.directives, config),
          interfaces: mergeNamedTypeArray(node.interfaces, existingNode.interfaces, config)
        };
      } catch (e) {
        throw new Error(`Unable to merge GraphQL type "${node.name.value}": ${e.message}`);
      }
    }
    return (config === null || config === undefined ? undefined : config.convertExtensions) ? {
      ...node,
      kind: "ObjectTypeDefinition"
    } : node;
  }
  function mergeScalar(node, existingNode, config) {
    if (existingNode) {
      return {
        name: node.name,
        description: node["description"] || existingNode["description"],
        kind: (config === null || config === undefined ? undefined : config.convertExtensions) || node.kind === "ScalarTypeDefinition" || existingNode.kind === "ScalarTypeDefinition" ? "ScalarTypeDefinition" : "ScalarTypeExtension",
        loc: node.loc,
        directives: mergeDirectives(node.directives, existingNode.directives, config)
      };
    }
    return (config === null || config === undefined ? undefined : config.convertExtensions) ? {
      ...node,
      kind: "ScalarTypeDefinition"
    } : node;
  }
  function mergeUnion(first, second, config) {
    if (second) {
      return {
        name: first.name,
        description: first["description"] || second["description"],
        directives: mergeDirectives(first.directives, second.directives, config),
        kind: (config === null || config === undefined ? undefined : config.convertExtensions) || first.kind === "UnionTypeDefinition" || second.kind === "UnionTypeDefinition" ? "UnionTypeDefinition" : "UnionTypeExtension",
        loc: first.loc,
        types: mergeNamedTypeArray(first.types, second.types, config)
      };
    }
    return (config === null || config === undefined ? undefined : config.convertExtensions) ? {
      ...first,
      kind: "UnionTypeDefinition"
    } : first;
  }
  var DEFAULT_OPERATION_TYPE_NAME_MAP = {
    query: "Query",
    mutation: "Mutation",
    subscription: "Subscription"
  };
  function mergeOperationTypes(opNodeList = [], existingOpNodeList = []) {
    const finalOpNodeList = [];
    for (const opNodeType in DEFAULT_OPERATION_TYPE_NAME_MAP) {
      const opNode = opNodeList.find((n) => n.operation === opNodeType) || existingOpNodeList.find((n) => n.operation === opNodeType);
      if (opNode) {
        finalOpNodeList.push(opNode);
      }
    }
    return finalOpNodeList;
  }
  function mergeSchemaDefs(node, existingNode, config) {
    if (existingNode) {
      return {
        kind: node.kind === graphql.Kind.SCHEMA_DEFINITION || existingNode.kind === graphql.Kind.SCHEMA_DEFINITION ? graphql.Kind.SCHEMA_DEFINITION : graphql.Kind.SCHEMA_EXTENSION,
        description: node["description"] || existingNode["description"],
        directives: mergeDirectives(node.directives, existingNode.directives, config),
        operationTypes: mergeOperationTypes(node.operationTypes, existingNode.operationTypes)
      };
    }
    return (config === null || config === undefined ? undefined : config.convertExtensions) ? {
      ...node,
      kind: graphql.Kind.SCHEMA_DEFINITION
    } : node;
  }
  var schemaDefSymbol = "SCHEMA_DEF_SYMBOL";
  function isNamedDefinitionNode(definitionNode) {
    return "name" in definitionNode;
  }
  function mergeGraphQLNodes(nodes, config) {
    var _a, _b, _c;
    const mergedResultMap = {};
    for (const nodeDefinition of nodes) {
      if (isNamedDefinitionNode(nodeDefinition)) {
        const name = (_a = nodeDefinition.name) === null || _a === undefined ? undefined : _a.value;
        if (config === null || config === undefined ? undefined : config.commentDescriptions) {
          utils.collectComment(nodeDefinition);
        }
        if (name == null) {
          continue;
        }
        if (((_b = config === null || config === undefined ? undefined : config.exclusions) === null || _b === undefined ? undefined : _b.includes(name + ".*")) || ((_c = config === null || config === undefined ? undefined : config.exclusions) === null || _c === undefined ? undefined : _c.includes(name))) {
          delete mergedResultMap[name];
        } else {
          switch (nodeDefinition.kind) {
            case graphql.Kind.OBJECT_TYPE_DEFINITION:
            case graphql.Kind.OBJECT_TYPE_EXTENSION:
              mergedResultMap[name] = mergeType(nodeDefinition, mergedResultMap[name], config);
              break;
            case graphql.Kind.ENUM_TYPE_DEFINITION:
            case graphql.Kind.ENUM_TYPE_EXTENSION:
              mergedResultMap[name] = mergeEnum(nodeDefinition, mergedResultMap[name], config);
              break;
            case graphql.Kind.UNION_TYPE_DEFINITION:
            case graphql.Kind.UNION_TYPE_EXTENSION:
              mergedResultMap[name] = mergeUnion(nodeDefinition, mergedResultMap[name], config);
              break;
            case graphql.Kind.SCALAR_TYPE_DEFINITION:
            case graphql.Kind.SCALAR_TYPE_EXTENSION:
              mergedResultMap[name] = mergeScalar(nodeDefinition, mergedResultMap[name], config);
              break;
            case graphql.Kind.INPUT_OBJECT_TYPE_DEFINITION:
            case graphql.Kind.INPUT_OBJECT_TYPE_EXTENSION:
              mergedResultMap[name] = mergeInputType(nodeDefinition, mergedResultMap[name], config);
              break;
            case graphql.Kind.INTERFACE_TYPE_DEFINITION:
            case graphql.Kind.INTERFACE_TYPE_EXTENSION:
              mergedResultMap[name] = mergeInterface(nodeDefinition, mergedResultMap[name], config);
              break;
            case graphql.Kind.DIRECTIVE_DEFINITION:
              mergedResultMap[name] = mergeDirective(nodeDefinition, mergedResultMap[name]);
              break;
          }
        }
      } else if (nodeDefinition.kind === graphql.Kind.SCHEMA_DEFINITION || nodeDefinition.kind === graphql.Kind.SCHEMA_EXTENSION) {
        mergedResultMap[schemaDefSymbol] = mergeSchemaDefs(nodeDefinition, mergedResultMap[schemaDefSymbol], config);
      }
    }
    return mergedResultMap;
  }
  function mergeTypeDefs(typeSource, config) {
    utils.resetComments();
    const doc = {
      kind: graphql.Kind.DOCUMENT,
      definitions: mergeGraphQLTypes(typeSource, {
        useSchemaDefinition: true,
        forceSchemaDefinition: false,
        throwOnConflict: false,
        commentDescriptions: false,
        ...config
      })
    };
    let result;
    if (config === null || config === undefined ? undefined : config.commentDescriptions) {
      result = utils.printWithComments(doc);
    } else {
      result = doc;
    }
    utils.resetComments();
    return result;
  }
  function visitTypeSources(typeSource, options, allNodes = [], visitedTypeSources = new Set) {
    if (typeSource && !visitedTypeSources.has(typeSource)) {
      visitedTypeSources.add(typeSource);
      if (typeof typeSource === "function") {
        visitTypeSources(typeSource(), options, allNodes, visitedTypeSources);
      } else if (Array.isArray(typeSource)) {
        for (const type of typeSource) {
          visitTypeSources(type, options, allNodes, visitedTypeSources);
        }
      } else if (graphql.isSchema(typeSource)) {
        const documentNode = utils.getDocumentNodeFromSchema(typeSource, options);
        visitTypeSources(documentNode.definitions, options, allNodes, visitedTypeSources);
      } else if (isStringTypes(typeSource) || isSourceTypes(typeSource)) {
        const documentNode = graphql.parse(typeSource, options);
        visitTypeSources(documentNode.definitions, options, allNodes, visitedTypeSources);
      } else if (typeof typeSource === "object" && graphql.isDefinitionNode(typeSource)) {
        allNodes.push(typeSource);
      } else if (utils.isDocumentNode(typeSource)) {
        visitTypeSources(typeSource.definitions, options, allNodes, visitedTypeSources);
      } else {
        throw new Error(`typeDefs must contain only strings, documents, schemas, or functions, got ${typeof typeSource}`);
      }
    }
    return allNodes;
  }
  function mergeGraphQLTypes(typeSource, config) {
    var _a, _b, _c;
    utils.resetComments();
    const allNodes = visitTypeSources(typeSource, config);
    const mergedNodes = mergeGraphQLNodes(allNodes, config);
    if (config === null || config === undefined ? undefined : config.useSchemaDefinition) {
      const schemaDef = mergedNodes[schemaDefSymbol] || {
        kind: graphql.Kind.SCHEMA_DEFINITION,
        operationTypes: []
      };
      const operationTypes = schemaDef.operationTypes;
      for (const opTypeDefNodeType in DEFAULT_OPERATION_TYPE_NAME_MAP) {
        const opTypeDefNode = operationTypes.find((operationType) => operationType.operation === opTypeDefNodeType);
        if (!opTypeDefNode) {
          const possibleRootTypeName = DEFAULT_OPERATION_TYPE_NAME_MAP[opTypeDefNodeType];
          const existingPossibleRootType = mergedNodes[possibleRootTypeName];
          if (existingPossibleRootType != null && existingPossibleRootType.name != null) {
            operationTypes.push({
              kind: graphql.Kind.OPERATION_TYPE_DEFINITION,
              type: {
                kind: graphql.Kind.NAMED_TYPE,
                name: existingPossibleRootType.name
              },
              operation: opTypeDefNodeType
            });
          }
        }
      }
      if (((_a = schemaDef === null || schemaDef === undefined ? undefined : schemaDef.operationTypes) === null || _a === undefined ? undefined : _a.length) != null && schemaDef.operationTypes.length > 0) {
        mergedNodes[schemaDefSymbol] = schemaDef;
      }
    }
    if ((config === null || config === undefined ? undefined : config.forceSchemaDefinition) && !((_c = (_b = mergedNodes[schemaDefSymbol]) === null || _b === undefined ? undefined : _b.operationTypes) === null || _c === undefined ? undefined : _c.length)) {
      mergedNodes[schemaDefSymbol] = {
        kind: graphql.Kind.SCHEMA_DEFINITION,
        operationTypes: [
          {
            kind: graphql.Kind.OPERATION_TYPE_DEFINITION,
            operation: "query",
            type: {
              kind: graphql.Kind.NAMED_TYPE,
              name: {
                kind: graphql.Kind.NAME,
                value: "Query"
              }
            }
          }
        ]
      };
    }
    const mergedNodeDefinitions = Object.values(mergedNodes);
    if (config === null || config === undefined ? undefined : config.sort) {
      const sortFn = typeof config.sort === "function" ? config.sort : defaultStringComparator;
      mergedNodeDefinitions.sort((a, b) => {
        var _a2, _b2;
        return sortFn((_a2 = a.name) === null || _a2 === undefined ? undefined : _a2.value, (_b2 = b.name) === null || _b2 === undefined ? undefined : _b2.value);
      });
    }
    return mergedNodeDefinitions;
  }
  function travelSchemaPossibleExtensions(schema, hooks) {
    hooks.onSchema(schema);
    const typesMap = schema.getTypeMap();
    for (const [, type] of Object.entries(typesMap)) {
      const isPredefinedScalar = graphql.isScalarType(type) && graphql.isSpecifiedScalarType(type);
      const isIntrospection = graphql.isIntrospectionType(type);
      if (isPredefinedScalar || isIntrospection) {
        continue;
      }
      if (graphql.isObjectType(type)) {
        hooks.onObjectType(type);
        const fields = type.getFields();
        for (const [, field] of Object.entries(fields)) {
          hooks.onObjectField(type, field);
          const args2 = field.args || [];
          for (const arg of args2) {
            hooks.onObjectFieldArg(type, field, arg);
          }
        }
      } else if (graphql.isInterfaceType(type)) {
        hooks.onInterface(type);
        const fields = type.getFields();
        for (const [, field] of Object.entries(fields)) {
          hooks.onInterfaceField(type, field);
          const args2 = field.args || [];
          for (const arg of args2) {
            hooks.onInterfaceFieldArg(type, field, arg);
          }
        }
      } else if (graphql.isInputObjectType(type)) {
        hooks.onInputType(type);
        const fields = type.getFields();
        for (const [, field] of Object.entries(fields)) {
          hooks.onInputFieldType(type, field);
        }
      } else if (graphql.isUnionType(type)) {
        hooks.onUnion(type);
      } else if (graphql.isScalarType(type)) {
        hooks.onScalar(type);
      } else if (graphql.isEnumType(type)) {
        hooks.onEnum(type);
        for (const value of type.getValues()) {
          hooks.onEnumValue(type, value);
        }
      }
    }
  }
  function mergeExtensions(extensions) {
    return utils.mergeDeep(extensions);
  }
  function applyExtensionObject(obj, extensions) {
    if (!obj) {
      return;
    }
    obj.extensions = utils.mergeDeep([obj.extensions || {}, extensions || {}]);
  }
  function applyExtensions(schema, extensions) {
    applyExtensionObject(schema, extensions.schemaExtensions);
    for (const [typeName, data] of Object.entries(extensions.types || {})) {
      const type = schema.getType(typeName);
      if (type) {
        applyExtensionObject(type, data.extensions);
        if (data.type === "object" || data.type === "interface") {
          for (const [fieldName, fieldData] of Object.entries(data.fields)) {
            const field = type.getFields()[fieldName];
            if (field) {
              applyExtensionObject(field, fieldData.extensions);
              for (const [arg, argData] of Object.entries(fieldData.arguments)) {
                applyExtensionObject(field.args.find((a) => a.name === arg), argData);
              }
            }
          }
        } else if (data.type === "input") {
          for (const [fieldName, fieldData] of Object.entries(data.fields)) {
            const field = type.getFields()[fieldName];
            applyExtensionObject(field, fieldData.extensions);
          }
        } else if (data.type === "enum") {
          for (const [valueName, valueData] of Object.entries(data.values)) {
            const value = type.getValue(valueName);
            applyExtensionObject(value, valueData);
          }
        }
      }
    }
    return schema;
  }
  function extractExtensionsFromSchema(schema) {
    const result = {
      schemaExtensions: {},
      types: {}
    };
    travelSchemaPossibleExtensions(schema, {
      onSchema: (schema2) => result.schemaExtensions = schema2.extensions || {},
      onObjectType: (type) => result.types[type.name] = { fields: {}, type: "object", extensions: type.extensions || {} },
      onObjectField: (type, field) => result.types[type.name].fields[field.name] = {
        arguments: {},
        extensions: field.extensions || {}
      },
      onObjectFieldArg: (type, field, arg) => result.types[type.name].fields[field.name].arguments[arg.name] = arg.extensions || {},
      onInterface: (type) => result.types[type.name] = { fields: {}, type: "interface", extensions: type.extensions || {} },
      onInterfaceField: (type, field) => result.types[type.name].fields[field.name] = {
        arguments: {},
        extensions: field.extensions || {}
      },
      onInterfaceFieldArg: (type, field, arg) => result.types[type.name].fields[field.name].arguments[arg.name] = arg.extensions || {},
      onEnum: (type) => result.types[type.name] = { values: {}, type: "enum", extensions: type.extensions || {} },
      onEnumValue: (type, value) => result.types[type.name].values[value.name] = value.extensions || {},
      onScalar: (type) => result.types[type.name] = { type: "scalar", extensions: type.extensions || {} },
      onUnion: (type) => result.types[type.name] = { type: "union", extensions: type.extensions || {} },
      onInputType: (type) => result.types[type.name] = { fields: {}, type: "input", extensions: type.extensions || {} },
      onInputFieldType: (type, field) => result.types[type.name].fields[field.name] = { extensions: field.extensions || {} }
    });
    return result;
  }
  exports.applyExtensions = applyExtensions;
  exports.defaultStringComparator = defaultStringComparator;
  exports.extractExtensionsFromSchema = extractExtensionsFromSchema;
  exports.extractType = extractType;
  exports.isListTypeNode = isListTypeNode;
  exports.isNamedDefinitionNode = isNamedDefinitionNode;
  exports.isNonNullTypeNode = isNonNullTypeNode;
  exports.isSourceTypes = isSourceTypes;
  exports.isStringTypes = isStringTypes;
  exports.isWrappingTypeNode = isWrappingTypeNode;
  exports.mergeArguments = mergeArguments;
  exports.mergeDirective = mergeDirective;
  exports.mergeDirectives = mergeDirectives;
  exports.mergeEnum = mergeEnum;
  exports.mergeEnumValues = mergeEnumValues;
  exports.mergeExtensions = mergeExtensions;
  exports.mergeFields = mergeFields;
  exports.mergeGraphQLNodes = mergeGraphQLNodes;
  exports.mergeGraphQLTypes = mergeGraphQLTypes;
  exports.mergeInputType = mergeInputType;
  exports.mergeInterface = mergeInterface;
  exports.mergeNamedTypeArray = mergeNamedTypeArray;
  exports.mergeResolvers = mergeResolvers;
  exports.mergeScalar = mergeScalar;
  exports.mergeType = mergeType;
  exports.mergeTypeDefs = mergeTypeDefs;
  exports.mergeUnion = mergeUnion;
  exports.printTypeNode = printTypeNode;
  exports.schemaDefSymbol = schemaDefSymbol;
  exports.travelSchemaPossibleExtensions = travelSchemaPossibleExtensions;
});

// node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/index.js
var require_schema2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var graphql = require_graphql2();
  var utils = require_utils5();
  var merge = require_merge();
  function assertResolversPresent(schema, resolverValidationOptions = {}) {
    const { requireResolversForArgs, requireResolversForNonScalar, requireResolversForAllFields } = resolverValidationOptions;
    if (requireResolversForAllFields && (requireResolversForArgs || requireResolversForNonScalar)) {
      throw new TypeError("requireResolversForAllFields takes precedence over the more specific assertions. " + "Please configure either requireResolversForAllFields or requireResolversForArgs / " + "requireResolversForNonScalar, but not a combination of them.");
    }
    utils.forEachField(schema, (field, typeName, fieldName) => {
      if (requireResolversForAllFields) {
        expectResolver("requireResolversForAllFields", requireResolversForAllFields, field, typeName, fieldName);
      }
      if (requireResolversForArgs && field.args.length > 0) {
        expectResolver("requireResolversForArgs", requireResolversForArgs, field, typeName, fieldName);
      }
      if (requireResolversForNonScalar !== "ignore" && !graphql.isScalarType(graphql.getNamedType(field.type))) {
        expectResolver("requireResolversForNonScalar", requireResolversForNonScalar, field, typeName, fieldName);
      }
    });
  }
  function expectResolver(validator, behavior, field, typeName, fieldName) {
    if (!field.resolve) {
      const message2 = `Resolver missing for "${typeName}.${fieldName}".
To disable this validator, use:
  resolverValidationOptions: {
    ${validator}: 'ignore'
  }`;
      if (behavior === "error") {
        throw new Error(message2);
      }
      if (behavior === "warn") {
        console.warn(message2);
      }
      return;
    }
    if (typeof field.resolve !== "function") {
      throw new Error(`Resolver "${typeName}.${fieldName}" must be a function`);
    }
  }
  function chainResolvers(resolvers) {
    return (root, args2, ctx, info) => resolvers.reduce((prev, curResolver) => {
      if (curResolver != null) {
        return curResolver(prev, args2, ctx, info);
      }
      return graphql.defaultFieldResolver(prev, args2, ctx, info);
    }, root);
  }
  function checkForResolveTypeResolver(schema, requireResolversForResolveType) {
    utils.mapSchema(schema, {
      [utils.MapperKind.ABSTRACT_TYPE]: (type) => {
        if (!type.resolveType) {
          const message2 = `Type "${type.name}" is missing a "__resolveType" resolver. Pass 'ignore' into ` + '"resolverValidationOptions.requireResolversForResolveType" to disable this error.';
          if (requireResolversForResolveType === "error") {
            throw new Error(message2);
          }
          if (requireResolversForResolveType === "warn") {
            console.warn(message2);
          }
        }
        return;
      }
    });
  }
  function extendResolversFromInterfaces(schema, resolvers) {
    const extendedResolvers = {};
    const typeMap = schema.getTypeMap();
    for (const typeName in typeMap) {
      const type = typeMap[typeName];
      if ("getInterfaces" in type) {
        extendedResolvers[typeName] = {};
        for (const iFace of type.getInterfaces()) {
          if (resolvers[iFace.name]) {
            for (const fieldName in resolvers[iFace.name]) {
              if (fieldName === "__isTypeOf" || !fieldName.startsWith("__")) {
                extendedResolvers[typeName][fieldName] = resolvers[iFace.name][fieldName];
              }
            }
          }
        }
        const typeResolvers = resolvers[typeName];
        extendedResolvers[typeName] = {
          ...extendedResolvers[typeName],
          ...typeResolvers
        };
      } else {
        const typeResolvers = resolvers[typeName];
        if (typeResolvers != null) {
          extendedResolvers[typeName] = typeResolvers;
        }
      }
    }
    return extendedResolvers;
  }
  function addResolversToSchema(schemaOrOptions, legacyInputResolvers, legacyInputValidationOptions) {
    const options = graphql.isSchema(schemaOrOptions) ? {
      schema: schemaOrOptions,
      resolvers: legacyInputResolvers !== null && legacyInputResolvers !== undefined ? legacyInputResolvers : {},
      resolverValidationOptions: legacyInputValidationOptions
    } : schemaOrOptions;
    let { schema, resolvers: inputResolvers, defaultFieldResolver, resolverValidationOptions = {}, inheritResolversFromInterfaces = false, updateResolversInPlace = false } = options;
    const { requireResolversToMatchSchema = "error", requireResolversForResolveType } = resolverValidationOptions;
    const resolvers = inheritResolversFromInterfaces ? extendResolversFromInterfaces(schema, inputResolvers) : inputResolvers;
    for (const typeName in resolvers) {
      const resolverValue = resolvers[typeName];
      const resolverType = typeof resolverValue;
      if (resolverType !== "object") {
        throw new Error(`"${typeName}" defined in resolvers, but has invalid value "${resolverValue}". The resolver's value must be of type object.`);
      }
      const type = schema.getType(typeName);
      if (type == null) {
        if (requireResolversToMatchSchema === "ignore") {
          break;
        }
        throw new Error(`"${typeName}" defined in resolvers, but not in schema`);
      } else if (graphql.isSpecifiedScalarType(type)) {
        for (const fieldName in resolverValue) {
          if (fieldName.startsWith("__")) {
            type[fieldName.substring(2)] = resolverValue[fieldName];
          } else {
            type[fieldName] = resolverValue[fieldName];
          }
        }
      } else if (graphql.isEnumType(type)) {
        const values = type.getValues();
        for (const fieldName in resolverValue) {
          if (!fieldName.startsWith("__") && !values.some((value) => value.name === fieldName) && requireResolversToMatchSchema && requireResolversToMatchSchema !== "ignore") {
            throw new Error(`${type.name}.${fieldName} was defined in resolvers, but not present within ${type.name}`);
          }
        }
      } else if (graphql.isUnionType(type)) {
        for (const fieldName in resolverValue) {
          if (!fieldName.startsWith("__") && requireResolversToMatchSchema && requireResolversToMatchSchema !== "ignore") {
            throw new Error(`${type.name}.${fieldName} was defined in resolvers, but ${type.name} is not an object or interface type`);
          }
        }
      } else if (graphql.isObjectType(type) || graphql.isInterfaceType(type)) {
        for (const fieldName in resolverValue) {
          if (!fieldName.startsWith("__")) {
            const fields = type.getFields();
            const field = fields[fieldName];
            if (field == null) {
              if (requireResolversToMatchSchema && requireResolversToMatchSchema !== "ignore") {
                throw new Error(`${typeName}.${fieldName} defined in resolvers, but not in schema`);
              }
            } else {
              const fieldResolve = resolverValue[fieldName];
              if (typeof fieldResolve !== "function" && typeof fieldResolve !== "object") {
                throw new Error(`Resolver ${typeName}.${fieldName} must be object or function`);
              }
            }
          }
        }
      }
    }
    schema = updateResolversInPlace ? addResolversToExistingSchema(schema, resolvers, defaultFieldResolver) : createNewSchemaWithResolvers(schema, resolvers, defaultFieldResolver);
    if (requireResolversForResolveType && requireResolversForResolveType !== "ignore") {
      checkForResolveTypeResolver(schema, requireResolversForResolveType);
    }
    return schema;
  }
  function addResolversToExistingSchema(schema, resolvers, defaultFieldResolver) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
    const typeMap = schema.getTypeMap();
    for (const typeName in resolvers) {
      const type = schema.getType(typeName);
      const resolverValue = resolvers[typeName];
      if (graphql.isScalarType(type)) {
        for (const fieldName in resolverValue) {
          if (fieldName.startsWith("__")) {
            type[fieldName.substring(2)] = resolverValue[fieldName];
          } else if (fieldName === "astNode" && type.astNode != null) {
            type.astNode = {
              ...type.astNode,
              description: (_c = (_b = (_a = resolverValue) === null || _a === undefined ? undefined : _a.astNode) === null || _b === undefined ? undefined : _b.description) !== null && _c !== undefined ? _c : type.astNode.description,
              directives: ((_d = type.astNode.directives) !== null && _d !== undefined ? _d : []).concat((_g = (_f = (_e = resolverValue) === null || _e === undefined ? undefined : _e.astNode) === null || _f === undefined ? undefined : _f.directives) !== null && _g !== undefined ? _g : [])
            };
          } else if (fieldName === "extensionASTNodes" && type.extensionASTNodes != null) {
            type.extensionASTNodes = type.extensionASTNodes.concat((_j = (_h = resolverValue) === null || _h === undefined ? undefined : _h.extensionASTNodes) !== null && _j !== undefined ? _j : []);
          } else if (fieldName === "extensions" && type.extensions != null && resolverValue.extensions != null) {
            type.extensions = Object.assign(Object.create(null), type.extensions, resolverValue.extensions);
          } else {
            type[fieldName] = resolverValue[fieldName];
          }
        }
      } else if (graphql.isEnumType(type)) {
        const config = type.toConfig();
        const enumValueConfigMap = config.values;
        for (const fieldName in resolverValue) {
          if (fieldName.startsWith("__")) {
            config[fieldName.substring(2)] = resolverValue[fieldName];
          } else if (fieldName === "astNode" && config.astNode != null) {
            config.astNode = {
              ...config.astNode,
              description: (_m = (_l = (_k = resolverValue) === null || _k === undefined ? undefined : _k.astNode) === null || _l === undefined ? undefined : _l.description) !== null && _m !== undefined ? _m : config.astNode.description,
              directives: ((_o = config.astNode.directives) !== null && _o !== undefined ? _o : []).concat((_r = (_q = (_p = resolverValue) === null || _p === undefined ? undefined : _p.astNode) === null || _q === undefined ? undefined : _q.directives) !== null && _r !== undefined ? _r : [])
            };
          } else if (fieldName === "extensionASTNodes" && config.extensionASTNodes != null) {
            config.extensionASTNodes = config.extensionASTNodes.concat((_t = (_s = resolverValue) === null || _s === undefined ? undefined : _s.extensionASTNodes) !== null && _t !== undefined ? _t : []);
          } else if (fieldName === "extensions" && type.extensions != null && resolverValue.extensions != null) {
            type.extensions = Object.assign(Object.create(null), type.extensions, resolverValue.extensions);
          } else if (enumValueConfigMap[fieldName]) {
            enumValueConfigMap[fieldName].value = resolverValue[fieldName];
          }
        }
        typeMap[typeName] = new graphql.GraphQLEnumType(config);
      } else if (graphql.isUnionType(type)) {
        for (const fieldName in resolverValue) {
          if (fieldName.startsWith("__")) {
            type[fieldName.substring(2)] = resolverValue[fieldName];
          }
        }
      } else if (graphql.isObjectType(type) || graphql.isInterfaceType(type)) {
        for (const fieldName in resolverValue) {
          if (fieldName.startsWith("__")) {
            type[fieldName.substring(2)] = resolverValue[fieldName];
            break;
          }
          const fields = type.getFields();
          const field = fields[fieldName];
          if (field != null) {
            const fieldResolve = resolverValue[fieldName];
            if (typeof fieldResolve === "function") {
              field.resolve = fieldResolve.bind(resolverValue);
            } else {
              setFieldProperties(field, fieldResolve);
            }
          }
        }
      }
    }
    utils.forEachDefaultValue(schema, utils.serializeInputValue);
    utils.healSchema(schema);
    utils.forEachDefaultValue(schema, utils.parseInputValue);
    if (defaultFieldResolver != null) {
      utils.forEachField(schema, (field) => {
        if (!field.resolve) {
          field.resolve = defaultFieldResolver;
        }
      });
    }
    return schema;
  }
  function createNewSchemaWithResolvers(schema, resolvers, defaultFieldResolver) {
    schema = utils.mapSchema(schema, {
      [utils.MapperKind.SCALAR_TYPE]: (type) => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const config = type.toConfig();
        const resolverValue = resolvers[type.name];
        if (!graphql.isSpecifiedScalarType(type) && resolverValue != null) {
          for (const fieldName in resolverValue) {
            if (fieldName.startsWith("__")) {
              config[fieldName.substring(2)] = resolverValue[fieldName];
            } else if (fieldName === "astNode" && config.astNode != null) {
              config.astNode = {
                ...config.astNode,
                description: (_c = (_b = (_a = resolverValue) === null || _a === undefined ? undefined : _a.astNode) === null || _b === undefined ? undefined : _b.description) !== null && _c !== undefined ? _c : config.astNode.description,
                directives: ((_d = config.astNode.directives) !== null && _d !== undefined ? _d : []).concat((_g = (_f = (_e = resolverValue) === null || _e === undefined ? undefined : _e.astNode) === null || _f === undefined ? undefined : _f.directives) !== null && _g !== undefined ? _g : [])
              };
            } else if (fieldName === "extensionASTNodes" && config.extensionASTNodes != null) {
              config.extensionASTNodes = config.extensionASTNodes.concat((_j = (_h = resolverValue) === null || _h === undefined ? undefined : _h.extensionASTNodes) !== null && _j !== undefined ? _j : []);
            } else if (fieldName === "extensions" && config.extensions != null && resolverValue.extensions != null) {
              config.extensions = Object.assign(Object.create(null), type.extensions, resolverValue.extensions);
            } else {
              config[fieldName] = resolverValue[fieldName];
            }
          }
          return new graphql.GraphQLScalarType(config);
        }
      },
      [utils.MapperKind.ENUM_TYPE]: (type) => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const resolverValue = resolvers[type.name];
        const config = type.toConfig();
        const enumValueConfigMap = config.values;
        if (resolverValue != null) {
          for (const fieldName in resolverValue) {
            if (fieldName.startsWith("__")) {
              config[fieldName.substring(2)] = resolverValue[fieldName];
            } else if (fieldName === "astNode" && config.astNode != null) {
              config.astNode = {
                ...config.astNode,
                description: (_c = (_b = (_a = resolverValue) === null || _a === undefined ? undefined : _a.astNode) === null || _b === undefined ? undefined : _b.description) !== null && _c !== undefined ? _c : config.astNode.description,
                directives: ((_d = config.astNode.directives) !== null && _d !== undefined ? _d : []).concat((_g = (_f = (_e = resolverValue) === null || _e === undefined ? undefined : _e.astNode) === null || _f === undefined ? undefined : _f.directives) !== null && _g !== undefined ? _g : [])
              };
            } else if (fieldName === "extensionASTNodes" && config.extensionASTNodes != null) {
              config.extensionASTNodes = config.extensionASTNodes.concat((_j = (_h = resolverValue) === null || _h === undefined ? undefined : _h.extensionASTNodes) !== null && _j !== undefined ? _j : []);
            } else if (fieldName === "extensions" && config.extensions != null && resolverValue.extensions != null) {
              config.extensions = Object.assign(Object.create(null), type.extensions, resolverValue.extensions);
            } else if (enumValueConfigMap[fieldName]) {
              enumValueConfigMap[fieldName].value = resolverValue[fieldName];
            }
          }
          return new graphql.GraphQLEnumType(config);
        }
      },
      [utils.MapperKind.UNION_TYPE]: (type) => {
        const resolverValue = resolvers[type.name];
        if (resolverValue != null) {
          const config = type.toConfig();
          if (resolverValue["__resolveType"]) {
            config.resolveType = resolverValue["__resolveType"];
          }
          return new graphql.GraphQLUnionType(config);
        }
      },
      [utils.MapperKind.OBJECT_TYPE]: (type) => {
        const resolverValue = resolvers[type.name];
        if (resolverValue != null) {
          const config = type.toConfig();
          if (resolverValue["__isTypeOf"]) {
            config.isTypeOf = resolverValue["__isTypeOf"];
          }
          return new graphql.GraphQLObjectType(config);
        }
      },
      [utils.MapperKind.INTERFACE_TYPE]: (type) => {
        const resolverValue = resolvers[type.name];
        if (resolverValue != null) {
          const config = type.toConfig();
          if (resolverValue["__resolveType"]) {
            config.resolveType = resolverValue["__resolveType"];
          }
          return new graphql.GraphQLInterfaceType(config);
        }
      },
      [utils.MapperKind.COMPOSITE_FIELD]: (fieldConfig, fieldName, typeName) => {
        const resolverValue = resolvers[typeName];
        if (resolverValue != null) {
          const fieldResolve = resolverValue[fieldName];
          if (fieldResolve != null) {
            const newFieldConfig = { ...fieldConfig };
            if (typeof fieldResolve === "function") {
              newFieldConfig.resolve = fieldResolve.bind(resolverValue);
            } else {
              setFieldProperties(newFieldConfig, fieldResolve);
            }
            return newFieldConfig;
          }
        }
      }
    });
    if (defaultFieldResolver != null) {
      schema = utils.mapSchema(schema, {
        [utils.MapperKind.OBJECT_FIELD]: (fieldConfig) => ({
          ...fieldConfig,
          resolve: fieldConfig.resolve != null ? fieldConfig.resolve : defaultFieldResolver
        })
      });
    }
    return schema;
  }
  function setFieldProperties(field, propertiesObj) {
    for (const propertyName in propertiesObj) {
      field[propertyName] = propertiesObj[propertyName];
    }
  }
  function makeExecutableSchema({ typeDefs, resolvers = {}, resolverValidationOptions = {}, parseOptions = {}, inheritResolversFromInterfaces = false, pruningOptions, updateResolversInPlace = false, schemaExtensions }) {
    if (typeof resolverValidationOptions !== "object") {
      throw new Error("Expected `resolverValidationOptions` to be an object");
    }
    if (!typeDefs) {
      throw new Error("Must provide typeDefs");
    }
    let schema;
    if (graphql.isSchema(typeDefs)) {
      schema = typeDefs;
    } else if (parseOptions === null || parseOptions === undefined ? undefined : parseOptions.commentDescriptions) {
      const mergedTypeDefs = merge.mergeTypeDefs(typeDefs, {
        ...parseOptions,
        commentDescriptions: true
      });
      schema = graphql.buildSchema(mergedTypeDefs, parseOptions);
    } else {
      const mergedTypeDefs = merge.mergeTypeDefs(typeDefs, parseOptions);
      schema = graphql.buildASTSchema(mergedTypeDefs, parseOptions);
    }
    if (pruningOptions) {
      schema = utils.pruneSchema(schema);
    }
    schema = addResolversToSchema({
      schema,
      resolvers: merge.mergeResolvers(resolvers),
      resolverValidationOptions,
      inheritResolversFromInterfaces,
      updateResolversInPlace
    });
    if (Object.keys(resolverValidationOptions).length > 0) {
      assertResolversPresent(schema, resolverValidationOptions);
    }
    if (schemaExtensions) {
      schemaExtensions = merge.mergeExtensions(utils.asArray(schemaExtensions));
      merge.applyExtensions(schema, schemaExtensions);
    }
    return schema;
  }
  function mergeSchemas(config) {
    const extractedTypeDefs = utils.asArray(config.typeDefs || []);
    const extractedResolvers = utils.asArray(config.resolvers || []);
    const extractedSchemaExtensions = utils.asArray(config.schemaExtensions || []);
    const schemas = config.schemas || [];
    for (const schema of schemas) {
      extractedTypeDefs.push(schema);
      extractedResolvers.push(utils.getResolversFromSchema(schema));
      extractedSchemaExtensions.push(merge.extractExtensionsFromSchema(schema));
    }
    return makeExecutableSchema({
      parseOptions: config,
      ...config,
      typeDefs: extractedTypeDefs,
      resolvers: extractedResolvers,
      schemaExtensions: extractedSchemaExtensions
    });
  }
  exports.addResolversToSchema = addResolversToSchema;
  exports.assertResolversPresent = assertResolversPresent;
  exports.chainResolvers = chainResolvers;
  exports.checkForResolveTypeResolver = checkForResolveTypeResolver;
  exports.extendResolversFromInterfaces = extendResolversFromInterfaces;
  exports.makeExecutableSchema = makeExecutableSchema;
  exports.mergeSchemas = mergeSchemas;
});

// node_modules/@graphql-tools/mock/index.js
var require_mock = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  function _interopDefault(ex) {
    return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
  }
  var graphql = require_graphql2();
  var stringify = _interopDefault(require_fast_json_stable_stringify());
  var utils = require_utils5();
  var schema = require_schema2();
  function isRef(maybeRef) {
    return !!(maybeRef && typeof maybeRef === "object" && ("$ref" in maybeRef));
  }
  function assertIsRef(maybeRef, message2) {
    if (!isRef(maybeRef)) {
      throw new Error(message2 || `Expected ${maybeRef} to be a valid Ref.`);
    }
  }
  function isRecord(obj) {
    return typeof obj === "object" && obj !== null;
  }
  function uuidv4() {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
      const r = Math.random() * 16 | 0;
      const v = c == "x" ? r : r & 3 | 8;
      return v.toString(16);
    });
  }
  var randomListLength = () => {
    return 2;
  };
  var takeRandom = (arr) => arr[Math.floor(Math.random() * arr.length)];
  function makeRef(typeName, key) {
    return { $ref: { key, typeName } };
  }
  function isObject(thing) {
    return thing === Object(thing) && !Array.isArray(thing);
  }
  function copyOwnPropsIfNotPresent(target, source) {
    for (const prop of Object.getOwnPropertyNames(source)) {
      if (!Object.getOwnPropertyDescriptor(target, prop)) {
        const propertyDescriptor = Object.getOwnPropertyDescriptor(source, prop);
        Object.defineProperty(target, prop, propertyDescriptor == null ? {} : propertyDescriptor);
      }
    }
  }
  function copyOwnProps(target, ...sources) {
    for (const source of sources) {
      let chain = source;
      while (chain != null) {
        copyOwnPropsIfNotPresent(target, chain);
        chain = Object.getPrototypeOf(chain);
      }
    }
    return target;
  }
  function isMockList(obj) {
    if (typeof (obj === null || obj === undefined ? undefined : obj.len) === "number" || Array.isArray(obj === null || obj === undefined ? undefined : obj.len) && typeof (obj === null || obj === undefined ? undefined : obj.len[0]) === "number") {
      if (typeof obj.wrappedFunction === "undefined" || typeof obj.wrappedFunction === "function") {
        return true;
      }
    }
    return false;
  }

  class MockList {
    constructor(length, mockFunction) {
      this.len = length;
      if (typeof mockFunction !== "undefined") {
        if (typeof mockFunction !== "function") {
          throw new Error("Second argument to MockList must be a function or undefined");
        }
        this.wrappedFunction = mockFunction;
      }
    }
    mock() {
      let arr;
      if (Array.isArray(this.len)) {
        arr = new Array(this.randint(this.len[0], this.len[1]));
      } else {
        arr = new Array(this.len);
      }
      for (let i = 0;i < arr.length; i++) {
        if (typeof this.wrappedFunction === "function") {
          const res = this.wrappedFunction();
          if (isMockList(res)) {
            arr[i] = res.mock();
          } else {
            arr[i] = res;
          }
        } else {
          arr[i] = undefined;
        }
      }
      return arr;
    }
    randint(low, high) {
      return Math.floor(Math.random() * (high - low + 1) + low);
    }
  }
  function deepResolveMockList(mockList) {
    return mockList.mock().map((v) => {
      if (isMockList(v))
        return deepResolveMockList(v);
      return v;
    });
  }
  var defaultMocks = {
    Int: () => Math.round(Math.random() * 200) - 100,
    Float: () => Math.random() * 200 - 100,
    String: () => "Hello World",
    Boolean: () => Math.random() > 0.5,
    ID: () => uuidv4()
  };
  var defaultKeyFieldNames = ["id", "_id"];

  class MockStore {
    constructor({ schema: schema2, mocks, typePolicies }) {
      this.store = {};
      this.schema = schema2;
      this.mocks = { ...defaultMocks, ...mocks };
      this.typePolicies = typePolicies || {};
    }
    get(_typeName, _key, _fieldName, _fieldArgs) {
      if (typeof _typeName !== "string") {
        if (_key === undefined) {
          if (isRef(_typeName)) {
            throw new Error("Can't provide a ref as first argument and no other argument");
          }
          return this.getImpl(_typeName);
        } else {
          assertIsRef(_typeName);
          const { $ref } = _typeName;
          _fieldArgs = _fieldName;
          _fieldName = _key;
          _key = $ref.key;
          _typeName = $ref.typeName;
        }
      }
      const args2 = {
        typeName: _typeName
      };
      if (isRecord(_key) || _key === undefined) {
        args2.defaultValue = _key;
        return this.getImpl(args2);
      }
      args2.key = _key;
      if (Array.isArray(_fieldName) && _fieldName.length === 1) {
        _fieldName = _fieldName[0];
      }
      if (typeof _fieldName !== "string" && !Array.isArray(_fieldName)) {
        args2.defaultValue = _fieldName;
        return this.getImpl(args2);
      }
      if (Array.isArray(_fieldName)) {
        const ref = this.get(_typeName, _key, _fieldName[0], _fieldArgs);
        assertIsRef(ref);
        return this.get(ref.$ref.typeName, ref.$ref.key, _fieldName.slice(1, _fieldName.length));
      }
      args2.fieldName = _fieldName;
      args2.fieldArgs = _fieldArgs;
      return this.getImpl(args2);
    }
    set(_typeName, _key, _fieldName, _value) {
      if (typeof _typeName !== "string") {
        if (_key === undefined) {
          if (isRef(_typeName)) {
            throw new Error("Can't provide a ref as first argument and no other argument");
          }
          return this.setImpl(_typeName);
        } else {
          assertIsRef(_typeName);
          const { $ref } = _typeName;
          _value = _fieldName;
          _fieldName = _key;
          _key = $ref.key;
          _typeName = $ref.typeName;
        }
      }
      assertIsDefined(_key, "key was not provided");
      const args2 = {
        typeName: _typeName,
        key: _key
      };
      if (typeof _fieldName !== "string") {
        if (!isRecord(_fieldName))
          throw new Error("Expected value to be a record");
        args2.value = _fieldName;
        return this.setImpl(args2);
      }
      args2.fieldName = _fieldName;
      args2.value = _value;
      return this.setImpl(args2);
    }
    reset() {
      this.store = {};
    }
    filter(key, predicate) {
      const entity = this.store[key];
      return Object.values(entity).filter(predicate);
    }
    find(key, predicate) {
      const entity = this.store[key];
      return Object.values(entity).find(predicate);
    }
    getImpl(args2) {
      const { typeName, key, fieldName, fieldArgs, defaultValue } = args2;
      if (!fieldName) {
        if (defaultValue !== undefined && !isRecord(defaultValue)) {
          throw new Error("`defaultValue` should be an object");
        }
        let valuesToInsert = defaultValue || {};
        if (key) {
          valuesToInsert = { ...valuesToInsert, ...makeRef(typeName, key) };
        }
        return this.insert(typeName, valuesToInsert, true);
      }
      assertIsDefined(key, "key argument should be given when fieldName is given");
      const fieldNameInStore = getFieldNameInStore(fieldName, fieldArgs);
      if (this.store[typeName] === undefined || this.store[typeName][key] === undefined || this.store[typeName][key][fieldNameInStore] === undefined) {
        let value;
        if (defaultValue !== undefined) {
          value = defaultValue;
        } else if (this.isKeyField(typeName, fieldName)) {
          value = key;
        } else {
          value = this.generateFieldValue(typeName, fieldName, (otherFieldName, otherValue) => {
            if (this.isKeyField(typeName, otherFieldName))
              return;
            this.set({ typeName, key, fieldName: otherFieldName, value: otherValue, noOverride: true });
          });
        }
        this.set({ typeName, key, fieldName, fieldArgs, value, noOverride: true });
      }
      return this.store[typeName][key][fieldNameInStore];
    }
    setImpl(args2) {
      const { typeName, key, fieldName, fieldArgs, noOverride } = args2;
      let { value } = args2;
      if (isMockList(value)) {
        value = deepResolveMockList(value);
      }
      if (!fieldName) {
        if (!isRecord(value)) {
          throw new Error("When no `fieldName` is provided, `value` should be a record.");
        }
        for (const fieldName2 in value) {
          this.setImpl({
            typeName,
            key,
            fieldName: fieldName2,
            value: value[fieldName2],
            noOverride
          });
        }
        return;
      }
      const fieldNameInStore = getFieldNameInStore(fieldName, fieldArgs);
      if (this.isKeyField(typeName, fieldName) && value !== key) {
        throw new Error(`Field ${fieldName} is a key field of ${typeName} and you are trying to set it to ${value} while the key is ${key}`);
      }
      if (this.store[typeName] === undefined) {
        this.store[typeName] = {};
      }
      if (this.store[typeName][key] === undefined) {
        this.store[typeName][key] = {};
      }
      if (this.store[typeName][key][fieldNameInStore] !== undefined && noOverride) {
        return;
      }
      const fieldType = this.getFieldType(typeName, fieldName);
      const currentValue = this.store[typeName][key][fieldNameInStore];
      let valueToStore;
      try {
        valueToStore = this.normalizeValueToStore(fieldType, value, currentValue, (typeName2, values) => this.insert(typeName2, values, noOverride));
      } catch (e) {
        throw new Error(`Value to set in ${typeName}.${fieldName} in not normalizable: ${e.message}`);
      }
      this.store[typeName][key] = {
        ...this.store[typeName][key],
        [fieldNameInStore]: valueToStore
      };
    }
    normalizeValueToStore(fieldType, value, currentValue, onInsertType) {
      const fieldTypeName = fieldType.toString();
      if (value === null) {
        if (!graphql.isNullableType(fieldType)) {
          throw new Error(`should not be null because ${fieldTypeName} is not nullable. Received null.`);
        }
        return null;
      }
      const nullableFieldType = graphql.getNullableType(fieldType);
      if (value === undefined)
        return this.generateValueFromType(nullableFieldType);
      if (graphql.isCompositeType(nullableFieldType)) {
        if (!isRecord(value))
          throw new Error(`should be an object or null or undefined. Received ${value}`);
        let joinedTypeName;
        if (graphql.isAbstractType(nullableFieldType)) {
          if (isRef(value)) {
            joinedTypeName = value.$ref.typeName;
          } else {
            if (typeof value["__typename"] !== "string") {
              throw new Error(`should contain a '__typename' because ${nullableFieldType.name} an abstract type`);
            }
            joinedTypeName = value["__typename"];
          }
        } else {
          joinedTypeName = nullableFieldType.name;
        }
        return onInsertType(joinedTypeName, isRef(currentValue) ? { ...currentValue, ...value } : value);
      }
      if (graphql.isListType(nullableFieldType)) {
        if (!Array.isArray(value))
          throw new Error(`should be an array or null or undefined. Received ${value}`);
        return value.map((v, index) => {
          return this.normalizeValueToStore(nullableFieldType.ofType, v, typeof currentValue === "object" && currentValue != null && currentValue[index] ? currentValue : undefined, onInsertType);
        });
      }
      return value;
    }
    insert(typeName, values, noOverride) {
      const keyFieldName = this.getKeyFieldName(typeName);
      let key;
      const otherValues = {};
      if (isRef(values)) {
        key = values.$ref.key;
      } else if (keyFieldName && keyFieldName in values) {
        key = values[keyFieldName];
      } else {
        key = this.generateKeyForType(typeName, (otherFieldName, otherFieldValue) => {
          otherValues[otherFieldName] = otherFieldValue;
        });
      }
      const toInsert = { ...otherValues, ...values };
      for (const fieldName in toInsert) {
        if (fieldName === "$ref")
          continue;
        if (fieldName === "__typename")
          continue;
        this.set({
          typeName,
          key,
          fieldName,
          value: toInsert[fieldName],
          noOverride
        });
      }
      return makeRef(typeName, key);
    }
    generateFieldValue(typeName, fieldName, onOtherFieldsGenerated) {
      const mockedValue = this.generateFieldValueFromMocks(typeName, fieldName, onOtherFieldsGenerated);
      if (mockedValue !== undefined)
        return mockedValue;
      const fieldType = this.getFieldType(typeName, fieldName);
      return this.generateValueFromType(fieldType);
    }
    generateFieldValueFromMocks(typeName, fieldName, onOtherFieldsGenerated) {
      let value;
      const mock = this.mocks ? this.mocks[typeName] : undefined;
      if (mock) {
        if (typeof mock === "function") {
          const values = mock();
          if (typeof values !== "object" || values == null) {
            throw new Error(`Value returned by the mock for ${typeName} is not an object`);
          }
          for (const otherFieldName in values) {
            if (otherFieldName === fieldName)
              continue;
            if (typeof values[otherFieldName] === "function")
              continue;
            onOtherFieldsGenerated && onOtherFieldsGenerated(otherFieldName, values[otherFieldName]);
          }
          value = values[fieldName];
          if (typeof value === "function")
            value = value();
        } else if (typeof mock === "object" && mock != null && typeof mock[fieldName] === "function") {
          value = mock[fieldName]();
        }
      }
      if (value !== undefined)
        return value;
      const type = this.getType(typeName);
      const interfaces = "getInterfaces" in type ? type.getInterfaces() : [];
      if (interfaces.length > 0) {
        for (const interface_ of interfaces) {
          if (value)
            break;
          value = this.generateFieldValueFromMocks(interface_.name, fieldName, onOtherFieldsGenerated);
        }
      }
      return value;
    }
    generateKeyForType(typeName, onOtherFieldsGenerated) {
      const keyFieldName = this.getKeyFieldName(typeName);
      if (!keyFieldName)
        return uuidv4();
      return this.generateFieldValue(typeName, keyFieldName, onOtherFieldsGenerated);
    }
    generateValueFromType(fieldType) {
      const nullableType = graphql.getNullableType(fieldType);
      if (graphql.isScalarType(nullableType)) {
        const mockFn = this.mocks[nullableType.name];
        if (typeof mockFn !== "function")
          throw new Error(`No mock defined for type "${nullableType.name}"`);
        return mockFn();
      } else if (graphql.isEnumType(nullableType)) {
        const mockFn = this.mocks[nullableType.name];
        if (typeof mockFn === "function")
          return mockFn();
        const values = nullableType.getValues().map((v) => v.value);
        return takeRandom(values);
      } else if (graphql.isObjectType(nullableType)) {
        return this.insert(nullableType.name, {});
      } else if (graphql.isListType(nullableType)) {
        return [...new Array(randomListLength())].map(() => this.generateValueFromType(nullableType.ofType));
      } else if (graphql.isAbstractType(nullableType)) {
        const mock = this.mocks[nullableType.name];
        let typeName;
        let values = {};
        if (!mock) {
          typeName = takeRandom(this.schema.getPossibleTypes(nullableType).map((t) => t.name));
        } else if (typeof mock === "function") {
          const mockRes = mock();
          if (mockRes === null)
            return null;
          if (!isRecord(mockRes)) {
            throw new Error(`Value returned by the mock for ${nullableType.name} is not an object or null`);
          }
          values = mockRes;
          if (typeof values["__typename"] !== "string") {
            throw new Error(`Please return a __typename in "${nullableType.name}"`);
          }
          typeName = values["__typename"];
        } else if (typeof mock === "object" && mock != null && typeof mock["__typename"] === "function") {
          const mockRes = mock["__typename"]();
          if (typeof mockRes !== "string")
            throw new Error(`'__typename' returned by the mock for abstract type ${nullableType.name} is not a string`);
          typeName = mockRes;
        } else {
          throw new Error(`Please return a __typename in "${nullableType.name}"`);
        }
        const toInsert = {};
        for (const fieldName in values) {
          if (fieldName === "__typename")
            continue;
          const fieldValue = values[fieldName];
          toInsert[fieldName] = typeof fieldValue === "function" ? fieldValue() : fieldValue;
        }
        return this.insert(typeName, toInsert);
      } else {
        throw new Error(`${nullableType} not implemented`);
      }
    }
    getFieldType(typeName, fieldName) {
      if (fieldName === "__typename") {
        return graphql.GraphQLString;
      }
      const type = this.getType(typeName);
      const field = type.getFields()[fieldName];
      if (!field) {
        throw new Error(`${fieldName} does not exist on type ${typeName}`);
      }
      return field.type;
    }
    getType(typeName) {
      const type = this.schema.getType(typeName);
      if (!type || !(graphql.isObjectType(type) || graphql.isInterfaceType(type))) {
        throw new Error(`${typeName} does not exist on schema or is not an object or interface`);
      }
      return type;
    }
    isKeyField(typeName, fieldName) {
      return this.getKeyFieldName(typeName) === fieldName;
    }
    getKeyFieldName(typeName) {
      var _a;
      const typePolicyKeyField = (_a = this.typePolicies[typeName]) === null || _a === undefined ? undefined : _a.keyFieldName;
      if (typePolicyKeyField !== undefined) {
        if (typePolicyKeyField === false)
          return null;
        return typePolicyKeyField;
      }
      const gqlType = this.getType(typeName);
      for (const fieldName in gqlType.getFields()) {
        if (defaultKeyFieldNames.includes(fieldName)) {
          return fieldName;
        }
      }
      return null;
    }
  }
  var getFieldNameInStore = (fieldName, fieldArgs) => {
    if (!fieldArgs)
      return fieldName;
    if (typeof fieldArgs === "string") {
      return `${fieldName}:${fieldArgs}`;
    }
    if (Object.keys(fieldArgs).length === 0) {
      return fieldName;
    }
    return `${fieldName}:${stringify(fieldArgs)}`;
  };
  function assertIsDefined(value, message2) {
    if (value !== undefined && value !== null) {
      return;
    }
    throw new Error(process.env["NODE_ENV"] === "production" ? "Invariant failed:" : `Invariant failed: ${message2 || ""}`);
  }
  function createMockStore(options) {
    return new MockStore(options);
  }
  function addMocksToSchema({ schema: schema$1, store: maybeStore, mocks, typePolicies, resolvers: resolversOrFnResolvers, preserveResolvers = false }) {
    if (!schema$1) {
      throw new Error("Must provide schema to mock");
    }
    if (!graphql.isSchema(schema$1)) {
      throw new Error('Value at "schema" must be of type GraphQLSchema');
    }
    if (mocks && !isObject(mocks)) {
      throw new Error("mocks must be of type Object");
    }
    const store = maybeStore || createMockStore({
      schema: schema$1,
      mocks,
      typePolicies
    });
    const resolvers = typeof resolversOrFnResolvers === "function" ? resolversOrFnResolvers(store) : resolversOrFnResolvers;
    const mockResolver = (source, args2, contex, info) => {
      const defaultResolvedValue = graphql.defaultFieldResolver(source, args2, contex, info);
      if (defaultResolvedValue !== undefined)
        return defaultResolvedValue;
      if (isRef(source)) {
        return store.get({
          typeName: source.$ref.typeName,
          key: source.$ref.key,
          fieldName: info.fieldName,
          fieldArgs: args2
        });
      }
      if (isRootType(info.parentType, info.schema)) {
        return store.get({
          typeName: info.parentType.name,
          key: "ROOT",
          fieldName: info.fieldName,
          fieldArgs: args2
        });
      }
      return;
    };
    const typeResolver = (data) => {
      if (isRef(data)) {
        return data.$ref.typeName;
      }
    };
    const mockSubscriber = () => ({
      [Symbol.asyncIterator]() {
        return {
          async next() {
            return {
              done: true,
              value: {}
            };
          }
        };
      }
    });
    const schemaWithMocks = utils.mapSchema(schema$1, {
      [utils.MapperKind.OBJECT_FIELD]: (fieldConfig) => {
        const newFieldConfig = {
          ...fieldConfig
        };
        const oldResolver = fieldConfig.resolve;
        if (!preserveResolvers || !oldResolver) {
          newFieldConfig.resolve = mockResolver;
        } else {
          newFieldConfig.resolve = async (rootObject, args2, context, info) => {
            const [mockedValue, resolvedValue] = await Promise.all([
              mockResolver(rootObject, args2, context, info),
              oldResolver(rootObject, args2, context, info)
            ]);
            if (mockedValue instanceof Error) {
              if (resolvedValue === undefined) {
                throw mockedValue;
              }
              return resolvedValue;
            }
            if (resolvedValue instanceof Date && mockedValue instanceof Date) {
              return resolvedValue !== undefined ? resolvedValue : mockedValue;
            }
            if (isObject(mockedValue) && isObject(resolvedValue)) {
              const emptyObject = Object.create(Object.getPrototypeOf(resolvedValue));
              return copyOwnProps(emptyObject, resolvedValue, mockedValue);
            }
            return resolvedValue !== undefined ? resolvedValue : mockedValue;
          };
        }
        const fieldSubscriber = fieldConfig.subscribe;
        if (!preserveResolvers || !fieldSubscriber) {
          newFieldConfig.subscribe = mockSubscriber;
        } else {
          newFieldConfig.subscribe = async (rootObject, args2, context, info) => {
            const [mockAsyncIterable, oldAsyncIterable] = await Promise.all([
              mockSubscriber(),
              fieldSubscriber(rootObject, args2, context, info)
            ]);
            return oldAsyncIterable || mockAsyncIterable;
          };
        }
        return newFieldConfig;
      },
      [utils.MapperKind.ABSTRACT_TYPE]: (type) => {
        if (preserveResolvers && type.resolveType != null && type.resolveType.length) {
          return;
        }
        if (graphql.isUnionType(type)) {
          return new graphql.GraphQLUnionType({
            ...type.toConfig(),
            resolveType: typeResolver
          });
        } else {
          return new graphql.GraphQLInterfaceType({
            ...type.toConfig(),
            resolveType: typeResolver
          });
        }
      }
    });
    return resolvers ? schema.addResolversToSchema(schemaWithMocks, resolvers) : schemaWithMocks;
  }
  var isRootType = (type, schema2) => {
    const rootTypeNames = utils.getRootTypeNames(schema2);
    return rootTypeNames.has(type.name);
  };
  function mockServer(schema$1, mocks, preserveResolvers = false) {
    const mockedSchema = addMocksToSchema({
      schema: graphql.isSchema(schema$1) ? schema$1 : schema.makeExecutableSchema({
        typeDefs: schema$1
      }),
      mocks,
      preserveResolvers
    });
    return {
      query: (query, vars) => graphql.graphql({
        schema: mockedSchema,
        source: query,
        rootValue: {},
        contextValue: {},
        variableValues: vars
      })
    };
  }
  exports.MockList = MockList;
  exports.MockStore = MockStore;
  exports.addMocksToSchema = addMocksToSchema;
  exports.assertIsRef = assertIsRef;
  exports.createMockStore = createMockStore;
  exports.deepResolveMockList = deepResolveMockList;
  exports.defaultMocks = defaultMocks;
  exports.isMockList = isMockList;
  exports.isRecord = isRecord;
  exports.isRef = isRef;
  exports.mockServer = mockServer;
});

// node_modules/apollo-server-core/node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/index.js
var require_utils6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var graphql = require_graphql2();
  var asArray = (fns) => Array.isArray(fns) ? fns : fns ? [fns] : [];
  var invalidDocRegex = /\.[a-z0-9]+$/i;
  function isDocumentString(str) {
    if (typeof str !== "string") {
      return false;
    }
    if (invalidDocRegex.test(str)) {
      return false;
    }
    try {
      graphql.parse(str);
      return true;
    } catch (e) {}
    return false;
  }
  var invalidPathRegex = /[!%&^<=>`]/;
  function isValidPath(str) {
    return typeof str === "string" && !invalidPathRegex.test(str);
  }
  function compareStrings(a, b) {
    if (String(a) < String(b)) {
      return -1;
    }
    if (String(a) > String(b)) {
      return 1;
    }
    return 0;
  }
  function nodeToString(a) {
    var _a, _b;
    let name;
    if ("alias" in a) {
      name = (_a = a.alias) === null || _a === undefined ? undefined : _a.value;
    }
    if (name == null && "name" in a) {
      name = (_b = a.name) === null || _b === undefined ? undefined : _b.value;
    }
    if (name == null) {
      name = a.kind;
    }
    return name;
  }
  function compareNodes(a, b, customFn) {
    const aStr = nodeToString(a);
    const bStr = nodeToString(b);
    if (typeof customFn === "function") {
      return customFn(aStr, bStr);
    }
    return compareStrings(aStr, bStr);
  }
  function isSome(input) {
    return input != null;
  }
  function assertSome(input, message2 = "Value should be something") {
    if (input == null) {
      throw new Error(message2);
    }
  }
  var MAX_ARRAY_LENGTH = 10;
  var MAX_RECURSIVE_DEPTH = 2;
  function inspect(value) {
    return formatValue(value, []);
  }
  function formatValue(value, seenValues) {
    switch (typeof value) {
      case "string":
        return JSON.stringify(value);
      case "function":
        return value.name ? `[function ${value.name}]` : "[function]";
      case "object":
        return formatObjectValue(value, seenValues);
      default:
        return String(value);
    }
  }
  function formatObjectValue(value, previouslySeenValues) {
    if (value === null) {
      return "null";
    }
    if (previouslySeenValues.includes(value)) {
      return "[Circular]";
    }
    const seenValues = [...previouslySeenValues, value];
    if (isJSONable(value)) {
      const jsonValue = value.toJSON();
      if (jsonValue !== value) {
        return typeof jsonValue === "string" ? jsonValue : formatValue(jsonValue, seenValues);
      }
    } else if (Array.isArray(value)) {
      return formatArray(value, seenValues);
    }
    return formatObject(value, seenValues);
  }
  function isJSONable(value) {
    return typeof value.toJSON === "function";
  }
  function formatObject(object, seenValues) {
    const entries = Object.entries(object);
    if (entries.length === 0) {
      return "{}";
    }
    if (seenValues.length > MAX_RECURSIVE_DEPTH) {
      return "[" + getObjectTag(object) + "]";
    }
    const properties = entries.map(([key, value]) => key + ": " + formatValue(value, seenValues));
    return "{ " + properties.join(", ") + " }";
  }
  function formatArray(array, seenValues) {
    if (array.length === 0) {
      return "[]";
    }
    if (seenValues.length > MAX_RECURSIVE_DEPTH) {
      return "[Array]";
    }
    const len = Math.min(MAX_ARRAY_LENGTH, array.length);
    const remaining = array.length - len;
    const items = [];
    for (let i = 0;i < len; ++i) {
      items.push(formatValue(array[i], seenValues));
    }
    if (remaining === 1) {
      items.push("... 1 more item");
    } else if (remaining > 1) {
      items.push(`... ${remaining} more items`);
    }
    return "[" + items.join(", ") + "]";
  }
  function getObjectTag(object) {
    const tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
    if (tag === "Object" && typeof object.constructor === "function") {
      const name = object.constructor.name;
      if (typeof name === "string" && name !== "") {
        return name;
      }
    }
    return tag;
  }
  function getArgumentValues(def, node, variableValues = {}) {
    var _a;
    const variableMap = Object.entries(variableValues).reduce((prev, [key, value]) => ({
      ...prev,
      [key]: value
    }), {});
    const coercedValues = {};
    const argumentNodes = (_a = node.arguments) !== null && _a !== undefined ? _a : [];
    const argNodeMap = argumentNodes.reduce((prev, arg) => ({
      ...prev,
      [arg.name.value]: arg
    }), {});
    for (const { name, type: argType, defaultValue } of def.args) {
      const argumentNode = argNodeMap[name];
      if (!argumentNode) {
        if (defaultValue !== undefined) {
          coercedValues[name] = defaultValue;
        } else if (graphql.isNonNullType(argType)) {
          throw new graphql.GraphQLError(`Argument "${name}" of required type "${inspect(argType)}" ` + "was not provided.", node);
        }
        continue;
      }
      const valueNode = argumentNode.value;
      let isNull = valueNode.kind === graphql.Kind.NULL;
      if (valueNode.kind === graphql.Kind.VARIABLE) {
        const variableName = valueNode.name.value;
        if (variableValues == null || !variableMap[variableName]) {
          if (defaultValue !== undefined) {
            coercedValues[name] = defaultValue;
          } else if (graphql.isNonNullType(argType)) {
            throw new graphql.GraphQLError(`Argument "${name}" of required type "${inspect(argType)}" ` + `was provided the variable "$${variableName}" which was not provided a runtime value.`, valueNode);
          }
          continue;
        }
        isNull = variableValues[variableName] == null;
      }
      if (isNull && graphql.isNonNullType(argType)) {
        throw new graphql.GraphQLError(`Argument "${name}" of non-null type "${inspect(argType)}" ` + "must not be null.", valueNode);
      }
      const coercedValue = graphql.valueFromAST(valueNode, argType, variableValues);
      if (coercedValue === undefined) {
        throw new graphql.GraphQLError(`Argument "${name}" has invalid value ${graphql.print(valueNode)}.`, valueNode);
      }
      coercedValues[name] = coercedValue;
    }
    return coercedValues;
  }
  function getDirectivesInExtensions(node, pathToDirectivesInExtensions = ["directives"]) {
    return pathToDirectivesInExtensions.reduce((acc, pathSegment) => acc == null ? acc : acc[pathSegment], node === null || node === undefined ? undefined : node.extensions);
  }
  function _getDirectiveInExtensions(directivesInExtensions, directiveName) {
    const directiveInExtensions = directivesInExtensions.filter((directiveAnnotation) => directiveAnnotation.name === directiveName);
    if (!directiveInExtensions.length) {
      return;
    }
    return directiveInExtensions.map((directive) => {
      var _a;
      return (_a = directive.args) !== null && _a !== undefined ? _a : {};
    });
  }
  function getDirectiveInExtensions(node, directiveName, pathToDirectivesInExtensions = ["directives"]) {
    const directivesInExtensions = pathToDirectivesInExtensions.reduce((acc, pathSegment) => acc == null ? acc : acc[pathSegment], node === null || node === undefined ? undefined : node.extensions);
    if (directivesInExtensions === undefined) {
      return;
    }
    if (Array.isArray(directivesInExtensions)) {
      return _getDirectiveInExtensions(directivesInExtensions, directiveName);
    }
    const reformattedDirectivesInExtensions = [];
    for (const [name, argsOrArrayOfArgs] of Object.entries(directivesInExtensions)) {
      if (Array.isArray(argsOrArrayOfArgs)) {
        for (const args2 of argsOrArrayOfArgs) {
          reformattedDirectivesInExtensions.push({ name, args: args2 });
        }
      } else {
        reformattedDirectivesInExtensions.push({ name, args: argsOrArrayOfArgs });
      }
    }
    return _getDirectiveInExtensions(reformattedDirectivesInExtensions, directiveName);
  }
  function getDirectives(schema, node, pathToDirectivesInExtensions = ["directives"]) {
    const directivesInExtensions = getDirectivesInExtensions(node, pathToDirectivesInExtensions);
    if (directivesInExtensions != null && directivesInExtensions.length > 0) {
      return directivesInExtensions;
    }
    const schemaDirectives = schema && schema.getDirectives ? schema.getDirectives() : [];
    const schemaDirectiveMap = schemaDirectives.reduce((schemaDirectiveMap2, schemaDirective) => {
      schemaDirectiveMap2[schemaDirective.name] = schemaDirective;
      return schemaDirectiveMap2;
    }, {});
    let astNodes = [];
    if (node.astNode) {
      astNodes.push(node.astNode);
    }
    if ("extensionASTNodes" in node && node.extensionASTNodes) {
      astNodes = [...astNodes, ...node.extensionASTNodes];
    }
    const result = [];
    for (const astNode of astNodes) {
      if (astNode.directives) {
        for (const directiveNode of astNode.directives) {
          const schemaDirective = schemaDirectiveMap[directiveNode.name.value];
          if (schemaDirective) {
            result.push({ name: directiveNode.name.value, args: getArgumentValues(schemaDirective, directiveNode) });
          }
        }
      }
    }
    return result;
  }
  function getDirective(schema, node, directiveName, pathToDirectivesInExtensions = ["directives"]) {
    const directiveInExtensions = getDirectiveInExtensions(node, directiveName, pathToDirectivesInExtensions);
    if (directiveInExtensions != null) {
      return directiveInExtensions;
    }
    const schemaDirective = schema && schema.getDirective ? schema.getDirective(directiveName) : undefined;
    if (schemaDirective == null) {
      return;
    }
    let astNodes = [];
    if (node.astNode) {
      astNodes.push(node.astNode);
    }
    if ("extensionASTNodes" in node && node.extensionASTNodes) {
      astNodes = [...astNodes, ...node.extensionASTNodes];
    }
    const result = [];
    for (const astNode of astNodes) {
      if (astNode.directives) {
        for (const directiveNode of astNode.directives) {
          if (directiveNode.name.value === directiveName) {
            result.push(getArgumentValues(schemaDirective, directiveNode));
          }
        }
      }
    }
    if (!result.length) {
      return;
    }
    return result;
  }
  function parseDirectiveValue(value) {
    switch (value.kind) {
      case graphql.Kind.INT:
        return parseInt(value.value);
      case graphql.Kind.FLOAT:
        return parseFloat(value.value);
      case graphql.Kind.BOOLEAN:
        return Boolean(value.value);
      case graphql.Kind.STRING:
      case graphql.Kind.ENUM:
        return value.value;
      case graphql.Kind.LIST:
        return value.values.map((v) => parseDirectiveValue(v));
      case graphql.Kind.OBJECT:
        return value.fields.reduce((prev, v) => ({ ...prev, [v.name.value]: parseDirectiveValue(v.value) }), {});
      case graphql.Kind.NULL:
        return null;
      default:
        return null;
    }
  }
  function getFieldsWithDirectives(documentNode, options = {}) {
    const result = {};
    let selected = ["ObjectTypeDefinition", "ObjectTypeExtension"];
    if (options.includeInputTypes) {
      selected = [...selected, "InputObjectTypeDefinition", "InputObjectTypeExtension"];
    }
    const allTypes = documentNode.definitions.filter((obj) => selected.includes(obj.kind));
    for (const type of allTypes) {
      const typeName = type.name.value;
      if (type.fields == null) {
        continue;
      }
      for (const field of type.fields) {
        if (field.directives && field.directives.length > 0) {
          const fieldName = field.name.value;
          const key = `${typeName}.${fieldName}`;
          const directives = field.directives.map((d) => ({
            name: d.name.value,
            args: (d.arguments || []).reduce((prev, arg) => ({ ...prev, [arg.name.value]: parseDirectiveValue(arg.value) }), {})
          }));
          result[key] = directives;
        }
      }
    }
    return result;
  }
  function getImplementingTypes(interfaceName, schema) {
    const allTypesMap = schema.getTypeMap();
    const result = [];
    for (const graphqlTypeName in allTypesMap) {
      const graphqlType = allTypesMap[graphqlTypeName];
      if (graphql.isObjectType(graphqlType)) {
        const allInterfaces = graphqlType.getInterfaces();
        if (allInterfaces.find((int) => int.name === interfaceName)) {
          result.push(graphqlType.name);
        }
      }
    }
    return result;
  }
  function astFromType(type) {
    if (graphql.isNonNullType(type)) {
      const innerType = astFromType(type.ofType);
      if (innerType.kind === graphql.Kind.NON_NULL_TYPE) {
        throw new Error(`Invalid type node ${inspect(type)}. Inner type of non-null type cannot be a non-null type.`);
      }
      return {
        kind: graphql.Kind.NON_NULL_TYPE,
        type: innerType
      };
    } else if (graphql.isListType(type)) {
      return {
        kind: graphql.Kind.LIST_TYPE,
        type: astFromType(type.ofType)
      };
    }
    return {
      kind: graphql.Kind.NAMED_TYPE,
      name: {
        kind: graphql.Kind.NAME,
        value: type.name
      }
    };
  }
  function astFromValueUntyped(value) {
    if (value === null) {
      return { kind: graphql.Kind.NULL };
    }
    if (value === undefined) {
      return null;
    }
    if (Array.isArray(value)) {
      const valuesNodes = [];
      for (const item of value) {
        const itemNode = astFromValueUntyped(item);
        if (itemNode != null) {
          valuesNodes.push(itemNode);
        }
      }
      return { kind: graphql.Kind.LIST, values: valuesNodes };
    }
    if (typeof value === "object") {
      const fieldNodes = [];
      for (const fieldName in value) {
        const fieldValue = value[fieldName];
        const ast = astFromValueUntyped(fieldValue);
        if (ast) {
          fieldNodes.push({
            kind: graphql.Kind.OBJECT_FIELD,
            name: { kind: graphql.Kind.NAME, value: fieldName },
            value: ast
          });
        }
      }
      return { kind: graphql.Kind.OBJECT, fields: fieldNodes };
    }
    if (typeof value === "boolean") {
      return { kind: graphql.Kind.BOOLEAN, value };
    }
    if (typeof value === "number" && isFinite(value)) {
      const stringNum = String(value);
      return integerStringRegExp.test(stringNum) ? { kind: graphql.Kind.INT, value: stringNum } : { kind: graphql.Kind.FLOAT, value: stringNum };
    }
    if (typeof value === "string") {
      return { kind: graphql.Kind.STRING, value };
    }
    throw new TypeError(`Cannot convert value to AST: ${value}.`);
  }
  var integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;
  function memoize1(fn2) {
    const memoize1cache = new WeakMap;
    return function memoized(a1) {
      const cachedValue = memoize1cache.get(a1);
      if (cachedValue === undefined) {
        const newValue = fn2(a1);
        memoize1cache.set(a1, newValue);
        return newValue;
      }
      return cachedValue;
    };
  }
  function memoize2(fn2) {
    const memoize2cache = new WeakMap;
    return function memoized(a1, a2) {
      let cache2 = memoize2cache.get(a1);
      if (!cache2) {
        cache2 = new WeakMap;
        memoize2cache.set(a1, cache2);
        const newValue = fn2(a1, a2);
        cache2.set(a2, newValue);
        return newValue;
      }
      const cachedValue = cache2.get(a2);
      if (cachedValue === undefined) {
        const newValue = fn2(a1, a2);
        cache2.set(a2, newValue);
        return newValue;
      }
      return cachedValue;
    };
  }
  function memoize3(fn2) {
    const memoize3Cache = new WeakMap;
    return function memoized(a1, a2, a3) {
      let cache2 = memoize3Cache.get(a1);
      if (!cache2) {
        cache2 = new WeakMap;
        memoize3Cache.set(a1, cache2);
        const cache32 = new WeakMap;
        cache2.set(a2, cache32);
        const newValue = fn2(a1, a2, a3);
        cache32.set(a3, newValue);
        return newValue;
      }
      let cache3 = cache2.get(a2);
      if (!cache3) {
        cache3 = new WeakMap;
        cache2.set(a2, cache3);
        const newValue = fn2(a1, a2, a3);
        cache3.set(a3, newValue);
        return newValue;
      }
      const cachedValue = cache3.get(a3);
      if (cachedValue === undefined) {
        const newValue = fn2(a1, a2, a3);
        cache3.set(a3, newValue);
        return newValue;
      }
      return cachedValue;
    };
  }
  function memoize4(fn2) {
    const memoize4Cache = new WeakMap;
    return function memoized(a1, a2, a3, a4) {
      let cache2 = memoize4Cache.get(a1);
      if (!cache2) {
        cache2 = new WeakMap;
        memoize4Cache.set(a1, cache2);
        const cache32 = new WeakMap;
        cache2.set(a2, cache32);
        const cache42 = new WeakMap;
        cache32.set(a3, cache42);
        const newValue = fn2(a1, a2, a3, a4);
        cache42.set(a4, newValue);
        return newValue;
      }
      let cache3 = cache2.get(a2);
      if (!cache3) {
        cache3 = new WeakMap;
        cache2.set(a2, cache3);
        const cache42 = new WeakMap;
        cache3.set(a3, cache42);
        const newValue = fn2(a1, a2, a3, a4);
        cache42.set(a4, newValue);
        return newValue;
      }
      const cache4 = cache3.get(a3);
      if (!cache4) {
        const cache42 = new WeakMap;
        cache3.set(a3, cache42);
        const newValue = fn2(a1, a2, a3, a4);
        cache42.set(a4, newValue);
        return newValue;
      }
      const cachedValue = cache4.get(a4);
      if (cachedValue === undefined) {
        const newValue = fn2(a1, a2, a3, a4);
        cache4.set(a4, newValue);
        return newValue;
      }
      return cachedValue;
    };
  }
  function memoize5(fn2) {
    const memoize5Cache = new WeakMap;
    return function memoized(a1, a2, a3, a4, a5) {
      let cache2 = memoize5Cache.get(a1);
      if (!cache2) {
        cache2 = new WeakMap;
        memoize5Cache.set(a1, cache2);
        const cache32 = new WeakMap;
        cache2.set(a2, cache32);
        const cache42 = new WeakMap;
        cache32.set(a3, cache42);
        const cache52 = new WeakMap;
        cache42.set(a4, cache52);
        const newValue = fn2(a1, a2, a3, a4, a5);
        cache52.set(a5, newValue);
        return newValue;
      }
      let cache3 = cache2.get(a2);
      if (!cache3) {
        cache3 = new WeakMap;
        cache2.set(a2, cache3);
        const cache42 = new WeakMap;
        cache3.set(a3, cache42);
        const cache52 = new WeakMap;
        cache42.set(a4, cache52);
        const newValue = fn2(a1, a2, a3, a4, a5);
        cache52.set(a5, newValue);
        return newValue;
      }
      let cache4 = cache3.get(a3);
      if (!cache4) {
        cache4 = new WeakMap;
        cache3.set(a3, cache4);
        const cache52 = new WeakMap;
        cache4.set(a4, cache52);
        const newValue = fn2(a1, a2, a3, a4, a5);
        cache52.set(a5, newValue);
        return newValue;
      }
      let cache5 = cache4.get(a4);
      if (!cache5) {
        cache5 = new WeakMap;
        cache4.set(a4, cache5);
        const newValue = fn2(a1, a2, a3, a4, a5);
        cache5.set(a5, newValue);
        return newValue;
      }
      const cachedValue = cache5.get(a5);
      if (cachedValue === undefined) {
        const newValue = fn2(a1, a2, a3, a4, a5);
        cache5.set(a5, newValue);
        return newValue;
      }
      return cachedValue;
    };
  }
  var memoize2of4cache = new WeakMap;
  function memoize2of4(fn2) {
    return function memoized(a1, a2, a3, a4) {
      let cache2 = memoize2of4cache.get(a1);
      if (!cache2) {
        cache2 = new WeakMap;
        memoize2of4cache.set(a1, cache2);
        const newValue = fn2(a1, a2, a3, a4);
        cache2.set(a2, newValue);
        return newValue;
      }
      const cachedValue = cache2.get(a2);
      if (cachedValue === undefined) {
        const newValue = fn2(a1, a2, a3, a4);
        cache2.set(a2, newValue);
        return newValue;
      }
      return cachedValue;
    };
  }
  function getDefinedRootType(schema, operation) {
    const rootTypeMap = getRootTypeMap(schema);
    const rootType = rootTypeMap.get(operation);
    if (rootType == null) {
      throw new Error(`Root type for operation "${operation}" not defined by the given schema.`);
    }
    return rootType;
  }
  var getRootTypeNames = memoize1(function getRootTypeNames(schema) {
    const rootTypes = getRootTypes(schema);
    return new Set([...rootTypes].map((type) => type.name));
  });
  var getRootTypes = memoize1(function getRootTypes(schema) {
    const rootTypeMap = getRootTypeMap(schema);
    return new Set(rootTypeMap.values());
  });
  var getRootTypeMap = memoize1(function getRootTypeMap(schema) {
    const rootTypeMap = new Map;
    const queryType = schema.getQueryType();
    if (queryType) {
      rootTypeMap.set("query", queryType);
    }
    const mutationType = schema.getMutationType();
    if (mutationType) {
      rootTypeMap.set("mutation", mutationType);
    }
    const subscriptionType = schema.getSubscriptionType();
    if (subscriptionType) {
      rootTypeMap.set("subscription", subscriptionType);
    }
    return rootTypeMap;
  });
  function getDocumentNodeFromSchema(schema, options = {}) {
    const pathToDirectivesInExtensions = options.pathToDirectivesInExtensions;
    const typesMap = schema.getTypeMap();
    const schemaNode = astFromSchema(schema, pathToDirectivesInExtensions);
    const definitions = schemaNode != null ? [schemaNode] : [];
    const directives = schema.getDirectives();
    for (const directive of directives) {
      if (graphql.isSpecifiedDirective(directive)) {
        continue;
      }
      definitions.push(astFromDirective(directive, schema, pathToDirectivesInExtensions));
    }
    for (const typeName in typesMap) {
      const type = typesMap[typeName];
      const isPredefinedScalar = graphql.isSpecifiedScalarType(type);
      const isIntrospection = graphql.isIntrospectionType(type);
      if (isPredefinedScalar || isIntrospection) {
        continue;
      }
      if (graphql.isObjectType(type)) {
        definitions.push(astFromObjectType(type, schema, pathToDirectivesInExtensions));
      } else if (graphql.isInterfaceType(type)) {
        definitions.push(astFromInterfaceType(type, schema, pathToDirectivesInExtensions));
      } else if (graphql.isUnionType(type)) {
        definitions.push(astFromUnionType(type, schema, pathToDirectivesInExtensions));
      } else if (graphql.isInputObjectType(type)) {
        definitions.push(astFromInputObjectType(type, schema, pathToDirectivesInExtensions));
      } else if (graphql.isEnumType(type)) {
        definitions.push(astFromEnumType(type, schema, pathToDirectivesInExtensions));
      } else if (graphql.isScalarType(type)) {
        definitions.push(astFromScalarType(type, schema, pathToDirectivesInExtensions));
      } else {
        throw new Error(`Unknown type ${type}.`);
      }
    }
    return {
      kind: graphql.Kind.DOCUMENT,
      definitions
    };
  }
  function printSchemaWithDirectives(schema, options = {}) {
    const documentNode = getDocumentNodeFromSchema(schema, options);
    return graphql.print(documentNode);
  }
  function astFromSchema(schema, pathToDirectivesInExtensions) {
    var _a, _b;
    const operationTypeMap = new Map([
      ["query", undefined],
      ["mutation", undefined],
      ["subscription", undefined]
    ]);
    const nodes = [];
    if (schema.astNode != null) {
      nodes.push(schema.astNode);
    }
    if (schema.extensionASTNodes != null) {
      for (const extensionASTNode of schema.extensionASTNodes) {
        nodes.push(extensionASTNode);
      }
    }
    for (const node of nodes) {
      if (node.operationTypes) {
        for (const operationTypeDefinitionNode of node.operationTypes) {
          operationTypeMap.set(operationTypeDefinitionNode.operation, operationTypeDefinitionNode);
        }
      }
    }
    const rootTypeMap = getRootTypeMap(schema);
    for (const [operationTypeNode, operationTypeDefinitionNode] of operationTypeMap) {
      const rootType = rootTypeMap.get(operationTypeNode);
      if (rootType != null) {
        const rootTypeAST = astFromType(rootType);
        if (operationTypeDefinitionNode != null) {
          operationTypeDefinitionNode.type = rootTypeAST;
        } else {
          operationTypeMap.set(operationTypeNode, {
            kind: graphql.Kind.OPERATION_TYPE_DEFINITION,
            operation: operationTypeNode,
            type: rootTypeAST
          });
        }
      }
    }
    const operationTypes = [...operationTypeMap.values()].filter(isSome);
    const directives = getDirectiveNodes(schema, schema, pathToDirectivesInExtensions);
    if (!operationTypes.length && !directives.length) {
      return null;
    }
    const schemaNode = {
      kind: operationTypes != null ? graphql.Kind.SCHEMA_DEFINITION : graphql.Kind.SCHEMA_EXTENSION,
      operationTypes,
      directives
    };
    schemaNode.description = ((_b = (_a = schema.astNode) === null || _a === undefined ? undefined : _a.description) !== null && _b !== undefined ? _b : schema.description != null) ? {
      kind: graphql.Kind.STRING,
      value: schema.description,
      block: true
    } : undefined;
    return schemaNode;
  }
  function astFromDirective(directive, schema, pathToDirectivesInExtensions) {
    var _a, _b, _c, _d;
    return {
      kind: graphql.Kind.DIRECTIVE_DEFINITION,
      description: (_b = (_a = directive.astNode) === null || _a === undefined ? undefined : _a.description) !== null && _b !== undefined ? _b : directive.description ? {
        kind: graphql.Kind.STRING,
        value: directive.description
      } : undefined,
      name: {
        kind: graphql.Kind.NAME,
        value: directive.name
      },
      arguments: (_c = directive.args) === null || _c === undefined ? undefined : _c.map((arg) => astFromArg(arg, schema, pathToDirectivesInExtensions)),
      repeatable: directive.isRepeatable,
      locations: ((_d = directive.locations) === null || _d === undefined ? undefined : _d.map((location) => ({
        kind: graphql.Kind.NAME,
        value: location
      }))) || []
    };
  }
  function getDirectiveNodes(entity, schema, pathToDirectivesInExtensions) {
    const directivesInExtensions = getDirectivesInExtensions(entity, pathToDirectivesInExtensions);
    let nodes = [];
    if (entity.astNode != null) {
      nodes.push(entity.astNode);
    }
    if ("extensionASTNodes" in entity && entity.extensionASTNodes != null) {
      nodes = nodes.concat(entity.extensionASTNodes);
    }
    let directives;
    if (directivesInExtensions != null) {
      directives = makeDirectiveNodes(schema, directivesInExtensions);
    } else {
      directives = [];
      for (const node of nodes) {
        if (node.directives) {
          directives.push(...node.directives);
        }
      }
    }
    return directives;
  }
  function getDeprecatableDirectiveNodes(entity, schema, pathToDirectivesInExtensions) {
    var _a, _b;
    let directiveNodesBesidesDeprecated = [];
    let deprecatedDirectiveNode = null;
    const directivesInExtensions = getDirectivesInExtensions(entity, pathToDirectivesInExtensions);
    let directives;
    if (directivesInExtensions != null) {
      directives = makeDirectiveNodes(schema, directivesInExtensions);
    } else {
      directives = (_a = entity.astNode) === null || _a === undefined ? undefined : _a.directives;
    }
    if (directives != null) {
      directiveNodesBesidesDeprecated = directives.filter((directive) => directive.name.value !== "deprecated");
      if (entity.deprecationReason != null) {
        deprecatedDirectiveNode = (_b = directives.filter((directive) => directive.name.value === "deprecated")) === null || _b === undefined ? undefined : _b[0];
      }
    }
    if (entity.deprecationReason != null && deprecatedDirectiveNode == null) {
      deprecatedDirectiveNode = makeDeprecatedDirective(entity.deprecationReason);
    }
    return deprecatedDirectiveNode == null ? directiveNodesBesidesDeprecated : [deprecatedDirectiveNode].concat(directiveNodesBesidesDeprecated);
  }
  function astFromArg(arg, schema, pathToDirectivesInExtensions) {
    var _a, _b, _c;
    return {
      kind: graphql.Kind.INPUT_VALUE_DEFINITION,
      description: (_b = (_a = arg.astNode) === null || _a === undefined ? undefined : _a.description) !== null && _b !== undefined ? _b : arg.description ? {
        kind: graphql.Kind.STRING,
        value: arg.description,
        block: true
      } : undefined,
      name: {
        kind: graphql.Kind.NAME,
        value: arg.name
      },
      type: astFromType(arg.type),
      defaultValue: arg.defaultValue !== undefined ? (_c = graphql.astFromValue(arg.defaultValue, arg.type)) !== null && _c !== undefined ? _c : undefined : undefined,
      directives: getDeprecatableDirectiveNodes(arg, schema, pathToDirectivesInExtensions)
    };
  }
  function astFromObjectType(type, schema, pathToDirectivesInExtensions) {
    var _a, _b;
    return {
      kind: graphql.Kind.OBJECT_TYPE_DEFINITION,
      description: (_b = (_a = type.astNode) === null || _a === undefined ? undefined : _a.description) !== null && _b !== undefined ? _b : type.description ? {
        kind: graphql.Kind.STRING,
        value: type.description,
        block: true
      } : undefined,
      name: {
        kind: graphql.Kind.NAME,
        value: type.name
      },
      fields: Object.values(type.getFields()).map((field) => astFromField(field, schema, pathToDirectivesInExtensions)),
      interfaces: Object.values(type.getInterfaces()).map((iFace) => astFromType(iFace)),
      directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions)
    };
  }
  function astFromInterfaceType(type, schema, pathToDirectivesInExtensions) {
    var _a, _b;
    const node = {
      kind: graphql.Kind.INTERFACE_TYPE_DEFINITION,
      description: (_b = (_a = type.astNode) === null || _a === undefined ? undefined : _a.description) !== null && _b !== undefined ? _b : type.description ? {
        kind: graphql.Kind.STRING,
        value: type.description,
        block: true
      } : undefined,
      name: {
        kind: graphql.Kind.NAME,
        value: type.name
      },
      fields: Object.values(type.getFields()).map((field) => astFromField(field, schema, pathToDirectivesInExtensions)),
      directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions)
    };
    if ("getInterfaces" in type) {
      node.interfaces = Object.values(type.getInterfaces()).map((iFace) => astFromType(iFace));
    }
    return node;
  }
  function astFromUnionType(type, schema, pathToDirectivesInExtensions) {
    var _a, _b;
    return {
      kind: graphql.Kind.UNION_TYPE_DEFINITION,
      description: (_b = (_a = type.astNode) === null || _a === undefined ? undefined : _a.description) !== null && _b !== undefined ? _b : type.description ? {
        kind: graphql.Kind.STRING,
        value: type.description,
        block: true
      } : undefined,
      name: {
        kind: graphql.Kind.NAME,
        value: type.name
      },
      directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions),
      types: type.getTypes().map((type2) => astFromType(type2))
    };
  }
  function astFromInputObjectType(type, schema, pathToDirectivesInExtensions) {
    var _a, _b;
    return {
      kind: graphql.Kind.INPUT_OBJECT_TYPE_DEFINITION,
      description: (_b = (_a = type.astNode) === null || _a === undefined ? undefined : _a.description) !== null && _b !== undefined ? _b : type.description ? {
        kind: graphql.Kind.STRING,
        value: type.description,
        block: true
      } : undefined,
      name: {
        kind: graphql.Kind.NAME,
        value: type.name
      },
      fields: Object.values(type.getFields()).map((field) => astFromInputField(field, schema, pathToDirectivesInExtensions)),
      directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions)
    };
  }
  function astFromEnumType(type, schema, pathToDirectivesInExtensions) {
    var _a, _b;
    return {
      kind: graphql.Kind.ENUM_TYPE_DEFINITION,
      description: (_b = (_a = type.astNode) === null || _a === undefined ? undefined : _a.description) !== null && _b !== undefined ? _b : type.description ? {
        kind: graphql.Kind.STRING,
        value: type.description,
        block: true
      } : undefined,
      name: {
        kind: graphql.Kind.NAME,
        value: type.name
      },
      values: Object.values(type.getValues()).map((value) => astFromEnumValue(value, schema, pathToDirectivesInExtensions)),
      directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions)
    };
  }
  function astFromScalarType(type, schema, pathToDirectivesInExtensions) {
    var _a, _b, _c;
    const directivesInExtensions = getDirectivesInExtensions(type, pathToDirectivesInExtensions);
    const directives = directivesInExtensions ? makeDirectiveNodes(schema, directivesInExtensions) : ((_a = type.astNode) === null || _a === undefined ? undefined : _a.directives) || [];
    if (type["specifiedByUrl"] && !directives.some((directiveNode) => directiveNode.name.value === "specifiedBy")) {
      const specifiedByArgs = {
        url: type["specifiedByUrl"]
      };
      directives.push(makeDirectiveNode("specifiedBy", specifiedByArgs));
    }
    return {
      kind: graphql.Kind.SCALAR_TYPE_DEFINITION,
      description: (_c = (_b = type.astNode) === null || _b === undefined ? undefined : _b.description) !== null && _c !== undefined ? _c : type.description ? {
        kind: graphql.Kind.STRING,
        value: type.description,
        block: true
      } : undefined,
      name: {
        kind: graphql.Kind.NAME,
        value: type.name
      },
      directives
    };
  }
  function astFromField(field, schema, pathToDirectivesInExtensions) {
    var _a, _b;
    return {
      kind: graphql.Kind.FIELD_DEFINITION,
      description: (_b = (_a = field.astNode) === null || _a === undefined ? undefined : _a.description) !== null && _b !== undefined ? _b : field.description ? {
        kind: graphql.Kind.STRING,
        value: field.description,
        block: true
      } : undefined,
      name: {
        kind: graphql.Kind.NAME,
        value: field.name
      },
      arguments: field.args.map((arg) => astFromArg(arg, schema, pathToDirectivesInExtensions)),
      type: astFromType(field.type),
      directives: getDeprecatableDirectiveNodes(field, schema, pathToDirectivesInExtensions)
    };
  }
  function astFromInputField(field, schema, pathToDirectivesInExtensions) {
    var _a, _b, _c;
    return {
      kind: graphql.Kind.INPUT_VALUE_DEFINITION,
      description: (_b = (_a = field.astNode) === null || _a === undefined ? undefined : _a.description) !== null && _b !== undefined ? _b : field.description ? {
        kind: graphql.Kind.STRING,
        value: field.description,
        block: true
      } : undefined,
      name: {
        kind: graphql.Kind.NAME,
        value: field.name
      },
      type: astFromType(field.type),
      directives: getDeprecatableDirectiveNodes(field, schema, pathToDirectivesInExtensions),
      defaultValue: (_c = graphql.astFromValue(field.defaultValue, field.type)) !== null && _c !== undefined ? _c : undefined
    };
  }
  function astFromEnumValue(value, schema, pathToDirectivesInExtensions) {
    var _a, _b;
    return {
      kind: graphql.Kind.ENUM_VALUE_DEFINITION,
      description: (_b = (_a = value.astNode) === null || _a === undefined ? undefined : _a.description) !== null && _b !== undefined ? _b : value.description ? {
        kind: graphql.Kind.STRING,
        value: value.description,
        block: true
      } : undefined,
      name: {
        kind: graphql.Kind.NAME,
        value: value.name
      },
      directives: getDirectiveNodes(value, schema, pathToDirectivesInExtensions)
    };
  }
  function makeDeprecatedDirective(deprecationReason) {
    return makeDirectiveNode("deprecated", { reason: deprecationReason }, graphql.GraphQLDeprecatedDirective);
  }
  function makeDirectiveNode(name, args2, directive) {
    const directiveArguments = [];
    if (directive != null) {
      for (const arg of directive.args) {
        const argName = arg.name;
        const argValue = args2[argName];
        if (argValue !== undefined) {
          const value = graphql.astFromValue(argValue, arg.type);
          if (value) {
            directiveArguments.push({
              kind: graphql.Kind.ARGUMENT,
              name: {
                kind: graphql.Kind.NAME,
                value: argName
              },
              value
            });
          }
        }
      }
    } else {
      for (const argName in args2) {
        const argValue = args2[argName];
        const value = astFromValueUntyped(argValue);
        if (value) {
          directiveArguments.push({
            kind: graphql.Kind.ARGUMENT,
            name: {
              kind: graphql.Kind.NAME,
              value: argName
            },
            value
          });
        }
      }
    }
    return {
      kind: graphql.Kind.DIRECTIVE,
      name: {
        kind: graphql.Kind.NAME,
        value: name
      },
      arguments: directiveArguments
    };
  }
  function makeDirectiveNodes(schema, directiveValues) {
    const directiveNodes = [];
    for (const directiveName in directiveValues) {
      const arrayOrSingleValue = directiveValues[directiveName];
      const directive = schema === null || schema === undefined ? undefined : schema.getDirective(directiveName);
      if (Array.isArray(arrayOrSingleValue)) {
        for (const value of arrayOrSingleValue) {
          directiveNodes.push(makeDirectiveNode(directiveName, value, directive));
        }
      } else {
        directiveNodes.push(makeDirectiveNode(directiveName, arrayOrSingleValue, directive));
      }
    }
    return directiveNodes;
  }
  exports.AggregateError = globalThis.AggregateError;
  if (typeof exports.AggregateError === "undefined") {

    class AggregateErrorClass extends Error {
      constructor(errors, message2 = "") {
        super(message2);
        this.errors = errors;
        this.name = "AggregateError";
        Error.captureStackTrace(this, AggregateErrorClass);
      }
    }
    exports.AggregateError = function(errors, message2) {
      return new AggregateErrorClass(errors, message2);
    };
  }
  async function validateGraphQlDocuments(schema, documentFiles, effectiveRules) {
    effectiveRules = effectiveRules || createDefaultRules();
    const allFragmentMap = new Map;
    const documentFileObjectsToValidate = [];
    for (const documentFile of documentFiles) {
      if (documentFile.document) {
        const definitionsToValidate = [];
        for (const definitionNode of documentFile.document.definitions) {
          if (definitionNode.kind === graphql.Kind.FRAGMENT_DEFINITION) {
            allFragmentMap.set(definitionNode.name.value, definitionNode);
          } else {
            definitionsToValidate.push(definitionNode);
          }
        }
        documentFileObjectsToValidate.push({
          location: documentFile.location,
          document: {
            kind: graphql.Kind.DOCUMENT,
            definitions: definitionsToValidate
          }
        });
      }
    }
    const allErrors = [];
    const allFragmentsDocument = {
      kind: graphql.Kind.DOCUMENT,
      definitions: [...allFragmentMap.values()]
    };
    await Promise.all(documentFileObjectsToValidate.map(async (documentFile) => {
      const documentToValidate = graphql.concatAST([allFragmentsDocument, documentFile.document]);
      const errors = graphql.validate(schema, documentToValidate, effectiveRules);
      if (errors.length > 0) {
        allErrors.push({
          filePath: documentFile.location,
          errors
        });
      }
    }));
    return allErrors;
  }
  function checkValidationErrors(loadDocumentErrors) {
    if (loadDocumentErrors.length > 0) {
      const errors = [];
      for (const loadDocumentError of loadDocumentErrors) {
        for (const graphQLError of loadDocumentError.errors) {
          const error = new Error;
          error.name = "GraphQLDocumentError";
          error.message = `${error.name}: ${graphQLError.message}`;
          error.stack = error.message;
          if (graphQLError.locations) {
            for (const location of graphQLError.locations) {
              error.stack += `
    at ${loadDocumentError.filePath}:${location.line}:${location.column}`;
            }
          }
          errors.push(error);
        }
      }
      throw new exports.AggregateError(errors, `GraphQL Document Validation failed with ${errors.length} errors;
  ${errors.map((error, index) => `Error ${index}: ${error.stack}`).join(`

`)}`);
    }
  }
  function createDefaultRules() {
    const ignored = ["NoUnusedFragmentsRule", "NoUnusedVariablesRule", "KnownDirectivesRule"];
    const v4ignored = ignored.map((rule) => rule.replace(/Rule$/, ""));
    return graphql.specifiedRules.filter((f) => !ignored.includes(f.name) && !v4ignored.includes(f.name));
  }
  function stripBOM(content) {
    content = content.toString();
    if (content.charCodeAt(0) === 65279) {
      content = content.slice(1);
    }
    return content;
  }
  function parseBOM(content) {
    return JSON.parse(stripBOM(content));
  }
  function parseGraphQLJSON(location, jsonContent, options) {
    let parsedJson = parseBOM(jsonContent);
    if (parsedJson.data) {
      parsedJson = parsedJson.data;
    }
    if (parsedJson.kind === "Document") {
      return {
        location,
        document: parsedJson
      };
    } else if (parsedJson.__schema) {
      const schema = graphql.buildClientSchema(parsedJson, options);
      return {
        location,
        schema
      };
    } else if (typeof parsedJson === "string") {
      return {
        location,
        rawSDL: parsedJson
      };
    }
    throw new Error(`Not valid JSON content`);
  }
  var MAX_LINE_LENGTH = 80;
  var commentsRegistry = {};
  function resetComments() {
    commentsRegistry = {};
  }
  function collectComment(node) {
    var _a;
    const entityName = (_a = node.name) === null || _a === undefined ? undefined : _a.value;
    if (entityName == null) {
      return;
    }
    pushComment(node, entityName);
    switch (node.kind) {
      case "EnumTypeDefinition":
        if (node.values) {
          for (const value of node.values) {
            pushComment(value, entityName, value.name.value);
          }
        }
        break;
      case "ObjectTypeDefinition":
      case "InputObjectTypeDefinition":
      case "InterfaceTypeDefinition":
        if (node.fields) {
          for (const field of node.fields) {
            pushComment(field, entityName, field.name.value);
            if (isFieldDefinitionNode(field) && field.arguments) {
              for (const arg of field.arguments) {
                pushComment(arg, entityName, field.name.value, arg.name.value);
              }
            }
          }
        }
        break;
    }
  }
  function pushComment(node, entity, field, argument) {
    const comment = getComment(node);
    if (typeof comment !== "string" || comment.length === 0) {
      return;
    }
    const keys = [entity];
    if (field) {
      keys.push(field);
      if (argument) {
        keys.push(argument);
      }
    }
    const path = keys.join(".");
    if (!commentsRegistry[path]) {
      commentsRegistry[path] = [];
    }
    commentsRegistry[path].push(comment);
  }
  function printComment(comment) {
    return `
# ` + comment.replace(/\n/g, `
# `);
  }
  function join(maybeArray, separator) {
    return maybeArray ? maybeArray.filter((x) => x).join(separator || "") : "";
  }
  function hasMultilineItems(maybeArray) {
    var _a;
    return (_a = maybeArray === null || maybeArray === undefined ? undefined : maybeArray.some((str) => str.includes(`
`))) !== null && _a !== undefined ? _a : false;
  }
  function addDescription(cb) {
    return (node, _key, _parent, path, ancestors) => {
      var _a;
      const keys = [];
      const parent = path.reduce((prev, key2) => {
        if (["fields", "arguments", "values"].includes(key2) && prev.name) {
          keys.push(prev.name.value);
        }
        return prev[key2];
      }, ancestors[0]);
      const key = [...keys, (_a = parent === null || parent === undefined ? undefined : parent.name) === null || _a === undefined ? undefined : _a.value].filter(Boolean).join(".");
      const items = [];
      if (node.kind.includes("Definition") && commentsRegistry[key]) {
        items.push(...commentsRegistry[key]);
      }
      return join([...items.map(printComment), node.description, cb(node, _key, _parent, path, ancestors)], `
`);
    };
  }
  function indent(maybeString) {
    return maybeString && `  ${maybeString.replace(/\n/g, `
  `)}`;
  }
  function block(array) {
    return array && array.length !== 0 ? `{
${indent(join(array, `
`))}
}` : "";
  }
  function wrap(start, maybeString, end) {
    return maybeString ? start + maybeString + (end || "") : "";
  }
  function printBlockString(value, isDescription = false) {
    const escaped = value.replace(/"""/g, '\\"""');
    return (value[0] === " " || value[0] === "\t") && value.indexOf(`
`) === -1 ? `"""${escaped.replace(/"$/, `"
`)}"""` : `"""
${isDescription ? escaped : indent(escaped)}
"""`;
  }
  var printDocASTReducer = {
    Name: { leave: (node) => node.value },
    Variable: { leave: (node) => "$" + node.name },
    Document: {
      leave: (node) => join(node.definitions, `

`)
    },
    OperationDefinition: {
      leave: (node) => {
        const varDefs = wrap("(", join(node.variableDefinitions, ", "), ")");
        const prefix = join([node.operation, join([node.name, varDefs]), join(node.directives, " ")], " ");
        return prefix + " " + node.selectionSet;
      }
    },
    VariableDefinition: {
      leave: ({ variable, type, defaultValue, directives }) => variable + ": " + type + wrap(" = ", defaultValue) + wrap(" ", join(directives, " "))
    },
    SelectionSet: { leave: ({ selections }) => block(selections) },
    Field: {
      leave({ alias, name, arguments: args2, directives, selectionSet }) {
        const prefix = wrap("", alias, ": ") + name;
        let argsLine = prefix + wrap("(", join(args2, ", "), ")");
        if (argsLine.length > MAX_LINE_LENGTH) {
          argsLine = prefix + wrap(`(
`, indent(join(args2, `
`)), `
)`);
        }
        return join([argsLine, join(directives, " "), selectionSet], " ");
      }
    },
    Argument: { leave: ({ name, value }) => name + ": " + value },
    FragmentSpread: {
      leave: ({ name, directives }) => "..." + name + wrap(" ", join(directives, " "))
    },
    InlineFragment: {
      leave: ({ typeCondition, directives, selectionSet }) => join(["...", wrap("on ", typeCondition), join(directives, " "), selectionSet], " ")
    },
    FragmentDefinition: {
      leave: ({ name, typeCondition, variableDefinitions, directives, selectionSet }) => `fragment ${name}${wrap("(", join(variableDefinitions, ", "), ")")} ` + `on ${typeCondition} ${wrap("", join(directives, " "), " ")}` + selectionSet
    },
    IntValue: { leave: ({ value }) => value },
    FloatValue: { leave: ({ value }) => value },
    StringValue: {
      leave: ({ value, block: isBlockString }) => {
        if (isBlockString) {
          return printBlockString(value);
        }
        return JSON.stringify(value);
      }
    },
    BooleanValue: { leave: ({ value }) => value ? "true" : "false" },
    NullValue: { leave: () => "null" },
    EnumValue: { leave: ({ value }) => value },
    ListValue: { leave: ({ values }) => "[" + join(values, ", ") + "]" },
    ObjectValue: { leave: ({ fields }) => "{" + join(fields, ", ") + "}" },
    ObjectField: { leave: ({ name, value }) => name + ": " + value },
    Directive: {
      leave: ({ name, arguments: args2 }) => "@" + name + wrap("(", join(args2, ", "), ")")
    },
    NamedType: { leave: ({ name }) => name },
    ListType: { leave: ({ type }) => "[" + type + "]" },
    NonNullType: { leave: ({ type }) => type + "!" },
    SchemaDefinition: {
      leave: ({ directives, operationTypes }) => join(["schema", join(directives, " "), block(operationTypes)], " ")
    },
    OperationTypeDefinition: {
      leave: ({ operation, type }) => operation + ": " + type
    },
    ScalarTypeDefinition: {
      leave: ({ name, directives }) => join(["scalar", name, join(directives, " ")], " ")
    },
    ObjectTypeDefinition: {
      leave: ({ name, interfaces, directives, fields }) => join(["type", name, wrap("implements ", join(interfaces, " & ")), join(directives, " "), block(fields)], " ")
    },
    FieldDefinition: {
      leave: ({ name, arguments: args2, type, directives }) => name + (hasMultilineItems(args2) ? wrap(`(
`, indent(join(args2, `
`)), `
)`) : wrap("(", join(args2, ", "), ")")) + ": " + type + wrap(" ", join(directives, " "))
    },
    InputValueDefinition: {
      leave: ({ name, type, defaultValue, directives }) => join([name + ": " + type, wrap("= ", defaultValue), join(directives, " ")], " ")
    },
    InterfaceTypeDefinition: {
      leave: ({ name, interfaces, directives, fields }) => join(["interface", name, wrap("implements ", join(interfaces, " & ")), join(directives, " "), block(fields)], " ")
    },
    UnionTypeDefinition: {
      leave: ({ name, directives, types }) => join(["union", name, join(directives, " "), wrap("= ", join(types, " | "))], " ")
    },
    EnumTypeDefinition: {
      leave: ({ name, directives, values }) => join(["enum", name, join(directives, " "), block(values)], " ")
    },
    EnumValueDefinition: {
      leave: ({ name, directives }) => join([name, join(directives, " ")], " ")
    },
    InputObjectTypeDefinition: {
      leave: ({ name, directives, fields }) => join(["input", name, join(directives, " "), block(fields)], " ")
    },
    DirectiveDefinition: {
      leave: ({ name, arguments: args2, repeatable, locations }) => "directive @" + name + (hasMultilineItems(args2) ? wrap(`(
`, indent(join(args2, `
`)), `
)`) : wrap("(", join(args2, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join(locations, " | ")
    },
    SchemaExtension: {
      leave: ({ directives, operationTypes }) => join(["extend schema", join(directives, " "), block(operationTypes)], " ")
    },
    ScalarTypeExtension: {
      leave: ({ name, directives }) => join(["extend scalar", name, join(directives, " ")], " ")
    },
    ObjectTypeExtension: {
      leave: ({ name, interfaces, directives, fields }) => join(["extend type", name, wrap("implements ", join(interfaces, " & ")), join(directives, " "), block(fields)], " ")
    },
    InterfaceTypeExtension: {
      leave: ({ name, interfaces, directives, fields }) => join(["extend interface", name, wrap("implements ", join(interfaces, " & ")), join(directives, " "), block(fields)], " ")
    },
    UnionTypeExtension: {
      leave: ({ name, directives, types }) => join(["extend union", name, join(directives, " "), wrap("= ", join(types, " | "))], " ")
    },
    EnumTypeExtension: {
      leave: ({ name, directives, values }) => join(["extend enum", name, join(directives, " "), block(values)], " ")
    },
    InputObjectTypeExtension: {
      leave: ({ name, directives, fields }) => join(["extend input", name, join(directives, " "), block(fields)], " ")
    }
  };
  var printDocASTReducerWithComments = Object.keys(printDocASTReducer).reduce((prev, key) => ({
    ...prev,
    [key]: {
      leave: addDescription(printDocASTReducer[key].leave)
    }
  }), {});
  function printWithComments(ast) {
    return graphql.visit(ast, printDocASTReducerWithComments);
  }
  function isFieldDefinitionNode(node) {
    return node.kind === "FieldDefinition";
  }
  function getDescription(node, options) {
    if (node.description != null) {
      return node.description.value;
    }
    if (options === null || options === undefined ? undefined : options.commentDescriptions) {
      return getComment(node);
    }
  }
  function getComment(node) {
    const rawValue = getLeadingCommentBlock(node);
    if (rawValue !== undefined) {
      return dedentBlockStringValue(`
${rawValue}`);
    }
  }
  function getLeadingCommentBlock(node) {
    const loc = node.loc;
    if (!loc) {
      return;
    }
    const comments = [];
    let token = loc.startToken.prev;
    while (token != null && token.kind === graphql.TokenKind.COMMENT && token.next != null && token.prev != null && token.line + 1 === token.next.line && token.line !== token.prev.line) {
      const value = String(token.value);
      comments.push(value);
      token = token.prev;
    }
    return comments.length > 0 ? comments.reverse().join(`
`) : undefined;
  }
  function dedentBlockStringValue(rawString) {
    const lines = rawString.split(/\r\n|[\n\r]/g);
    const commonIndent = getBlockStringIndentation(lines);
    if (commonIndent !== 0) {
      for (let i = 1;i < lines.length; i++) {
        lines[i] = lines[i].slice(commonIndent);
      }
    }
    while (lines.length > 0 && isBlank(lines[0])) {
      lines.shift();
    }
    while (lines.length > 0 && isBlank(lines[lines.length - 1])) {
      lines.pop();
    }
    return lines.join(`
`);
  }
  function getBlockStringIndentation(lines) {
    let commonIndent = null;
    for (let i = 1;i < lines.length; i++) {
      const line = lines[i];
      const indent2 = leadingWhitespace(line);
      if (indent2 === line.length) {
        continue;
      }
      if (commonIndent === null || indent2 < commonIndent) {
        commonIndent = indent2;
        if (commonIndent === 0) {
          break;
        }
      }
    }
    return commonIndent === null ? 0 : commonIndent;
  }
  function leadingWhitespace(str) {
    let i = 0;
    while (i < str.length && (str[i] === " " || str[i] === "\t")) {
      i++;
    }
    return i;
  }
  function isBlank(str) {
    return leadingWhitespace(str) === str.length;
  }
  function parseGraphQLSDL(location, rawSDL, options = {}) {
    let document2;
    try {
      if (options.commentDescriptions && rawSDL.includes("#")) {
        document2 = transformCommentsToDescriptions(rawSDL, options);
        if (options.noLocation) {
          document2 = graphql.parse(graphql.print(document2), options);
        }
      } else {
        document2 = graphql.parse(new graphql.Source(rawSDL, location), options);
      }
    } catch (e) {
      if (e.message.includes("EOF") && rawSDL.replace(/(\#[^*]*)/g, "").trim() === "") {
        document2 = {
          kind: graphql.Kind.DOCUMENT,
          definitions: []
        };
      } else {
        throw e;
      }
    }
    return {
      location,
      document: document2
    };
  }
  function transformCommentsToDescriptions(sourceSdl, options = {}) {
    const parsedDoc = graphql.parse(sourceSdl, {
      ...options,
      noLocation: false
    });
    const modifiedDoc = graphql.visit(parsedDoc, {
      leave: (node) => {
        if (isDescribable(node)) {
          const rawValue = getLeadingCommentBlock(node);
          if (rawValue !== undefined) {
            const commentsBlock = dedentBlockStringValue(`
` + rawValue);
            const isBlock = commentsBlock.includes(`
`);
            if (!node.description) {
              return {
                ...node,
                description: {
                  kind: graphql.Kind.STRING,
                  value: commentsBlock,
                  block: isBlock
                }
              };
            } else {
              return {
                ...node,
                description: {
                  ...node.description,
                  value: node.description.value + `
` + commentsBlock,
                  block: true
                }
              };
            }
          }
        }
      }
    });
    return modifiedDoc;
  }
  function isDescribable(node) {
    return graphql.isTypeSystemDefinitionNode(node) || node.kind === graphql.Kind.FIELD_DEFINITION || node.kind === graphql.Kind.INPUT_VALUE_DEFINITION || node.kind === graphql.Kind.ENUM_VALUE_DEFINITION;
  }
  var operationVariables = [];
  var fieldTypeMap = new Map;
  function addOperationVariable(variable) {
    operationVariables.push(variable);
  }
  function resetOperationVariables() {
    operationVariables = [];
  }
  function resetFieldMap() {
    fieldTypeMap = new Map;
  }
  function buildOperationNodeForField({ schema, kind, field, models, ignore = [], depthLimit, circularReferenceDepth, argNames, selectedFields = true }) {
    resetOperationVariables();
    resetFieldMap();
    const rootTypeNames = getRootTypeNames(schema);
    const operationNode = buildOperationAndCollectVariables({
      schema,
      fieldName: field,
      kind,
      models: models || [],
      ignore,
      depthLimit: depthLimit || Infinity,
      circularReferenceDepth: circularReferenceDepth || 1,
      argNames,
      selectedFields,
      rootTypeNames
    });
    operationNode.variableDefinitions = [...operationVariables];
    resetOperationVariables();
    resetFieldMap();
    return operationNode;
  }
  function buildOperationAndCollectVariables({ schema, fieldName, kind, models, ignore, depthLimit, circularReferenceDepth, argNames, selectedFields, rootTypeNames }) {
    const type = getDefinedRootType(schema, kind);
    const field = type.getFields()[fieldName];
    const operationName = `${fieldName}_${kind}`;
    if (field.args) {
      for (const arg of field.args) {
        const argName = arg.name;
        if (!argNames || argNames.includes(argName)) {
          addOperationVariable(resolveVariable(arg, argName));
        }
      }
    }
    return {
      kind: graphql.Kind.OPERATION_DEFINITION,
      operation: kind,
      name: {
        kind: "Name",
        value: operationName
      },
      variableDefinitions: [],
      selectionSet: {
        kind: graphql.Kind.SELECTION_SET,
        selections: [
          resolveField({
            type,
            field,
            models,
            firstCall: true,
            path: [],
            ancestors: [],
            ignore,
            depthLimit,
            circularReferenceDepth,
            schema,
            depth: 0,
            argNames,
            selectedFields,
            rootTypeNames
          })
        ]
      }
    };
  }
  function resolveSelectionSet({ parent, type, models, firstCall, path, ancestors, ignore, depthLimit, circularReferenceDepth, schema, depth, argNames, selectedFields, rootTypeNames }) {
    if (typeof selectedFields === "boolean" && depth > depthLimit) {
      return;
    }
    if (graphql.isUnionType(type)) {
      const types = type.getTypes();
      return {
        kind: graphql.Kind.SELECTION_SET,
        selections: types.filter((t) => !hasCircularRef([...ancestors, t], {
          depth: circularReferenceDepth
        })).map((t) => {
          return {
            kind: graphql.Kind.INLINE_FRAGMENT,
            typeCondition: {
              kind: graphql.Kind.NAMED_TYPE,
              name: {
                kind: graphql.Kind.NAME,
                value: t.name
              }
            },
            selectionSet: resolveSelectionSet({
              parent: type,
              type: t,
              models,
              path,
              ancestors,
              ignore,
              depthLimit,
              circularReferenceDepth,
              schema,
              depth,
              argNames,
              selectedFields,
              rootTypeNames
            })
          };
        }).filter((fragmentNode) => {
          var _a, _b;
          return ((_b = (_a = fragmentNode === null || fragmentNode === undefined ? undefined : fragmentNode.selectionSet) === null || _a === undefined ? undefined : _a.selections) === null || _b === undefined ? undefined : _b.length) > 0;
        })
      };
    }
    if (graphql.isInterfaceType(type)) {
      const types = Object.values(schema.getTypeMap()).filter((t) => graphql.isObjectType(t) && t.getInterfaces().includes(type));
      return {
        kind: graphql.Kind.SELECTION_SET,
        selections: types.filter((t) => !hasCircularRef([...ancestors, t], {
          depth: circularReferenceDepth
        })).map((t) => {
          return {
            kind: graphql.Kind.INLINE_FRAGMENT,
            typeCondition: {
              kind: graphql.Kind.NAMED_TYPE,
              name: {
                kind: graphql.Kind.NAME,
                value: t.name
              }
            },
            selectionSet: resolveSelectionSet({
              parent: type,
              type: t,
              models,
              path,
              ancestors,
              ignore,
              depthLimit,
              circularReferenceDepth,
              schema,
              depth,
              argNames,
              selectedFields,
              rootTypeNames
            })
          };
        }).filter((fragmentNode) => {
          var _a, _b;
          return ((_b = (_a = fragmentNode === null || fragmentNode === undefined ? undefined : fragmentNode.selectionSet) === null || _a === undefined ? undefined : _a.selections) === null || _b === undefined ? undefined : _b.length) > 0;
        })
      };
    }
    if (graphql.isObjectType(type) && !rootTypeNames.has(type.name)) {
      const isIgnored = ignore.includes(type.name) || ignore.includes(`${parent.name}.${path[path.length - 1]}`);
      const isModel = models.includes(type.name);
      if (!firstCall && isModel && !isIgnored) {
        return {
          kind: graphql.Kind.SELECTION_SET,
          selections: [
            {
              kind: graphql.Kind.FIELD,
              name: {
                kind: graphql.Kind.NAME,
                value: "id"
              }
            }
          ]
        };
      }
      const fields = type.getFields();
      return {
        kind: graphql.Kind.SELECTION_SET,
        selections: Object.keys(fields).filter((fieldName) => {
          return !hasCircularRef([...ancestors, graphql.getNamedType(fields[fieldName].type)], {
            depth: circularReferenceDepth
          });
        }).map((fieldName) => {
          const selectedSubFields = typeof selectedFields === "object" ? selectedFields[fieldName] : true;
          if (selectedSubFields) {
            return resolveField({
              type,
              field: fields[fieldName],
              models,
              path: [...path, fieldName],
              ancestors,
              ignore,
              depthLimit,
              circularReferenceDepth,
              schema,
              depth,
              argNames,
              selectedFields: selectedSubFields,
              rootTypeNames
            });
          }
          return null;
        }).filter((f) => {
          var _a, _b;
          if (f == null) {
            return false;
          } else if ("selectionSet" in f) {
            return !!((_b = (_a = f.selectionSet) === null || _a === undefined ? undefined : _a.selections) === null || _b === undefined ? undefined : _b.length);
          }
          return true;
        })
      };
    }
  }
  function resolveVariable(arg, name) {
    function resolveVariableType(type) {
      if (graphql.isListType(type)) {
        return {
          kind: graphql.Kind.LIST_TYPE,
          type: resolveVariableType(type.ofType)
        };
      }
      if (graphql.isNonNullType(type)) {
        return {
          kind: graphql.Kind.NON_NULL_TYPE,
          type: resolveVariableType(type.ofType)
        };
      }
      return {
        kind: graphql.Kind.NAMED_TYPE,
        name: {
          kind: graphql.Kind.NAME,
          value: type.name
        }
      };
    }
    return {
      kind: graphql.Kind.VARIABLE_DEFINITION,
      variable: {
        kind: graphql.Kind.VARIABLE,
        name: {
          kind: graphql.Kind.NAME,
          value: name || arg.name
        }
      },
      type: resolveVariableType(arg.type)
    };
  }
  function getArgumentName(name, path) {
    return [...path, name].join("_");
  }
  function resolveField({ type, field, models, firstCall, path, ancestors, ignore, depthLimit, circularReferenceDepth, schema, depth, argNames, selectedFields, rootTypeNames }) {
    const namedType = graphql.getNamedType(field.type);
    let args2 = [];
    let removeField = false;
    if (field.args && field.args.length) {
      args2 = field.args.map((arg) => {
        const argumentName = getArgumentName(arg.name, path);
        if (argNames && !argNames.includes(argumentName)) {
          if (graphql.isNonNullType(arg.type)) {
            removeField = true;
          }
          return null;
        }
        if (!firstCall) {
          addOperationVariable(resolveVariable(arg, argumentName));
        }
        return {
          kind: graphql.Kind.ARGUMENT,
          name: {
            kind: graphql.Kind.NAME,
            value: arg.name
          },
          value: {
            kind: graphql.Kind.VARIABLE,
            name: {
              kind: graphql.Kind.NAME,
              value: getArgumentName(arg.name, path)
            }
          }
        };
      }).filter(Boolean);
    }
    if (removeField) {
      return null;
    }
    const fieldPath = [...path, field.name];
    const fieldPathStr = fieldPath.join(".");
    let fieldName = field.name;
    if (fieldTypeMap.has(fieldPathStr) && fieldTypeMap.get(fieldPathStr) !== field.type.toString()) {
      fieldName += field.type.toString().replace("!", "NonNull");
    }
    fieldTypeMap.set(fieldPathStr, field.type.toString());
    if (!graphql.isScalarType(namedType) && !graphql.isEnumType(namedType)) {
      return {
        kind: graphql.Kind.FIELD,
        name: {
          kind: graphql.Kind.NAME,
          value: field.name
        },
        ...fieldName !== field.name && { alias: { kind: graphql.Kind.NAME, value: fieldName } },
        selectionSet: resolveSelectionSet({
          parent: type,
          type: namedType,
          models,
          firstCall,
          path: fieldPath,
          ancestors: [...ancestors, type],
          ignore,
          depthLimit,
          circularReferenceDepth,
          schema,
          depth: depth + 1,
          argNames,
          selectedFields,
          rootTypeNames
        }) || undefined,
        arguments: args2
      };
    }
    return {
      kind: graphql.Kind.FIELD,
      name: {
        kind: graphql.Kind.NAME,
        value: field.name
      },
      ...fieldName !== field.name && { alias: { kind: graphql.Kind.NAME, value: fieldName } },
      arguments: args2
    };
  }
  function hasCircularRef(types, config = {
    depth: 1
  }) {
    const type = types[types.length - 1];
    if (graphql.isScalarType(type)) {
      return false;
    }
    const size = types.filter((t) => t.name === type.name).length;
    return size > config.depth;
  }
  (function(MapperKind) {
    MapperKind["TYPE"] = "MapperKind.TYPE";
    MapperKind["SCALAR_TYPE"] = "MapperKind.SCALAR_TYPE";
    MapperKind["ENUM_TYPE"] = "MapperKind.ENUM_TYPE";
    MapperKind["COMPOSITE_TYPE"] = "MapperKind.COMPOSITE_TYPE";
    MapperKind["OBJECT_TYPE"] = "MapperKind.OBJECT_TYPE";
    MapperKind["INPUT_OBJECT_TYPE"] = "MapperKind.INPUT_OBJECT_TYPE";
    MapperKind["ABSTRACT_TYPE"] = "MapperKind.ABSTRACT_TYPE";
    MapperKind["UNION_TYPE"] = "MapperKind.UNION_TYPE";
    MapperKind["INTERFACE_TYPE"] = "MapperKind.INTERFACE_TYPE";
    MapperKind["ROOT_OBJECT"] = "MapperKind.ROOT_OBJECT";
    MapperKind["QUERY"] = "MapperKind.QUERY";
    MapperKind["MUTATION"] = "MapperKind.MUTATION";
    MapperKind["SUBSCRIPTION"] = "MapperKind.SUBSCRIPTION";
    MapperKind["DIRECTIVE"] = "MapperKind.DIRECTIVE";
    MapperKind["FIELD"] = "MapperKind.FIELD";
    MapperKind["COMPOSITE_FIELD"] = "MapperKind.COMPOSITE_FIELD";
    MapperKind["OBJECT_FIELD"] = "MapperKind.OBJECT_FIELD";
    MapperKind["ROOT_FIELD"] = "MapperKind.ROOT_FIELD";
    MapperKind["QUERY_ROOT_FIELD"] = "MapperKind.QUERY_ROOT_FIELD";
    MapperKind["MUTATION_ROOT_FIELD"] = "MapperKind.MUTATION_ROOT_FIELD";
    MapperKind["SUBSCRIPTION_ROOT_FIELD"] = "MapperKind.SUBSCRIPTION_ROOT_FIELD";
    MapperKind["INTERFACE_FIELD"] = "MapperKind.INTERFACE_FIELD";
    MapperKind["INPUT_OBJECT_FIELD"] = "MapperKind.INPUT_OBJECT_FIELD";
    MapperKind["ARGUMENT"] = "MapperKind.ARGUMENT";
    MapperKind["ENUM_VALUE"] = "MapperKind.ENUM_VALUE";
  })(exports.MapperKind || (exports.MapperKind = {}));
  function getObjectTypeFromTypeMap(typeMap, type) {
    if (type) {
      const maybeObjectType = typeMap[type.name];
      if (graphql.isObjectType(maybeObjectType)) {
        return maybeObjectType;
      }
    }
  }
  function createNamedStub(name, type) {
    let constructor;
    if (type === "object") {
      constructor = graphql.GraphQLObjectType;
    } else if (type === "interface") {
      constructor = graphql.GraphQLInterfaceType;
    } else {
      constructor = graphql.GraphQLInputObjectType;
    }
    return new constructor({
      name,
      fields: {
        _fake: {
          type: graphql.GraphQLString
        }
      }
    });
  }
  function createStub(node, type) {
    switch (node.kind) {
      case graphql.Kind.LIST_TYPE:
        return new graphql.GraphQLList(createStub(node.type, type));
      case graphql.Kind.NON_NULL_TYPE:
        return new graphql.GraphQLNonNull(createStub(node.type, type));
      default:
        if (type === "output") {
          return createNamedStub(node.name.value, "object");
        }
        return createNamedStub(node.name.value, "input");
    }
  }
  function isNamedStub(type) {
    if ("getFields" in type) {
      const fields = type.getFields();
      for (const fieldName in fields) {
        const field = fields[fieldName];
        return field.name === "_fake";
      }
    }
    return false;
  }
  function getBuiltInForStub(type) {
    switch (type.name) {
      case graphql.GraphQLInt.name:
        return graphql.GraphQLInt;
      case graphql.GraphQLFloat.name:
        return graphql.GraphQLFloat;
      case graphql.GraphQLString.name:
        return graphql.GraphQLString;
      case graphql.GraphQLBoolean.name:
        return graphql.GraphQLBoolean;
      case graphql.GraphQLID.name:
        return graphql.GraphQLID;
      default:
        return type;
    }
  }
  function rewireTypes(originalTypeMap, directives) {
    const referenceTypeMap = Object.create(null);
    for (const typeName in originalTypeMap) {
      referenceTypeMap[typeName] = originalTypeMap[typeName];
    }
    const newTypeMap = Object.create(null);
    for (const typeName in referenceTypeMap) {
      const namedType = referenceTypeMap[typeName];
      if (namedType == null || typeName.startsWith("__")) {
        continue;
      }
      const newName = namedType.name;
      if (newName.startsWith("__")) {
        continue;
      }
      if (newTypeMap[newName] != null) {
        throw new Error(`Duplicate schema type name ${newName}`);
      }
      newTypeMap[newName] = namedType;
    }
    for (const typeName in newTypeMap) {
      newTypeMap[typeName] = rewireNamedType(newTypeMap[typeName]);
    }
    const newDirectives = directives.map((directive) => rewireDirective(directive));
    return {
      typeMap: newTypeMap,
      directives: newDirectives
    };
    function rewireDirective(directive) {
      if (graphql.isSpecifiedDirective(directive)) {
        return directive;
      }
      const directiveConfig = directive.toConfig();
      directiveConfig.args = rewireArgs(directiveConfig.args);
      return new graphql.GraphQLDirective(directiveConfig);
    }
    function rewireArgs(args2) {
      const rewiredArgs = {};
      for (const argName in args2) {
        const arg = args2[argName];
        const rewiredArgType = rewireType(arg.type);
        if (rewiredArgType != null) {
          arg.type = rewiredArgType;
          rewiredArgs[argName] = arg;
        }
      }
      return rewiredArgs;
    }
    function rewireNamedType(type) {
      if (graphql.isObjectType(type)) {
        const config = type.toConfig();
        const newConfig = {
          ...config,
          fields: () => rewireFields(config.fields),
          interfaces: () => rewireNamedTypes(config.interfaces)
        };
        return new graphql.GraphQLObjectType(newConfig);
      } else if (graphql.isInterfaceType(type)) {
        const config = type.toConfig();
        const newConfig = {
          ...config,
          fields: () => rewireFields(config.fields)
        };
        if ("interfaces" in newConfig) {
          newConfig.interfaces = () => rewireNamedTypes(config.interfaces);
        }
        return new graphql.GraphQLInterfaceType(newConfig);
      } else if (graphql.isUnionType(type)) {
        const config = type.toConfig();
        const newConfig = {
          ...config,
          types: () => rewireNamedTypes(config.types)
        };
        return new graphql.GraphQLUnionType(newConfig);
      } else if (graphql.isInputObjectType(type)) {
        const config = type.toConfig();
        const newConfig = {
          ...config,
          fields: () => rewireInputFields(config.fields)
        };
        return new graphql.GraphQLInputObjectType(newConfig);
      } else if (graphql.isEnumType(type)) {
        const enumConfig = type.toConfig();
        return new graphql.GraphQLEnumType(enumConfig);
      } else if (graphql.isScalarType(type)) {
        if (graphql.isSpecifiedScalarType(type)) {
          return type;
        }
        const scalarConfig = type.toConfig();
        return new graphql.GraphQLScalarType(scalarConfig);
      }
      throw new Error(`Unexpected schema type: ${type}`);
    }
    function rewireFields(fields) {
      const rewiredFields = {};
      for (const fieldName in fields) {
        const field = fields[fieldName];
        const rewiredFieldType = rewireType(field.type);
        if (rewiredFieldType != null && field.args) {
          field.type = rewiredFieldType;
          field.args = rewireArgs(field.args);
          rewiredFields[fieldName] = field;
        }
      }
      return rewiredFields;
    }
    function rewireInputFields(fields) {
      const rewiredFields = {};
      for (const fieldName in fields) {
        const field = fields[fieldName];
        const rewiredFieldType = rewireType(field.type);
        if (rewiredFieldType != null) {
          field.type = rewiredFieldType;
          rewiredFields[fieldName] = field;
        }
      }
      return rewiredFields;
    }
    function rewireNamedTypes(namedTypes) {
      const rewiredTypes = [];
      for (const namedType of namedTypes) {
        const rewiredType = rewireType(namedType);
        if (rewiredType != null) {
          rewiredTypes.push(rewiredType);
        }
      }
      return rewiredTypes;
    }
    function rewireType(type) {
      if (graphql.isListType(type)) {
        const rewiredType = rewireType(type.ofType);
        return rewiredType != null ? new graphql.GraphQLList(rewiredType) : null;
      } else if (graphql.isNonNullType(type)) {
        const rewiredType = rewireType(type.ofType);
        return rewiredType != null ? new graphql.GraphQLNonNull(rewiredType) : null;
      } else if (graphql.isNamedType(type)) {
        let rewiredType = referenceTypeMap[type.name];
        if (rewiredType === undefined) {
          rewiredType = isNamedStub(type) ? getBuiltInForStub(type) : rewireNamedType(type);
          newTypeMap[rewiredType.name] = referenceTypeMap[type.name] = rewiredType;
        }
        return rewiredType != null ? newTypeMap[rewiredType.name] : null;
      }
      return null;
    }
  }
  function transformInputValue(type, value, inputLeafValueTransformer = null, inputObjectValueTransformer = null) {
    if (value == null) {
      return value;
    }
    const nullableType = graphql.getNullableType(type);
    if (graphql.isLeafType(nullableType)) {
      return inputLeafValueTransformer != null ? inputLeafValueTransformer(nullableType, value) : value;
    } else if (graphql.isListType(nullableType)) {
      return value.map((listMember) => transformInputValue(nullableType.ofType, listMember, inputLeafValueTransformer, inputObjectValueTransformer));
    } else if (graphql.isInputObjectType(nullableType)) {
      const fields = nullableType.getFields();
      const newValue = {};
      for (const key in value) {
        const field = fields[key];
        if (field != null) {
          newValue[key] = transformInputValue(field.type, value[key], inputLeafValueTransformer, inputObjectValueTransformer);
        }
      }
      return inputObjectValueTransformer != null ? inputObjectValueTransformer(nullableType, newValue) : newValue;
    }
  }
  function serializeInputValue(type, value) {
    return transformInputValue(type, value, (t, v) => t.serialize(v));
  }
  function parseInputValue(type, value) {
    return transformInputValue(type, value, (t, v) => t.parseValue(v));
  }
  function parseInputValueLiteral(type, value) {
    return transformInputValue(type, value, (t, v) => t.parseLiteral(v, {}));
  }
  function mapSchema(schema, schemaMapper = {}) {
    const newTypeMap = mapArguments(mapFields(mapTypes(mapDefaultValues(mapEnumValues(mapTypes(mapDefaultValues(schema.getTypeMap(), schema, serializeInputValue), schema, schemaMapper, (type) => graphql.isLeafType(type)), schema, schemaMapper), schema, parseInputValue), schema, schemaMapper, (type) => !graphql.isLeafType(type)), schema, schemaMapper), schema, schemaMapper);
    const originalDirectives = schema.getDirectives();
    const newDirectives = mapDirectives(originalDirectives, schema, schemaMapper);
    const { typeMap, directives } = rewireTypes(newTypeMap, newDirectives);
    return new graphql.GraphQLSchema({
      ...schema.toConfig(),
      query: getObjectTypeFromTypeMap(typeMap, getObjectTypeFromTypeMap(newTypeMap, schema.getQueryType())),
      mutation: getObjectTypeFromTypeMap(typeMap, getObjectTypeFromTypeMap(newTypeMap, schema.getMutationType())),
      subscription: getObjectTypeFromTypeMap(typeMap, getObjectTypeFromTypeMap(newTypeMap, schema.getSubscriptionType())),
      types: Object.values(typeMap),
      directives
    });
  }
  function mapTypes(originalTypeMap, schema, schemaMapper, testFn = () => true) {
    const newTypeMap = {};
    for (const typeName in originalTypeMap) {
      if (!typeName.startsWith("__")) {
        const originalType = originalTypeMap[typeName];
        if (originalType == null || !testFn(originalType)) {
          newTypeMap[typeName] = originalType;
          continue;
        }
        const typeMapper = getTypeMapper(schema, schemaMapper, typeName);
        if (typeMapper == null) {
          newTypeMap[typeName] = originalType;
          continue;
        }
        const maybeNewType = typeMapper(originalType, schema);
        if (maybeNewType === undefined) {
          newTypeMap[typeName] = originalType;
          continue;
        }
        newTypeMap[typeName] = maybeNewType;
      }
    }
    return newTypeMap;
  }
  function mapEnumValues(originalTypeMap, schema, schemaMapper) {
    const enumValueMapper = getEnumValueMapper(schemaMapper);
    if (!enumValueMapper) {
      return originalTypeMap;
    }
    return mapTypes(originalTypeMap, schema, {
      [exports.MapperKind.ENUM_TYPE]: (type) => {
        const config = type.toConfig();
        const originalEnumValueConfigMap = config.values;
        const newEnumValueConfigMap = {};
        for (const externalValue in originalEnumValueConfigMap) {
          const originalEnumValueConfig = originalEnumValueConfigMap[externalValue];
          const mappedEnumValue = enumValueMapper(originalEnumValueConfig, type.name, schema, externalValue);
          if (mappedEnumValue === undefined) {
            newEnumValueConfigMap[externalValue] = originalEnumValueConfig;
          } else if (Array.isArray(mappedEnumValue)) {
            const [newExternalValue, newEnumValueConfig] = mappedEnumValue;
            newEnumValueConfigMap[newExternalValue] = newEnumValueConfig === undefined ? originalEnumValueConfig : newEnumValueConfig;
          } else if (mappedEnumValue !== null) {
            newEnumValueConfigMap[externalValue] = mappedEnumValue;
          }
        }
        return correctASTNodes(new graphql.GraphQLEnumType({
          ...config,
          values: newEnumValueConfigMap
        }));
      }
    }, (type) => graphql.isEnumType(type));
  }
  function mapDefaultValues(originalTypeMap, schema, fn2) {
    const newTypeMap = mapArguments(originalTypeMap, schema, {
      [exports.MapperKind.ARGUMENT]: (argumentConfig) => {
        if (argumentConfig.defaultValue === undefined) {
          return argumentConfig;
        }
        const maybeNewType = getNewType(originalTypeMap, argumentConfig.type);
        if (maybeNewType != null) {
          return {
            ...argumentConfig,
            defaultValue: fn2(maybeNewType, argumentConfig.defaultValue)
          };
        }
      }
    });
    return mapFields(newTypeMap, schema, {
      [exports.MapperKind.INPUT_OBJECT_FIELD]: (inputFieldConfig) => {
        if (inputFieldConfig.defaultValue === undefined) {
          return inputFieldConfig;
        }
        const maybeNewType = getNewType(newTypeMap, inputFieldConfig.type);
        if (maybeNewType != null) {
          return {
            ...inputFieldConfig,
            defaultValue: fn2(maybeNewType, inputFieldConfig.defaultValue)
          };
        }
      }
    });
  }
  function getNewType(newTypeMap, type) {
    if (graphql.isListType(type)) {
      const newType = getNewType(newTypeMap, type.ofType);
      return newType != null ? new graphql.GraphQLList(newType) : null;
    } else if (graphql.isNonNullType(type)) {
      const newType = getNewType(newTypeMap, type.ofType);
      return newType != null ? new graphql.GraphQLNonNull(newType) : null;
    } else if (graphql.isNamedType(type)) {
      const newType = newTypeMap[type.name];
      return newType != null ? newType : null;
    }
    return null;
  }
  function mapFields(originalTypeMap, schema, schemaMapper) {
    const newTypeMap = {};
    for (const typeName in originalTypeMap) {
      if (!typeName.startsWith("__")) {
        const originalType = originalTypeMap[typeName];
        if (!graphql.isObjectType(originalType) && !graphql.isInterfaceType(originalType) && !graphql.isInputObjectType(originalType)) {
          newTypeMap[typeName] = originalType;
          continue;
        }
        const fieldMapper = getFieldMapper(schema, schemaMapper, typeName);
        if (fieldMapper == null) {
          newTypeMap[typeName] = originalType;
          continue;
        }
        const config = originalType.toConfig();
        const originalFieldConfigMap = config.fields;
        const newFieldConfigMap = {};
        for (const fieldName in originalFieldConfigMap) {
          const originalFieldConfig = originalFieldConfigMap[fieldName];
          const mappedField = fieldMapper(originalFieldConfig, fieldName, typeName, schema);
          if (mappedField === undefined) {
            newFieldConfigMap[fieldName] = originalFieldConfig;
          } else if (Array.isArray(mappedField)) {
            const [newFieldName, newFieldConfig] = mappedField;
            if (newFieldConfig.astNode != null) {
              newFieldConfig.astNode = {
                ...newFieldConfig.astNode,
                name: {
                  ...newFieldConfig.astNode.name,
                  value: newFieldName
                }
              };
            }
            newFieldConfigMap[newFieldName] = newFieldConfig === undefined ? originalFieldConfig : newFieldConfig;
          } else if (mappedField !== null) {
            newFieldConfigMap[fieldName] = mappedField;
          }
        }
        if (graphql.isObjectType(originalType)) {
          newTypeMap[typeName] = correctASTNodes(new graphql.GraphQLObjectType({
            ...config,
            fields: newFieldConfigMap
          }));
        } else if (graphql.isInterfaceType(originalType)) {
          newTypeMap[typeName] = correctASTNodes(new graphql.GraphQLInterfaceType({
            ...config,
            fields: newFieldConfigMap
          }));
        } else {
          newTypeMap[typeName] = correctASTNodes(new graphql.GraphQLInputObjectType({
            ...config,
            fields: newFieldConfigMap
          }));
        }
      }
    }
    return newTypeMap;
  }
  function mapArguments(originalTypeMap, schema, schemaMapper) {
    const newTypeMap = {};
    for (const typeName in originalTypeMap) {
      if (!typeName.startsWith("__")) {
        const originalType = originalTypeMap[typeName];
        if (!graphql.isObjectType(originalType) && !graphql.isInterfaceType(originalType)) {
          newTypeMap[typeName] = originalType;
          continue;
        }
        const argumentMapper = getArgumentMapper(schemaMapper);
        if (argumentMapper == null) {
          newTypeMap[typeName] = originalType;
          continue;
        }
        const config = originalType.toConfig();
        const originalFieldConfigMap = config.fields;
        const newFieldConfigMap = {};
        for (const fieldName in originalFieldConfigMap) {
          const originalFieldConfig = originalFieldConfigMap[fieldName];
          const originalArgumentConfigMap = originalFieldConfig.args;
          if (originalArgumentConfigMap == null) {
            newFieldConfigMap[fieldName] = originalFieldConfig;
            continue;
          }
          const argumentNames = Object.keys(originalArgumentConfigMap);
          if (!argumentNames.length) {
            newFieldConfigMap[fieldName] = originalFieldConfig;
            continue;
          }
          const newArgumentConfigMap = {};
          for (const argumentName of argumentNames) {
            const originalArgumentConfig = originalArgumentConfigMap[argumentName];
            const mappedArgument = argumentMapper(originalArgumentConfig, fieldName, typeName, schema);
            if (mappedArgument === undefined) {
              newArgumentConfigMap[argumentName] = originalArgumentConfig;
            } else if (Array.isArray(mappedArgument)) {
              const [newArgumentName, newArgumentConfig] = mappedArgument;
              newArgumentConfigMap[newArgumentName] = newArgumentConfig;
            } else if (mappedArgument !== null) {
              newArgumentConfigMap[argumentName] = mappedArgument;
            }
          }
          newFieldConfigMap[fieldName] = {
            ...originalFieldConfig,
            args: newArgumentConfigMap
          };
        }
        if (graphql.isObjectType(originalType)) {
          newTypeMap[typeName] = new graphql.GraphQLObjectType({
            ...config,
            fields: newFieldConfigMap
          });
        } else if (graphql.isInterfaceType(originalType)) {
          newTypeMap[typeName] = new graphql.GraphQLInterfaceType({
            ...config,
            fields: newFieldConfigMap
          });
        } else {
          newTypeMap[typeName] = new graphql.GraphQLInputObjectType({
            ...config,
            fields: newFieldConfigMap
          });
        }
      }
    }
    return newTypeMap;
  }
  function mapDirectives(originalDirectives, schema, schemaMapper) {
    const directiveMapper = getDirectiveMapper(schemaMapper);
    if (directiveMapper == null) {
      return originalDirectives.slice();
    }
    const newDirectives = [];
    for (const directive of originalDirectives) {
      const mappedDirective = directiveMapper(directive, schema);
      if (mappedDirective === undefined) {
        newDirectives.push(directive);
      } else if (mappedDirective !== null) {
        newDirectives.push(mappedDirective);
      }
    }
    return newDirectives;
  }
  function getTypeSpecifiers(schema, typeName) {
    var _a, _b, _c;
    const type = schema.getType(typeName);
    const specifiers = [exports.MapperKind.TYPE];
    if (graphql.isObjectType(type)) {
      specifiers.push(exports.MapperKind.COMPOSITE_TYPE, exports.MapperKind.OBJECT_TYPE);
      if (typeName === ((_a = schema.getQueryType()) === null || _a === undefined ? undefined : _a.name)) {
        specifiers.push(exports.MapperKind.ROOT_OBJECT, exports.MapperKind.QUERY);
      } else if (typeName === ((_b = schema.getMutationType()) === null || _b === undefined ? undefined : _b.name)) {
        specifiers.push(exports.MapperKind.ROOT_OBJECT, exports.MapperKind.MUTATION);
      } else if (typeName === ((_c = schema.getSubscriptionType()) === null || _c === undefined ? undefined : _c.name)) {
        specifiers.push(exports.MapperKind.ROOT_OBJECT, exports.MapperKind.SUBSCRIPTION);
      }
    } else if (graphql.isInputObjectType(type)) {
      specifiers.push(exports.MapperKind.INPUT_OBJECT_TYPE);
    } else if (graphql.isInterfaceType(type)) {
      specifiers.push(exports.MapperKind.COMPOSITE_TYPE, exports.MapperKind.ABSTRACT_TYPE, exports.MapperKind.INTERFACE_TYPE);
    } else if (graphql.isUnionType(type)) {
      specifiers.push(exports.MapperKind.COMPOSITE_TYPE, exports.MapperKind.ABSTRACT_TYPE, exports.MapperKind.UNION_TYPE);
    } else if (graphql.isEnumType(type)) {
      specifiers.push(exports.MapperKind.ENUM_TYPE);
    } else if (graphql.isScalarType(type)) {
      specifiers.push(exports.MapperKind.SCALAR_TYPE);
    }
    return specifiers;
  }
  function getTypeMapper(schema, schemaMapper, typeName) {
    const specifiers = getTypeSpecifiers(schema, typeName);
    let typeMapper;
    const stack2 = [...specifiers];
    while (!typeMapper && stack2.length > 0) {
      const next = stack2.pop();
      typeMapper = schemaMapper[next];
    }
    return typeMapper != null ? typeMapper : null;
  }
  function getFieldSpecifiers(schema, typeName) {
    var _a, _b, _c;
    const type = schema.getType(typeName);
    const specifiers = [exports.MapperKind.FIELD];
    if (graphql.isObjectType(type)) {
      specifiers.push(exports.MapperKind.COMPOSITE_FIELD, exports.MapperKind.OBJECT_FIELD);
      if (typeName === ((_a = schema.getQueryType()) === null || _a === undefined ? undefined : _a.name)) {
        specifiers.push(exports.MapperKind.ROOT_FIELD, exports.MapperKind.QUERY_ROOT_FIELD);
      } else if (typeName === ((_b = schema.getMutationType()) === null || _b === undefined ? undefined : _b.name)) {
        specifiers.push(exports.MapperKind.ROOT_FIELD, exports.MapperKind.MUTATION_ROOT_FIELD);
      } else if (typeName === ((_c = schema.getSubscriptionType()) === null || _c === undefined ? undefined : _c.name)) {
        specifiers.push(exports.MapperKind.ROOT_FIELD, exports.MapperKind.SUBSCRIPTION_ROOT_FIELD);
      }
    } else if (graphql.isInterfaceType(type)) {
      specifiers.push(exports.MapperKind.COMPOSITE_FIELD, exports.MapperKind.INTERFACE_FIELD);
    } else if (graphql.isInputObjectType(type)) {
      specifiers.push(exports.MapperKind.INPUT_OBJECT_FIELD);
    }
    return specifiers;
  }
  function getFieldMapper(schema, schemaMapper, typeName) {
    const specifiers = getFieldSpecifiers(schema, typeName);
    let fieldMapper;
    const stack2 = [...specifiers];
    while (!fieldMapper && stack2.length > 0) {
      const next = stack2.pop();
      fieldMapper = schemaMapper[next];
    }
    return fieldMapper !== null && fieldMapper !== undefined ? fieldMapper : null;
  }
  function getArgumentMapper(schemaMapper) {
    const argumentMapper = schemaMapper[exports.MapperKind.ARGUMENT];
    return argumentMapper != null ? argumentMapper : null;
  }
  function getDirectiveMapper(schemaMapper) {
    const directiveMapper = schemaMapper[exports.MapperKind.DIRECTIVE];
    return directiveMapper != null ? directiveMapper : null;
  }
  function getEnumValueMapper(schemaMapper) {
    const enumValueMapper = schemaMapper[exports.MapperKind.ENUM_VALUE];
    return enumValueMapper != null ? enumValueMapper : null;
  }
  function correctASTNodes(type) {
    if (graphql.isObjectType(type)) {
      const config = type.toConfig();
      if (config.astNode != null) {
        const fields = [];
        for (const fieldName in config.fields) {
          const fieldConfig = config.fields[fieldName];
          if (fieldConfig.astNode != null) {
            fields.push(fieldConfig.astNode);
          }
        }
        config.astNode = {
          ...config.astNode,
          kind: graphql.Kind.OBJECT_TYPE_DEFINITION,
          fields
        };
      }
      if (config.extensionASTNodes != null) {
        config.extensionASTNodes = config.extensionASTNodes.map((node) => ({
          ...node,
          kind: graphql.Kind.OBJECT_TYPE_EXTENSION,
          fields: undefined
        }));
      }
      return new graphql.GraphQLObjectType(config);
    } else if (graphql.isInterfaceType(type)) {
      const config = type.toConfig();
      if (config.astNode != null) {
        const fields = [];
        for (const fieldName in config.fields) {
          const fieldConfig = config.fields[fieldName];
          if (fieldConfig.astNode != null) {
            fields.push(fieldConfig.astNode);
          }
        }
        config.astNode = {
          ...config.astNode,
          kind: graphql.Kind.INTERFACE_TYPE_DEFINITION,
          fields
        };
      }
      if (config.extensionASTNodes != null) {
        config.extensionASTNodes = config.extensionASTNodes.map((node) => ({
          ...node,
          kind: graphql.Kind.INTERFACE_TYPE_EXTENSION,
          fields: undefined
        }));
      }
      return new graphql.GraphQLInterfaceType(config);
    } else if (graphql.isInputObjectType(type)) {
      const config = type.toConfig();
      if (config.astNode != null) {
        const fields = [];
        for (const fieldName in config.fields) {
          const fieldConfig = config.fields[fieldName];
          if (fieldConfig.astNode != null) {
            fields.push(fieldConfig.astNode);
          }
        }
        config.astNode = {
          ...config.astNode,
          kind: graphql.Kind.INPUT_OBJECT_TYPE_DEFINITION,
          fields
        };
      }
      if (config.extensionASTNodes != null) {
        config.extensionASTNodes = config.extensionASTNodes.map((node) => ({
          ...node,
          kind: graphql.Kind.INPUT_OBJECT_TYPE_EXTENSION,
          fields: undefined
        }));
      }
      return new graphql.GraphQLInputObjectType(config);
    } else if (graphql.isEnumType(type)) {
      const config = type.toConfig();
      if (config.astNode != null) {
        const values = [];
        for (const enumKey in config.values) {
          const enumValueConfig = config.values[enumKey];
          if (enumValueConfig.astNode != null) {
            values.push(enumValueConfig.astNode);
          }
        }
        config.astNode = {
          ...config.astNode,
          values
        };
      }
      if (config.extensionASTNodes != null) {
        config.extensionASTNodes = config.extensionASTNodes.map((node) => ({
          ...node,
          values: undefined
        }));
      }
      return new graphql.GraphQLEnumType(config);
    } else {
      return type;
    }
  }
  function filterSchema({ schema, typeFilter = () => true, fieldFilter = undefined, rootFieldFilter = undefined, objectFieldFilter = undefined, interfaceFieldFilter = undefined, inputObjectFieldFilter = undefined, argumentFilter = undefined }) {
    const filteredSchema = mapSchema(schema, {
      [exports.MapperKind.QUERY]: (type) => filterRootFields(type, "Query", rootFieldFilter, argumentFilter),
      [exports.MapperKind.MUTATION]: (type) => filterRootFields(type, "Mutation", rootFieldFilter, argumentFilter),
      [exports.MapperKind.SUBSCRIPTION]: (type) => filterRootFields(type, "Subscription", rootFieldFilter, argumentFilter),
      [exports.MapperKind.OBJECT_TYPE]: (type) => typeFilter(type.name, type) ? filterElementFields(graphql.GraphQLObjectType, type, objectFieldFilter || fieldFilter, argumentFilter) : null,
      [exports.MapperKind.INTERFACE_TYPE]: (type) => typeFilter(type.name, type) ? filterElementFields(graphql.GraphQLInterfaceType, type, interfaceFieldFilter || fieldFilter, argumentFilter) : null,
      [exports.MapperKind.INPUT_OBJECT_TYPE]: (type) => typeFilter(type.name, type) ? filterElementFields(graphql.GraphQLInputObjectType, type, inputObjectFieldFilter || fieldFilter) : null,
      [exports.MapperKind.UNION_TYPE]: (type) => typeFilter(type.name, type) ? undefined : null,
      [exports.MapperKind.ENUM_TYPE]: (type) => typeFilter(type.name, type) ? undefined : null,
      [exports.MapperKind.SCALAR_TYPE]: (type) => typeFilter(type.name, type) ? undefined : null
    });
    return filteredSchema;
  }
  function filterRootFields(type, operation, rootFieldFilter, argumentFilter) {
    if (rootFieldFilter || argumentFilter) {
      const config = type.toConfig();
      for (const fieldName in config.fields) {
        const field = config.fields[fieldName];
        if (rootFieldFilter && !rootFieldFilter(operation, fieldName, config.fields[fieldName])) {
          delete config.fields[fieldName];
        } else if (argumentFilter && field.args) {
          for (const argName in field.args) {
            if (!argumentFilter(operation, fieldName, argName, field.args[argName])) {
              delete field.args[argName];
            }
          }
        }
      }
      return new graphql.GraphQLObjectType(config);
    }
    return type;
  }
  function filterElementFields(ElementConstructor, type, fieldFilter, argumentFilter) {
    if (fieldFilter || argumentFilter) {
      const config = type.toConfig();
      for (const fieldName in config.fields) {
        const field = config.fields[fieldName];
        if (fieldFilter && !fieldFilter(type.name, fieldName, config.fields[fieldName])) {
          delete config.fields[fieldName];
        } else if (argumentFilter && "args" in field) {
          for (const argName in field.args) {
            if (!argumentFilter(type.name, fieldName, argName, field.args[argName])) {
              delete field.args[argName];
            }
          }
        }
      }
      return new ElementConstructor(config);
    }
  }
  function healSchema(schema) {
    healTypes(schema.getTypeMap(), schema.getDirectives());
    return schema;
  }
  function healTypes(originalTypeMap, directives) {
    const actualNamedTypeMap = Object.create(null);
    for (const typeName in originalTypeMap) {
      const namedType = originalTypeMap[typeName];
      if (namedType == null || typeName.startsWith("__")) {
        continue;
      }
      const actualName = namedType.name;
      if (actualName.startsWith("__")) {
        continue;
      }
      if (actualName in actualNamedTypeMap) {
        throw new Error(`Duplicate schema type name ${actualName}`);
      }
      actualNamedTypeMap[actualName] = namedType;
    }
    for (const typeName in actualNamedTypeMap) {
      const namedType = actualNamedTypeMap[typeName];
      originalTypeMap[typeName] = namedType;
    }
    for (const decl of directives) {
      decl.args = decl.args.filter((arg) => {
        arg.type = healType(arg.type);
        return arg.type !== null;
      });
    }
    for (const typeName in originalTypeMap) {
      const namedType = originalTypeMap[typeName];
      if (!typeName.startsWith("__") && typeName in actualNamedTypeMap) {
        if (namedType != null) {
          healNamedType(namedType);
        }
      }
    }
    for (const typeName in originalTypeMap) {
      if (!typeName.startsWith("__") && !(typeName in actualNamedTypeMap)) {
        delete originalTypeMap[typeName];
      }
    }
    function healNamedType(type) {
      if (graphql.isObjectType(type)) {
        healFields(type);
        healInterfaces(type);
        return;
      } else if (graphql.isInterfaceType(type)) {
        healFields(type);
        if ("getInterfaces" in type) {
          healInterfaces(type);
        }
        return;
      } else if (graphql.isUnionType(type)) {
        healUnderlyingTypes(type);
        return;
      } else if (graphql.isInputObjectType(type)) {
        healInputFields(type);
        return;
      } else if (graphql.isLeafType(type)) {
        return;
      }
      throw new Error(`Unexpected schema type: ${type}`);
    }
    function healFields(type) {
      const fieldMap = type.getFields();
      for (const [key, field] of Object.entries(fieldMap)) {
        field.args.map((arg) => {
          arg.type = healType(arg.type);
          return arg.type === null ? null : arg;
        }).filter(Boolean);
        field.type = healType(field.type);
        if (field.type === null) {
          delete fieldMap[key];
        }
      }
    }
    function healInterfaces(type) {
      if ("getInterfaces" in type) {
        const interfaces = type.getInterfaces();
        interfaces.push(...interfaces.splice(0).map((iface) => healType(iface)).filter(Boolean));
      }
    }
    function healInputFields(type) {
      const fieldMap = type.getFields();
      for (const [key, field] of Object.entries(fieldMap)) {
        field.type = healType(field.type);
        if (field.type === null) {
          delete fieldMap[key];
        }
      }
    }
    function healUnderlyingTypes(type) {
      const types = type.getTypes();
      types.push(...types.splice(0).map((t) => healType(t)).filter(Boolean));
    }
    function healType(type) {
      if (graphql.isListType(type)) {
        const healedType = healType(type.ofType);
        return healedType != null ? new graphql.GraphQLList(healedType) : null;
      } else if (graphql.isNonNullType(type)) {
        const healedType = healType(type.ofType);
        return healedType != null ? new graphql.GraphQLNonNull(healedType) : null;
      } else if (graphql.isNamedType(type)) {
        const officialType = originalTypeMap[type.name];
        if (officialType && type !== officialType) {
          return officialType;
        }
      }
      return type;
    }
  }
  function getResolversFromSchema(schema) {
    var _a, _b;
    const resolvers = Object.create(null);
    const typeMap = schema.getTypeMap();
    for (const typeName in typeMap) {
      if (!typeName.startsWith("__")) {
        const type = typeMap[typeName];
        if (graphql.isScalarType(type)) {
          if (!graphql.isSpecifiedScalarType(type)) {
            const config = type.toConfig();
            delete config.astNode;
            resolvers[typeName] = new graphql.GraphQLScalarType(config);
          }
        } else if (graphql.isEnumType(type)) {
          resolvers[typeName] = {};
          const values = type.getValues();
          for (const value of values) {
            resolvers[typeName][value.name] = value.value;
          }
        } else if (graphql.isInterfaceType(type)) {
          if (type.resolveType != null) {
            resolvers[typeName] = {
              __resolveType: type.resolveType
            };
          }
        } else if (graphql.isUnionType(type)) {
          if (type.resolveType != null) {
            resolvers[typeName] = {
              __resolveType: type.resolveType
            };
          }
        } else if (graphql.isObjectType(type)) {
          resolvers[typeName] = {};
          if (type.isTypeOf != null) {
            resolvers[typeName].__isTypeOf = type.isTypeOf;
          }
          const fields = type.getFields();
          for (const fieldName in fields) {
            const field = fields[fieldName];
            if (field.subscribe != null) {
              resolvers[typeName][fieldName] = resolvers[typeName][fieldName] || {};
              resolvers[typeName][fieldName].subscribe = field.subscribe;
            }
            if (field.resolve != null && ((_a = field.resolve) === null || _a === undefined ? undefined : _a.name) !== "defaultFieldResolver" && ((_b = field.resolve) === null || _b === undefined ? undefined : _b.name) !== "defaultMergedResolver") {
              resolvers[typeName][fieldName] = resolvers[typeName][fieldName] || {};
              resolvers[typeName][fieldName].resolve = field.resolve;
            }
          }
        }
      }
    }
    return resolvers;
  }
  function forEachField(schema, fn2) {
    const typeMap = schema.getTypeMap();
    for (const typeName in typeMap) {
      const type = typeMap[typeName];
      if (!graphql.getNamedType(type).name.startsWith("__") && graphql.isObjectType(type)) {
        const fields = type.getFields();
        for (const fieldName in fields) {
          const field = fields[fieldName];
          fn2(field, typeName, fieldName);
        }
      }
    }
  }
  function forEachDefaultValue(schema, fn2) {
    const typeMap = schema.getTypeMap();
    for (const typeName in typeMap) {
      const type = typeMap[typeName];
      if (!graphql.getNamedType(type).name.startsWith("__")) {
        if (graphql.isObjectType(type)) {
          const fields = type.getFields();
          for (const fieldName in fields) {
            const field = fields[fieldName];
            for (const arg of field.args) {
              arg.defaultValue = fn2(arg.type, arg.defaultValue);
            }
          }
        } else if (graphql.isInputObjectType(type)) {
          const fields = type.getFields();
          for (const fieldName in fields) {
            const field = fields[fieldName];
            field.defaultValue = fn2(field.type, field.defaultValue);
          }
        }
      }
    }
  }
  function addTypes(schema, newTypesOrDirectives) {
    const config = schema.toConfig();
    const originalTypeMap = {};
    for (const type of config.types) {
      originalTypeMap[type.name] = type;
    }
    const originalDirectiveMap = {};
    for (const directive of config.directives) {
      originalDirectiveMap[directive.name] = directive;
    }
    for (const newTypeOrDirective of newTypesOrDirectives) {
      if (graphql.isNamedType(newTypeOrDirective)) {
        originalTypeMap[newTypeOrDirective.name] = newTypeOrDirective;
      } else if (graphql.isDirective(newTypeOrDirective)) {
        originalDirectiveMap[newTypeOrDirective.name] = newTypeOrDirective;
      }
    }
    const { typeMap, directives } = rewireTypes(originalTypeMap, Object.values(originalDirectiveMap));
    return new graphql.GraphQLSchema({
      ...config,
      query: getObjectTypeFromTypeMap(typeMap, schema.getQueryType()),
      mutation: getObjectTypeFromTypeMap(typeMap, schema.getMutationType()),
      subscription: getObjectTypeFromTypeMap(typeMap, schema.getSubscriptionType()),
      types: Object.values(typeMap),
      directives
    });
  }
  function pruneSchema(schema, options = {}) {
    const pruningContext = {
      schema,
      unusedTypes: Object.create(null),
      implementations: Object.create(null)
    };
    for (const typeName in schema.getTypeMap()) {
      const type = schema.getType(typeName);
      if (type && "getInterfaces" in type) {
        for (const iface of type.getInterfaces()) {
          const implementations = getImplementations(pruningContext, iface);
          if (implementations == null) {
            pruningContext.implementations[iface.name] = Object.create(null);
          }
          pruningContext.implementations[iface.name][type.name] = true;
        }
      }
    }
    visitTypes(pruningContext, schema);
    return mapSchema(schema, {
      [exports.MapperKind.TYPE]: (type) => {
        if (options.skipPruning && options.skipPruning(type)) {
          return type;
        }
        if (graphql.isObjectType(type) || graphql.isInputObjectType(type)) {
          if (!Object.keys(type.getFields()).length && !options.skipEmptyCompositeTypePruning || pruningContext.unusedTypes[type.name] && !options.skipUnusedTypesPruning) {
            return null;
          }
        } else if (graphql.isUnionType(type)) {
          if (!type.getTypes().length && !options.skipEmptyUnionPruning || pruningContext.unusedTypes[type.name] && !options.skipUnusedTypesPruning) {
            return null;
          }
        } else if (graphql.isInterfaceType(type)) {
          const implementations = getImplementations(pruningContext, type);
          if (!Object.keys(type.getFields()).length && !options.skipEmptyCompositeTypePruning || implementations && !Object.keys(implementations).length && !options.skipUnimplementedInterfacesPruning || pruningContext.unusedTypes[type.name] && !options.skipUnusedTypesPruning) {
            return null;
          }
        } else {
          if (pruningContext.unusedTypes[type.name] && !options.skipUnusedTypesPruning) {
            return null;
          }
        }
      }
    });
  }
  function visitOutputType(visitedTypes, pruningContext, type) {
    if (visitedTypes[type.name]) {
      return;
    }
    visitedTypes[type.name] = true;
    pruningContext.unusedTypes[type.name] = false;
    if (graphql.isObjectType(type) || graphql.isInterfaceType(type)) {
      const fields = type.getFields();
      for (const fieldName in fields) {
        const field = fields[fieldName];
        const namedType = graphql.getNamedType(field.type);
        visitOutputType(visitedTypes, pruningContext, namedType);
        for (const arg of field.args) {
          const type2 = graphql.getNamedType(arg.type);
          visitInputType(visitedTypes, pruningContext, type2);
        }
      }
      if (graphql.isInterfaceType(type)) {
        const implementations = getImplementations(pruningContext, type);
        if (implementations) {
          for (const typeName in implementations) {
            visitOutputType(visitedTypes, pruningContext, pruningContext.schema.getType(typeName));
          }
        }
      }
      if ("getInterfaces" in type) {
        for (const iFace of type.getInterfaces()) {
          visitOutputType(visitedTypes, pruningContext, iFace);
        }
      }
    } else if (graphql.isUnionType(type)) {
      const types = type.getTypes();
      for (const type2 of types) {
        visitOutputType(visitedTypes, pruningContext, type2);
      }
    }
  }
  function getImplementations(pruningContext, type) {
    return pruningContext.implementations[type.name];
  }
  function visitInputType(visitedTypes, pruningContext, type) {
    if (visitedTypes[type.name]) {
      return;
    }
    pruningContext.unusedTypes[type.name] = false;
    visitedTypes[type.name] = true;
    if (graphql.isInputObjectType(type)) {
      const fields = type.getFields();
      for (const fieldName in fields) {
        const field = fields[fieldName];
        const namedType = graphql.getNamedType(field.type);
        visitInputType(visitedTypes, pruningContext, namedType);
      }
    }
  }
  function visitTypes(pruningContext, schema) {
    for (const typeName in schema.getTypeMap()) {
      if (!typeName.startsWith("__")) {
        pruningContext.unusedTypes[typeName] = true;
      }
    }
    const visitedTypes = Object.create(null);
    const rootTypes = getRootTypes(schema);
    for (const rootType of rootTypes) {
      visitOutputType(visitedTypes, pruningContext, rootType);
    }
    for (const directive of schema.getDirectives()) {
      for (const arg of directive.args) {
        const type = graphql.getNamedType(arg.type);
        visitInputType(visitedTypes, pruningContext, type);
      }
    }
  }
  function mergeDeep(sources, respectPrototype = false) {
    const target = sources[0] || {};
    const output = {};
    if (respectPrototype) {
      Object.setPrototypeOf(output, Object.create(Object.getPrototypeOf(target)));
    }
    for (const source of sources) {
      if (isObject(target) && isObject(source)) {
        if (respectPrototype) {
          const outputPrototype = Object.getPrototypeOf(output);
          const sourcePrototype = Object.getPrototypeOf(source);
          if (sourcePrototype) {
            for (const key of Object.getOwnPropertyNames(sourcePrototype)) {
              const descriptor = Object.getOwnPropertyDescriptor(sourcePrototype, key);
              if (isSome(descriptor)) {
                Object.defineProperty(outputPrototype, key, descriptor);
              }
            }
          }
        }
        for (const key in source) {
          if (isObject(source[key])) {
            if (!(key in output)) {
              Object.assign(output, { [key]: source[key] });
            } else {
              output[key] = mergeDeep([output[key], source[key]], respectPrototype);
            }
          } else {
            Object.assign(output, { [key]: source[key] });
          }
        }
      }
    }
    return output;
  }
  function isObject(item) {
    return item && typeof item === "object" && !Array.isArray(item);
  }
  function parseSelectionSet(selectionSet, options) {
    const query = graphql.parse(selectionSet, options).definitions[0];
    return query.selectionSet;
  }
  function getResponseKeyFromInfo(info) {
    return info.fieldNodes[0].alias != null ? info.fieldNodes[0].alias.value : info.fieldName;
  }
  function appendObjectFields(schema, typeName, additionalFields) {
    if (schema.getType(typeName) == null) {
      return addTypes(schema, [
        new graphql.GraphQLObjectType({
          name: typeName,
          fields: additionalFields
        })
      ]);
    }
    return mapSchema(schema, {
      [exports.MapperKind.OBJECT_TYPE]: (type) => {
        if (type.name === typeName) {
          const config = type.toConfig();
          const originalFieldConfigMap = config.fields;
          const newFieldConfigMap = {};
          for (const fieldName in originalFieldConfigMap) {
            newFieldConfigMap[fieldName] = originalFieldConfigMap[fieldName];
          }
          for (const fieldName in additionalFields) {
            newFieldConfigMap[fieldName] = additionalFields[fieldName];
          }
          return correctASTNodes(new graphql.GraphQLObjectType({
            ...config,
            fields: newFieldConfigMap
          }));
        }
      }
    });
  }
  function removeObjectFields(schema, typeName, testFn) {
    const removedFields = {};
    const newSchema = mapSchema(schema, {
      [exports.MapperKind.OBJECT_TYPE]: (type) => {
        if (type.name === typeName) {
          const config = type.toConfig();
          const originalFieldConfigMap = config.fields;
          const newFieldConfigMap = {};
          for (const fieldName in originalFieldConfigMap) {
            const originalFieldConfig = originalFieldConfigMap[fieldName];
            if (testFn(fieldName, originalFieldConfig)) {
              removedFields[fieldName] = originalFieldConfig;
            } else {
              newFieldConfigMap[fieldName] = originalFieldConfig;
            }
          }
          return correctASTNodes(new graphql.GraphQLObjectType({
            ...config,
            fields: newFieldConfigMap
          }));
        }
      }
    });
    return [newSchema, removedFields];
  }
  function selectObjectFields(schema, typeName, testFn) {
    const selectedFields = {};
    mapSchema(schema, {
      [exports.MapperKind.OBJECT_TYPE]: (type) => {
        if (type.name === typeName) {
          const config = type.toConfig();
          const originalFieldConfigMap = config.fields;
          for (const fieldName in originalFieldConfigMap) {
            const originalFieldConfig = originalFieldConfigMap[fieldName];
            if (testFn(fieldName, originalFieldConfig)) {
              selectedFields[fieldName] = originalFieldConfig;
            }
          }
        }
        return;
      }
    });
    return selectedFields;
  }
  function modifyObjectFields(schema, typeName, testFn, newFields) {
    const removedFields = {};
    const newSchema = mapSchema(schema, {
      [exports.MapperKind.OBJECT_TYPE]: (type) => {
        if (type.name === typeName) {
          const config = type.toConfig();
          const originalFieldConfigMap = config.fields;
          const newFieldConfigMap = {};
          for (const fieldName in originalFieldConfigMap) {
            const originalFieldConfig = originalFieldConfigMap[fieldName];
            if (testFn(fieldName, originalFieldConfig)) {
              removedFields[fieldName] = originalFieldConfig;
            } else {
              newFieldConfigMap[fieldName] = originalFieldConfig;
            }
          }
          for (const fieldName in newFields) {
            const fieldConfig = newFields[fieldName];
            newFieldConfigMap[fieldName] = fieldConfig;
          }
          return correctASTNodes(new graphql.GraphQLObjectType({
            ...config,
            fields: newFieldConfigMap
          }));
        }
      }
    });
    return [newSchema, removedFields];
  }
  function renameType(type, newTypeName) {
    if (graphql.isObjectType(type)) {
      return new graphql.GraphQLObjectType({
        ...type.toConfig(),
        name: newTypeName,
        astNode: type.astNode == null ? type.astNode : {
          ...type.astNode,
          name: {
            ...type.astNode.name,
            value: newTypeName
          }
        },
        extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map((node) => ({
          ...node,
          name: {
            ...node.name,
            value: newTypeName
          }
        }))
      });
    } else if (graphql.isInterfaceType(type)) {
      return new graphql.GraphQLInterfaceType({
        ...type.toConfig(),
        name: newTypeName,
        astNode: type.astNode == null ? type.astNode : {
          ...type.astNode,
          name: {
            ...type.astNode.name,
            value: newTypeName
          }
        },
        extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map((node) => ({
          ...node,
          name: {
            ...node.name,
            value: newTypeName
          }
        }))
      });
    } else if (graphql.isUnionType(type)) {
      return new graphql.GraphQLUnionType({
        ...type.toConfig(),
        name: newTypeName,
        astNode: type.astNode == null ? type.astNode : {
          ...type.astNode,
          name: {
            ...type.astNode.name,
            value: newTypeName
          }
        },
        extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map((node) => ({
          ...node,
          name: {
            ...node.name,
            value: newTypeName
          }
        }))
      });
    } else if (graphql.isInputObjectType(type)) {
      return new graphql.GraphQLInputObjectType({
        ...type.toConfig(),
        name: newTypeName,
        astNode: type.astNode == null ? type.astNode : {
          ...type.astNode,
          name: {
            ...type.astNode.name,
            value: newTypeName
          }
        },
        extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map((node) => ({
          ...node,
          name: {
            ...node.name,
            value: newTypeName
          }
        }))
      });
    } else if (graphql.isEnumType(type)) {
      return new graphql.GraphQLEnumType({
        ...type.toConfig(),
        name: newTypeName,
        astNode: type.astNode == null ? type.astNode : {
          ...type.astNode,
          name: {
            ...type.astNode.name,
            value: newTypeName
          }
        },
        extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map((node) => ({
          ...node,
          name: {
            ...node.name,
            value: newTypeName
          }
        }))
      });
    } else if (graphql.isScalarType(type)) {
      return new graphql.GraphQLScalarType({
        ...type.toConfig(),
        name: newTypeName,
        astNode: type.astNode == null ? type.astNode : {
          ...type.astNode,
          name: {
            ...type.astNode.name,
            value: newTypeName
          }
        },
        extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map((node) => ({
          ...node,
          name: {
            ...node.name,
            value: newTypeName
          }
        }))
      });
    }
    throw new Error(`Unknown type ${type}.`);
  }
  function mapAsyncIterator(iterator, callback, rejectCallback) {
    let $return;
    let abruptClose;
    if (typeof iterator.return === "function") {
      $return = iterator.return;
      abruptClose = (error) => {
        const rethrow = () => Promise.reject(error);
        return $return.call(iterator).then(rethrow, rethrow);
      };
    }
    function mapResult(result) {
      return result.done ? result : asyncMapValue(result.value, callback).then(iteratorResult, abruptClose);
    }
    let mapReject;
    if (rejectCallback) {
      const reject = rejectCallback;
      mapReject = (error) => asyncMapValue(error, reject).then(iteratorResult, abruptClose);
    }
    return {
      next() {
        return iterator.next().then(mapResult, mapReject);
      },
      return() {
        return $return ? $return.call(iterator).then(mapResult, mapReject) : Promise.resolve({ value: undefined, done: true });
      },
      throw(error) {
        if (typeof iterator.throw === "function") {
          return iterator.throw(error).then(mapResult, mapReject);
        }
        return Promise.reject(error).catch(abruptClose);
      },
      [Symbol.asyncIterator]() {
        return this;
      }
    };
  }
  function asyncMapValue(value, callback) {
    return new Promise((resolve) => resolve(callback(value)));
  }
  function iteratorResult(value) {
    return { value, done: false };
  }
  function updateArgument(argumentNodes, variableDefinitionsMap, variableValues, argName, varName, type, value) {
    argumentNodes[argName] = {
      kind: graphql.Kind.ARGUMENT,
      name: {
        kind: graphql.Kind.NAME,
        value: argName
      },
      value: {
        kind: graphql.Kind.VARIABLE,
        name: {
          kind: graphql.Kind.NAME,
          value: varName
        }
      }
    };
    variableDefinitionsMap[varName] = {
      kind: graphql.Kind.VARIABLE_DEFINITION,
      variable: {
        kind: graphql.Kind.VARIABLE,
        name: {
          kind: graphql.Kind.NAME,
          value: varName
        }
      },
      type: astFromType(type)
    };
    if (value !== undefined) {
      variableValues[varName] = value;
      return;
    }
    if (varName in variableValues) {
      delete variableValues[varName];
    }
  }
  function createVariableNameGenerator(variableDefinitionMap) {
    let varCounter = 0;
    return (argName) => {
      let varName;
      do {
        varName = `_v${(varCounter++).toString()}_${argName}`;
      } while (varName in variableDefinitionMap);
      return varName;
    };
  }
  function implementsAbstractType(schema, typeA, typeB) {
    if (typeB == null || typeA == null) {
      return false;
    } else if (typeA === typeB) {
      return true;
    } else if (graphql.isCompositeType(typeA) && graphql.isCompositeType(typeB)) {
      return graphql.doTypesOverlap(schema, typeA, typeB);
    }
    return false;
  }
  function relocatedError(originalError, path) {
    return new graphql.GraphQLError(originalError.message, originalError.nodes, originalError.source, originalError.positions, path === null ? undefined : path === undefined ? originalError.path : path, originalError.originalError, originalError.extensions);
  }
  function observableToAsyncIterable(observable) {
    const pullQueue = [];
    const pushQueue = [];
    let listening = true;
    const pushValue = (value) => {
      if (pullQueue.length !== 0) {
        pullQueue.shift()({ value, done: false });
      } else {
        pushQueue.push({ value, done: false });
      }
    };
    const pushError = (error) => {
      if (pullQueue.length !== 0) {
        pullQueue.shift()({ value: { errors: [error] }, done: false });
      } else {
        pushQueue.push({ value: { errors: [error] }, done: false });
      }
    };
    const pushDone = () => {
      if (pullQueue.length !== 0) {
        pullQueue.shift()({ done: true });
      } else {
        pushQueue.push({ done: true });
      }
    };
    const pullValue = () => new Promise((resolve) => {
      if (pushQueue.length !== 0) {
        const element = pushQueue.shift();
        resolve(element);
      } else {
        pullQueue.push(resolve);
      }
    });
    const subscription = observable.subscribe({
      next(value) {
        pushValue(value);
      },
      error(err) {
        pushError(err);
      },
      complete() {
        pushDone();
      }
    });
    const emptyQueue = () => {
      if (listening) {
        listening = false;
        subscription.unsubscribe();
        for (const resolve of pullQueue) {
          resolve({ value: undefined, done: true });
        }
        pullQueue.length = 0;
        pushQueue.length = 0;
      }
    };
    return {
      next() {
        return listening ? pullValue() : this.return();
      },
      return() {
        emptyQueue();
        return Promise.resolve({ value: undefined, done: true });
      },
      throw(error) {
        emptyQueue();
        return Promise.reject(error);
      },
      [Symbol.asyncIterator]() {
        return this;
      }
    };
  }
  function collectFields(schema, fragments, variableValues, runtimeType, selectionSet, fields, visitedFragmentNames) {
    for (const selection of selectionSet.selections) {
      switch (selection.kind) {
        case graphql.Kind.FIELD: {
          if (!shouldIncludeNode(variableValues, selection)) {
            continue;
          }
          const name = getFieldEntryKey(selection);
          const fieldList = fields.get(name);
          if (fieldList !== undefined) {
            fieldList.push(selection);
          } else {
            fields.set(name, [selection]);
          }
          break;
        }
        case graphql.Kind.INLINE_FRAGMENT: {
          if (!shouldIncludeNode(variableValues, selection) || !doesFragmentConditionMatch(schema, selection, runtimeType)) {
            continue;
          }
          collectFields(schema, fragments, variableValues, runtimeType, selection.selectionSet, fields, visitedFragmentNames);
          break;
        }
        case graphql.Kind.FRAGMENT_SPREAD: {
          const fragName = selection.name.value;
          if (visitedFragmentNames.has(fragName) || !shouldIncludeNode(variableValues, selection)) {
            continue;
          }
          visitedFragmentNames.add(fragName);
          const fragment = fragments[fragName];
          if (!fragment || !doesFragmentConditionMatch(schema, fragment, runtimeType)) {
            continue;
          }
          collectFields(schema, fragments, variableValues, runtimeType, fragment.selectionSet, fields, visitedFragmentNames);
          break;
        }
      }
    }
    return fields;
  }
  function shouldIncludeNode(variableValues, node) {
    const skip = graphql.getDirectiveValues(graphql.GraphQLSkipDirective, node, variableValues);
    if ((skip === null || skip === undefined ? undefined : skip["if"]) === true) {
      return false;
    }
    const include = graphql.getDirectiveValues(graphql.GraphQLIncludeDirective, node, variableValues);
    if ((include === null || include === undefined ? undefined : include["if"]) === false) {
      return false;
    }
    return true;
  }
  function doesFragmentConditionMatch(schema, fragment, type) {
    const typeConditionNode = fragment.typeCondition;
    if (!typeConditionNode) {
      return true;
    }
    const conditionalType = graphql.typeFromAST(schema, typeConditionNode);
    if (conditionalType === type) {
      return true;
    }
    if (graphql.isAbstractType(conditionalType)) {
      const possibleTypes = schema.getPossibleTypes(conditionalType);
      return possibleTypes.includes(type);
    }
    return false;
  }
  function getFieldEntryKey(node) {
    return node.alias ? node.alias.value : node.name.value;
  }
  var collectSubFields = memoize5(function collectSubFields(schema, fragments, variableValues, type, fieldNodes) {
    const subFieldNodes = new Map;
    const visitedFragmentNames = new Set;
    for (const fieldNode of fieldNodes) {
      if (fieldNode.selectionSet) {
        collectFields(schema, fragments, variableValues, type, fieldNode.selectionSet, subFieldNodes, visitedFragmentNames);
      }
    }
    return subFieldNodes;
  });
  function visitData(data, enter, leave) {
    if (Array.isArray(data)) {
      return data.map((value) => visitData(value, enter, leave));
    } else if (typeof data === "object") {
      const newData = enter != null ? enter(data) : data;
      if (newData != null) {
        for (const key in newData) {
          const value = newData[key];
          newData[key] = visitData(value, enter, leave);
        }
      }
      return leave != null ? leave(newData) : newData;
    }
    return data;
  }
  function visitErrors(errors, visitor) {
    return errors.map((error) => visitor(error));
  }
  function visitResult(result, request, schema, resultVisitorMap, errorVisitorMap) {
    const fragments = request.document.definitions.reduce((acc, def) => {
      if (def.kind === graphql.Kind.FRAGMENT_DEFINITION) {
        acc[def.name.value] = def;
      }
      return acc;
    }, {});
    const variableValues = request.variables || {};
    const errorInfo = {
      segmentInfoMap: new Map,
      unpathedErrors: new Set
    };
    const data = result.data;
    const errors = result.errors;
    const visitingErrors = errors != null && errorVisitorMap != null;
    const operationDocumentNode = graphql.getOperationAST(request.document, undefined);
    if (data != null && operationDocumentNode != null) {
      result.data = visitRoot(data, operationDocumentNode, schema, fragments, variableValues, resultVisitorMap, visitingErrors ? errors : undefined, errorInfo);
    }
    if (errors != null && errorVisitorMap) {
      result.errors = visitErrorsByType(errors, errorVisitorMap, errorInfo);
    }
    return result;
  }
  function visitErrorsByType(errors, errorVisitorMap, errorInfo) {
    const segmentInfoMap = errorInfo.segmentInfoMap;
    const unpathedErrors = errorInfo.unpathedErrors;
    const unpathedErrorVisitor = errorVisitorMap["__unpathed"];
    return errors.map((originalError) => {
      const pathSegmentsInfo = segmentInfoMap.get(originalError);
      const newError = pathSegmentsInfo == null ? originalError : pathSegmentsInfo.reduceRight((acc, segmentInfo) => {
        const typeName = segmentInfo.type.name;
        const typeVisitorMap = errorVisitorMap[typeName];
        if (typeVisitorMap == null) {
          return acc;
        }
        const errorVisitor = typeVisitorMap[segmentInfo.fieldName];
        return errorVisitor == null ? acc : errorVisitor(acc, segmentInfo.pathIndex);
      }, originalError);
      if (unpathedErrorVisitor && unpathedErrors.has(originalError)) {
        return unpathedErrorVisitor(newError);
      }
      return newError;
    });
  }
  function visitRoot(root, operation, schema, fragments, variableValues, resultVisitorMap, errors, errorInfo) {
    const operationRootType = graphql.getOperationRootType(schema, operation);
    const collectedFields = collectFields(schema, fragments, variableValues, operationRootType, operation.selectionSet, new Map, new Set);
    return visitObjectValue(root, operationRootType, collectedFields, schema, fragments, variableValues, resultVisitorMap, 0, errors, errorInfo);
  }
  function visitObjectValue(object, type, fieldNodeMap, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo) {
    const fieldMap = type.getFields();
    const typeVisitorMap = resultVisitorMap === null || resultVisitorMap === undefined ? undefined : resultVisitorMap[type.name];
    const enterObject = typeVisitorMap === null || typeVisitorMap === undefined ? undefined : typeVisitorMap.__enter;
    const newObject = enterObject != null ? enterObject(object) : object;
    let sortedErrors;
    let errorMap = null;
    if (errors != null) {
      sortedErrors = sortErrorsByPathSegment(errors, pathIndex);
      errorMap = sortedErrors.errorMap;
      for (const error of sortedErrors.unpathedErrors) {
        errorInfo.unpathedErrors.add(error);
      }
    }
    for (const [responseKey, subFieldNodes] of fieldNodeMap) {
      const fieldName = subFieldNodes[0].name.value;
      const fieldType = fieldName === "__typename" ? graphql.TypeNameMetaFieldDef.type : fieldMap[fieldName].type;
      const newPathIndex = pathIndex + 1;
      let fieldErrors;
      if (errorMap) {
        fieldErrors = errorMap[responseKey];
        if (fieldErrors != null) {
          delete errorMap[responseKey];
        }
        addPathSegmentInfo(type, fieldName, newPathIndex, fieldErrors, errorInfo);
      }
      const newValue = visitFieldValue(object[responseKey], fieldType, subFieldNodes, schema, fragments, variableValues, resultVisitorMap, newPathIndex, fieldErrors, errorInfo);
      updateObject(newObject, responseKey, newValue, typeVisitorMap, fieldName);
    }
    const oldTypename = newObject.__typename;
    if (oldTypename != null) {
      updateObject(newObject, "__typename", oldTypename, typeVisitorMap, "__typename");
    }
    if (errorMap) {
      for (const errorsKey in errorMap) {
        const errors2 = errorMap[errorsKey];
        for (const error of errors2) {
          errorInfo.unpathedErrors.add(error);
        }
      }
    }
    const leaveObject = typeVisitorMap === null || typeVisitorMap === undefined ? undefined : typeVisitorMap.__leave;
    return leaveObject != null ? leaveObject(newObject) : newObject;
  }
  function updateObject(object, responseKey, newValue, typeVisitorMap, fieldName) {
    if (typeVisitorMap == null) {
      object[responseKey] = newValue;
      return;
    }
    const fieldVisitor = typeVisitorMap[fieldName];
    if (fieldVisitor == null) {
      object[responseKey] = newValue;
      return;
    }
    const visitedValue = fieldVisitor(newValue);
    if (visitedValue === undefined) {
      delete object[responseKey];
      return;
    }
    object[responseKey] = visitedValue;
  }
  function visitListValue(list, returnType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo) {
    return list.map((listMember) => visitFieldValue(listMember, returnType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex + 1, errors, errorInfo));
  }
  function visitFieldValue(value, returnType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors = [], errorInfo) {
    if (value == null) {
      return value;
    }
    const nullableType = graphql.getNullableType(returnType);
    if (graphql.isListType(nullableType)) {
      return visitListValue(value, nullableType.ofType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo);
    } else if (graphql.isAbstractType(nullableType)) {
      const finalType = schema.getType(value.__typename);
      const collectedFields = collectSubFields(schema, fragments, variableValues, finalType, fieldNodes);
      return visitObjectValue(value, finalType, collectedFields, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo);
    } else if (graphql.isObjectType(nullableType)) {
      const collectedFields = collectSubFields(schema, fragments, variableValues, nullableType, fieldNodes);
      return visitObjectValue(value, nullableType, collectedFields, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo);
    }
    const typeVisitorMap = resultVisitorMap === null || resultVisitorMap === undefined ? undefined : resultVisitorMap[nullableType.name];
    if (typeVisitorMap == null) {
      return value;
    }
    const visitedValue = typeVisitorMap(value);
    return visitedValue === undefined ? value : visitedValue;
  }
  function sortErrorsByPathSegment(errors, pathIndex) {
    var _a;
    const errorMap = Object.create(null);
    const unpathedErrors = new Set;
    for (const error of errors) {
      const pathSegment = (_a = error.path) === null || _a === undefined ? undefined : _a[pathIndex];
      if (pathSegment == null) {
        unpathedErrors.add(error);
        continue;
      }
      if (pathSegment in errorMap) {
        errorMap[pathSegment].push(error);
      } else {
        errorMap[pathSegment] = [error];
      }
    }
    return {
      errorMap,
      unpathedErrors
    };
  }
  function addPathSegmentInfo(type, fieldName, pathIndex, errors = [], errorInfo) {
    for (const error of errors) {
      const segmentInfo = {
        type,
        fieldName,
        pathIndex
      };
      const pathSegmentsInfo = errorInfo.segmentInfoMap.get(error);
      if (pathSegmentsInfo == null) {
        errorInfo.segmentInfoMap.set(error, [segmentInfo]);
      } else {
        pathSegmentsInfo.push(segmentInfo);
      }
    }
  }
  function valueMatchesCriteria(value, criteria) {
    if (value == null) {
      return value === criteria;
    } else if (Array.isArray(value)) {
      return Array.isArray(criteria) && value.every((val, index) => valueMatchesCriteria(val, criteria[index]));
    } else if (typeof value === "object") {
      return typeof criteria === "object" && criteria && Object.keys(criteria).every((propertyName) => valueMatchesCriteria(value[propertyName], criteria[propertyName]));
    } else if (criteria instanceof RegExp) {
      return criteria.test(value);
    }
    return value === criteria;
  }
  function isAsyncIterable(value) {
    return typeof value === "object" && value != null && Symbol.asyncIterator in value;
  }
  function isDocumentNode(object) {
    return object && typeof object === "object" && "kind" in object && object.kind === graphql.Kind.DOCUMENT;
  }
  function withCancel(asyncIteratorLike, onCancel) {
    const asyncIterator = asyncIteratorLike[Symbol.asyncIterator]();
    if (!asyncIterator.return) {
      asyncIterator.return = () => Promise.resolve({ value: undefined, done: true });
    }
    const savedReturn = asyncIterator.return.bind(asyncIterator);
    asyncIterator.return = () => {
      onCancel();
      return savedReturn();
    };
    return asyncIterator;
  }
  function buildFixedSchema(schema, options) {
    const document2 = getDocumentNodeFromSchema(schema);
    return graphql.buildASTSchema(document2, {
      ...options || {}
    });
  }
  function fixSchemaAst(schema, options) {
    let schemaWithValidAst = undefined;
    if (!schema.astNode || !schema.extensionASTNodes) {
      schemaWithValidAst = buildFixedSchema(schema, options);
    }
    if (!schema.astNode && (schemaWithValidAst === null || schemaWithValidAst === undefined ? undefined : schemaWithValidAst.astNode)) {
      schema.astNode = schemaWithValidAst.astNode;
    }
    if (!schema.extensionASTNodes && (schemaWithValidAst === null || schemaWithValidAst === undefined ? undefined : schemaWithValidAst.astNode)) {
      schema.extensionASTNodes = schemaWithValidAst.extensionASTNodes;
    }
    return schema;
  }
  exports.addTypes = addTypes;
  exports.appendObjectFields = appendObjectFields;
  exports.asArray = asArray;
  exports.assertSome = assertSome;
  exports.astFromArg = astFromArg;
  exports.astFromDirective = astFromDirective;
  exports.astFromEnumType = astFromEnumType;
  exports.astFromEnumValue = astFromEnumValue;
  exports.astFromField = astFromField;
  exports.astFromInputField = astFromInputField;
  exports.astFromInputObjectType = astFromInputObjectType;
  exports.astFromInterfaceType = astFromInterfaceType;
  exports.astFromObjectType = astFromObjectType;
  exports.astFromScalarType = astFromScalarType;
  exports.astFromSchema = astFromSchema;
  exports.astFromUnionType = astFromUnionType;
  exports.astFromValueUntyped = astFromValueUntyped;
  exports.buildOperationNodeForField = buildOperationNodeForField;
  exports.checkValidationErrors = checkValidationErrors;
  exports.collectComment = collectComment;
  exports.collectFields = collectFields;
  exports.collectSubFields = collectSubFields;
  exports.compareNodes = compareNodes;
  exports.compareStrings = compareStrings;
  exports.correctASTNodes = correctASTNodes;
  exports.createNamedStub = createNamedStub;
  exports.createStub = createStub;
  exports.createVariableNameGenerator = createVariableNameGenerator;
  exports.dedentBlockStringValue = dedentBlockStringValue;
  exports.filterSchema = filterSchema;
  exports.fixSchemaAst = fixSchemaAst;
  exports.forEachDefaultValue = forEachDefaultValue;
  exports.forEachField = forEachField;
  exports.getArgumentValues = getArgumentValues;
  exports.getBlockStringIndentation = getBlockStringIndentation;
  exports.getBuiltInForStub = getBuiltInForStub;
  exports.getComment = getComment;
  exports.getDefinedRootType = getDefinedRootType;
  exports.getDeprecatableDirectiveNodes = getDeprecatableDirectiveNodes;
  exports.getDescription = getDescription;
  exports.getDirective = getDirective;
  exports.getDirectiveInExtensions = getDirectiveInExtensions;
  exports.getDirectiveNodes = getDirectiveNodes;
  exports.getDirectives = getDirectives;
  exports.getDirectivesInExtensions = getDirectivesInExtensions;
  exports.getDocumentNodeFromSchema = getDocumentNodeFromSchema;
  exports.getFieldsWithDirectives = getFieldsWithDirectives;
  exports.getImplementingTypes = getImplementingTypes;
  exports.getLeadingCommentBlock = getLeadingCommentBlock;
  exports.getResolversFromSchema = getResolversFromSchema;
  exports.getResponseKeyFromInfo = getResponseKeyFromInfo;
  exports.getRootTypeMap = getRootTypeMap;
  exports.getRootTypeNames = getRootTypeNames;
  exports.getRootTypes = getRootTypes;
  exports.healSchema = healSchema;
  exports.healTypes = healTypes;
  exports.implementsAbstractType = implementsAbstractType;
  exports.inspect = inspect;
  exports.isAsyncIterable = isAsyncIterable;
  exports.isDescribable = isDescribable;
  exports.isDocumentNode = isDocumentNode;
  exports.isDocumentString = isDocumentString;
  exports.isNamedStub = isNamedStub;
  exports.isSome = isSome;
  exports.isValidPath = isValidPath;
  exports.makeDeprecatedDirective = makeDeprecatedDirective;
  exports.makeDirectiveNode = makeDirectiveNode;
  exports.makeDirectiveNodes = makeDirectiveNodes;
  exports.mapAsyncIterator = mapAsyncIterator;
  exports.mapSchema = mapSchema;
  exports.memoize1 = memoize1;
  exports.memoize2 = memoize2;
  exports.memoize2of4 = memoize2of4;
  exports.memoize3 = memoize3;
  exports.memoize4 = memoize4;
  exports.memoize5 = memoize5;
  exports.mergeDeep = mergeDeep;
  exports.modifyObjectFields = modifyObjectFields;
  exports.nodeToString = nodeToString;
  exports.observableToAsyncIterable = observableToAsyncIterable;
  exports.parseGraphQLJSON = parseGraphQLJSON;
  exports.parseGraphQLSDL = parseGraphQLSDL;
  exports.parseInputValue = parseInputValue;
  exports.parseInputValueLiteral = parseInputValueLiteral;
  exports.parseSelectionSet = parseSelectionSet;
  exports.printComment = printComment;
  exports.printSchemaWithDirectives = printSchemaWithDirectives;
  exports.printWithComments = printWithComments;
  exports.pruneSchema = pruneSchema;
  exports.pushComment = pushComment;
  exports.relocatedError = relocatedError;
  exports.removeObjectFields = removeObjectFields;
  exports.renameType = renameType;
  exports.resetComments = resetComments;
  exports.rewireTypes = rewireTypes;
  exports.selectObjectFields = selectObjectFields;
  exports.serializeInputValue = serializeInputValue;
  exports.transformCommentsToDescriptions = transformCommentsToDescriptions;
  exports.transformInputValue = transformInputValue;
  exports.updateArgument = updateArgument;
  exports.validateGraphQlDocuments = validateGraphQlDocuments;
  exports.valueMatchesCriteria = valueMatchesCriteria;
  exports.visitData = visitData;
  exports.visitErrors = visitErrors;
  exports.visitResult = visitResult;
  exports.withCancel = withCancel;
});

// node_modules/apollo-server-core/node_modules/@graphql-tools/schema/node_modules/@graphql-tools/merge/index.js
var require_merge2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils = require_utils6();
  var graphql = require_graphql2();
  function mergeResolvers(resolversDefinitions, options) {
    if (!resolversDefinitions || Array.isArray(resolversDefinitions) && resolversDefinitions.length === 0) {
      return {};
    }
    if (!Array.isArray(resolversDefinitions)) {
      return resolversDefinitions;
    }
    if (resolversDefinitions.length === 1) {
      return resolversDefinitions[0] || {};
    }
    const resolvers = new Array;
    for (let resolversDefinition of resolversDefinitions) {
      if (Array.isArray(resolversDefinition)) {
        resolversDefinition = mergeResolvers(resolversDefinition);
      }
      if (typeof resolversDefinition === "object" && resolversDefinition) {
        resolvers.push(resolversDefinition);
      }
    }
    const result = utils.mergeDeep(resolvers, true);
    if (options === null || options === undefined ? undefined : options.exclusions) {
      for (const exclusion of options.exclusions) {
        const [typeName, fieldName] = exclusion.split(".");
        if (!fieldName || fieldName === "*") {
          delete result[typeName];
        } else if (result[typeName]) {
          delete result[typeName][fieldName];
        }
      }
    }
    return result;
  }
  function mergeArguments(args1, args2, config) {
    const result = deduplicateArguments([...args2, ...args1].filter(utils.isSome));
    if (config && config.sort) {
      result.sort(utils.compareNodes);
    }
    return result;
  }
  function deduplicateArguments(args2) {
    return args2.reduce((acc, current) => {
      const dup = acc.find((arg) => arg.name.value === current.name.value);
      if (!dup) {
        return acc.concat([current]);
      }
      return acc;
    }, []);
  }
  function directiveAlreadyExists(directivesArr, otherDirective) {
    return !!directivesArr.find((directive) => directive.name.value === otherDirective.name.value);
  }
  function nameAlreadyExists(name, namesArr) {
    return namesArr.some(({ value }) => value === name.value);
  }
  function mergeArguments$1(a1, a2) {
    const result = [...a2];
    for (const argument of a1) {
      const existingIndex = result.findIndex((a) => a.name.value === argument.name.value);
      if (existingIndex > -1) {
        const existingArg = result[existingIndex];
        if (existingArg.value.kind === "ListValue") {
          const source = existingArg.value.values;
          const target = argument.value.values;
          existingArg.value.values = deduplicateLists(source, target, (targetVal, source2) => {
            const value = targetVal.value;
            return !value || !source2.some((sourceVal) => sourceVal.value === value);
          });
        } else {
          existingArg.value = argument.value;
        }
      } else {
        result.push(argument);
      }
    }
    return result;
  }
  function deduplicateDirectives(directives) {
    return directives.map((directive, i, all) => {
      const firstAt = all.findIndex((d) => d.name.value === directive.name.value);
      if (firstAt !== i) {
        const dup = all[firstAt];
        directive.arguments = mergeArguments$1(directive.arguments, dup.arguments);
        return null;
      }
      return directive;
    }).filter(utils.isSome);
  }
  function mergeDirectives(d1 = [], d2 = [], config) {
    const reverseOrder = config && config.reverseDirectives;
    const asNext = reverseOrder ? d1 : d2;
    const asFirst = reverseOrder ? d2 : d1;
    const result = deduplicateDirectives([...asNext]);
    for (const directive of asFirst) {
      if (directiveAlreadyExists(result, directive)) {
        const existingDirectiveIndex = result.findIndex((d) => d.name.value === directive.name.value);
        const existingDirective = result[existingDirectiveIndex];
        result[existingDirectiveIndex].arguments = mergeArguments$1(directive.arguments || [], existingDirective.arguments || []);
      } else {
        result.push(directive);
      }
    }
    return result;
  }
  function validateInputs(node, existingNode) {
    const printedNode = graphql.print({
      ...node,
      description: undefined
    });
    const printedExistingNode = graphql.print({
      ...existingNode,
      description: undefined
    });
    const leaveInputs = new RegExp("(directive @w*d*)|( on .*$)", "g");
    const sameArguments = printedNode.replace(leaveInputs, "") === printedExistingNode.replace(leaveInputs, "");
    if (!sameArguments) {
      throw new Error(`Unable to merge GraphQL directive "${node.name.value}". 
Existing directive:  
	${printedExistingNode} 
Received directive: 
	${printedNode}`);
    }
  }
  function mergeDirective(node, existingNode) {
    if (existingNode) {
      validateInputs(node, existingNode);
      return {
        ...node,
        locations: [
          ...existingNode.locations,
          ...node.locations.filter((name) => !nameAlreadyExists(name, existingNode.locations))
        ]
      };
    }
    return node;
  }
  function deduplicateLists(source, target, filterFn) {
    return source.concat(target.filter((val) => filterFn(val, source)));
  }
  function mergeEnumValues(first, second, config) {
    if (config === null || config === undefined ? undefined : config.consistentEnumMerge) {
      const reversed = [];
      if (first) {
        reversed.push(...first);
      }
      first = second;
      second = reversed;
    }
    const enumValueMap = new Map;
    if (first) {
      for (const firstValue of first) {
        enumValueMap.set(firstValue.name.value, firstValue);
      }
    }
    if (second) {
      for (const secondValue of second) {
        const enumValue = secondValue.name.value;
        if (enumValueMap.has(enumValue)) {
          const firstValue = enumValueMap.get(enumValue);
          firstValue.description = secondValue.description || firstValue.description;
          firstValue.directives = mergeDirectives(secondValue.directives, firstValue.directives);
        } else {
          enumValueMap.set(enumValue, secondValue);
        }
      }
    }
    const result = [...enumValueMap.values()];
    if (config && config.sort) {
      result.sort(utils.compareNodes);
    }
    return result;
  }
  function mergeEnum(e1, e2, config) {
    if (e2) {
      return {
        name: e1.name,
        description: e1["description"] || e2["description"],
        kind: (config === null || config === undefined ? undefined : config.convertExtensions) || e1.kind === "EnumTypeDefinition" || e2.kind === "EnumTypeDefinition" ? "EnumTypeDefinition" : "EnumTypeExtension",
        loc: e1.loc,
        directives: mergeDirectives(e1.directives, e2.directives, config),
        values: mergeEnumValues(e1.values, e2.values, config)
      };
    }
    return (config === null || config === undefined ? undefined : config.convertExtensions) ? {
      ...e1,
      kind: "EnumTypeDefinition"
    } : e1;
  }
  function isStringTypes(types) {
    return typeof types === "string";
  }
  function isSourceTypes(types) {
    return types instanceof graphql.Source;
  }
  function extractType(type) {
    let visitedType = type;
    while (visitedType.kind === graphql.Kind.LIST_TYPE || visitedType.kind === "NonNullType") {
      visitedType = visitedType.type;
    }
    return visitedType;
  }
  function isWrappingTypeNode(type) {
    return type.kind !== graphql.Kind.NAMED_TYPE;
  }
  function isListTypeNode(type) {
    return type.kind === graphql.Kind.LIST_TYPE;
  }
  function isNonNullTypeNode(type) {
    return type.kind === graphql.Kind.NON_NULL_TYPE;
  }
  function printTypeNode(type) {
    if (isListTypeNode(type)) {
      return `[${printTypeNode(type.type)}]`;
    }
    if (isNonNullTypeNode(type)) {
      return `${printTypeNode(type.type)}!`;
    }
    return type.name.value;
  }
  (function(CompareVal) {
    CompareVal[CompareVal["A_SMALLER_THAN_B"] = -1] = "A_SMALLER_THAN_B";
    CompareVal[CompareVal["A_EQUALS_B"] = 0] = "A_EQUALS_B";
    CompareVal[CompareVal["A_GREATER_THAN_B"] = 1] = "A_GREATER_THAN_B";
  })(exports.CompareVal || (exports.CompareVal = {}));
  function defaultStringComparator(a, b) {
    if (a == null && b == null) {
      return exports.CompareVal.A_EQUALS_B;
    }
    if (a == null) {
      return exports.CompareVal.A_SMALLER_THAN_B;
    }
    if (b == null) {
      return exports.CompareVal.A_GREATER_THAN_B;
    }
    if (a < b)
      return exports.CompareVal.A_SMALLER_THAN_B;
    if (a > b)
      return exports.CompareVal.A_GREATER_THAN_B;
    return exports.CompareVal.A_EQUALS_B;
  }
  function fieldAlreadyExists(fieldsArr, otherField, config) {
    const result = fieldsArr.find((field) => field.name.value === otherField.name.value);
    if (result && !(config === null || config === undefined ? undefined : config.ignoreFieldConflicts)) {
      const t1 = extractType(result.type);
      const t2 = extractType(otherField.type);
      if (t1.name.value !== t2.name.value) {
        throw new Error(`Field "${otherField.name.value}" already defined with a different type. Declared as "${t1.name.value}", but you tried to override with "${t2.name.value}"`);
      }
    }
    return !!result;
  }
  function mergeFields(type, f1, f2, config) {
    const result = [];
    if (f2 != null) {
      result.push(...f2);
    }
    if (f1 != null) {
      for (const field of f1) {
        if (fieldAlreadyExists(result, field, config)) {
          const existing = result.find((f) => f.name.value === field.name.value);
          if (!(config === null || config === undefined ? undefined : config.ignoreFieldConflicts)) {
            if (config === null || config === undefined ? undefined : config.throwOnConflict) {
              preventConflicts(type, existing, field, false);
            } else {
              preventConflicts(type, existing, field, true);
            }
            if (isNonNullTypeNode(field.type) && !isNonNullTypeNode(existing.type)) {
              existing.type = field.type;
            }
          }
          existing.arguments = mergeArguments(field["arguments"] || [], existing.arguments || [], config);
          existing.directives = mergeDirectives(field.directives, existing.directives, config);
          existing.description = field.description || existing.description;
        } else {
          result.push(field);
        }
      }
    }
    if (config && config.sort) {
      result.sort(utils.compareNodes);
    }
    if (config && config.exclusions) {
      const exclusions = config.exclusions;
      return result.filter((field) => !exclusions.includes(`${type.name.value}.${field.name.value}`));
    }
    return result;
  }
  function preventConflicts(type, a, b, ignoreNullability = false) {
    const aType = printTypeNode(a.type);
    const bType = printTypeNode(b.type);
    if (aType !== bType && !safeChangeForFieldType(a.type, b.type, ignoreNullability)) {
      throw new Error(`Field '${type.name.value}.${a.name.value}' changed type from '${aType}' to '${bType}'`);
    }
  }
  function safeChangeForFieldType(oldType, newType, ignoreNullability = false) {
    if (!isWrappingTypeNode(oldType) && !isWrappingTypeNode(newType)) {
      return oldType.toString() === newType.toString();
    }
    if (isNonNullTypeNode(newType)) {
      const ofType = isNonNullTypeNode(oldType) ? oldType.type : oldType;
      return safeChangeForFieldType(ofType, newType.type);
    }
    if (isNonNullTypeNode(oldType)) {
      return safeChangeForFieldType(newType, oldType, ignoreNullability);
    }
    if (isListTypeNode(oldType)) {
      return isListTypeNode(newType) && safeChangeForFieldType(oldType.type, newType.type) || isNonNullTypeNode(newType) && safeChangeForFieldType(oldType, newType["type"]);
    }
    return false;
  }
  function mergeInputType(node, existingNode, config) {
    if (existingNode) {
      try {
        return {
          name: node.name,
          description: node["description"] || existingNode["description"],
          kind: (config === null || config === undefined ? undefined : config.convertExtensions) || node.kind === "InputObjectTypeDefinition" || existingNode.kind === "InputObjectTypeDefinition" ? "InputObjectTypeDefinition" : "InputObjectTypeExtension",
          loc: node.loc,
          fields: mergeFields(node, node.fields, existingNode.fields, config),
          directives: mergeDirectives(node.directives, existingNode.directives, config)
        };
      } catch (e) {
        throw new Error(`Unable to merge GraphQL input type "${node.name.value}": ${e.message}`);
      }
    }
    return (config === null || config === undefined ? undefined : config.convertExtensions) ? {
      ...node,
      kind: "InputObjectTypeDefinition"
    } : node;
  }
  function mergeInterface(node, existingNode, config) {
    if (existingNode) {
      try {
        return {
          name: node.name,
          description: node["description"] || existingNode["description"],
          kind: (config === null || config === undefined ? undefined : config.convertExtensions) || node.kind === "InterfaceTypeDefinition" || existingNode.kind === "InterfaceTypeDefinition" ? "InterfaceTypeDefinition" : "InterfaceTypeExtension",
          loc: node.loc,
          fields: mergeFields(node, node.fields, existingNode.fields, config),
          directives: mergeDirectives(node.directives, existingNode.directives, config)
        };
      } catch (e) {
        throw new Error(`Unable to merge GraphQL interface "${node.name.value}": ${e.message}`);
      }
    }
    return (config === null || config === undefined ? undefined : config.convertExtensions) ? {
      ...node,
      kind: "InterfaceTypeDefinition"
    } : node;
  }
  function alreadyExists(arr, other) {
    return !!arr.find((i) => i.name.value === other.name.value);
  }
  function mergeNamedTypeArray(first = [], second = [], config = {}) {
    const result = [...second, ...first.filter((d) => !alreadyExists(second, d))];
    if (config && config.sort) {
      result.sort(utils.compareNodes);
    }
    return result;
  }
  function mergeType(node, existingNode, config) {
    if (existingNode) {
      try {
        return {
          name: node.name,
          description: node["description"] || existingNode["description"],
          kind: (config === null || config === undefined ? undefined : config.convertExtensions) || node.kind === "ObjectTypeDefinition" || existingNode.kind === "ObjectTypeDefinition" ? "ObjectTypeDefinition" : "ObjectTypeExtension",
          loc: node.loc,
          fields: mergeFields(node, node.fields, existingNode.fields, config),
          directives: mergeDirectives(node.directives, existingNode.directives, config),
          interfaces: mergeNamedTypeArray(node.interfaces, existingNode.interfaces, config)
        };
      } catch (e) {
        throw new Error(`Unable to merge GraphQL type "${node.name.value}": ${e.message}`);
      }
    }
    return (config === null || config === undefined ? undefined : config.convertExtensions) ? {
      ...node,
      kind: "ObjectTypeDefinition"
    } : node;
  }
  function mergeScalar(node, existingNode, config) {
    if (existingNode) {
      return {
        name: node.name,
        description: node["description"] || existingNode["description"],
        kind: (config === null || config === undefined ? undefined : config.convertExtensions) || node.kind === "ScalarTypeDefinition" || existingNode.kind === "ScalarTypeDefinition" ? "ScalarTypeDefinition" : "ScalarTypeExtension",
        loc: node.loc,
        directives: mergeDirectives(node.directives, existingNode.directives, config)
      };
    }
    return (config === null || config === undefined ? undefined : config.convertExtensions) ? {
      ...node,
      kind: "ScalarTypeDefinition"
    } : node;
  }
  function mergeUnion(first, second, config) {
    if (second) {
      return {
        name: first.name,
        description: first["description"] || second["description"],
        directives: mergeDirectives(first.directives, second.directives, config),
        kind: (config === null || config === undefined ? undefined : config.convertExtensions) || first.kind === "UnionTypeDefinition" || second.kind === "UnionTypeDefinition" ? "UnionTypeDefinition" : "UnionTypeExtension",
        loc: first.loc,
        types: mergeNamedTypeArray(first.types, second.types, config)
      };
    }
    return (config === null || config === undefined ? undefined : config.convertExtensions) ? {
      ...first,
      kind: "UnionTypeDefinition"
    } : first;
  }
  var DEFAULT_OPERATION_TYPE_NAME_MAP = {
    query: "Query",
    mutation: "Mutation",
    subscription: "Subscription"
  };
  function mergeOperationTypes(opNodeList = [], existingOpNodeList = []) {
    const finalOpNodeList = [];
    for (const opNodeType in DEFAULT_OPERATION_TYPE_NAME_MAP) {
      const opNode = opNodeList.find((n) => n.operation === opNodeType) || existingOpNodeList.find((n) => n.operation === opNodeType);
      if (opNode) {
        finalOpNodeList.push(opNode);
      }
    }
    return finalOpNodeList;
  }
  function mergeSchemaDefs(node, existingNode, config) {
    if (existingNode) {
      return {
        kind: node.kind === graphql.Kind.SCHEMA_DEFINITION || existingNode.kind === graphql.Kind.SCHEMA_DEFINITION ? graphql.Kind.SCHEMA_DEFINITION : graphql.Kind.SCHEMA_EXTENSION,
        description: node["description"] || existingNode["description"],
        directives: mergeDirectives(node.directives, existingNode.directives, config),
        operationTypes: mergeOperationTypes(node.operationTypes, existingNode.operationTypes)
      };
    }
    return (config === null || config === undefined ? undefined : config.convertExtensions) ? {
      ...node,
      kind: graphql.Kind.SCHEMA_DEFINITION
    } : node;
  }
  var schemaDefSymbol = "SCHEMA_DEF_SYMBOL";
  function isNamedDefinitionNode(definitionNode) {
    return "name" in definitionNode;
  }
  function mergeGraphQLNodes(nodes, config) {
    var _a, _b, _c;
    const mergedResultMap = {};
    for (const nodeDefinition of nodes) {
      if (isNamedDefinitionNode(nodeDefinition)) {
        const name = (_a = nodeDefinition.name) === null || _a === undefined ? undefined : _a.value;
        if (config === null || config === undefined ? undefined : config.commentDescriptions) {
          utils.collectComment(nodeDefinition);
        }
        if (name == null) {
          continue;
        }
        if (((_b = config === null || config === undefined ? undefined : config.exclusions) === null || _b === undefined ? undefined : _b.includes(name + ".*")) || ((_c = config === null || config === undefined ? undefined : config.exclusions) === null || _c === undefined ? undefined : _c.includes(name))) {
          delete mergedResultMap[name];
        } else {
          switch (nodeDefinition.kind) {
            case graphql.Kind.OBJECT_TYPE_DEFINITION:
            case graphql.Kind.OBJECT_TYPE_EXTENSION:
              mergedResultMap[name] = mergeType(nodeDefinition, mergedResultMap[name], config);
              break;
            case graphql.Kind.ENUM_TYPE_DEFINITION:
            case graphql.Kind.ENUM_TYPE_EXTENSION:
              mergedResultMap[name] = mergeEnum(nodeDefinition, mergedResultMap[name], config);
              break;
            case graphql.Kind.UNION_TYPE_DEFINITION:
            case graphql.Kind.UNION_TYPE_EXTENSION:
              mergedResultMap[name] = mergeUnion(nodeDefinition, mergedResultMap[name], config);
              break;
            case graphql.Kind.SCALAR_TYPE_DEFINITION:
            case graphql.Kind.SCALAR_TYPE_EXTENSION:
              mergedResultMap[name] = mergeScalar(nodeDefinition, mergedResultMap[name], config);
              break;
            case graphql.Kind.INPUT_OBJECT_TYPE_DEFINITION:
            case graphql.Kind.INPUT_OBJECT_TYPE_EXTENSION:
              mergedResultMap[name] = mergeInputType(nodeDefinition, mergedResultMap[name], config);
              break;
            case graphql.Kind.INTERFACE_TYPE_DEFINITION:
            case graphql.Kind.INTERFACE_TYPE_EXTENSION:
              mergedResultMap[name] = mergeInterface(nodeDefinition, mergedResultMap[name], config);
              break;
            case graphql.Kind.DIRECTIVE_DEFINITION:
              mergedResultMap[name] = mergeDirective(nodeDefinition, mergedResultMap[name]);
              break;
          }
        }
      } else if (nodeDefinition.kind === graphql.Kind.SCHEMA_DEFINITION || nodeDefinition.kind === graphql.Kind.SCHEMA_EXTENSION) {
        mergedResultMap[schemaDefSymbol] = mergeSchemaDefs(nodeDefinition, mergedResultMap[schemaDefSymbol], config);
      }
    }
    return mergedResultMap;
  }
  function mergeTypeDefs(typeSource, config) {
    utils.resetComments();
    const doc = {
      kind: graphql.Kind.DOCUMENT,
      definitions: mergeGraphQLTypes(typeSource, {
        useSchemaDefinition: true,
        forceSchemaDefinition: false,
        throwOnConflict: false,
        commentDescriptions: false,
        ...config
      })
    };
    let result;
    if (config === null || config === undefined ? undefined : config.commentDescriptions) {
      result = utils.printWithComments(doc);
    } else {
      result = doc;
    }
    utils.resetComments();
    return result;
  }
  function visitTypeSources(typeSource, options, allNodes = [], visitedTypeSources = new Set) {
    if (typeSource && !visitedTypeSources.has(typeSource)) {
      visitedTypeSources.add(typeSource);
      if (typeof typeSource === "function") {
        visitTypeSources(typeSource(), options, allNodes, visitedTypeSources);
      } else if (Array.isArray(typeSource)) {
        for (const type of typeSource) {
          visitTypeSources(type, options, allNodes, visitedTypeSources);
        }
      } else if (graphql.isSchema(typeSource)) {
        const documentNode = utils.getDocumentNodeFromSchema(typeSource, options);
        visitTypeSources(documentNode.definitions, options, allNodes, visitedTypeSources);
      } else if (isStringTypes(typeSource) || isSourceTypes(typeSource)) {
        const documentNode = graphql.parse(typeSource, options);
        visitTypeSources(documentNode.definitions, options, allNodes, visitedTypeSources);
      } else if (typeof typeSource === "object" && graphql.isDefinitionNode(typeSource)) {
        allNodes.push(typeSource);
      } else if (utils.isDocumentNode(typeSource)) {
        visitTypeSources(typeSource.definitions, options, allNodes, visitedTypeSources);
      } else {
        throw new Error(`typeDefs must contain only strings, documents, schemas, or functions, got ${typeof typeSource}`);
      }
    }
    return allNodes;
  }
  function mergeGraphQLTypes(typeSource, config) {
    var _a, _b, _c;
    utils.resetComments();
    const allNodes = visitTypeSources(typeSource, config);
    const mergedNodes = mergeGraphQLNodes(allNodes, config);
    if (config === null || config === undefined ? undefined : config.useSchemaDefinition) {
      const schemaDef = mergedNodes[schemaDefSymbol] || {
        kind: graphql.Kind.SCHEMA_DEFINITION,
        operationTypes: []
      };
      const operationTypes = schemaDef.operationTypes;
      for (const opTypeDefNodeType in DEFAULT_OPERATION_TYPE_NAME_MAP) {
        const opTypeDefNode = operationTypes.find((operationType) => operationType.operation === opTypeDefNodeType);
        if (!opTypeDefNode) {
          const possibleRootTypeName = DEFAULT_OPERATION_TYPE_NAME_MAP[opTypeDefNodeType];
          const existingPossibleRootType = mergedNodes[possibleRootTypeName];
          if (existingPossibleRootType != null && existingPossibleRootType.name != null) {
            operationTypes.push({
              kind: graphql.Kind.OPERATION_TYPE_DEFINITION,
              type: {
                kind: graphql.Kind.NAMED_TYPE,
                name: existingPossibleRootType.name
              },
              operation: opTypeDefNodeType
            });
          }
        }
      }
      if (((_a = schemaDef === null || schemaDef === undefined ? undefined : schemaDef.operationTypes) === null || _a === undefined ? undefined : _a.length) != null && schemaDef.operationTypes.length > 0) {
        mergedNodes[schemaDefSymbol] = schemaDef;
      }
    }
    if ((config === null || config === undefined ? undefined : config.forceSchemaDefinition) && !((_c = (_b = mergedNodes[schemaDefSymbol]) === null || _b === undefined ? undefined : _b.operationTypes) === null || _c === undefined ? undefined : _c.length)) {
      mergedNodes[schemaDefSymbol] = {
        kind: graphql.Kind.SCHEMA_DEFINITION,
        operationTypes: [
          {
            kind: graphql.Kind.OPERATION_TYPE_DEFINITION,
            operation: "query",
            type: {
              kind: graphql.Kind.NAMED_TYPE,
              name: {
                kind: graphql.Kind.NAME,
                value: "Query"
              }
            }
          }
        ]
      };
    }
    const mergedNodeDefinitions = Object.values(mergedNodes);
    if (config === null || config === undefined ? undefined : config.sort) {
      const sortFn = typeof config.sort === "function" ? config.sort : defaultStringComparator;
      mergedNodeDefinitions.sort((a, b) => {
        var _a2, _b2;
        return sortFn((_a2 = a.name) === null || _a2 === undefined ? undefined : _a2.value, (_b2 = b.name) === null || _b2 === undefined ? undefined : _b2.value);
      });
    }
    return mergedNodeDefinitions;
  }
  function travelSchemaPossibleExtensions(schema, hooks) {
    hooks.onSchema(schema);
    const typesMap = schema.getTypeMap();
    for (const [, type] of Object.entries(typesMap)) {
      const isPredefinedScalar = graphql.isScalarType(type) && graphql.isSpecifiedScalarType(type);
      const isIntrospection = graphql.isIntrospectionType(type);
      if (isPredefinedScalar || isIntrospection) {
        continue;
      }
      if (graphql.isObjectType(type)) {
        hooks.onObjectType(type);
        const fields = type.getFields();
        for (const [, field] of Object.entries(fields)) {
          hooks.onObjectField(type, field);
          const args2 = field.args || [];
          for (const arg of args2) {
            hooks.onObjectFieldArg(type, field, arg);
          }
        }
      } else if (graphql.isInterfaceType(type)) {
        hooks.onInterface(type);
        const fields = type.getFields();
        for (const [, field] of Object.entries(fields)) {
          hooks.onInterfaceField(type, field);
          const args2 = field.args || [];
          for (const arg of args2) {
            hooks.onInterfaceFieldArg(type, field, arg);
          }
        }
      } else if (graphql.isInputObjectType(type)) {
        hooks.onInputType(type);
        const fields = type.getFields();
        for (const [, field] of Object.entries(fields)) {
          hooks.onInputFieldType(type, field);
        }
      } else if (graphql.isUnionType(type)) {
        hooks.onUnion(type);
      } else if (graphql.isScalarType(type)) {
        hooks.onScalar(type);
      } else if (graphql.isEnumType(type)) {
        hooks.onEnum(type);
        for (const value of type.getValues()) {
          hooks.onEnumValue(type, value);
        }
      }
    }
  }
  function mergeExtensions(extensions) {
    return utils.mergeDeep(extensions);
  }
  function applyExtensionObject(obj, extensions) {
    if (!obj) {
      return;
    }
    obj.extensions = utils.mergeDeep([obj.extensions || {}, extensions || {}]);
  }
  function applyExtensions(schema, extensions) {
    applyExtensionObject(schema, extensions.schemaExtensions);
    for (const [typeName, data] of Object.entries(extensions.types || {})) {
      const type = schema.getType(typeName);
      if (type) {
        applyExtensionObject(type, data.extensions);
        if (data.type === "object" || data.type === "interface") {
          for (const [fieldName, fieldData] of Object.entries(data.fields)) {
            const field = type.getFields()[fieldName];
            if (field) {
              applyExtensionObject(field, fieldData.extensions);
              for (const [arg, argData] of Object.entries(fieldData.arguments)) {
                applyExtensionObject(field.args.find((a) => a.name === arg), argData);
              }
            }
          }
        } else if (data.type === "input") {
          for (const [fieldName, fieldData] of Object.entries(data.fields)) {
            const field = type.getFields()[fieldName];
            applyExtensionObject(field, fieldData.extensions);
          }
        } else if (data.type === "enum") {
          for (const [valueName, valueData] of Object.entries(data.values)) {
            const value = type.getValue(valueName);
            applyExtensionObject(value, valueData);
          }
        }
      }
    }
    return schema;
  }
  function extractExtensionsFromSchema(schema) {
    const result = {
      schemaExtensions: {},
      types: {}
    };
    travelSchemaPossibleExtensions(schema, {
      onSchema: (schema2) => result.schemaExtensions = schema2.extensions || {},
      onObjectType: (type) => result.types[type.name] = { fields: {}, type: "object", extensions: type.extensions || {} },
      onObjectField: (type, field) => result.types[type.name].fields[field.name] = {
        arguments: {},
        extensions: field.extensions || {}
      },
      onObjectFieldArg: (type, field, arg) => result.types[type.name].fields[field.name].arguments[arg.name] = arg.extensions || {},
      onInterface: (type) => result.types[type.name] = { fields: {}, type: "interface", extensions: type.extensions || {} },
      onInterfaceField: (type, field) => result.types[type.name].fields[field.name] = {
        arguments: {},
        extensions: field.extensions || {}
      },
      onInterfaceFieldArg: (type, field, arg) => result.types[type.name].fields[field.name].arguments[arg.name] = arg.extensions || {},
      onEnum: (type) => result.types[type.name] = { values: {}, type: "enum", extensions: type.extensions || {} },
      onEnumValue: (type, value) => result.types[type.name].values[value.name] = value.extensions || {},
      onScalar: (type) => result.types[type.name] = { type: "scalar", extensions: type.extensions || {} },
      onUnion: (type) => result.types[type.name] = { type: "union", extensions: type.extensions || {} },
      onInputType: (type) => result.types[type.name] = { fields: {}, type: "input", extensions: type.extensions || {} },
      onInputFieldType: (type, field) => result.types[type.name].fields[field.name] = { extensions: field.extensions || {} }
    });
    return result;
  }
  exports.applyExtensions = applyExtensions;
  exports.defaultStringComparator = defaultStringComparator;
  exports.extractExtensionsFromSchema = extractExtensionsFromSchema;
  exports.extractType = extractType;
  exports.isListTypeNode = isListTypeNode;
  exports.isNamedDefinitionNode = isNamedDefinitionNode;
  exports.isNonNullTypeNode = isNonNullTypeNode;
  exports.isSourceTypes = isSourceTypes;
  exports.isStringTypes = isStringTypes;
  exports.isWrappingTypeNode = isWrappingTypeNode;
  exports.mergeArguments = mergeArguments;
  exports.mergeDirective = mergeDirective;
  exports.mergeDirectives = mergeDirectives;
  exports.mergeEnum = mergeEnum;
  exports.mergeEnumValues = mergeEnumValues;
  exports.mergeExtensions = mergeExtensions;
  exports.mergeFields = mergeFields;
  exports.mergeGraphQLNodes = mergeGraphQLNodes;
  exports.mergeGraphQLTypes = mergeGraphQLTypes;
  exports.mergeInputType = mergeInputType;
  exports.mergeInterface = mergeInterface;
  exports.mergeNamedTypeArray = mergeNamedTypeArray;
  exports.mergeResolvers = mergeResolvers;
  exports.mergeScalar = mergeScalar;
  exports.mergeType = mergeType;
  exports.mergeTypeDefs = mergeTypeDefs;
  exports.mergeUnion = mergeUnion;
  exports.printTypeNode = printTypeNode;
  exports.schemaDefSymbol = schemaDefSymbol;
  exports.travelSchemaPossibleExtensions = travelSchemaPossibleExtensions;
});

// node_modules/apollo-server-core/node_modules/@graphql-tools/schema/index.js
var require_schema3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var graphql = require_graphql2();
  var utils = require_utils6();
  var merge = require_merge2();
  function assertResolversPresent(schema, resolverValidationOptions = {}) {
    const { requireResolversForArgs, requireResolversForNonScalar, requireResolversForAllFields } = resolverValidationOptions;
    if (requireResolversForAllFields && (requireResolversForArgs || requireResolversForNonScalar)) {
      throw new TypeError("requireResolversForAllFields takes precedence over the more specific assertions. " + "Please configure either requireResolversForAllFields or requireResolversForArgs / " + "requireResolversForNonScalar, but not a combination of them.");
    }
    utils.forEachField(schema, (field, typeName, fieldName) => {
      if (requireResolversForAllFields) {
        expectResolver("requireResolversForAllFields", requireResolversForAllFields, field, typeName, fieldName);
      }
      if (requireResolversForArgs && field.args.length > 0) {
        expectResolver("requireResolversForArgs", requireResolversForArgs, field, typeName, fieldName);
      }
      if (requireResolversForNonScalar !== "ignore" && !graphql.isScalarType(graphql.getNamedType(field.type))) {
        expectResolver("requireResolversForNonScalar", requireResolversForNonScalar, field, typeName, fieldName);
      }
    });
  }
  function expectResolver(validator, behavior, field, typeName, fieldName) {
    if (!field.resolve) {
      const message2 = `Resolver missing for "${typeName}.${fieldName}".
To disable this validator, use:
  resolverValidationOptions: {
    ${validator}: 'ignore'
  }`;
      if (behavior === "error") {
        throw new Error(message2);
      }
      if (behavior === "warn") {
        console.warn(message2);
      }
      return;
    }
    if (typeof field.resolve !== "function") {
      throw new Error(`Resolver "${typeName}.${fieldName}" must be a function`);
    }
  }
  function chainResolvers(resolvers) {
    return (root, args2, ctx, info) => resolvers.reduce((prev, curResolver) => {
      if (curResolver != null) {
        return curResolver(prev, args2, ctx, info);
      }
      return graphql.defaultFieldResolver(prev, args2, ctx, info);
    }, root);
  }
  function checkForResolveTypeResolver(schema, requireResolversForResolveType) {
    utils.mapSchema(schema, {
      [utils.MapperKind.ABSTRACT_TYPE]: (type) => {
        if (!type.resolveType) {
          const message2 = `Type "${type.name}" is missing a "__resolveType" resolver. Pass 'ignore' into ` + '"resolverValidationOptions.requireResolversForResolveType" to disable this error.';
          if (requireResolversForResolveType === "error") {
            throw new Error(message2);
          }
          if (requireResolversForResolveType === "warn") {
            console.warn(message2);
          }
        }
        return;
      }
    });
  }
  function extendResolversFromInterfaces(schema, resolvers) {
    const extendedResolvers = {};
    const typeMap = schema.getTypeMap();
    for (const typeName in typeMap) {
      const type = typeMap[typeName];
      if ("getInterfaces" in type) {
        extendedResolvers[typeName] = {};
        for (const iFace of type.getInterfaces()) {
          if (resolvers[iFace.name]) {
            for (const fieldName in resolvers[iFace.name]) {
              if (fieldName === "__isTypeOf" || !fieldName.startsWith("__")) {
                extendedResolvers[typeName][fieldName] = resolvers[iFace.name][fieldName];
              }
            }
          }
        }
        const typeResolvers = resolvers[typeName];
        extendedResolvers[typeName] = {
          ...extendedResolvers[typeName],
          ...typeResolvers
        };
      } else {
        const typeResolvers = resolvers[typeName];
        if (typeResolvers != null) {
          extendedResolvers[typeName] = typeResolvers;
        }
      }
    }
    return extendedResolvers;
  }
  function addResolversToSchema(schemaOrOptions, legacyInputResolvers, legacyInputValidationOptions) {
    const options = graphql.isSchema(schemaOrOptions) ? {
      schema: schemaOrOptions,
      resolvers: legacyInputResolvers !== null && legacyInputResolvers !== undefined ? legacyInputResolvers : {},
      resolverValidationOptions: legacyInputValidationOptions
    } : schemaOrOptions;
    let { schema, resolvers: inputResolvers, defaultFieldResolver, resolverValidationOptions = {}, inheritResolversFromInterfaces = false, updateResolversInPlace = false } = options;
    const { requireResolversToMatchSchema = "error", requireResolversForResolveType } = resolverValidationOptions;
    const resolvers = inheritResolversFromInterfaces ? extendResolversFromInterfaces(schema, inputResolvers) : inputResolvers;
    for (const typeName in resolvers) {
      const resolverValue = resolvers[typeName];
      const resolverType = typeof resolverValue;
      if (resolverType !== "object") {
        throw new Error(`"${typeName}" defined in resolvers, but has invalid value "${resolverValue}". The resolver's value must be of type object.`);
      }
      const type = schema.getType(typeName);
      if (type == null) {
        if (requireResolversToMatchSchema === "ignore") {
          break;
        }
        throw new Error(`"${typeName}" defined in resolvers, but not in schema`);
      } else if (graphql.isSpecifiedScalarType(type)) {
        for (const fieldName in resolverValue) {
          if (fieldName.startsWith("__")) {
            type[fieldName.substring(2)] = resolverValue[fieldName];
          } else {
            type[fieldName] = resolverValue[fieldName];
          }
        }
      } else if (graphql.isEnumType(type)) {
        const values = type.getValues();
        for (const fieldName in resolverValue) {
          if (!fieldName.startsWith("__") && !values.some((value) => value.name === fieldName) && requireResolversToMatchSchema && requireResolversToMatchSchema !== "ignore") {
            throw new Error(`${type.name}.${fieldName} was defined in resolvers, but not present within ${type.name}`);
          }
        }
      } else if (graphql.isUnionType(type)) {
        for (const fieldName in resolverValue) {
          if (!fieldName.startsWith("__") && requireResolversToMatchSchema && requireResolversToMatchSchema !== "ignore") {
            throw new Error(`${type.name}.${fieldName} was defined in resolvers, but ${type.name} is not an object or interface type`);
          }
        }
      } else if (graphql.isObjectType(type) || graphql.isInterfaceType(type)) {
        for (const fieldName in resolverValue) {
          if (!fieldName.startsWith("__")) {
            const fields = type.getFields();
            const field = fields[fieldName];
            if (field == null) {
              if (requireResolversToMatchSchema && requireResolversToMatchSchema !== "ignore") {
                throw new Error(`${typeName}.${fieldName} defined in resolvers, but not in schema`);
              }
            } else {
              const fieldResolve = resolverValue[fieldName];
              if (typeof fieldResolve !== "function" && typeof fieldResolve !== "object") {
                throw new Error(`Resolver ${typeName}.${fieldName} must be object or function`);
              }
            }
          }
        }
      }
    }
    schema = updateResolversInPlace ? addResolversToExistingSchema(schema, resolvers, defaultFieldResolver) : createNewSchemaWithResolvers(schema, resolvers, defaultFieldResolver);
    if (requireResolversForResolveType && requireResolversForResolveType !== "ignore") {
      checkForResolveTypeResolver(schema, requireResolversForResolveType);
    }
    return schema;
  }
  function addResolversToExistingSchema(schema, resolvers, defaultFieldResolver) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
    const typeMap = schema.getTypeMap();
    for (const typeName in resolvers) {
      const type = schema.getType(typeName);
      const resolverValue = resolvers[typeName];
      if (graphql.isScalarType(type)) {
        for (const fieldName in resolverValue) {
          if (fieldName.startsWith("__")) {
            type[fieldName.substring(2)] = resolverValue[fieldName];
          } else if (fieldName === "astNode" && type.astNode != null) {
            type.astNode = {
              ...type.astNode,
              description: (_c = (_b = (_a = resolverValue) === null || _a === undefined ? undefined : _a.astNode) === null || _b === undefined ? undefined : _b.description) !== null && _c !== undefined ? _c : type.astNode.description,
              directives: ((_d = type.astNode.directives) !== null && _d !== undefined ? _d : []).concat((_g = (_f = (_e = resolverValue) === null || _e === undefined ? undefined : _e.astNode) === null || _f === undefined ? undefined : _f.directives) !== null && _g !== undefined ? _g : [])
            };
          } else if (fieldName === "extensionASTNodes" && type.extensionASTNodes != null) {
            type.extensionASTNodes = type.extensionASTNodes.concat((_j = (_h = resolverValue) === null || _h === undefined ? undefined : _h.extensionASTNodes) !== null && _j !== undefined ? _j : []);
          } else if (fieldName === "extensions" && type.extensions != null && resolverValue.extensions != null) {
            type.extensions = Object.assign(Object.create(null), type.extensions, resolverValue.extensions);
          } else {
            type[fieldName] = resolverValue[fieldName];
          }
        }
      } else if (graphql.isEnumType(type)) {
        const config = type.toConfig();
        const enumValueConfigMap = config.values;
        for (const fieldName in resolverValue) {
          if (fieldName.startsWith("__")) {
            config[fieldName.substring(2)] = resolverValue[fieldName];
          } else if (fieldName === "astNode" && config.astNode != null) {
            config.astNode = {
              ...config.astNode,
              description: (_m = (_l = (_k = resolverValue) === null || _k === undefined ? undefined : _k.astNode) === null || _l === undefined ? undefined : _l.description) !== null && _m !== undefined ? _m : config.astNode.description,
              directives: ((_o = config.astNode.directives) !== null && _o !== undefined ? _o : []).concat((_r = (_q = (_p = resolverValue) === null || _p === undefined ? undefined : _p.astNode) === null || _q === undefined ? undefined : _q.directives) !== null && _r !== undefined ? _r : [])
            };
          } else if (fieldName === "extensionASTNodes" && config.extensionASTNodes != null) {
            config.extensionASTNodes = config.extensionASTNodes.concat((_t = (_s = resolverValue) === null || _s === undefined ? undefined : _s.extensionASTNodes) !== null && _t !== undefined ? _t : []);
          } else if (fieldName === "extensions" && type.extensions != null && resolverValue.extensions != null) {
            type.extensions = Object.assign(Object.create(null), type.extensions, resolverValue.extensions);
          } else if (enumValueConfigMap[fieldName]) {
            enumValueConfigMap[fieldName].value = resolverValue[fieldName];
          }
        }
        typeMap[typeName] = new graphql.GraphQLEnumType(config);
      } else if (graphql.isUnionType(type)) {
        for (const fieldName in resolverValue) {
          if (fieldName.startsWith("__")) {
            type[fieldName.substring(2)] = resolverValue[fieldName];
          }
        }
      } else if (graphql.isObjectType(type) || graphql.isInterfaceType(type)) {
        for (const fieldName in resolverValue) {
          if (fieldName.startsWith("__")) {
            type[fieldName.substring(2)] = resolverValue[fieldName];
            break;
          }
          const fields = type.getFields();
          const field = fields[fieldName];
          if (field != null) {
            const fieldResolve = resolverValue[fieldName];
            if (typeof fieldResolve === "function") {
              field.resolve = fieldResolve.bind(resolverValue);
            } else {
              setFieldProperties(field, fieldResolve);
            }
          }
        }
      }
    }
    utils.forEachDefaultValue(schema, utils.serializeInputValue);
    utils.healSchema(schema);
    utils.forEachDefaultValue(schema, utils.parseInputValue);
    if (defaultFieldResolver != null) {
      utils.forEachField(schema, (field) => {
        if (!field.resolve) {
          field.resolve = defaultFieldResolver;
        }
      });
    }
    return schema;
  }
  function createNewSchemaWithResolvers(schema, resolvers, defaultFieldResolver) {
    schema = utils.mapSchema(schema, {
      [utils.MapperKind.SCALAR_TYPE]: (type) => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const config = type.toConfig();
        const resolverValue = resolvers[type.name];
        if (!graphql.isSpecifiedScalarType(type) && resolverValue != null) {
          for (const fieldName in resolverValue) {
            if (fieldName.startsWith("__")) {
              config[fieldName.substring(2)] = resolverValue[fieldName];
            } else if (fieldName === "astNode" && config.astNode != null) {
              config.astNode = {
                ...config.astNode,
                description: (_c = (_b = (_a = resolverValue) === null || _a === undefined ? undefined : _a.astNode) === null || _b === undefined ? undefined : _b.description) !== null && _c !== undefined ? _c : config.astNode.description,
                directives: ((_d = config.astNode.directives) !== null && _d !== undefined ? _d : []).concat((_g = (_f = (_e = resolverValue) === null || _e === undefined ? undefined : _e.astNode) === null || _f === undefined ? undefined : _f.directives) !== null && _g !== undefined ? _g : [])
              };
            } else if (fieldName === "extensionASTNodes" && config.extensionASTNodes != null) {
              config.extensionASTNodes = config.extensionASTNodes.concat((_j = (_h = resolverValue) === null || _h === undefined ? undefined : _h.extensionASTNodes) !== null && _j !== undefined ? _j : []);
            } else if (fieldName === "extensions" && config.extensions != null && resolverValue.extensions != null) {
              config.extensions = Object.assign(Object.create(null), type.extensions, resolverValue.extensions);
            } else {
              config[fieldName] = resolverValue[fieldName];
            }
          }
          return new graphql.GraphQLScalarType(config);
        }
      },
      [utils.MapperKind.ENUM_TYPE]: (type) => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const resolverValue = resolvers[type.name];
        const config = type.toConfig();
        const enumValueConfigMap = config.values;
        if (resolverValue != null) {
          for (const fieldName in resolverValue) {
            if (fieldName.startsWith("__")) {
              config[fieldName.substring(2)] = resolverValue[fieldName];
            } else if (fieldName === "astNode" && config.astNode != null) {
              config.astNode = {
                ...config.astNode,
                description: (_c = (_b = (_a = resolverValue) === null || _a === undefined ? undefined : _a.astNode) === null || _b === undefined ? undefined : _b.description) !== null && _c !== undefined ? _c : config.astNode.description,
                directives: ((_d = config.astNode.directives) !== null && _d !== undefined ? _d : []).concat((_g = (_f = (_e = resolverValue) === null || _e === undefined ? undefined : _e.astNode) === null || _f === undefined ? undefined : _f.directives) !== null && _g !== undefined ? _g : [])
              };
            } else if (fieldName === "extensionASTNodes" && config.extensionASTNodes != null) {
              config.extensionASTNodes = config.extensionASTNodes.concat((_j = (_h = resolverValue) === null || _h === undefined ? undefined : _h.extensionASTNodes) !== null && _j !== undefined ? _j : []);
            } else if (fieldName === "extensions" && config.extensions != null && resolverValue.extensions != null) {
              config.extensions = Object.assign(Object.create(null), type.extensions, resolverValue.extensions);
            } else if (enumValueConfigMap[fieldName]) {
              enumValueConfigMap[fieldName].value = resolverValue[fieldName];
            }
          }
          return new graphql.GraphQLEnumType(config);
        }
      },
      [utils.MapperKind.UNION_TYPE]: (type) => {
        const resolverValue = resolvers[type.name];
        if (resolverValue != null) {
          const config = type.toConfig();
          if (resolverValue["__resolveType"]) {
            config.resolveType = resolverValue["__resolveType"];
          }
          return new graphql.GraphQLUnionType(config);
        }
      },
      [utils.MapperKind.OBJECT_TYPE]: (type) => {
        const resolverValue = resolvers[type.name];
        if (resolverValue != null) {
          const config = type.toConfig();
          if (resolverValue["__isTypeOf"]) {
            config.isTypeOf = resolverValue["__isTypeOf"];
          }
          return new graphql.GraphQLObjectType(config);
        }
      },
      [utils.MapperKind.INTERFACE_TYPE]: (type) => {
        const resolverValue = resolvers[type.name];
        if (resolverValue != null) {
          const config = type.toConfig();
          if (resolverValue["__resolveType"]) {
            config.resolveType = resolverValue["__resolveType"];
          }
          return new graphql.GraphQLInterfaceType(config);
        }
      },
      [utils.MapperKind.COMPOSITE_FIELD]: (fieldConfig, fieldName, typeName) => {
        const resolverValue = resolvers[typeName];
        if (resolverValue != null) {
          const fieldResolve = resolverValue[fieldName];
          if (fieldResolve != null) {
            const newFieldConfig = { ...fieldConfig };
            if (typeof fieldResolve === "function") {
              newFieldConfig.resolve = fieldResolve.bind(resolverValue);
            } else {
              setFieldProperties(newFieldConfig, fieldResolve);
            }
            return newFieldConfig;
          }
        }
      }
    });
    if (defaultFieldResolver != null) {
      schema = utils.mapSchema(schema, {
        [utils.MapperKind.OBJECT_FIELD]: (fieldConfig) => ({
          ...fieldConfig,
          resolve: fieldConfig.resolve != null ? fieldConfig.resolve : defaultFieldResolver
        })
      });
    }
    return schema;
  }
  function setFieldProperties(field, propertiesObj) {
    for (const propertyName in propertiesObj) {
      field[propertyName] = propertiesObj[propertyName];
    }
  }
  function makeExecutableSchema({ typeDefs, resolvers = {}, resolverValidationOptions = {}, parseOptions = {}, inheritResolversFromInterfaces = false, pruningOptions, updateResolversInPlace = false, schemaExtensions }) {
    if (typeof resolverValidationOptions !== "object") {
      throw new Error("Expected `resolverValidationOptions` to be an object");
    }
    if (!typeDefs) {
      throw new Error("Must provide typeDefs");
    }
    let schema;
    if (graphql.isSchema(typeDefs)) {
      schema = typeDefs;
    } else if (parseOptions === null || parseOptions === undefined ? undefined : parseOptions.commentDescriptions) {
      const mergedTypeDefs = merge.mergeTypeDefs(typeDefs, {
        ...parseOptions,
        commentDescriptions: true
      });
      schema = graphql.buildSchema(mergedTypeDefs, parseOptions);
    } else {
      const mergedTypeDefs = merge.mergeTypeDefs(typeDefs, parseOptions);
      schema = graphql.buildASTSchema(mergedTypeDefs, parseOptions);
    }
    if (pruningOptions) {
      schema = utils.pruneSchema(schema);
    }
    schema = addResolversToSchema({
      schema,
      resolvers: merge.mergeResolvers(resolvers),
      resolverValidationOptions,
      inheritResolversFromInterfaces,
      updateResolversInPlace
    });
    if (Object.keys(resolverValidationOptions).length > 0) {
      assertResolversPresent(schema, resolverValidationOptions);
    }
    if (schemaExtensions) {
      schemaExtensions = merge.mergeExtensions(utils.asArray(schemaExtensions));
      merge.applyExtensions(schema, schemaExtensions);
    }
    return schema;
  }
  function mergeSchemas(config) {
    const extractedTypeDefs = utils.asArray(config.typeDefs || []);
    const extractedResolvers = utils.asArray(config.resolvers || []);
    const extractedSchemaExtensions = utils.asArray(config.schemaExtensions || []);
    const schemas = config.schemas || [];
    for (const schema of schemas) {
      extractedTypeDefs.push(schema);
      extractedResolvers.push(utils.getResolversFromSchema(schema));
      extractedSchemaExtensions.push(merge.extractExtensionsFromSchema(schema));
    }
    return makeExecutableSchema({
      parseOptions: config,
      ...config,
      typeDefs: extractedTypeDefs,
      resolvers: extractedResolvers,
      schemaExtensions: extractedSchemaExtensions
    });
  }
  exports.addResolversToSchema = addResolversToSchema;
  exports.assertResolversPresent = assertResolversPresent;
  exports.chainResolvers = chainResolvers;
  exports.checkForResolveTypeResolver = checkForResolveTypeResolver;
  exports.extendResolversFromInterfaces = extendResolversFromInterfaces;
  exports.makeExecutableSchema = makeExecutableSchema;
  exports.mergeSchemas = mergeSchemas;
});

// node_modules/loglevel/lib/loglevel.js
var require_loglevel = __commonJS((exports, module) => {
  (function(root, definition) {
    if (typeof define === "function" && define.amd) {
      define(definition);
    } else if (typeof module === "object" && module.exports) {
      module.exports = definition();
    } else {
      root.log = definition();
    }
  })(exports, function() {
    var noop = function() {};
    var undefinedType = "undefined";
    var isIE = typeof window !== undefinedType && typeof window.navigator !== undefinedType && /Trident\/|MSIE /.test(window.navigator.userAgent);
    var logMethods = [
      "trace",
      "debug",
      "info",
      "warn",
      "error"
    ];
    function bindMethod(obj, methodName) {
      var method = obj[methodName];
      if (typeof method.bind === "function") {
        return method.bind(obj);
      } else {
        try {
          return Function.prototype.bind.call(method, obj);
        } catch (e) {
          return function() {
            return Function.prototype.apply.apply(method, [obj, arguments]);
          };
        }
      }
    }
    function traceForIE() {
      if (console.log) {
        if (console.log.apply) {
          console.log.apply(console, arguments);
        } else {
          Function.prototype.apply.apply(console.log, [console, arguments]);
        }
      }
      if (console.trace)
        console.trace();
    }
    function realMethod(methodName) {
      if (methodName === "debug") {
        methodName = "log";
      }
      if (typeof console === undefinedType) {
        return false;
      } else if (methodName === "trace" && isIE) {
        return traceForIE;
      } else if (console[methodName] !== undefined) {
        return bindMethod(console, methodName);
      } else if (console.log !== undefined) {
        return bindMethod(console, "log");
      } else {
        return noop;
      }
    }
    function replaceLoggingMethods(level, loggerName) {
      for (var i = 0;i < logMethods.length; i++) {
        var methodName = logMethods[i];
        this[methodName] = i < level ? noop : this.methodFactory(methodName, level, loggerName);
      }
      this.log = this.debug;
    }
    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {
      return function() {
        if (typeof console !== undefinedType) {
          replaceLoggingMethods.call(this, level, loggerName);
          this[methodName].apply(this, arguments);
        }
      };
    }
    function defaultMethodFactory(methodName, level, loggerName) {
      return realMethod(methodName) || enableLoggingWhenConsoleArrives.apply(this, arguments);
    }
    function Logger(name, defaultLevel, factory) {
      var self2 = this;
      var currentLevel;
      var storageKey = "loglevel";
      if (typeof name === "string") {
        storageKey += ":" + name;
      } else if (typeof name === "symbol") {
        storageKey = undefined;
      }
      function persistLevelIfPossible(levelNum) {
        var levelName = (logMethods[levelNum] || "silent").toUpperCase();
        if (typeof window === undefinedType || !storageKey)
          return;
        try {
          window.localStorage[storageKey] = levelName;
          return;
        } catch (ignore) {}
        try {
          window.document.cookie = encodeURIComponent(storageKey) + "=" + levelName + ";";
        } catch (ignore) {}
      }
      function getPersistedLevel() {
        var storedLevel;
        if (typeof window === undefinedType || !storageKey)
          return;
        try {
          storedLevel = window.localStorage[storageKey];
        } catch (ignore) {}
        if (typeof storedLevel === undefinedType) {
          try {
            var cookie = window.document.cookie;
            var location = cookie.indexOf(encodeURIComponent(storageKey) + "=");
            if (location !== -1) {
              storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];
            }
          } catch (ignore) {}
        }
        if (self2.levels[storedLevel] === undefined) {
          storedLevel = undefined;
        }
        return storedLevel;
      }
      self2.name = name;
      self2.levels = {
        TRACE: 0,
        DEBUG: 1,
        INFO: 2,
        WARN: 3,
        ERROR: 4,
        SILENT: 5
      };
      self2.methodFactory = factory || defaultMethodFactory;
      self2.getLevel = function() {
        return currentLevel;
      };
      self2.setLevel = function(level, persist) {
        if (typeof level === "string" && self2.levels[level.toUpperCase()] !== undefined) {
          level = self2.levels[level.toUpperCase()];
        }
        if (typeof level === "number" && level >= 0 && level <= self2.levels.SILENT) {
          currentLevel = level;
          if (persist !== false) {
            persistLevelIfPossible(level);
          }
          replaceLoggingMethods.call(self2, level, name);
          if (typeof console === undefinedType && level < self2.levels.SILENT) {
            return "No console available for logging";
          }
        } else {
          throw "log.setLevel() called with invalid level: " + level;
        }
      };
      self2.setDefaultLevel = function(level) {
        if (!getPersistedLevel()) {
          self2.setLevel(level, false);
        }
      };
      self2.enableAll = function(persist) {
        self2.setLevel(self2.levels.TRACE, persist);
      };
      self2.disableAll = function(persist) {
        self2.setLevel(self2.levels.SILENT, persist);
      };
      var initialLevel = getPersistedLevel();
      if (initialLevel == null) {
        initialLevel = defaultLevel == null ? "WARN" : defaultLevel;
      }
      self2.setLevel(initialLevel, false);
    }
    var defaultLogger = new Logger;
    var _loggersByName = {};
    defaultLogger.getLogger = function getLogger(name) {
      if (typeof name !== "symbol" && typeof name !== "string" || name === "") {
        throw new TypeError("You must supply a name when creating a logger.");
      }
      var logger = _loggersByName[name];
      if (!logger) {
        logger = _loggersByName[name] = new Logger(name, defaultLogger.getLevel(), defaultLogger.methodFactory);
      }
      return logger;
    };
    var _log = typeof window !== undefinedType ? window.log : undefined;
    defaultLogger.noConflict = function() {
      if (typeof window !== undefinedType && window.log === defaultLogger) {
        window.log = _log;
      }
      return defaultLogger;
    };
    defaultLogger.getLoggers = function getLoggers() {
      return _loggersByName;
    };
    defaultLogger["default"] = defaultLogger;
    return defaultLogger;
  });
});

// node_modules/@josephg/resolvable/index.js
var require_resolvable = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var resolvablePromise = () => {
    let resolve;
    let reject;
    const promise = new Promise((_resolve, _reject) => {
      resolve = _resolve;
      reject = _reject;
    });
    promise.resolve = resolve;
    promise.reject = reject;
    return promise;
  };
  exports.default = resolvablePromise;
  module.exports = resolvablePromise;
});

// node_modules/apollo-server-core/dist/utils/schemaHash.js
var require_schemaHash = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.generateSchemaHash = undefined;
  var language_1 = require_language2();
  var execution_1 = require_execution();
  var utilities_1 = require_utilities();
  var fast_json_stable_stringify_1 = __importDefault(require_fast_json_stable_stringify());
  var createSHA_1 = __importDefault(require_createSHA());
  function generateSchemaHash(schema) {
    const introspectionQuery = (0, utilities_1.getIntrospectionQuery)();
    const document2 = (0, language_1.parse)(introspectionQuery);
    const result = (0, execution_1.execute)({
      schema,
      document: document2
    });
    if (result && typeof result.then === "function") {
      throw new Error([
        "The introspection query is resolving asynchronously; execution of an introspection query is not expected to return a `Promise`.",
        "",
        "Wrapped type resolvers should maintain the existing execution dynamics of the resolvers they wrap (i.e. async vs sync) or introspection types should be excluded from wrapping by checking them with `graphql/type`s, `isIntrospectionType` predicate function prior to wrapping."
      ].join(`
`));
    }
    if (!result || !result.data || !result.data.__schema) {
      throw new Error("Unable to generate server introspection document.");
    }
    const introspectionSchema = result.data.__schema;
    const stringifiedSchema = (0, fast_json_stable_stringify_1.default)(introspectionSchema);
    return (0, createSHA_1.default)("sha512").update(stringifiedSchema).digest("hex");
  }
  exports.generateSchemaHash = generateSchemaHash;
});

// node_modules/@apollographql/apollo-tools/lib/utilities/invariant.js
var require_invariant2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.invariant = undefined;
  function invariant(condition, message2) {
    if (!condition) {
      throw new Error(message2);
    }
  }
  exports.invariant = invariant;
});

// node_modules/@apollographql/apollo-tools/lib/utilities/predicates.js
var require_predicates2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isNotNullOrUndefined = undefined;
  function isNotNullOrUndefined(value) {
    return value !== null && typeof value !== "undefined";
  }
  exports.isNotNullOrUndefined = isNotNullOrUndefined;
});

// node_modules/@apollographql/apollo-tools/lib/utilities/graphql.js
var require_graphql3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isDocumentNode = exports.isNode = undefined;
  var graphql_1 = require_graphql2();
  function isNode(maybeNode) {
    return maybeNode && typeof maybeNode.kind === "string";
  }
  exports.isNode = isNode;
  function isDocumentNode(node) {
    return isNode(node) && node.kind === graphql_1.Kind.DOCUMENT;
  }
  exports.isDocumentNode = isDocumentNode;
});

// node_modules/@apollographql/apollo-tools/lib/utilities/index.js
var require_utilities2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_invariant2(), exports);
  __exportStar(require_predicates2(), exports);
  __exportStar(require_graphql3(), exports);
});

// node_modules/@apollographql/apollo-tools/lib/schema/resolverMap.js
var require_resolverMap = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@apollographql/apollo-tools/lib/schema/resolveObject.js
var require_resolveObject = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@apollographql/apollo-tools/lib/schema/index.js
var require_schema4 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_resolverMap(), exports);
  __exportStar(require_resolveObject(), exports);
});

// node_modules/@apollographql/apollo-tools/lib/buildServiceDefinition.js
var require_buildServiceDefinition = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.buildServiceDefinition = undefined;
  var graphql_1 = require_graphql2();
  var graphql_2 = require_graphql3();
  var predicates_1 = require_predicates2();
  function flattened(arr) {
    return new Array().concat(...arr);
  }
  function buildServiceDefinition(modules) {
    const errors = [];
    const typeDefinitionsMap = Object.create(null);
    const typeExtensionsMap = Object.create(null);
    const directivesMap = Object.create(null);
    const schemaDefinitions = [];
    const schemaExtensions = [];
    for (let module2 of modules) {
      if ((0, graphql_2.isNode)(module2) && (0, graphql_2.isDocumentNode)(module2)) {
        module2 = { typeDefs: module2 };
      }
      for (const definition of module2.typeDefs.definitions) {
        if ((0, graphql_1.isTypeDefinitionNode)(definition)) {
          const typeName = definition.name.value;
          if (typeDefinitionsMap[typeName]) {
            typeDefinitionsMap[typeName].push(definition);
          } else {
            typeDefinitionsMap[typeName] = [definition];
          }
        } else if ((0, graphql_1.isTypeExtensionNode)(definition)) {
          const typeName = definition.name.value;
          if (typeExtensionsMap[typeName]) {
            typeExtensionsMap[typeName].push(definition);
          } else {
            typeExtensionsMap[typeName] = [definition];
          }
        } else if (definition.kind === graphql_1.Kind.DIRECTIVE_DEFINITION) {
          const directiveName = definition.name.value;
          if (directivesMap[directiveName]) {
            directivesMap[directiveName].push(definition);
          } else {
            directivesMap[directiveName] = [definition];
          }
        } else if (definition.kind === graphql_1.Kind.SCHEMA_DEFINITION) {
          schemaDefinitions.push(definition);
        } else if (definition.kind === graphql_1.Kind.SCHEMA_EXTENSION) {
          schemaExtensions.push(definition);
        }
      }
    }
    for (const [typeName, typeDefinitions] of Object.entries(typeDefinitionsMap)) {
      if (typeDefinitions.length > 1) {
        errors.push(new graphql_1.GraphQLError(`Type "${typeName}" was defined more than once.`, typeDefinitions));
      }
    }
    for (const [directiveName, directives] of Object.entries(directivesMap)) {
      if (directives.length > 1) {
        errors.push(new graphql_1.GraphQLError(`Directive "${directiveName}" was defined more than once.`, directives));
      }
    }
    let operationTypeMap;
    if (schemaDefinitions.length > 0 || schemaExtensions.length > 0) {
      operationTypeMap = {};
      const schemaDefinition = schemaDefinitions[schemaDefinitions.length - 1];
      const operationTypes = flattened([schemaDefinition, ...schemaExtensions].map((node) => node.operationTypes).filter(predicates_1.isNotNullOrUndefined));
      for (const operationType of operationTypes) {
        const typeName = operationType.type.name.value;
        const operation = operationType.operation;
        if (operationTypeMap[operation]) {
          throw new graphql_1.GraphQLError(`Must provide only one ${operation} type in schema.`, [schemaDefinition]);
        }
        if (!(typeDefinitionsMap[typeName] || typeExtensionsMap[typeName])) {
          throw new graphql_1.GraphQLError(`Specified ${operation} type "${typeName}" not found in document.`, [schemaDefinition]);
        }
        operationTypeMap[operation] = typeName;
      }
    } else {
      operationTypeMap = {
        query: "Query",
        mutation: "Mutation",
        subscription: "Subscription"
      };
    }
    for (const [typeName, typeExtensions] of Object.entries(typeExtensionsMap)) {
      if (!typeDefinitionsMap[typeName]) {
        if (Object.values(operationTypeMap).includes(typeName)) {
          typeDefinitionsMap[typeName] = [
            {
              kind: graphql_1.Kind.OBJECT_TYPE_DEFINITION,
              name: {
                kind: graphql_1.Kind.NAME,
                value: typeName
              }
            }
          ];
        } else {
          errors.push(new graphql_1.GraphQLError(`Cannot extend type "${typeName}" because it does not exist in the existing schema.`, typeExtensions));
        }
      }
    }
    if (errors.length > 0) {
      return { errors };
    }
    try {
      const typeDefinitions = flattened(Object.values(typeDefinitionsMap));
      const directives = flattened(Object.values(directivesMap));
      let schema = (0, graphql_1.buildASTSchema)({
        kind: graphql_1.Kind.DOCUMENT,
        definitions: [...typeDefinitions, ...directives]
      });
      const typeExtensions = flattened(Object.values(typeExtensionsMap));
      if (typeExtensions.length > 0) {
        schema = (0, graphql_1.extendSchema)(schema, {
          kind: graphql_1.Kind.DOCUMENT,
          definitions: typeExtensions
        });
      }
      for (const module2 of modules) {
        if ("kind" in module2 || !module2.resolvers)
          continue;
        addResolversToSchema(schema, module2.resolvers);
      }
      return { schema };
    } catch (error) {
      return { errors: [error] };
    }
  }
  exports.buildServiceDefinition = buildServiceDefinition;
  function addResolversToSchema(schema, resolvers) {
    for (const [typeName, fieldConfigs] of Object.entries(resolvers)) {
      const type = schema.getType(typeName);
      if (!(0, graphql_1.isObjectType)(type))
        continue;
      const fieldMap = type.getFields();
      for (const [fieldName, fieldConfig] of Object.entries(fieldConfigs)) {
        if (fieldName.startsWith("__")) {
          type[fieldName.substring(2)] = fieldConfig;
          continue;
        }
        const field = fieldMap[fieldName];
        if (!field)
          continue;
        if (typeof fieldConfig === "function") {
          field.resolve = fieldConfig;
        } else {
          if (fieldConfig.resolve) {
            field.resolve = fieldConfig.resolve;
          }
          if (fieldConfig.subscribe) {
            field.subscribe = fieldConfig.subscribe;
          }
        }
      }
    }
  }
});

// node_modules/@apollographql/apollo-tools/lib/index.js
var require_lib6 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_utilities2(), exports);
  __exportStar(require_schema4(), exports);
  __exportStar(require_buildServiceDefinition(), exports);
});

// node_modules/apollo-server-core/dist/determineApolloConfig.js
var require_determineApolloConfig = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.determineApolloConfig = undefined;
  var createSHA_1 = __importDefault(require_createSHA());
  function determineApolloConfig(input, logger) {
    var _a, _b, _c;
    const apolloConfig = {};
    const { APOLLO_KEY, APOLLO_GRAPH_REF, APOLLO_GRAPH_ID, APOLLO_GRAPH_VARIANT } = process.env;
    if (input === null || input === undefined ? undefined : input.key) {
      apolloConfig.key = input.key.trim();
    } else if (APOLLO_KEY) {
      apolloConfig.key = APOLLO_KEY.trim();
    }
    if (((_a = input === null || input === undefined ? undefined : input.key) !== null && _a !== undefined ? _a : APOLLO_KEY) !== apolloConfig.key) {
      logger.warn("The provided API key has unexpected leading or trailing whitespace. " + "Apollo Server will trim the key value before use.");
    }
    if (apolloConfig.key) {
      assertValidHeaderValue(apolloConfig.key);
    }
    if (apolloConfig.key) {
      apolloConfig.keyHash = (0, createSHA_1.default)("sha512").update(apolloConfig.key).digest("hex");
    }
    if (input === null || input === undefined ? undefined : input.graphRef) {
      apolloConfig.graphRef = input.graphRef;
    } else if (APOLLO_GRAPH_REF) {
      apolloConfig.graphRef = APOLLO_GRAPH_REF;
    }
    const graphId = (_b = input === null || input === undefined ? undefined : input.graphId) !== null && _b !== undefined ? _b : APOLLO_GRAPH_ID;
    const graphVariant = (_c = input === null || input === undefined ? undefined : input.graphVariant) !== null && _c !== undefined ? _c : APOLLO_GRAPH_VARIANT;
    if (apolloConfig.graphRef) {
      if (graphId) {
        throw new Error("Cannot specify both graph ref and graph ID. Please use " + "`apollo.graphRef` or `APOLLO_GRAPH_REF` without also setting the graph ID.");
      }
      if (graphVariant) {
        throw new Error("Cannot specify both graph ref and graph variant. Please use " + "`apollo.graphRef` or `APOLLO_GRAPH_REF` without also setting the graph variant.");
      }
    } else if (graphId) {
      apolloConfig.graphRef = graphVariant ? `${graphId}@${graphVariant}` : graphId;
    }
    return apolloConfig;
  }
  exports.determineApolloConfig = determineApolloConfig;
  function assertValidHeaderValue(value) {
    const invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/g;
    if (invalidHeaderCharRegex.test(value)) {
      const invalidChars = value.match(invalidHeaderCharRegex);
      throw new Error(`The API key provided to Apollo Server contains characters which are invalid as HTTP header values. The following characters found in the key are invalid: ${invalidChars.join(", ")}. Valid header values may only contain ASCII visible characters. If you think there is an issue with your key, please contact Apollo support.`);
    }
  }
});

// node_modules/retry/lib/retry_operation.js
var require_retry_operation = __commonJS((exports, module) => {
  function RetryOperation(timeouts, options) {
    if (typeof options === "boolean") {
      options = { forever: options };
    }
    this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
    this._timeouts = timeouts;
    this._options = options || {};
    this._maxRetryTime = options && options.maxRetryTime || Infinity;
    this._fn = null;
    this._errors = [];
    this._attempts = 1;
    this._operationTimeout = null;
    this._operationTimeoutCb = null;
    this._timeout = null;
    this._operationStart = null;
    this._timer = null;
    if (this._options.forever) {
      this._cachedTimeouts = this._timeouts.slice(0);
    }
  }
  module.exports = RetryOperation;
  RetryOperation.prototype.reset = function() {
    this._attempts = 1;
    this._timeouts = this._originalTimeouts.slice(0);
  };
  RetryOperation.prototype.stop = function() {
    if (this._timeout) {
      clearTimeout(this._timeout);
    }
    if (this._timer) {
      clearTimeout(this._timer);
    }
    this._timeouts = [];
    this._cachedTimeouts = null;
  };
  RetryOperation.prototype.retry = function(err) {
    if (this._timeout) {
      clearTimeout(this._timeout);
    }
    if (!err) {
      return false;
    }
    var currentTime = new Date().getTime();
    if (err && currentTime - this._operationStart >= this._maxRetryTime) {
      this._errors.push(err);
      this._errors.unshift(new Error("RetryOperation timeout occurred"));
      return false;
    }
    this._errors.push(err);
    var timeout = this._timeouts.shift();
    if (timeout === undefined) {
      if (this._cachedTimeouts) {
        this._errors.splice(0, this._errors.length - 1);
        timeout = this._cachedTimeouts.slice(-1);
      } else {
        return false;
      }
    }
    var self2 = this;
    this._timer = setTimeout(function() {
      self2._attempts++;
      if (self2._operationTimeoutCb) {
        self2._timeout = setTimeout(function() {
          self2._operationTimeoutCb(self2._attempts);
        }, self2._operationTimeout);
        if (self2._options.unref) {
          self2._timeout.unref();
        }
      }
      self2._fn(self2._attempts);
    }, timeout);
    if (this._options.unref) {
      this._timer.unref();
    }
    return true;
  };
  RetryOperation.prototype.attempt = function(fn2, timeoutOps) {
    this._fn = fn2;
    if (timeoutOps) {
      if (timeoutOps.timeout) {
        this._operationTimeout = timeoutOps.timeout;
      }
      if (timeoutOps.cb) {
        this._operationTimeoutCb = timeoutOps.cb;
      }
    }
    var self2 = this;
    if (this._operationTimeoutCb) {
      this._timeout = setTimeout(function() {
        self2._operationTimeoutCb();
      }, self2._operationTimeout);
    }
    this._operationStart = new Date().getTime();
    this._fn(this._attempts);
  };
  RetryOperation.prototype.try = function(fn2) {
    console.log("Using RetryOperation.try() is deprecated");
    this.attempt(fn2);
  };
  RetryOperation.prototype.start = function(fn2) {
    console.log("Using RetryOperation.start() is deprecated");
    this.attempt(fn2);
  };
  RetryOperation.prototype.start = RetryOperation.prototype.try;
  RetryOperation.prototype.errors = function() {
    return this._errors;
  };
  RetryOperation.prototype.attempts = function() {
    return this._attempts;
  };
  RetryOperation.prototype.mainError = function() {
    if (this._errors.length === 0) {
      return null;
    }
    var counts = {};
    var mainError = null;
    var mainErrorCount = 0;
    for (var i = 0;i < this._errors.length; i++) {
      var error = this._errors[i];
      var message2 = error.message;
      var count = (counts[message2] || 0) + 1;
      counts[message2] = count;
      if (count >= mainErrorCount) {
        mainError = error;
        mainErrorCount = count;
      }
    }
    return mainError;
  };
});

// node_modules/retry/lib/retry.js
var require_retry = __commonJS((exports) => {
  var RetryOperation = require_retry_operation();
  exports.operation = function(options) {
    var timeouts = exports.timeouts(options);
    return new RetryOperation(timeouts, {
      forever: options && (options.forever || options.retries === Infinity),
      unref: options && options.unref,
      maxRetryTime: options && options.maxRetryTime
    });
  };
  exports.timeouts = function(options) {
    if (options instanceof Array) {
      return [].concat(options);
    }
    var opts = {
      retries: 10,
      factor: 2,
      minTimeout: 1 * 1000,
      maxTimeout: Infinity,
      randomize: false
    };
    for (var key in options) {
      opts[key] = options[key];
    }
    if (opts.minTimeout > opts.maxTimeout) {
      throw new Error("minTimeout is greater than maxTimeout");
    }
    var timeouts = [];
    for (var i = 0;i < opts.retries; i++) {
      timeouts.push(this.createTimeout(i, opts));
    }
    if (options && options.forever && !timeouts.length) {
      timeouts.push(this.createTimeout(i, opts));
    }
    timeouts.sort(function(a, b) {
      return a - b;
    });
    return timeouts;
  };
  exports.createTimeout = function(attempt, opts) {
    var random = opts.randomize ? Math.random() + 1 : 1;
    var timeout = Math.round(random * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));
    timeout = Math.min(timeout, opts.maxTimeout);
    return timeout;
  };
  exports.wrap = function(obj, options, methods) {
    if (options instanceof Array) {
      methods = options;
      options = null;
    }
    if (!methods) {
      methods = [];
      for (var key in obj) {
        if (typeof obj[key] === "function") {
          methods.push(key);
        }
      }
    }
    for (var i = 0;i < methods.length; i++) {
      var method = methods[i];
      var original = obj[method];
      obj[method] = function retryWrapper(original2) {
        var op = exports.operation(options);
        var args2 = Array.prototype.slice.call(arguments, 1);
        var callback = args2.pop();
        args2.push(function(err) {
          if (op.retry(err)) {
            return;
          }
          if (err) {
            arguments[0] = op.mainError();
          }
          callback.apply(this, arguments);
        });
        op.attempt(function() {
          original2.apply(obj, args2);
        });
      }.bind(obj, original);
      obj[method].options = options;
    }
  };
});

// node_modules/async-retry/lib/index.js
var require_lib7 = __commonJS((exports, module) => {
  var retrier = require_retry();
  function retry(fn2, opts) {
    function run(resolve, reject) {
      var options = opts || {};
      var op;
      if (!("randomize" in options)) {
        options.randomize = true;
      }
      op = retrier.operation(options);
      function bail(err) {
        reject(err || new Error("Aborted"));
      }
      function onError(err, num) {
        if (err.bail) {
          bail(err);
          return;
        }
        if (!op.retry(err)) {
          reject(op.mainError());
        } else if (options.onRetry) {
          options.onRetry(err, num);
        }
      }
      function runAttempt(num) {
        var val;
        try {
          val = fn2(bail, num);
        } catch (err) {
          onError(err, num);
          return;
        }
        Promise.resolve(val).then(resolve).catch(function catchIt(err) {
          onError(err, num);
        });
      }
      op.attempt(runAttempt);
    }
    return new Promise(run);
  }
  module.exports = retry;
});

// node_modules/@protobufjs/aspromise/index.js
var require_aspromise = __commonJS((exports, module) => {
  module.exports = asPromise;
  function asPromise(fn2, ctx) {
    var params = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;
    while (index < arguments.length)
      params[offset++] = arguments[index++];
    return new Promise(function executor(resolve, reject) {
      params[offset] = function callback(err) {
        if (pending) {
          pending = false;
          if (err)
            reject(err);
          else {
            var params2 = new Array(arguments.length - 1), offset2 = 0;
            while (offset2 < params2.length)
              params2[offset2++] = arguments[offset2];
            resolve.apply(null, params2);
          }
        }
      };
      try {
        fn2.apply(ctx || null, params);
      } catch (err) {
        if (pending) {
          pending = false;
          reject(err);
        }
      }
    });
  }
});

// node_modules/@protobufjs/base64/index.js
var require_base64 = __commonJS((exports) => {
  var base64 = exports;
  base64.length = function length(string) {
    var p = string.length;
    if (!p)
      return 0;
    var n = 0;
    while (--p % 4 > 1 && string.charAt(p) === "=")
      ++n;
    return Math.ceil(string.length * 3) / 4 - n;
  };
  var b64 = new Array(64);
  var s64 = new Array(123);
  for (i = 0;i < 64; )
    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;
  var i;
  base64.encode = function encode(buffer, start, end) {
    var parts = null, chunk = [];
    var i2 = 0, j = 0, t;
    while (start < end) {
      var b = buffer[start++];
      switch (j) {
        case 0:
          chunk[i2++] = b64[b >> 2];
          t = (b & 3) << 4;
          j = 1;
          break;
        case 1:
          chunk[i2++] = b64[t | b >> 4];
          t = (b & 15) << 2;
          j = 2;
          break;
        case 2:
          chunk[i2++] = b64[t | b >> 6];
          chunk[i2++] = b64[b & 63];
          j = 0;
          break;
      }
      if (i2 > 8191) {
        (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
        i2 = 0;
      }
    }
    if (j) {
      chunk[i2++] = b64[t];
      chunk[i2++] = 61;
      if (j === 1)
        chunk[i2++] = 61;
    }
    if (parts) {
      if (i2)
        parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
      return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i2));
  };
  var invalidEncoding = "invalid encoding";
  base64.decode = function decode(string, buffer, offset) {
    var start = offset;
    var j = 0, t;
    for (var i2 = 0;i2 < string.length; ) {
      var c = string.charCodeAt(i2++);
      if (c === 61 && j > 1)
        break;
      if ((c = s64[c]) === undefined)
        throw Error(invalidEncoding);
      switch (j) {
        case 0:
          t = c;
          j = 1;
          break;
        case 1:
          buffer[offset++] = t << 2 | (c & 48) >> 4;
          t = c;
          j = 2;
          break;
        case 2:
          buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
          t = c;
          j = 3;
          break;
        case 3:
          buffer[offset++] = (t & 3) << 6 | c;
          j = 0;
          break;
      }
    }
    if (j === 1)
      throw Error(invalidEncoding);
    return offset - start;
  };
  base64.test = function test(string) {
    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
  };
});

// node_modules/@protobufjs/eventemitter/index.js
var require_eventemitter = __commonJS((exports, module) => {
  module.exports = EventEmitter;
  function EventEmitter() {
    this._listeners = {};
  }
  EventEmitter.prototype.on = function on(evt, fn2, ctx) {
    (this._listeners[evt] || (this._listeners[evt] = [])).push({
      fn: fn2,
      ctx: ctx || this
    });
    return this;
  };
  EventEmitter.prototype.off = function off(evt, fn2) {
    if (evt === undefined)
      this._listeners = {};
    else {
      if (fn2 === undefined)
        this._listeners[evt] = [];
      else {
        var listeners = this._listeners[evt];
        for (var i = 0;i < listeners.length; )
          if (listeners[i].fn === fn2)
            listeners.splice(i, 1);
          else
            ++i;
      }
    }
    return this;
  };
  EventEmitter.prototype.emit = function emit(evt) {
    var listeners = this._listeners[evt];
    if (listeners) {
      var args2 = [], i = 1;
      for (;i < arguments.length; )
        args2.push(arguments[i++]);
      for (i = 0;i < listeners.length; )
        listeners[i].fn.apply(listeners[i++].ctx, args2);
    }
    return this;
  };
});

// node_modules/@protobufjs/float/index.js
var require_float = __commonJS((exports, module) => {
  module.exports = factory(factory);
  function factory(exports2) {
    if (typeof Float32Array !== "undefined")
      (function() {
        var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;
        function writeFloat_f32_cpy(val, buf, pos) {
          f32[0] = val;
          buf[pos] = f8b[0];
          buf[pos + 1] = f8b[1];
          buf[pos + 2] = f8b[2];
          buf[pos + 3] = f8b[3];
        }
        function writeFloat_f32_rev(val, buf, pos) {
          f32[0] = val;
          buf[pos] = f8b[3];
          buf[pos + 1] = f8b[2];
          buf[pos + 2] = f8b[1];
          buf[pos + 3] = f8b[0];
        }
        exports2.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
        exports2.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;
        function readFloat_f32_cpy(buf, pos) {
          f8b[0] = buf[pos];
          f8b[1] = buf[pos + 1];
          f8b[2] = buf[pos + 2];
          f8b[3] = buf[pos + 3];
          return f32[0];
        }
        function readFloat_f32_rev(buf, pos) {
          f8b[3] = buf[pos];
          f8b[2] = buf[pos + 1];
          f8b[1] = buf[pos + 2];
          f8b[0] = buf[pos + 3];
          return f32[0];
        }
        exports2.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
        exports2.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;
      })();
    else
      (function() {
        function writeFloat_ieee754(writeUint, val, buf, pos) {
          var sign = val < 0 ? 1 : 0;
          if (sign)
            val = -val;
          if (val === 0)
            writeUint(1 / val > 0 ? 0 : 2147483648, buf, pos);
          else if (isNaN(val))
            writeUint(2143289344, buf, pos);
          else if (val > 340282346638528860000000000000000000000)
            writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
          else if (val < 0.000000000000000000000000000000000000011754943508222875)
            writeUint((sign << 31 | Math.round(val / 0.000000000000000000000000000000000000000000001401298464324817)) >>> 0, buf, pos);
          else {
            var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
            writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
          }
        }
        exports2.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
        exports2.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
        function readFloat_ieee754(readUint, buf, pos) {
          var uint = readUint(buf, pos), sign = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
          return exponent === 255 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 0.000000000000000000000000000000000000000000001401298464324817 * mantissa : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
        }
        exports2.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
        exports2.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
      })();
    if (typeof Float64Array !== "undefined")
      (function() {
        var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;
        function writeDouble_f64_cpy(val, buf, pos) {
          f64[0] = val;
          buf[pos] = f8b[0];
          buf[pos + 1] = f8b[1];
          buf[pos + 2] = f8b[2];
          buf[pos + 3] = f8b[3];
          buf[pos + 4] = f8b[4];
          buf[pos + 5] = f8b[5];
          buf[pos + 6] = f8b[6];
          buf[pos + 7] = f8b[7];
        }
        function writeDouble_f64_rev(val, buf, pos) {
          f64[0] = val;
          buf[pos] = f8b[7];
          buf[pos + 1] = f8b[6];
          buf[pos + 2] = f8b[5];
          buf[pos + 3] = f8b[4];
          buf[pos + 4] = f8b[3];
          buf[pos + 5] = f8b[2];
          buf[pos + 6] = f8b[1];
          buf[pos + 7] = f8b[0];
        }
        exports2.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
        exports2.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;
        function readDouble_f64_cpy(buf, pos) {
          f8b[0] = buf[pos];
          f8b[1] = buf[pos + 1];
          f8b[2] = buf[pos + 2];
          f8b[3] = buf[pos + 3];
          f8b[4] = buf[pos + 4];
          f8b[5] = buf[pos + 5];
          f8b[6] = buf[pos + 6];
          f8b[7] = buf[pos + 7];
          return f64[0];
        }
        function readDouble_f64_rev(buf, pos) {
          f8b[7] = buf[pos];
          f8b[6] = buf[pos + 1];
          f8b[5] = buf[pos + 2];
          f8b[4] = buf[pos + 3];
          f8b[3] = buf[pos + 4];
          f8b[2] = buf[pos + 5];
          f8b[1] = buf[pos + 6];
          f8b[0] = buf[pos + 7];
          return f64[0];
        }
        exports2.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
        exports2.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;
      })();
    else
      (function() {
        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
          var sign = val < 0 ? 1 : 0;
          if (sign)
            val = -val;
          if (val === 0) {
            writeUint(0, buf, pos + off0);
            writeUint(1 / val > 0 ? 0 : 2147483648, buf, pos + off1);
          } else if (isNaN(val)) {
            writeUint(0, buf, pos + off0);
            writeUint(2146959360, buf, pos + off1);
          } else if (val > 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000) {
            writeUint(0, buf, pos + off0);
            writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
          } else {
            var mantissa;
            if (val < 0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000022250738585072014) {
              mantissa = val / 0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005;
              writeUint(mantissa >>> 0, buf, pos + off0);
              writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
            } else {
              var exponent = Math.floor(Math.log(val) / Math.LN2);
              if (exponent === 1024)
                exponent = 1023;
              mantissa = val * Math.pow(2, -exponent);
              writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
              writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
            }
          }
        }
        exports2.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
        exports2.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
        function readDouble_ieee754(readUint, off0, off1, buf, pos) {
          var lo = readUint(buf, pos + off0), hi = readUint(buf, pos + off1);
          var sign = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
          return exponent === 2047 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005 * mantissa : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
        }
        exports2.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
        exports2.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
      })();
    return exports2;
  }
  function writeUintLE(val, buf, pos) {
    buf[pos] = val & 255;
    buf[pos + 1] = val >>> 8 & 255;
    buf[pos + 2] = val >>> 16 & 255;
    buf[pos + 3] = val >>> 24;
  }
  function writeUintBE(val, buf, pos) {
    buf[pos] = val >>> 24;
    buf[pos + 1] = val >>> 16 & 255;
    buf[pos + 2] = val >>> 8 & 255;
    buf[pos + 3] = val & 255;
  }
  function readUintLE(buf, pos) {
    return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;
  }
  function readUintBE(buf, pos) {
    return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;
  }
});

// node_modules/@protobufjs/inquire/index.js
var require_inquire = __commonJS((exports, module) => {
  module.exports = inquire;
  function inquire(moduleName) {
    try {
      var mod = eval("quire".replace(/^/, "re"))(moduleName);
      if (mod && (mod.length || Object.keys(mod).length))
        return mod;
    } catch (e) {}
    return null;
  }
});

// node_modules/@protobufjs/utf8/index.js
var require_utf8 = __commonJS((exports) => {
  var utf8 = exports;
  utf8.length = function utf8_length(string) {
    var len = 0, c = 0;
    for (var i = 0;i < string.length; ++i) {
      c = string.charCodeAt(i);
      if (c < 128)
        len += 1;
      else if (c < 2048)
        len += 2;
      else if ((c & 64512) === 55296 && (string.charCodeAt(i + 1) & 64512) === 56320) {
        ++i;
        len += 4;
      } else
        len += 3;
    }
    return len;
  };
  utf8.read = function utf8_read(buffer, start, end) {
    var len = end - start;
    if (len < 1)
      return "";
    var parts = null, chunk = [], i = 0, t;
    while (start < end) {
      t = buffer[start++];
      if (t < 128)
        chunk[i++] = t;
      else if (t > 191 && t < 224)
        chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
      else if (t > 239 && t < 365) {
        t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 65536;
        chunk[i++] = 55296 + (t >> 10);
        chunk[i++] = 56320 + (t & 1023);
      } else
        chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
      if (i > 8191) {
        (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
        i = 0;
      }
    }
    if (parts) {
      if (i)
        parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
      return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
  };
  utf8.write = function utf8_write(string, buffer, offset) {
    var start = offset, c1, c2;
    for (var i = 0;i < string.length; ++i) {
      c1 = string.charCodeAt(i);
      if (c1 < 128) {
        buffer[offset++] = c1;
      } else if (c1 < 2048) {
        buffer[offset++] = c1 >> 6 | 192;
        buffer[offset++] = c1 & 63 | 128;
      } else if ((c1 & 64512) === 55296 && ((c2 = string.charCodeAt(i + 1)) & 64512) === 56320) {
        c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
        ++i;
        buffer[offset++] = c1 >> 18 | 240;
        buffer[offset++] = c1 >> 12 & 63 | 128;
        buffer[offset++] = c1 >> 6 & 63 | 128;
        buffer[offset++] = c1 & 63 | 128;
      } else {
        buffer[offset++] = c1 >> 12 | 224;
        buffer[offset++] = c1 >> 6 & 63 | 128;
        buffer[offset++] = c1 & 63 | 128;
      }
    }
    return offset - start;
  };
});

// node_modules/@protobufjs/pool/index.js
var require_pool = __commonJS((exports, module) => {
  module.exports = pool;
  function pool(alloc, slice, size) {
    var SIZE = size || 8192;
    var MAX = SIZE >>> 1;
    var slab = null;
    var offset = SIZE;
    return function pool_alloc(size2) {
      if (size2 < 1 || size2 > MAX)
        return alloc(size2);
      if (offset + size2 > SIZE) {
        slab = alloc(SIZE);
        offset = 0;
      }
      var buf = slice.call(slab, offset, offset += size2);
      if (offset & 7)
        offset = (offset | 7) + 1;
      return buf;
    };
  }
});

// node_modules/@apollo/protobufjs/src/util/longbits.js
var require_longbits = __commonJS((exports, module) => {
  module.exports = LongBits;
  var util = require_minimal();
  function LongBits(lo, hi) {
    this.lo = lo >>> 0;
    this.hi = hi >>> 0;
  }
  var zero = LongBits.zero = new LongBits(0, 0);
  zero.toNumber = function() {
    return 0;
  };
  zero.zzEncode = zero.zzDecode = function() {
    return this;
  };
  zero.length = function() {
    return 1;
  };
  var zeroHash = LongBits.zeroHash = "\x00\x00\x00\x00\x00\x00\x00\x00";
  LongBits.fromNumber = function fromNumber(value) {
    if (value === 0)
      return zero;
    var sign = value < 0;
    if (sign)
      value = -value;
    var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
    if (sign) {
      hi = ~hi >>> 0;
      lo = ~lo >>> 0;
      if (++lo > 4294967295) {
        lo = 0;
        if (++hi > 4294967295)
          hi = 0;
      }
    }
    return new LongBits(lo, hi);
  };
  LongBits.from = function from(value) {
    if (typeof value === "number")
      return LongBits.fromNumber(value);
    if (util.isString(value)) {
      if (util.Long)
        value = util.Long.fromString(value);
      else
        return LongBits.fromNumber(parseInt(value, 10));
    }
    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
  };
  LongBits.prototype.toNumber = function toNumber(unsigned) {
    if (!unsigned && this.hi >>> 31) {
      var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
      if (!lo)
        hi = hi + 1 >>> 0;
      return -(lo + hi * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
  };
  LongBits.prototype.toLong = function toLong(unsigned) {
    return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
  };
  var charCodeAt = String.prototype.charCodeAt;
  LongBits.fromHash = function fromHash(hash) {
    if (hash === zeroHash)
      return zero;
    return new LongBits((charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0, (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0);
  };
  LongBits.prototype.toHash = function toHash() {
    return String.fromCharCode(this.lo & 255, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, this.hi & 255, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24);
  };
  LongBits.prototype.zzEncode = function zzEncode() {
    var mask = this.hi >> 31;
    this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
    this.lo = (this.lo << 1 ^ mask) >>> 0;
    return this;
  };
  LongBits.prototype.zzDecode = function zzDecode() {
    var mask = -(this.lo & 1);
    this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
    this.hi = (this.hi >>> 1 ^ mask) >>> 0;
    return this;
  };
  LongBits.prototype.length = function length() {
    var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
    return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
  };
});

// node_modules/@apollo/protobufjs/src/util/minimal.js
var require_minimal = __commonJS((exports) => {
  var util = exports;
  util.asPromise = require_aspromise();
  util.base64 = require_base64();
  util.EventEmitter = require_eventemitter();
  util.float = require_float();
  util.inquire = require_inquire();
  util.utf8 = require_utf8();
  util.pool = require_pool();
  util.LongBits = require_longbits();
  util.global = typeof window !== "undefined" && window || typeof global !== "undefined" && global || typeof self !== "undefined" && self || exports;
  util.emptyArray = Object.freeze ? Object.freeze([]) : [];
  util.emptyObject = Object.freeze ? Object.freeze({}) : {};
  util.isNode = Boolean(util.global.process && util.global.process.versions && util.global.process.versions.node);
  util.isInteger = Number.isInteger || function isInteger(value) {
    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
  };
  util.isString = function isString(value) {
    return typeof value === "string" || value instanceof String;
  };
  util.isObject = function isObject(value) {
    return value && typeof value === "object";
  };
  util.isset = util.isSet = function isSet(obj, prop) {
    var value = obj[prop];
    if (value != null && obj.hasOwnProperty(prop))
      return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
    return false;
  };
  util.Buffer = function() {
    try {
      var Buffer2 = util.inquire("buffer").Buffer;
      return Buffer2.prototype.utf8Write ? Buffer2 : null;
    } catch (e) {
      return null;
    }
  }();
  util._Buffer_from = null;
  util._Buffer_allocUnsafe = null;
  util.newBuffer = function newBuffer(sizeOrArray) {
    return typeof sizeOrArray === "number" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
  };
  util.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
  util.Long = typeof process === "undefined" || process.env.ENABLE_LONG ? util.global.dcodeIO && util.global.dcodeIO.Long || util.global.Long || util.inquire("long") : undefined;
  util.key2Re = /^true|false|0|1$/;
  util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
  util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
  util.longToHash = function longToHash(value) {
    return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;
  };
  util.longFromHash = function longFromHash(hash, unsigned) {
    var bits = util.LongBits.fromHash(hash);
    if (util.Long)
      return util.Long.fromBits(bits.lo, bits.hi, unsigned);
    return bits.toNumber(Boolean(unsigned));
  };
  function merge(dst, src, ifNotSet) {
    for (var keys = Object.keys(src), i = 0;i < keys.length; ++i)
      if (dst[keys[i]] === undefined || !ifNotSet)
        dst[keys[i]] = src[keys[i]];
    return dst;
  }
  util.merge = merge;
  util.lcFirst = function lcFirst(str) {
    return str.charAt(0).toLowerCase() + str.substring(1);
  };
  function newError(name) {
    function CustomError(message2, properties) {
      if (!(this instanceof CustomError))
        return new CustomError(message2, properties);
      Object.defineProperty(this, "message", { get: function() {
        return message2;
      } });
      if (Error.captureStackTrace)
        Error.captureStackTrace(this, CustomError);
      else
        Object.defineProperty(this, "stack", { value: new Error().stack || "" });
      if (properties)
        merge(this, properties);
    }
    (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;
    Object.defineProperty(CustomError.prototype, "name", { get: function() {
      return name;
    } });
    CustomError.prototype.toString = function toString() {
      return this.name + ": " + this.message;
    };
    return CustomError;
  }
  util.newError = newError;
  util.ProtocolError = newError("ProtocolError");
  util.oneOfGetter = function getOneOf(fieldNames) {
    var fieldMap = {};
    for (var i = 0;i < fieldNames.length; ++i)
      fieldMap[fieldNames[i]] = 1;
    return function() {
      for (var keys = Object.keys(this), i2 = keys.length - 1;i2 > -1; --i2)
        if (fieldMap[keys[i2]] === 1 && this[keys[i2]] !== undefined && this[keys[i2]] !== null)
          return keys[i2];
    };
  };
  util.oneOfSetter = function setOneOf(fieldNames) {
    return function(name) {
      for (var i = 0;i < fieldNames.length; ++i)
        if (fieldNames[i] !== name)
          delete this[fieldNames[i]];
    };
  };
  util.toJSONOptions = {
    longs: String,
    enums: String,
    bytes: String,
    json: true
  };
  util._configure = function() {
    var Buffer2 = util.Buffer;
    if (!Buffer2) {
      util._Buffer_from = util._Buffer_allocUnsafe = null;
      return;
    }
    util._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || function Buffer_from(value, encoding) {
      return new Buffer2(value, encoding);
    };
    util._Buffer_allocUnsafe = Buffer2.allocUnsafe || function Buffer_allocUnsafe(size) {
      return new Buffer2(size);
    };
  };
});

// node_modules/@apollo/protobufjs/src/writer.js
var require_writer = __commonJS((exports, module) => {
  module.exports = Writer;
  var util = require_minimal();
  var BufferWriter;
  var LongBits = util.LongBits;
  var base64 = util.base64;
  var utf8 = util.utf8;
  function Op(fn2, len, val) {
    this.fn = fn2;
    this.len = len;
    this.next = undefined;
    this.val = val;
  }
  function noop() {}
  function State(writer) {
    this.head = writer.head;
    this.tail = writer.tail;
    this.len = writer.len;
    this.next = writer.states;
  }
  function Writer() {
    this.len = 0;
    this.head = new Op(noop, 0, 0);
    this.tail = this.head;
    this.states = null;
  }
  Writer.create = util.Buffer ? function create_buffer_setup() {
    return (Writer.create = function create_buffer() {
      return new BufferWriter;
    })();
  } : function create_array() {
    return new Writer;
  };
  Writer.alloc = function alloc(size) {
    return new util.Array(size);
  };
  if (util.Array !== Array)
    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);
  Writer.prototype._push = function push(fn2, len, val) {
    this.tail = this.tail.next = new Op(fn2, len, val);
    this.len += len;
    return this;
  };
  function writeByte(val, buf, pos) {
    buf[pos] = val & 255;
  }
  function writeVarint32(val, buf, pos) {
    while (val > 127) {
      buf[pos++] = val & 127 | 128;
      val >>>= 7;
    }
    buf[pos] = val;
  }
  function VarintOp(len, val) {
    this.len = len;
    this.next = undefined;
    this.val = val;
  }
  VarintOp.prototype = Object.create(Op.prototype);
  VarintOp.prototype.fn = writeVarint32;
  Writer.prototype.uint32 = function write_uint32(value) {
    this.len += (this.tail = this.tail.next = new VarintOp((value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5, value)).len;
    return this;
  };
  Writer.prototype.int32 = function write_int32(value) {
    return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);
  };
  Writer.prototype.sint32 = function write_sint32(value) {
    return this.uint32((value << 1 ^ value >> 31) >>> 0);
  };
  function writeVarint64(val, buf, pos) {
    while (val.hi) {
      buf[pos++] = val.lo & 127 | 128;
      val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
      val.hi >>>= 7;
    }
    while (val.lo > 127) {
      buf[pos++] = val.lo & 127 | 128;
      val.lo = val.lo >>> 7;
    }
    buf[pos++] = val.lo;
  }
  Writer.prototype.uint64 = function write_uint64(value) {
    var bits = LongBits.from(value);
    return this._push(writeVarint64, bits.length(), bits);
  };
  Writer.prototype.int64 = Writer.prototype.uint64;
  Writer.prototype.sint64 = function write_sint64(value) {
    var bits = LongBits.from(value).zzEncode();
    return this._push(writeVarint64, bits.length(), bits);
  };
  Writer.prototype.bool = function write_bool(value) {
    return this._push(writeByte, 1, value ? 1 : 0);
  };
  function writeFixed32(val, buf, pos) {
    buf[pos] = val & 255;
    buf[pos + 1] = val >>> 8 & 255;
    buf[pos + 2] = val >>> 16 & 255;
    buf[pos + 3] = val >>> 24;
  }
  Writer.prototype.fixed32 = function write_fixed32(value) {
    return this._push(writeFixed32, 4, value >>> 0);
  };
  Writer.prototype.sfixed32 = Writer.prototype.fixed32;
  Writer.prototype.fixed64 = function write_fixed64(value) {
    var bits = LongBits.from(value);
    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
  };
  Writer.prototype.sfixed64 = Writer.prototype.fixed64;
  Writer.prototype.float = function write_float(value) {
    return this._push(util.float.writeFloatLE, 4, value);
  };
  Writer.prototype.double = function write_double(value) {
    return this._push(util.float.writeDoubleLE, 8, value);
  };
  var writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf, pos) {
    buf.set(val, pos);
  } : function writeBytes_for(val, buf, pos) {
    for (var i = 0;i < val.length; ++i)
      buf[pos + i] = val[i];
  };
  Writer.prototype.bytes = function write_bytes(value) {
    var len = value.length >>> 0;
    if (!len)
      return this._push(writeByte, 1, 0);
    if (util.isString(value)) {
      var buf = Writer.alloc(len = base64.length(value));
      base64.decode(value, buf, 0);
      value = buf;
    }
    return this.uint32(len)._push(writeBytes, len, value);
  };
  Writer.prototype.string = function write_string(value) {
    var len = utf8.length(value);
    return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);
  };
  Writer.prototype.fork = function fork() {
    this.states = new State(this);
    this.head = this.tail = new Op(noop, 0, 0);
    this.len = 0;
    return this;
  };
  Writer.prototype.reset = function reset() {
    if (this.states) {
      this.head = this.states.head;
      this.tail = this.states.tail;
      this.len = this.states.len;
      this.states = this.states.next;
    } else {
      this.head = this.tail = new Op(noop, 0, 0);
      this.len = 0;
    }
    return this;
  };
  Writer.prototype.ldelim = function ldelim() {
    var head = this.head, tail = this.tail, len = this.len;
    this.reset().uint32(len);
    if (len) {
      this.tail.next = head.next;
      this.tail = tail;
      this.len += len;
    }
    return this;
  };
  Writer.prototype.finish = function finish() {
    var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;
    while (head) {
      head.fn(head.val, buf, pos);
      pos += head.len;
      head = head.next;
    }
    return buf;
  };
  Writer._configure = function(BufferWriter_) {
    BufferWriter = BufferWriter_;
  };
});

// node_modules/@apollo/protobufjs/src/writer_buffer.js
var require_writer_buffer = __commonJS((exports, module) => {
  module.exports = BufferWriter;
  var Writer = require_writer();
  (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
  var util = require_minimal();
  var Buffer2 = util.Buffer;
  function BufferWriter() {
    Writer.call(this);
  }
  BufferWriter.alloc = function alloc_buffer(size) {
    return (BufferWriter.alloc = util._Buffer_allocUnsafe)(size);
  };
  var writeBytesBuffer = Buffer2 && Buffer2.prototype instanceof Uint8Array && Buffer2.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf, pos) {
    buf.set(val, pos);
  } : function writeBytesBuffer_copy(val, buf, pos) {
    if (val.copy)
      val.copy(buf, pos, 0, val.length);
    else
      for (var i = 0;i < val.length; )
        buf[pos++] = val[i++];
  };
  BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
    if (util.isString(value))
      value = util._Buffer_from(value, "base64");
    var len = value.length >>> 0;
    this.uint32(len);
    if (len)
      this._push(writeBytesBuffer, len, value);
    return this;
  };
  function writeStringBuffer(val, buf, pos) {
    if (val.length < 40)
      util.utf8.write(val, buf, pos);
    else
      buf.utf8Write(val, pos);
  }
  BufferWriter.prototype.string = function write_string_buffer(value) {
    var len = Buffer2.byteLength(value);
    this.uint32(len);
    if (len)
      this._push(writeStringBuffer, len, value);
    return this;
  };
});

// node_modules/@apollo/protobufjs/src/reader.js
var require_reader = __commonJS((exports, module) => {
  module.exports = Reader;
  var util = require_minimal();
  var BufferReader;
  var LongBits = util.LongBits;
  var utf8 = util.utf8;
  function indexOutOfRange(reader, writeLength) {
    return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
  }
  function Reader(buffer) {
    this.buf = buffer;
    this.pos = 0;
    this.len = buffer.length;
  }
  var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer) {
    if (buffer instanceof Uint8Array || Array.isArray(buffer))
      return new Reader(buffer);
    throw Error("illegal buffer");
  } : function create_array(buffer) {
    if (Array.isArray(buffer))
      return new Reader(buffer);
    throw Error("illegal buffer");
  };
  Reader.create = util.Buffer ? function create_buffer_setup(buffer) {
    return (Reader.create = function create_buffer(buffer2) {
      return util.Buffer.isBuffer(buffer2) ? new BufferReader(buffer2) : create_array(buffer2);
    })(buffer);
  } : create_array;
  Reader.prototype._slice = util.Array.prototype.subarray || util.Array.prototype.slice;
  Reader.prototype.uint32 = function read_uint32_setup() {
    var value = 4294967295;
    return function read_uint32() {
      value = (this.buf[this.pos] & 127) >>> 0;
      if (this.buf[this.pos++] < 128)
        return value;
      value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
      if (this.buf[this.pos++] < 128)
        return value;
      value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
      if (this.buf[this.pos++] < 128)
        return value;
      value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
      if (this.buf[this.pos++] < 128)
        return value;
      value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
      if (this.buf[this.pos++] < 128)
        return value;
      if ((this.pos += 5) > this.len) {
        this.pos = this.len;
        throw indexOutOfRange(this, 10);
      }
      return value;
    };
  }();
  Reader.prototype.int32 = function read_int32() {
    return this.uint32() | 0;
  };
  Reader.prototype.sint32 = function read_sint32() {
    var value = this.uint32();
    return value >>> 1 ^ -(value & 1) | 0;
  };
  function readLongVarint() {
    var bits = new LongBits(0, 0);
    var i = 0;
    if (this.len - this.pos > 4) {
      for (;i < 4; ++i) {
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
      }
      bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
      bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
      if (this.buf[this.pos++] < 128)
        return bits;
      i = 0;
    } else {
      for (;i < 3; ++i) {
        if (this.pos >= this.len)
          throw indexOutOfRange(this);
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
      }
      bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
      return bits;
    }
    if (this.len - this.pos > 4) {
      for (;i < 5; ++i) {
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
      }
    } else {
      for (;i < 5; ++i) {
        if (this.pos >= this.len)
          throw indexOutOfRange(this);
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
      }
    }
    throw Error("invalid varint encoding");
  }
  Reader.prototype.bool = function read_bool() {
    return this.uint32() !== 0;
  };
  function readFixed32_end(buf, end) {
    return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;
  }
  Reader.prototype.fixed32 = function read_fixed32() {
    if (this.pos + 4 > this.len)
      throw indexOutOfRange(this, 4);
    return readFixed32_end(this.buf, this.pos += 4);
  };
  Reader.prototype.sfixed32 = function read_sfixed32() {
    if (this.pos + 4 > this.len)
      throw indexOutOfRange(this, 4);
    return readFixed32_end(this.buf, this.pos += 4) | 0;
  };
  function readFixed64() {
    if (this.pos + 8 > this.len)
      throw indexOutOfRange(this, 8);
    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
  }
  Reader.prototype.float = function read_float() {
    if (this.pos + 4 > this.len)
      throw indexOutOfRange(this, 4);
    var value = util.float.readFloatLE(this.buf, this.pos);
    this.pos += 4;
    return value;
  };
  Reader.prototype.double = function read_double() {
    if (this.pos + 8 > this.len)
      throw indexOutOfRange(this, 4);
    var value = util.float.readDoubleLE(this.buf, this.pos);
    this.pos += 8;
    return value;
  };
  Reader.prototype.bytes = function read_bytes() {
    var length = this.uint32(), start = this.pos, end = this.pos + length;
    if (end > this.len)
      throw indexOutOfRange(this, length);
    this.pos += length;
    if (Array.isArray(this.buf))
      return this.buf.slice(start, end);
    return start === end ? new this.buf.constructor(0) : this._slice.call(this.buf, start, end);
  };
  Reader.prototype.string = function read_string() {
    var bytes = this.bytes();
    return utf8.read(bytes, 0, bytes.length);
  };
  Reader.prototype.skip = function skip(length) {
    if (typeof length === "number") {
      if (this.pos + length > this.len)
        throw indexOutOfRange(this, length);
      this.pos += length;
    } else {
      do {
        if (this.pos >= this.len)
          throw indexOutOfRange(this);
      } while (this.buf[this.pos++] & 128);
    }
    return this;
  };
  Reader.prototype.skipType = function(wireType) {
    switch (wireType) {
      case 0:
        this.skip();
        break;
      case 1:
        this.skip(8);
        break;
      case 2:
        this.skip(this.uint32());
        break;
      case 3:
        while ((wireType = this.uint32() & 7) !== 4) {
          this.skipType(wireType);
        }
        break;
      case 5:
        this.skip(4);
        break;
      default:
        throw Error("invalid wire type " + wireType + " at offset " + this.pos);
    }
    return this;
  };
  Reader._configure = function(BufferReader_) {
    BufferReader = BufferReader_;
    var fn2 = util.Long ? "toLong" : "toNumber";
    util.merge(Reader.prototype, {
      int64: function read_int64() {
        return readLongVarint.call(this)[fn2](false);
      },
      uint64: function read_uint64() {
        return readLongVarint.call(this)[fn2](true);
      },
      sint64: function read_sint64() {
        return readLongVarint.call(this).zzDecode()[fn2](false);
      },
      fixed64: function read_fixed64() {
        return readFixed64.call(this)[fn2](true);
      },
      sfixed64: function read_sfixed64() {
        return readFixed64.call(this)[fn2](false);
      }
    });
  };
});

// node_modules/@apollo/protobufjs/src/reader_buffer.js
var require_reader_buffer = __commonJS((exports, module) => {
  module.exports = BufferReader;
  var Reader = require_reader();
  (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
  var util = require_minimal();
  function BufferReader(buffer) {
    Reader.call(this, buffer);
  }
  if (util.Buffer)
    BufferReader.prototype._slice = util.Buffer.prototype.slice;
  BufferReader.prototype.string = function read_string_buffer() {
    var len = this.uint32();
    return this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len));
  };
});

// node_modules/@apollo/protobufjs/src/rpc/service.js
var require_service = __commonJS((exports, module) => {
  module.exports = Service;
  var util = require_minimal();
  (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
  function Service(rpcImpl, requestDelimited, responseDelimited) {
    if (typeof rpcImpl !== "function")
      throw TypeError("rpcImpl must be a function");
    util.EventEmitter.call(this);
    this.rpcImpl = rpcImpl;
    this.requestDelimited = Boolean(requestDelimited);
    this.responseDelimited = Boolean(responseDelimited);
  }
  Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {
    if (!request)
      throw TypeError("request must be specified");
    var self2 = this;
    if (!callback)
      return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);
    if (!self2.rpcImpl) {
      setTimeout(function() {
        callback(Error("already ended"));
      }, 0);
      return;
    }
    try {
      return self2.rpcImpl(method, requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request).finish(), function rpcCallback(err, response) {
        if (err) {
          self2.emit("error", err, method);
          return callback(err);
        }
        if (response === null) {
          self2.end(true);
          return;
        }
        if (!(response instanceof responseCtor)) {
          try {
            response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
          } catch (err2) {
            self2.emit("error", err2, method);
            return callback(err2);
          }
        }
        self2.emit("data", response, method);
        return callback(null, response);
      });
    } catch (err) {
      self2.emit("error", err, method);
      setTimeout(function() {
        callback(err);
      }, 0);
      return;
    }
  };
  Service.prototype.end = function end(endedByRPC) {
    if (this.rpcImpl) {
      if (!endedByRPC)
        this.rpcImpl(null, null, null);
      this.rpcImpl = null;
      this.emit("end").off();
    }
    return this;
  };
});

// node_modules/@apollo/protobufjs/src/rpc.js
var require_rpc = __commonJS((exports) => {
  var rpc = exports;
  rpc.Service = require_service();
});

// node_modules/@apollo/protobufjs/src/roots.js
var require_roots = __commonJS((exports, module) => {
  module.exports = {};
});

// node_modules/@apollo/protobufjs/src/index-minimal.js
var require_index_minimal = __commonJS((exports) => {
  var protobuf = exports;
  protobuf.build = "minimal";
  protobuf.Writer = require_writer();
  protobuf.BufferWriter = require_writer_buffer();
  protobuf.Reader = require_reader();
  protobuf.BufferReader = require_reader_buffer();
  protobuf.util = require_minimal();
  protobuf.rpc = require_rpc();
  protobuf.roots = require_roots();
  protobuf.configure = configure;
  function configure() {
    protobuf.Reader._configure(protobuf.BufferReader);
    protobuf.util._configure();
  }
  protobuf.Writer._configure(protobuf.BufferWriter);
  configure();
});

// node_modules/apollo-reporting-protobuf/generated/protobuf.js
var require_protobuf = __commonJS((exports, module) => {
  var $protobuf = require_index_minimal();
  var $Reader = $protobuf.Reader;
  var $Writer = $protobuf.Writer;
  var $util = $protobuf.util;
  var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
  $root.Trace = function() {
    function Trace(properties) {
      if (properties) {
        for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    Trace.prototype.startTime = null;
    Trace.prototype.endTime = null;
    Trace.prototype.durationNs = 0;
    Trace.prototype.root = null;
    Trace.prototype.isIncomplete = false;
    Trace.prototype.signature = "";
    Trace.prototype.unexecutedOperationBody = "";
    Trace.prototype.unexecutedOperationName = "";
    Trace.prototype.details = null;
    Trace.prototype.clientName = "";
    Trace.prototype.clientVersion = "";
    Trace.prototype.http = null;
    Trace.prototype.cachePolicy = null;
    Trace.prototype.queryPlan = null;
    Trace.prototype.fullQueryCacheHit = false;
    Trace.prototype.persistedQueryHit = false;
    Trace.prototype.persistedQueryRegister = false;
    Trace.prototype.registeredOperation = false;
    Trace.prototype.forbiddenOperation = false;
    Trace.prototype.fieldExecutionWeight = 0;
    Trace.create = function create(properties) {
      return new Trace(properties);
    };
    Trace.encode = function encode(message2, writer) {
      if (!writer)
        writer = $Writer.create();
      if (message2.endTime != null && Object.hasOwnProperty.call(message2, "endTime"))
        $root.google.protobuf.Timestamp.encode(message2.endTime, writer.uint32(26).fork()).ldelim();
      if (message2.startTime != null && Object.hasOwnProperty.call(message2, "startTime"))
        $root.google.protobuf.Timestamp.encode(message2.startTime, writer.uint32(34).fork()).ldelim();
      if (message2.details != null && Object.hasOwnProperty.call(message2, "details"))
        $root.Trace.Details.encode(message2.details, writer.uint32(50).fork()).ldelim();
      if (message2.clientName != null && Object.hasOwnProperty.call(message2, "clientName"))
        writer.uint32(58).string(message2.clientName);
      if (message2.clientVersion != null && Object.hasOwnProperty.call(message2, "clientVersion"))
        writer.uint32(66).string(message2.clientVersion);
      if (message2.http != null && Object.hasOwnProperty.call(message2, "http"))
        $root.Trace.HTTP.encode(message2.http, writer.uint32(82).fork()).ldelim();
      if (message2.durationNs != null && Object.hasOwnProperty.call(message2, "durationNs"))
        writer.uint32(88).uint64(message2.durationNs);
      if (message2.root != null && Object.hasOwnProperty.call(message2, "root"))
        $root.Trace.Node.encode(message2.root, writer.uint32(114).fork()).ldelim();
      if (message2.cachePolicy != null && Object.hasOwnProperty.call(message2, "cachePolicy"))
        $root.Trace.CachePolicy.encode(message2.cachePolicy, writer.uint32(146).fork()).ldelim();
      if (message2.signature != null && Object.hasOwnProperty.call(message2, "signature"))
        writer.uint32(154).string(message2.signature);
      if (message2.fullQueryCacheHit != null && Object.hasOwnProperty.call(message2, "fullQueryCacheHit"))
        writer.uint32(160).bool(message2.fullQueryCacheHit);
      if (message2.persistedQueryHit != null && Object.hasOwnProperty.call(message2, "persistedQueryHit"))
        writer.uint32(168).bool(message2.persistedQueryHit);
      if (message2.persistedQueryRegister != null && Object.hasOwnProperty.call(message2, "persistedQueryRegister"))
        writer.uint32(176).bool(message2.persistedQueryRegister);
      if (message2.registeredOperation != null && Object.hasOwnProperty.call(message2, "registeredOperation"))
        writer.uint32(192).bool(message2.registeredOperation);
      if (message2.forbiddenOperation != null && Object.hasOwnProperty.call(message2, "forbiddenOperation"))
        writer.uint32(200).bool(message2.forbiddenOperation);
      if (message2.queryPlan != null && Object.hasOwnProperty.call(message2, "queryPlan"))
        $root.Trace.QueryPlanNode.encode(message2.queryPlan, writer.uint32(210).fork()).ldelim();
      if (message2.unexecutedOperationBody != null && Object.hasOwnProperty.call(message2, "unexecutedOperationBody"))
        writer.uint32(218).string(message2.unexecutedOperationBody);
      if (message2.unexecutedOperationName != null && Object.hasOwnProperty.call(message2, "unexecutedOperationName"))
        writer.uint32(226).string(message2.unexecutedOperationName);
      if (message2.fieldExecutionWeight != null && Object.hasOwnProperty.call(message2, "fieldExecutionWeight"))
        writer.uint32(249).double(message2.fieldExecutionWeight);
      if (message2.isIncomplete != null && Object.hasOwnProperty.call(message2, "isIncomplete"))
        writer.uint32(264).bool(message2.isIncomplete);
      return writer;
    };
    Trace.encodeDelimited = function encodeDelimited(message2, writer) {
      return this.encode(message2, writer).ldelim();
    };
    Trace.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader))
        reader = $Reader.create(reader);
      var end = length === undefined ? reader.len : reader.pos + length, message2 = new $root.Trace;
      while (reader.pos < end) {
        var tag = reader.uint32();
        switch (tag >>> 3) {
          case 4:
            message2.startTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
            break;
          case 3:
            message2.endTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
            break;
          case 11:
            message2.durationNs = reader.uint64();
            break;
          case 14:
            message2.root = $root.Trace.Node.decode(reader, reader.uint32());
            break;
          case 33:
            message2.isIncomplete = reader.bool();
            break;
          case 19:
            message2.signature = reader.string();
            break;
          case 27:
            message2.unexecutedOperationBody = reader.string();
            break;
          case 28:
            message2.unexecutedOperationName = reader.string();
            break;
          case 6:
            message2.details = $root.Trace.Details.decode(reader, reader.uint32());
            break;
          case 7:
            message2.clientName = reader.string();
            break;
          case 8:
            message2.clientVersion = reader.string();
            break;
          case 10:
            message2.http = $root.Trace.HTTP.decode(reader, reader.uint32());
            break;
          case 18:
            message2.cachePolicy = $root.Trace.CachePolicy.decode(reader, reader.uint32());
            break;
          case 26:
            message2.queryPlan = $root.Trace.QueryPlanNode.decode(reader, reader.uint32());
            break;
          case 20:
            message2.fullQueryCacheHit = reader.bool();
            break;
          case 21:
            message2.persistedQueryHit = reader.bool();
            break;
          case 22:
            message2.persistedQueryRegister = reader.bool();
            break;
          case 24:
            message2.registeredOperation = reader.bool();
            break;
          case 25:
            message2.forbiddenOperation = reader.bool();
            break;
          case 31:
            message2.fieldExecutionWeight = reader.double();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message2;
    };
    Trace.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader))
        reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };
    Trace.verify = function verify(message2) {
      if (typeof message2 !== "object" || message2 === null)
        return "object expected";
      if (message2.startTime != null && message2.hasOwnProperty("startTime")) {
        var error = $root.google.protobuf.Timestamp.verify(message2.startTime);
        if (error)
          return "startTime." + error;
      }
      if (message2.endTime != null && message2.hasOwnProperty("endTime")) {
        var error = $root.google.protobuf.Timestamp.verify(message2.endTime);
        if (error)
          return "endTime." + error;
      }
      if (message2.durationNs != null && message2.hasOwnProperty("durationNs")) {
        if (!$util.isInteger(message2.durationNs) && !(message2.durationNs && $util.isInteger(message2.durationNs.low) && $util.isInteger(message2.durationNs.high)))
          return "durationNs: integer|Long expected";
      }
      if (message2.root != null && message2.hasOwnProperty("root")) {
        var error = $root.Trace.Node.verify(message2.root);
        if (error)
          return "root." + error;
      }
      if (message2.isIncomplete != null && message2.hasOwnProperty("isIncomplete")) {
        if (typeof message2.isIncomplete !== "boolean")
          return "isIncomplete: boolean expected";
      }
      if (message2.signature != null && message2.hasOwnProperty("signature")) {
        if (!$util.isString(message2.signature))
          return "signature: string expected";
      }
      if (message2.unexecutedOperationBody != null && message2.hasOwnProperty("unexecutedOperationBody")) {
        if (!$util.isString(message2.unexecutedOperationBody))
          return "unexecutedOperationBody: string expected";
      }
      if (message2.unexecutedOperationName != null && message2.hasOwnProperty("unexecutedOperationName")) {
        if (!$util.isString(message2.unexecutedOperationName))
          return "unexecutedOperationName: string expected";
      }
      if (message2.details != null && message2.hasOwnProperty("details")) {
        var error = $root.Trace.Details.verify(message2.details);
        if (error)
          return "details." + error;
      }
      if (message2.clientName != null && message2.hasOwnProperty("clientName")) {
        if (!$util.isString(message2.clientName))
          return "clientName: string expected";
      }
      if (message2.clientVersion != null && message2.hasOwnProperty("clientVersion")) {
        if (!$util.isString(message2.clientVersion))
          return "clientVersion: string expected";
      }
      if (message2.http != null && message2.hasOwnProperty("http")) {
        var error = $root.Trace.HTTP.verify(message2.http);
        if (error)
          return "http." + error;
      }
      if (message2.cachePolicy != null && message2.hasOwnProperty("cachePolicy")) {
        var error = $root.Trace.CachePolicy.verify(message2.cachePolicy);
        if (error)
          return "cachePolicy." + error;
      }
      if (message2.queryPlan != null && message2.hasOwnProperty("queryPlan")) {
        var error = $root.Trace.QueryPlanNode.verify(message2.queryPlan);
        if (error)
          return "queryPlan." + error;
      }
      if (message2.fullQueryCacheHit != null && message2.hasOwnProperty("fullQueryCacheHit")) {
        if (typeof message2.fullQueryCacheHit !== "boolean")
          return "fullQueryCacheHit: boolean expected";
      }
      if (message2.persistedQueryHit != null && message2.hasOwnProperty("persistedQueryHit")) {
        if (typeof message2.persistedQueryHit !== "boolean")
          return "persistedQueryHit: boolean expected";
      }
      if (message2.persistedQueryRegister != null && message2.hasOwnProperty("persistedQueryRegister")) {
        if (typeof message2.persistedQueryRegister !== "boolean")
          return "persistedQueryRegister: boolean expected";
      }
      if (message2.registeredOperation != null && message2.hasOwnProperty("registeredOperation")) {
        if (typeof message2.registeredOperation !== "boolean")
          return "registeredOperation: boolean expected";
      }
      if (message2.forbiddenOperation != null && message2.hasOwnProperty("forbiddenOperation")) {
        if (typeof message2.forbiddenOperation !== "boolean")
          return "forbiddenOperation: boolean expected";
      }
      if (message2.fieldExecutionWeight != null && message2.hasOwnProperty("fieldExecutionWeight")) {
        if (typeof message2.fieldExecutionWeight !== "number")
          return "fieldExecutionWeight: number expected";
      }
      return null;
    };
    Trace.toObject = function toObject(message2, options) {
      if (!options)
        options = {};
      var object = {};
      if (options.defaults) {
        object.endTime = null;
        object.startTime = null;
        object.details = null;
        object.clientName = "";
        object.clientVersion = "";
        object.http = null;
        object.durationNs = 0;
        object.root = null;
        object.cachePolicy = null;
        object.signature = "";
        object.fullQueryCacheHit = false;
        object.persistedQueryHit = false;
        object.persistedQueryRegister = false;
        object.registeredOperation = false;
        object.forbiddenOperation = false;
        object.queryPlan = null;
        object.unexecutedOperationBody = "";
        object.unexecutedOperationName = "";
        object.fieldExecutionWeight = 0;
        object.isIncomplete = false;
      }
      if (message2.endTime != null && message2.hasOwnProperty("endTime"))
        object.endTime = $root.google.protobuf.Timestamp.toObject(message2.endTime, options);
      if (message2.startTime != null && message2.hasOwnProperty("startTime"))
        object.startTime = $root.google.protobuf.Timestamp.toObject(message2.startTime, options);
      if (message2.details != null && message2.hasOwnProperty("details"))
        object.details = $root.Trace.Details.toObject(message2.details, options);
      if (message2.clientName != null && message2.hasOwnProperty("clientName"))
        object.clientName = message2.clientName;
      if (message2.clientVersion != null && message2.hasOwnProperty("clientVersion"))
        object.clientVersion = message2.clientVersion;
      if (message2.http != null && message2.hasOwnProperty("http"))
        object.http = $root.Trace.HTTP.toObject(message2.http, options);
      if (message2.durationNs != null && message2.hasOwnProperty("durationNs"))
        if (typeof message2.durationNs === "number")
          object.durationNs = options.longs === String ? String(message2.durationNs) : message2.durationNs;
        else
          object.durationNs = options.longs === String ? $util.Long.prototype.toString.call(message2.durationNs) : options.longs === Number ? new $util.LongBits(message2.durationNs.low >>> 0, message2.durationNs.high >>> 0).toNumber(true) : message2.durationNs;
      if (message2.root != null && message2.hasOwnProperty("root"))
        object.root = $root.Trace.Node.toObject(message2.root, options);
      if (message2.cachePolicy != null && message2.hasOwnProperty("cachePolicy"))
        object.cachePolicy = $root.Trace.CachePolicy.toObject(message2.cachePolicy, options);
      if (message2.signature != null && message2.hasOwnProperty("signature"))
        object.signature = message2.signature;
      if (message2.fullQueryCacheHit != null && message2.hasOwnProperty("fullQueryCacheHit"))
        object.fullQueryCacheHit = message2.fullQueryCacheHit;
      if (message2.persistedQueryHit != null && message2.hasOwnProperty("persistedQueryHit"))
        object.persistedQueryHit = message2.persistedQueryHit;
      if (message2.persistedQueryRegister != null && message2.hasOwnProperty("persistedQueryRegister"))
        object.persistedQueryRegister = message2.persistedQueryRegister;
      if (message2.registeredOperation != null && message2.hasOwnProperty("registeredOperation"))
        object.registeredOperation = message2.registeredOperation;
      if (message2.forbiddenOperation != null && message2.hasOwnProperty("forbiddenOperation"))
        object.forbiddenOperation = message2.forbiddenOperation;
      if (message2.queryPlan != null && message2.hasOwnProperty("queryPlan"))
        object.queryPlan = $root.Trace.QueryPlanNode.toObject(message2.queryPlan, options);
      if (message2.unexecutedOperationBody != null && message2.hasOwnProperty("unexecutedOperationBody"))
        object.unexecutedOperationBody = message2.unexecutedOperationBody;
      if (message2.unexecutedOperationName != null && message2.hasOwnProperty("unexecutedOperationName"))
        object.unexecutedOperationName = message2.unexecutedOperationName;
      if (message2.fieldExecutionWeight != null && message2.hasOwnProperty("fieldExecutionWeight"))
        object.fieldExecutionWeight = options.json && !isFinite(message2.fieldExecutionWeight) ? String(message2.fieldExecutionWeight) : message2.fieldExecutionWeight;
      if (message2.isIncomplete != null && message2.hasOwnProperty("isIncomplete"))
        object.isIncomplete = message2.isIncomplete;
      return object;
    };
    Trace.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };
    Trace.CachePolicy = function() {
      function CachePolicy(properties) {
        if (properties) {
          for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      CachePolicy.prototype.scope = 0;
      CachePolicy.prototype.maxAgeNs = 0;
      CachePolicy.create = function create(properties) {
        return new CachePolicy(properties);
      };
      CachePolicy.encode = function encode(message2, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message2.scope != null && Object.hasOwnProperty.call(message2, "scope"))
          writer.uint32(8).int32(message2.scope);
        if (message2.maxAgeNs != null && Object.hasOwnProperty.call(message2, "maxAgeNs"))
          writer.uint32(16).int64(message2.maxAgeNs);
        return writer;
      };
      CachePolicy.encodeDelimited = function encodeDelimited(message2, writer) {
        return this.encode(message2, writer).ldelim();
      };
      CachePolicy.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message2 = new $root.Trace.CachePolicy;
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message2.scope = reader.int32();
              break;
            case 2:
              message2.maxAgeNs = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message2;
      };
      CachePolicy.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };
      CachePolicy.verify = function verify(message2) {
        if (typeof message2 !== "object" || message2 === null)
          return "object expected";
        if (message2.scope != null && message2.hasOwnProperty("scope"))
          switch (message2.scope) {
            default:
              return "scope: enum value expected";
            case 0:
            case 1:
            case 2:
              break;
          }
        if (message2.maxAgeNs != null && message2.hasOwnProperty("maxAgeNs")) {
          if (!$util.isInteger(message2.maxAgeNs) && !(message2.maxAgeNs && $util.isInteger(message2.maxAgeNs.low) && $util.isInteger(message2.maxAgeNs.high)))
            return "maxAgeNs: integer|Long expected";
        }
        return null;
      };
      CachePolicy.toObject = function toObject(message2, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.defaults) {
          object.scope = options.enums === String ? "UNKNOWN" : 0;
          object.maxAgeNs = 0;
        }
        if (message2.scope != null && message2.hasOwnProperty("scope"))
          object.scope = options.enums === String ? $root.Trace.CachePolicy.Scope[message2.scope] : message2.scope;
        if (message2.maxAgeNs != null && message2.hasOwnProperty("maxAgeNs"))
          if (typeof message2.maxAgeNs === "number")
            object.maxAgeNs = options.longs === String ? String(message2.maxAgeNs) : message2.maxAgeNs;
          else
            object.maxAgeNs = options.longs === String ? $util.Long.prototype.toString.call(message2.maxAgeNs) : options.longs === Number ? new $util.LongBits(message2.maxAgeNs.low >>> 0, message2.maxAgeNs.high >>> 0).toNumber() : message2.maxAgeNs;
        return object;
      };
      CachePolicy.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };
      CachePolicy.Scope = function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "UNKNOWN"] = 0;
        values[valuesById[1] = "PUBLIC"] = 1;
        values[valuesById[2] = "PRIVATE"] = 2;
        return values;
      }();
      return CachePolicy;
    }();
    Trace.Details = function() {
      function Details(properties) {
        this.variablesJson = {};
        if (properties) {
          for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      Details.prototype.variablesJson = $util.emptyObject;
      Details.prototype.operationName = "";
      Details.create = function create(properties) {
        return new Details(properties);
      };
      Details.encode = function encode(message2, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message2.operationName != null && Object.hasOwnProperty.call(message2, "operationName"))
          writer.uint32(26).string(message2.operationName);
        if (message2.variablesJson != null && Object.hasOwnProperty.call(message2, "variablesJson"))
          for (var keys = Object.keys(message2.variablesJson), i = 0;i < keys.length; ++i)
            writer.uint32(34).fork().uint32(10).string(keys[i]).uint32(18).string(message2.variablesJson[keys[i]]).ldelim();
        return writer;
      };
      Details.encodeDelimited = function encodeDelimited(message2, writer) {
        return this.encode(message2, writer).ldelim();
      };
      Details.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message2 = new $root.Trace.Details, key;
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 4:
              reader.skip().pos++;
              if (message2.variablesJson === $util.emptyObject)
                message2.variablesJson = {};
              key = reader.string();
              reader.pos++;
              message2.variablesJson[key] = reader.string();
              break;
            case 3:
              message2.operationName = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message2;
      };
      Details.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };
      Details.verify = function verify(message2) {
        if (typeof message2 !== "object" || message2 === null)
          return "object expected";
        if (message2.variablesJson != null && message2.hasOwnProperty("variablesJson")) {
          if (!$util.isObject(message2.variablesJson))
            return "variablesJson: object expected";
          var key = Object.keys(message2.variablesJson);
          for (var i = 0;i < key.length; ++i)
            if (!$util.isString(message2.variablesJson[key[i]]))
              return "variablesJson: string{k:string} expected";
        }
        if (message2.operationName != null && message2.hasOwnProperty("operationName")) {
          if (!$util.isString(message2.operationName))
            return "operationName: string expected";
        }
        return null;
      };
      Details.toObject = function toObject(message2, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.objects || options.defaults)
          object.variablesJson = {};
        if (options.defaults)
          object.operationName = "";
        if (message2.operationName != null && message2.hasOwnProperty("operationName"))
          object.operationName = message2.operationName;
        var keys2;
        if (message2.variablesJson && (keys2 = Object.keys(message2.variablesJson)).length) {
          object.variablesJson = {};
          for (var j = 0;j < keys2.length; ++j)
            object.variablesJson[keys2[j]] = message2.variablesJson[keys2[j]];
        }
        return object;
      };
      Details.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };
      return Details;
    }();
    Trace.Error = function() {
      function Error2(properties) {
        this.location = [];
        if (properties) {
          for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      Error2.prototype.message = "";
      Error2.prototype.location = $util.emptyArray;
      Error2.prototype.timeNs = 0;
      Error2.prototype.json = "";
      Error2.create = function create(properties) {
        return new Error2(properties);
      };
      Error2.encode = function encode(message2, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message2.message != null && Object.hasOwnProperty.call(message2, "message"))
          writer.uint32(10).string(message2.message);
        if (message2.location != null && message2.location.length)
          for (var i = 0;i < message2.location.length; ++i)
            $root.Trace.Location.encode(message2.location[i], writer.uint32(18).fork()).ldelim();
        if (message2.timeNs != null && Object.hasOwnProperty.call(message2, "timeNs"))
          writer.uint32(24).uint64(message2.timeNs);
        if (message2.json != null && Object.hasOwnProperty.call(message2, "json"))
          writer.uint32(34).string(message2.json);
        return writer;
      };
      Error2.encodeDelimited = function encodeDelimited(message2, writer) {
        return this.encode(message2, writer).ldelim();
      };
      Error2.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message2 = new $root.Trace.Error;
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message2.message = reader.string();
              break;
            case 2:
              if (!(message2.location && message2.location.length))
                message2.location = [];
              message2.location.push($root.Trace.Location.decode(reader, reader.uint32()));
              break;
            case 3:
              message2.timeNs = reader.uint64();
              break;
            case 4:
              message2.json = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message2;
      };
      Error2.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };
      Error2.verify = function verify(message2) {
        if (typeof message2 !== "object" || message2 === null)
          return "object expected";
        if (message2.message != null && message2.hasOwnProperty("message")) {
          if (!$util.isString(message2.message))
            return "message: string expected";
        }
        if (message2.location != null && message2.hasOwnProperty("location")) {
          if (!Array.isArray(message2.location))
            return "location: array expected";
          for (var i = 0;i < message2.location.length; ++i) {
            var error = $root.Trace.Location.verify(message2.location[i]);
            if (error)
              return "location." + error;
          }
        }
        if (message2.timeNs != null && message2.hasOwnProperty("timeNs")) {
          if (!$util.isInteger(message2.timeNs) && !(message2.timeNs && $util.isInteger(message2.timeNs.low) && $util.isInteger(message2.timeNs.high)))
            return "timeNs: integer|Long expected";
        }
        if (message2.json != null && message2.hasOwnProperty("json")) {
          if (!$util.isString(message2.json))
            return "json: string expected";
        }
        return null;
      };
      Error2.toObject = function toObject(message2, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.arrays || options.defaults)
          object.location = [];
        if (options.defaults) {
          object.message = "";
          object.timeNs = 0;
          object.json = "";
        }
        if (message2.message != null && message2.hasOwnProperty("message"))
          object.message = message2.message;
        if (message2.location && message2.location.length) {
          object.location = [];
          for (var j = 0;j < message2.location.length; ++j)
            object.location[j] = $root.Trace.Location.toObject(message2.location[j], options);
        }
        if (message2.timeNs != null && message2.hasOwnProperty("timeNs"))
          if (typeof message2.timeNs === "number")
            object.timeNs = options.longs === String ? String(message2.timeNs) : message2.timeNs;
          else
            object.timeNs = options.longs === String ? $util.Long.prototype.toString.call(message2.timeNs) : options.longs === Number ? new $util.LongBits(message2.timeNs.low >>> 0, message2.timeNs.high >>> 0).toNumber(true) : message2.timeNs;
        if (message2.json != null && message2.hasOwnProperty("json"))
          object.json = message2.json;
        return object;
      };
      Error2.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };
      return Error2;
    }();
    Trace.HTTP = function() {
      function HTTP(properties) {
        this.requestHeaders = {};
        this.responseHeaders = {};
        if (properties) {
          for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      HTTP.prototype.method = 0;
      HTTP.prototype.requestHeaders = $util.emptyObject;
      HTTP.prototype.responseHeaders = $util.emptyObject;
      HTTP.prototype.statusCode = 0;
      HTTP.create = function create(properties) {
        return new HTTP(properties);
      };
      HTTP.encode = function encode(message2, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message2.method != null && Object.hasOwnProperty.call(message2, "method"))
          writer.uint32(8).int32(message2.method);
        if (message2.requestHeaders != null && Object.hasOwnProperty.call(message2, "requestHeaders"))
          for (var keys = Object.keys(message2.requestHeaders), i = 0;i < keys.length; ++i) {
            writer.uint32(34).fork().uint32(10).string(keys[i]);
            $root.Trace.HTTP.Values.encode(message2.requestHeaders[keys[i]], writer.uint32(18).fork()).ldelim().ldelim();
          }
        if (message2.responseHeaders != null && Object.hasOwnProperty.call(message2, "responseHeaders"))
          for (var keys = Object.keys(message2.responseHeaders), i = 0;i < keys.length; ++i) {
            writer.uint32(42).fork().uint32(10).string(keys[i]);
            $root.Trace.HTTP.Values.encode(message2.responseHeaders[keys[i]], writer.uint32(18).fork()).ldelim().ldelim();
          }
        if (message2.statusCode != null && Object.hasOwnProperty.call(message2, "statusCode"))
          writer.uint32(48).uint32(message2.statusCode);
        return writer;
      };
      HTTP.encodeDelimited = function encodeDelimited(message2, writer) {
        return this.encode(message2, writer).ldelim();
      };
      HTTP.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message2 = new $root.Trace.HTTP, key;
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message2.method = reader.int32();
              break;
            case 4:
              reader.skip().pos++;
              if (message2.requestHeaders === $util.emptyObject)
                message2.requestHeaders = {};
              key = reader.string();
              reader.pos++;
              message2.requestHeaders[key] = $root.Trace.HTTP.Values.decode(reader, reader.uint32());
              break;
            case 5:
              reader.skip().pos++;
              if (message2.responseHeaders === $util.emptyObject)
                message2.responseHeaders = {};
              key = reader.string();
              reader.pos++;
              message2.responseHeaders[key] = $root.Trace.HTTP.Values.decode(reader, reader.uint32());
              break;
            case 6:
              message2.statusCode = reader.uint32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message2;
      };
      HTTP.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };
      HTTP.verify = function verify(message2) {
        if (typeof message2 !== "object" || message2 === null)
          return "object expected";
        if (message2.method != null && message2.hasOwnProperty("method"))
          switch (message2.method) {
            default:
              return "method: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
              break;
          }
        if (message2.requestHeaders != null && message2.hasOwnProperty("requestHeaders")) {
          if (!$util.isObject(message2.requestHeaders))
            return "requestHeaders: object expected";
          var key = Object.keys(message2.requestHeaders);
          for (var i = 0;i < key.length; ++i) {
            var error = $root.Trace.HTTP.Values.verify(message2.requestHeaders[key[i]]);
            if (error)
              return "requestHeaders." + error;
          }
        }
        if (message2.responseHeaders != null && message2.hasOwnProperty("responseHeaders")) {
          if (!$util.isObject(message2.responseHeaders))
            return "responseHeaders: object expected";
          var key = Object.keys(message2.responseHeaders);
          for (var i = 0;i < key.length; ++i) {
            var error = $root.Trace.HTTP.Values.verify(message2.responseHeaders[key[i]]);
            if (error)
              return "responseHeaders." + error;
          }
        }
        if (message2.statusCode != null && message2.hasOwnProperty("statusCode")) {
          if (!$util.isInteger(message2.statusCode))
            return "statusCode: integer expected";
        }
        return null;
      };
      HTTP.toObject = function toObject(message2, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.objects || options.defaults) {
          object.requestHeaders = {};
          object.responseHeaders = {};
        }
        if (options.defaults) {
          object.method = options.enums === String ? "UNKNOWN" : 0;
          object.statusCode = 0;
        }
        if (message2.method != null && message2.hasOwnProperty("method"))
          object.method = options.enums === String ? $root.Trace.HTTP.Method[message2.method] : message2.method;
        var keys2;
        if (message2.requestHeaders && (keys2 = Object.keys(message2.requestHeaders)).length) {
          object.requestHeaders = {};
          for (var j = 0;j < keys2.length; ++j)
            object.requestHeaders[keys2[j]] = $root.Trace.HTTP.Values.toObject(message2.requestHeaders[keys2[j]], options);
        }
        if (message2.responseHeaders && (keys2 = Object.keys(message2.responseHeaders)).length) {
          object.responseHeaders = {};
          for (var j = 0;j < keys2.length; ++j)
            object.responseHeaders[keys2[j]] = $root.Trace.HTTP.Values.toObject(message2.responseHeaders[keys2[j]], options);
        }
        if (message2.statusCode != null && message2.hasOwnProperty("statusCode"))
          object.statusCode = message2.statusCode;
        return object;
      };
      HTTP.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };
      HTTP.Values = function() {
        function Values(properties) {
          this.value = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        Values.prototype.value = $util.emptyArray;
        Values.create = function create(properties) {
          return new Values(properties);
        };
        Values.encode = function encode(message2, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message2.value != null && message2.value.length)
            for (var i = 0;i < message2.value.length; ++i)
              writer.uint32(10).string(message2.value[i]);
          return writer;
        };
        Values.encodeDelimited = function encodeDelimited(message2, writer) {
          return this.encode(message2, writer).ldelim();
        };
        Values.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message2 = new $root.Trace.HTTP.Values;
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                if (!(message2.value && message2.value.length))
                  message2.value = [];
                message2.value.push(reader.string());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message2;
        };
        Values.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        Values.verify = function verify(message2) {
          if (typeof message2 !== "object" || message2 === null)
            return "object expected";
          if (message2.value != null && message2.hasOwnProperty("value")) {
            if (!Array.isArray(message2.value))
              return "value: array expected";
            for (var i = 0;i < message2.value.length; ++i)
              if (!$util.isString(message2.value[i]))
                return "value: string[] expected";
          }
          return null;
        };
        Values.toObject = function toObject(message2, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.arrays || options.defaults)
            object.value = [];
          if (message2.value && message2.value.length) {
            object.value = [];
            for (var j = 0;j < message2.value.length; ++j)
              object.value[j] = message2.value[j];
          }
          return object;
        };
        Values.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return Values;
      }();
      HTTP.Method = function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "UNKNOWN"] = 0;
        values[valuesById[1] = "OPTIONS"] = 1;
        values[valuesById[2] = "GET"] = 2;
        values[valuesById[3] = "HEAD"] = 3;
        values[valuesById[4] = "POST"] = 4;
        values[valuesById[5] = "PUT"] = 5;
        values[valuesById[6] = "DELETE"] = 6;
        values[valuesById[7] = "TRACE"] = 7;
        values[valuesById[8] = "CONNECT"] = 8;
        values[valuesById[9] = "PATCH"] = 9;
        return values;
      }();
      return HTTP;
    }();
    Trace.Location = function() {
      function Location(properties) {
        if (properties) {
          for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      Location.prototype.line = 0;
      Location.prototype.column = 0;
      Location.create = function create(properties) {
        return new Location(properties);
      };
      Location.encode = function encode(message2, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message2.line != null && Object.hasOwnProperty.call(message2, "line"))
          writer.uint32(8).uint32(message2.line);
        if (message2.column != null && Object.hasOwnProperty.call(message2, "column"))
          writer.uint32(16).uint32(message2.column);
        return writer;
      };
      Location.encodeDelimited = function encodeDelimited(message2, writer) {
        return this.encode(message2, writer).ldelim();
      };
      Location.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message2 = new $root.Trace.Location;
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message2.line = reader.uint32();
              break;
            case 2:
              message2.column = reader.uint32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message2;
      };
      Location.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };
      Location.verify = function verify(message2) {
        if (typeof message2 !== "object" || message2 === null)
          return "object expected";
        if (message2.line != null && message2.hasOwnProperty("line")) {
          if (!$util.isInteger(message2.line))
            return "line: integer expected";
        }
        if (message2.column != null && message2.hasOwnProperty("column")) {
          if (!$util.isInteger(message2.column))
            return "column: integer expected";
        }
        return null;
      };
      Location.toObject = function toObject(message2, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.defaults) {
          object.line = 0;
          object.column = 0;
        }
        if (message2.line != null && message2.hasOwnProperty("line"))
          object.line = message2.line;
        if (message2.column != null && message2.hasOwnProperty("column"))
          object.column = message2.column;
        return object;
      };
      Location.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };
      return Location;
    }();
    Trace.Node = function() {
      function Node(properties) {
        this.error = [];
        this.child = [];
        if (properties) {
          for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      Node.prototype.responseName = "";
      Node.prototype.index = 0;
      Node.prototype.originalFieldName = "";
      Node.prototype.type = "";
      Node.prototype.parentType = "";
      Node.prototype.cachePolicy = null;
      Node.prototype.startTime = 0;
      Node.prototype.endTime = 0;
      Node.prototype.error = $util.emptyArray;
      Node.prototype.child = $util.emptyArray;
      var $oneOfFields;
      Object.defineProperty(Node.prototype, "id", {
        get: $util.oneOfGetter($oneOfFields = ["responseName", "index"]),
        set: $util.oneOfSetter($oneOfFields)
      });
      Node.create = function create(properties) {
        return new Node(properties);
      };
      Node.encode = function encode(message2, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message2.responseName != null && Object.hasOwnProperty.call(message2, "responseName"))
          writer.uint32(10).string(message2.responseName);
        if (message2.index != null && Object.hasOwnProperty.call(message2, "index"))
          writer.uint32(16).uint32(message2.index);
        if (message2.type != null && Object.hasOwnProperty.call(message2, "type"))
          writer.uint32(26).string(message2.type);
        if (message2.cachePolicy != null && Object.hasOwnProperty.call(message2, "cachePolicy"))
          $root.Trace.CachePolicy.encode(message2.cachePolicy, writer.uint32(42).fork()).ldelim();
        if (message2.startTime != null && Object.hasOwnProperty.call(message2, "startTime"))
          writer.uint32(64).uint64(message2.startTime);
        if (message2.endTime != null && Object.hasOwnProperty.call(message2, "endTime"))
          writer.uint32(72).uint64(message2.endTime);
        if (message2.error != null && message2.error.length)
          for (var i = 0;i < message2.error.length; ++i)
            $root.Trace.Error.encode(message2.error[i], writer.uint32(90).fork()).ldelim();
        if (message2.child != null && message2.child.length)
          for (var i = 0;i < message2.child.length; ++i)
            $root.Trace.Node.encode(message2.child[i], writer.uint32(98).fork()).ldelim();
        if (message2.parentType != null && Object.hasOwnProperty.call(message2, "parentType"))
          writer.uint32(106).string(message2.parentType);
        if (message2.originalFieldName != null && Object.hasOwnProperty.call(message2, "originalFieldName"))
          writer.uint32(114).string(message2.originalFieldName);
        return writer;
      };
      Node.encodeDelimited = function encodeDelimited(message2, writer) {
        return this.encode(message2, writer).ldelim();
      };
      Node.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message2 = new $root.Trace.Node;
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message2.responseName = reader.string();
              break;
            case 2:
              message2.index = reader.uint32();
              break;
            case 14:
              message2.originalFieldName = reader.string();
              break;
            case 3:
              message2.type = reader.string();
              break;
            case 13:
              message2.parentType = reader.string();
              break;
            case 5:
              message2.cachePolicy = $root.Trace.CachePolicy.decode(reader, reader.uint32());
              break;
            case 8:
              message2.startTime = reader.uint64();
              break;
            case 9:
              message2.endTime = reader.uint64();
              break;
            case 11:
              if (!(message2.error && message2.error.length))
                message2.error = [];
              message2.error.push($root.Trace.Error.decode(reader, reader.uint32()));
              break;
            case 12:
              if (!(message2.child && message2.child.length))
                message2.child = [];
              message2.child.push($root.Trace.Node.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message2;
      };
      Node.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };
      Node.verify = function verify(message2) {
        if (typeof message2 !== "object" || message2 === null)
          return "object expected";
        var properties = {};
        if (message2.responseName != null && message2.hasOwnProperty("responseName")) {
          properties.id = 1;
          if (!$util.isString(message2.responseName))
            return "responseName: string expected";
        }
        if (message2.index != null && message2.hasOwnProperty("index")) {
          if (properties.id === 1)
            return "id: multiple values";
          properties.id = 1;
          if (!$util.isInteger(message2.index))
            return "index: integer expected";
        }
        if (message2.originalFieldName != null && message2.hasOwnProperty("originalFieldName")) {
          if (!$util.isString(message2.originalFieldName))
            return "originalFieldName: string expected";
        }
        if (message2.type != null && message2.hasOwnProperty("type")) {
          if (!$util.isString(message2.type))
            return "type: string expected";
        }
        if (message2.parentType != null && message2.hasOwnProperty("parentType")) {
          if (!$util.isString(message2.parentType))
            return "parentType: string expected";
        }
        if (message2.cachePolicy != null && message2.hasOwnProperty("cachePolicy")) {
          var error = $root.Trace.CachePolicy.verify(message2.cachePolicy);
          if (error)
            return "cachePolicy." + error;
        }
        if (message2.startTime != null && message2.hasOwnProperty("startTime")) {
          if (!$util.isInteger(message2.startTime) && !(message2.startTime && $util.isInteger(message2.startTime.low) && $util.isInteger(message2.startTime.high)))
            return "startTime: integer|Long expected";
        }
        if (message2.endTime != null && message2.hasOwnProperty("endTime")) {
          if (!$util.isInteger(message2.endTime) && !(message2.endTime && $util.isInteger(message2.endTime.low) && $util.isInteger(message2.endTime.high)))
            return "endTime: integer|Long expected";
        }
        if (message2.error != null && message2.hasOwnProperty("error")) {
          if (!Array.isArray(message2.error))
            return "error: array expected";
          for (var i = 0;i < message2.error.length; ++i) {
            var error = $root.Trace.Error.verify(message2.error[i]);
            if (error)
              return "error." + error;
          }
        }
        if (message2.child != null && message2.hasOwnProperty("child")) {
          if (!Array.isArray(message2.child))
            return "child: array expected";
          for (var i = 0;i < message2.child.length; ++i) {
            var error = $root.Trace.Node.verify(message2.child[i]);
            if (error)
              return "child." + error;
          }
        }
        return null;
      };
      Node.toObject = function toObject(message2, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.arrays || options.defaults) {
          object.error = [];
          object.child = [];
        }
        if (options.defaults) {
          object.type = "";
          object.cachePolicy = null;
          object.startTime = 0;
          object.endTime = 0;
          object.parentType = "";
          object.originalFieldName = "";
        }
        if (message2.responseName != null && message2.hasOwnProperty("responseName")) {
          object.responseName = message2.responseName;
          if (options.oneofs)
            object.id = "responseName";
        }
        if (message2.index != null && message2.hasOwnProperty("index")) {
          object.index = message2.index;
          if (options.oneofs)
            object.id = "index";
        }
        if (message2.type != null && message2.hasOwnProperty("type"))
          object.type = message2.type;
        if (message2.cachePolicy != null && message2.hasOwnProperty("cachePolicy"))
          object.cachePolicy = $root.Trace.CachePolicy.toObject(message2.cachePolicy, options);
        if (message2.startTime != null && message2.hasOwnProperty("startTime"))
          if (typeof message2.startTime === "number")
            object.startTime = options.longs === String ? String(message2.startTime) : message2.startTime;
          else
            object.startTime = options.longs === String ? $util.Long.prototype.toString.call(message2.startTime) : options.longs === Number ? new $util.LongBits(message2.startTime.low >>> 0, message2.startTime.high >>> 0).toNumber(true) : message2.startTime;
        if (message2.endTime != null && message2.hasOwnProperty("endTime"))
          if (typeof message2.endTime === "number")
            object.endTime = options.longs === String ? String(message2.endTime) : message2.endTime;
          else
            object.endTime = options.longs === String ? $util.Long.prototype.toString.call(message2.endTime) : options.longs === Number ? new $util.LongBits(message2.endTime.low >>> 0, message2.endTime.high >>> 0).toNumber(true) : message2.endTime;
        if (message2.error && message2.error.length) {
          object.error = [];
          for (var j = 0;j < message2.error.length; ++j)
            object.error[j] = $root.Trace.Error.toObject(message2.error[j], options);
        }
        if (message2.child && message2.child.length) {
          object.child = [];
          for (var j = 0;j < message2.child.length; ++j)
            object.child[j] = $root.Trace.Node.toObject(message2.child[j], options);
        }
        if (message2.parentType != null && message2.hasOwnProperty("parentType"))
          object.parentType = message2.parentType;
        if (message2.originalFieldName != null && message2.hasOwnProperty("originalFieldName"))
          object.originalFieldName = message2.originalFieldName;
        return object;
      };
      Node.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };
      return Node;
    }();
    Trace.QueryPlanNode = function() {
      function QueryPlanNode(properties) {
        if (properties) {
          for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      QueryPlanNode.prototype.sequence = null;
      QueryPlanNode.prototype.parallel = null;
      QueryPlanNode.prototype.fetch = null;
      QueryPlanNode.prototype.flatten = null;
      QueryPlanNode.prototype.defer = null;
      QueryPlanNode.prototype.condition = null;
      var $oneOfFields;
      Object.defineProperty(QueryPlanNode.prototype, "node", {
        get: $util.oneOfGetter($oneOfFields = ["sequence", "parallel", "fetch", "flatten", "defer", "condition"]),
        set: $util.oneOfSetter($oneOfFields)
      });
      QueryPlanNode.create = function create(properties) {
        return new QueryPlanNode(properties);
      };
      QueryPlanNode.encode = function encode(message2, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message2.sequence != null && Object.hasOwnProperty.call(message2, "sequence"))
          $root.Trace.QueryPlanNode.SequenceNode.encode(message2.sequence, writer.uint32(10).fork()).ldelim();
        if (message2.parallel != null && Object.hasOwnProperty.call(message2, "parallel"))
          $root.Trace.QueryPlanNode.ParallelNode.encode(message2.parallel, writer.uint32(18).fork()).ldelim();
        if (message2.fetch != null && Object.hasOwnProperty.call(message2, "fetch"))
          $root.Trace.QueryPlanNode.FetchNode.encode(message2.fetch, writer.uint32(26).fork()).ldelim();
        if (message2.flatten != null && Object.hasOwnProperty.call(message2, "flatten"))
          $root.Trace.QueryPlanNode.FlattenNode.encode(message2.flatten, writer.uint32(34).fork()).ldelim();
        if (message2.defer != null && Object.hasOwnProperty.call(message2, "defer"))
          $root.Trace.QueryPlanNode.DeferNode.encode(message2.defer, writer.uint32(42).fork()).ldelim();
        if (message2.condition != null && Object.hasOwnProperty.call(message2, "condition"))
          $root.Trace.QueryPlanNode.ConditionNode.encode(message2.condition, writer.uint32(50).fork()).ldelim();
        return writer;
      };
      QueryPlanNode.encodeDelimited = function encodeDelimited(message2, writer) {
        return this.encode(message2, writer).ldelim();
      };
      QueryPlanNode.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message2 = new $root.Trace.QueryPlanNode;
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message2.sequence = $root.Trace.QueryPlanNode.SequenceNode.decode(reader, reader.uint32());
              break;
            case 2:
              message2.parallel = $root.Trace.QueryPlanNode.ParallelNode.decode(reader, reader.uint32());
              break;
            case 3:
              message2.fetch = $root.Trace.QueryPlanNode.FetchNode.decode(reader, reader.uint32());
              break;
            case 4:
              message2.flatten = $root.Trace.QueryPlanNode.FlattenNode.decode(reader, reader.uint32());
              break;
            case 5:
              message2.defer = $root.Trace.QueryPlanNode.DeferNode.decode(reader, reader.uint32());
              break;
            case 6:
              message2.condition = $root.Trace.QueryPlanNode.ConditionNode.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message2;
      };
      QueryPlanNode.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };
      QueryPlanNode.verify = function verify(message2) {
        if (typeof message2 !== "object" || message2 === null)
          return "object expected";
        var properties = {};
        if (message2.sequence != null && message2.hasOwnProperty("sequence")) {
          properties.node = 1;
          {
            var error = $root.Trace.QueryPlanNode.SequenceNode.verify(message2.sequence);
            if (error)
              return "sequence." + error;
          }
        }
        if (message2.parallel != null && message2.hasOwnProperty("parallel")) {
          if (properties.node === 1)
            return "node: multiple values";
          properties.node = 1;
          {
            var error = $root.Trace.QueryPlanNode.ParallelNode.verify(message2.parallel);
            if (error)
              return "parallel." + error;
          }
        }
        if (message2.fetch != null && message2.hasOwnProperty("fetch")) {
          if (properties.node === 1)
            return "node: multiple values";
          properties.node = 1;
          {
            var error = $root.Trace.QueryPlanNode.FetchNode.verify(message2.fetch);
            if (error)
              return "fetch." + error;
          }
        }
        if (message2.flatten != null && message2.hasOwnProperty("flatten")) {
          if (properties.node === 1)
            return "node: multiple values";
          properties.node = 1;
          {
            var error = $root.Trace.QueryPlanNode.FlattenNode.verify(message2.flatten);
            if (error)
              return "flatten." + error;
          }
        }
        if (message2.defer != null && message2.hasOwnProperty("defer")) {
          if (properties.node === 1)
            return "node: multiple values";
          properties.node = 1;
          {
            var error = $root.Trace.QueryPlanNode.DeferNode.verify(message2.defer);
            if (error)
              return "defer." + error;
          }
        }
        if (message2.condition != null && message2.hasOwnProperty("condition")) {
          if (properties.node === 1)
            return "node: multiple values";
          properties.node = 1;
          {
            var error = $root.Trace.QueryPlanNode.ConditionNode.verify(message2.condition);
            if (error)
              return "condition." + error;
          }
        }
        return null;
      };
      QueryPlanNode.toObject = function toObject(message2, options) {
        if (!options)
          options = {};
        var object = {};
        if (message2.sequence != null && message2.hasOwnProperty("sequence")) {
          object.sequence = $root.Trace.QueryPlanNode.SequenceNode.toObject(message2.sequence, options);
          if (options.oneofs)
            object.node = "sequence";
        }
        if (message2.parallel != null && message2.hasOwnProperty("parallel")) {
          object.parallel = $root.Trace.QueryPlanNode.ParallelNode.toObject(message2.parallel, options);
          if (options.oneofs)
            object.node = "parallel";
        }
        if (message2.fetch != null && message2.hasOwnProperty("fetch")) {
          object.fetch = $root.Trace.QueryPlanNode.FetchNode.toObject(message2.fetch, options);
          if (options.oneofs)
            object.node = "fetch";
        }
        if (message2.flatten != null && message2.hasOwnProperty("flatten")) {
          object.flatten = $root.Trace.QueryPlanNode.FlattenNode.toObject(message2.flatten, options);
          if (options.oneofs)
            object.node = "flatten";
        }
        if (message2.defer != null && message2.hasOwnProperty("defer")) {
          object.defer = $root.Trace.QueryPlanNode.DeferNode.toObject(message2.defer, options);
          if (options.oneofs)
            object.node = "defer";
        }
        if (message2.condition != null && message2.hasOwnProperty("condition")) {
          object.condition = $root.Trace.QueryPlanNode.ConditionNode.toObject(message2.condition, options);
          if (options.oneofs)
            object.node = "condition";
        }
        return object;
      };
      QueryPlanNode.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };
      QueryPlanNode.SequenceNode = function() {
        function SequenceNode(properties) {
          this.nodes = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        SequenceNode.prototype.nodes = $util.emptyArray;
        SequenceNode.create = function create(properties) {
          return new SequenceNode(properties);
        };
        SequenceNode.encode = function encode(message2, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message2.nodes != null && message2.nodes.length)
            for (var i = 0;i < message2.nodes.length; ++i)
              $root.Trace.QueryPlanNode.encode(message2.nodes[i], writer.uint32(10).fork()).ldelim();
          return writer;
        };
        SequenceNode.encodeDelimited = function encodeDelimited(message2, writer) {
          return this.encode(message2, writer).ldelim();
        };
        SequenceNode.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message2 = new $root.Trace.QueryPlanNode.SequenceNode;
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                if (!(message2.nodes && message2.nodes.length))
                  message2.nodes = [];
                message2.nodes.push($root.Trace.QueryPlanNode.decode(reader, reader.uint32()));
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message2;
        };
        SequenceNode.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        SequenceNode.verify = function verify(message2) {
          if (typeof message2 !== "object" || message2 === null)
            return "object expected";
          if (message2.nodes != null && message2.hasOwnProperty("nodes")) {
            if (!Array.isArray(message2.nodes))
              return "nodes: array expected";
            for (var i = 0;i < message2.nodes.length; ++i) {
              var error = $root.Trace.QueryPlanNode.verify(message2.nodes[i]);
              if (error)
                return "nodes." + error;
            }
          }
          return null;
        };
        SequenceNode.toObject = function toObject(message2, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.arrays || options.defaults)
            object.nodes = [];
          if (message2.nodes && message2.nodes.length) {
            object.nodes = [];
            for (var j = 0;j < message2.nodes.length; ++j)
              object.nodes[j] = $root.Trace.QueryPlanNode.toObject(message2.nodes[j], options);
          }
          return object;
        };
        SequenceNode.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return SequenceNode;
      }();
      QueryPlanNode.ParallelNode = function() {
        function ParallelNode(properties) {
          this.nodes = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        ParallelNode.prototype.nodes = $util.emptyArray;
        ParallelNode.create = function create(properties) {
          return new ParallelNode(properties);
        };
        ParallelNode.encode = function encode(message2, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message2.nodes != null && message2.nodes.length)
            for (var i = 0;i < message2.nodes.length; ++i)
              $root.Trace.QueryPlanNode.encode(message2.nodes[i], writer.uint32(10).fork()).ldelim();
          return writer;
        };
        ParallelNode.encodeDelimited = function encodeDelimited(message2, writer) {
          return this.encode(message2, writer).ldelim();
        };
        ParallelNode.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message2 = new $root.Trace.QueryPlanNode.ParallelNode;
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                if (!(message2.nodes && message2.nodes.length))
                  message2.nodes = [];
                message2.nodes.push($root.Trace.QueryPlanNode.decode(reader, reader.uint32()));
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message2;
        };
        ParallelNode.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        ParallelNode.verify = function verify(message2) {
          if (typeof message2 !== "object" || message2 === null)
            return "object expected";
          if (message2.nodes != null && message2.hasOwnProperty("nodes")) {
            if (!Array.isArray(message2.nodes))
              return "nodes: array expected";
            for (var i = 0;i < message2.nodes.length; ++i) {
              var error = $root.Trace.QueryPlanNode.verify(message2.nodes[i]);
              if (error)
                return "nodes." + error;
            }
          }
          return null;
        };
        ParallelNode.toObject = function toObject(message2, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.arrays || options.defaults)
            object.nodes = [];
          if (message2.nodes && message2.nodes.length) {
            object.nodes = [];
            for (var j = 0;j < message2.nodes.length; ++j)
              object.nodes[j] = $root.Trace.QueryPlanNode.toObject(message2.nodes[j], options);
          }
          return object;
        };
        ParallelNode.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return ParallelNode;
      }();
      QueryPlanNode.FetchNode = function() {
        function FetchNode(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        FetchNode.prototype.serviceName = "";
        FetchNode.prototype.traceParsingFailed = false;
        FetchNode.prototype.trace = null;
        FetchNode.prototype.sentTimeOffset = 0;
        FetchNode.prototype.sentTime = null;
        FetchNode.prototype.receivedTime = null;
        FetchNode.create = function create(properties) {
          return new FetchNode(properties);
        };
        FetchNode.encode = function encode(message2, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message2.serviceName != null && Object.hasOwnProperty.call(message2, "serviceName"))
            writer.uint32(10).string(message2.serviceName);
          if (message2.traceParsingFailed != null && Object.hasOwnProperty.call(message2, "traceParsingFailed"))
            writer.uint32(16).bool(message2.traceParsingFailed);
          if (message2.trace != null && Object.hasOwnProperty.call(message2, "trace"))
            $root.Trace.encode(message2.trace, writer.uint32(26).fork()).ldelim();
          if (message2.sentTimeOffset != null && Object.hasOwnProperty.call(message2, "sentTimeOffset"))
            writer.uint32(32).uint64(message2.sentTimeOffset);
          if (message2.sentTime != null && Object.hasOwnProperty.call(message2, "sentTime"))
            $root.google.protobuf.Timestamp.encode(message2.sentTime, writer.uint32(42).fork()).ldelim();
          if (message2.receivedTime != null && Object.hasOwnProperty.call(message2, "receivedTime"))
            $root.google.protobuf.Timestamp.encode(message2.receivedTime, writer.uint32(50).fork()).ldelim();
          return writer;
        };
        FetchNode.encodeDelimited = function encodeDelimited(message2, writer) {
          return this.encode(message2, writer).ldelim();
        };
        FetchNode.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message2 = new $root.Trace.QueryPlanNode.FetchNode;
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message2.serviceName = reader.string();
                break;
              case 2:
                message2.traceParsingFailed = reader.bool();
                break;
              case 3:
                message2.trace = $root.Trace.decode(reader, reader.uint32());
                break;
              case 4:
                message2.sentTimeOffset = reader.uint64();
                break;
              case 5:
                message2.sentTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                break;
              case 6:
                message2.receivedTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message2;
        };
        FetchNode.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        FetchNode.verify = function verify(message2) {
          if (typeof message2 !== "object" || message2 === null)
            return "object expected";
          if (message2.serviceName != null && message2.hasOwnProperty("serviceName")) {
            if (!$util.isString(message2.serviceName))
              return "serviceName: string expected";
          }
          if (message2.traceParsingFailed != null && message2.hasOwnProperty("traceParsingFailed")) {
            if (typeof message2.traceParsingFailed !== "boolean")
              return "traceParsingFailed: boolean expected";
          }
          if (message2.trace != null && message2.hasOwnProperty("trace")) {
            var error = $root.Trace.verify(message2.trace);
            if (error)
              return "trace." + error;
          }
          if (message2.sentTimeOffset != null && message2.hasOwnProperty("sentTimeOffset")) {
            if (!$util.isInteger(message2.sentTimeOffset) && !(message2.sentTimeOffset && $util.isInteger(message2.sentTimeOffset.low) && $util.isInteger(message2.sentTimeOffset.high)))
              return "sentTimeOffset: integer|Long expected";
          }
          if (message2.sentTime != null && message2.hasOwnProperty("sentTime")) {
            var error = $root.google.protobuf.Timestamp.verify(message2.sentTime);
            if (error)
              return "sentTime." + error;
          }
          if (message2.receivedTime != null && message2.hasOwnProperty("receivedTime")) {
            var error = $root.google.protobuf.Timestamp.verify(message2.receivedTime);
            if (error)
              return "receivedTime." + error;
          }
          return null;
        };
        FetchNode.toObject = function toObject(message2, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.defaults) {
            object.serviceName = "";
            object.traceParsingFailed = false;
            object.trace = null;
            object.sentTimeOffset = 0;
            object.sentTime = null;
            object.receivedTime = null;
          }
          if (message2.serviceName != null && message2.hasOwnProperty("serviceName"))
            object.serviceName = message2.serviceName;
          if (message2.traceParsingFailed != null && message2.hasOwnProperty("traceParsingFailed"))
            object.traceParsingFailed = message2.traceParsingFailed;
          if (message2.trace != null && message2.hasOwnProperty("trace"))
            object.trace = $root.Trace.toObject(message2.trace, options);
          if (message2.sentTimeOffset != null && message2.hasOwnProperty("sentTimeOffset"))
            if (typeof message2.sentTimeOffset === "number")
              object.sentTimeOffset = options.longs === String ? String(message2.sentTimeOffset) : message2.sentTimeOffset;
            else
              object.sentTimeOffset = options.longs === String ? $util.Long.prototype.toString.call(message2.sentTimeOffset) : options.longs === Number ? new $util.LongBits(message2.sentTimeOffset.low >>> 0, message2.sentTimeOffset.high >>> 0).toNumber(true) : message2.sentTimeOffset;
          if (message2.sentTime != null && message2.hasOwnProperty("sentTime"))
            object.sentTime = $root.google.protobuf.Timestamp.toObject(message2.sentTime, options);
          if (message2.receivedTime != null && message2.hasOwnProperty("receivedTime"))
            object.receivedTime = $root.google.protobuf.Timestamp.toObject(message2.receivedTime, options);
          return object;
        };
        FetchNode.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return FetchNode;
      }();
      QueryPlanNode.FlattenNode = function() {
        function FlattenNode(properties) {
          this.responsePath = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        FlattenNode.prototype.responsePath = $util.emptyArray;
        FlattenNode.prototype.node = null;
        FlattenNode.create = function create(properties) {
          return new FlattenNode(properties);
        };
        FlattenNode.encode = function encode(message2, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message2.responsePath != null && message2.responsePath.length)
            for (var i = 0;i < message2.responsePath.length; ++i)
              $root.Trace.QueryPlanNode.ResponsePathElement.encode(message2.responsePath[i], writer.uint32(10).fork()).ldelim();
          if (message2.node != null && Object.hasOwnProperty.call(message2, "node"))
            $root.Trace.QueryPlanNode.encode(message2.node, writer.uint32(18).fork()).ldelim();
          return writer;
        };
        FlattenNode.encodeDelimited = function encodeDelimited(message2, writer) {
          return this.encode(message2, writer).ldelim();
        };
        FlattenNode.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message2 = new $root.Trace.QueryPlanNode.FlattenNode;
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                if (!(message2.responsePath && message2.responsePath.length))
                  message2.responsePath = [];
                message2.responsePath.push($root.Trace.QueryPlanNode.ResponsePathElement.decode(reader, reader.uint32()));
                break;
              case 2:
                message2.node = $root.Trace.QueryPlanNode.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message2;
        };
        FlattenNode.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        FlattenNode.verify = function verify(message2) {
          if (typeof message2 !== "object" || message2 === null)
            return "object expected";
          if (message2.responsePath != null && message2.hasOwnProperty("responsePath")) {
            if (!Array.isArray(message2.responsePath))
              return "responsePath: array expected";
            for (var i = 0;i < message2.responsePath.length; ++i) {
              var error = $root.Trace.QueryPlanNode.ResponsePathElement.verify(message2.responsePath[i]);
              if (error)
                return "responsePath." + error;
            }
          }
          if (message2.node != null && message2.hasOwnProperty("node")) {
            var error = $root.Trace.QueryPlanNode.verify(message2.node);
            if (error)
              return "node." + error;
          }
          return null;
        };
        FlattenNode.toObject = function toObject(message2, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.arrays || options.defaults)
            object.responsePath = [];
          if (options.defaults)
            object.node = null;
          if (message2.responsePath && message2.responsePath.length) {
            object.responsePath = [];
            for (var j = 0;j < message2.responsePath.length; ++j)
              object.responsePath[j] = $root.Trace.QueryPlanNode.ResponsePathElement.toObject(message2.responsePath[j], options);
          }
          if (message2.node != null && message2.hasOwnProperty("node"))
            object.node = $root.Trace.QueryPlanNode.toObject(message2.node, options);
          return object;
        };
        FlattenNode.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return FlattenNode;
      }();
      QueryPlanNode.DeferNode = function() {
        function DeferNode(properties) {
          this.deferred = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        DeferNode.prototype.primary = null;
        DeferNode.prototype.deferred = $util.emptyArray;
        DeferNode.create = function create(properties) {
          return new DeferNode(properties);
        };
        DeferNode.encode = function encode(message2, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message2.primary != null && Object.hasOwnProperty.call(message2, "primary"))
            $root.Trace.QueryPlanNode.DeferNodePrimary.encode(message2.primary, writer.uint32(10).fork()).ldelim();
          if (message2.deferred != null && message2.deferred.length)
            for (var i = 0;i < message2.deferred.length; ++i)
              $root.Trace.QueryPlanNode.DeferredNode.encode(message2.deferred[i], writer.uint32(18).fork()).ldelim();
          return writer;
        };
        DeferNode.encodeDelimited = function encodeDelimited(message2, writer) {
          return this.encode(message2, writer).ldelim();
        };
        DeferNode.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message2 = new $root.Trace.QueryPlanNode.DeferNode;
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message2.primary = $root.Trace.QueryPlanNode.DeferNodePrimary.decode(reader, reader.uint32());
                break;
              case 2:
                if (!(message2.deferred && message2.deferred.length))
                  message2.deferred = [];
                message2.deferred.push($root.Trace.QueryPlanNode.DeferredNode.decode(reader, reader.uint32()));
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message2;
        };
        DeferNode.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        DeferNode.verify = function verify(message2) {
          if (typeof message2 !== "object" || message2 === null)
            return "object expected";
          if (message2.primary != null && message2.hasOwnProperty("primary")) {
            var error = $root.Trace.QueryPlanNode.DeferNodePrimary.verify(message2.primary);
            if (error)
              return "primary." + error;
          }
          if (message2.deferred != null && message2.hasOwnProperty("deferred")) {
            if (!Array.isArray(message2.deferred))
              return "deferred: array expected";
            for (var i = 0;i < message2.deferred.length; ++i) {
              var error = $root.Trace.QueryPlanNode.DeferredNode.verify(message2.deferred[i]);
              if (error)
                return "deferred." + error;
            }
          }
          return null;
        };
        DeferNode.toObject = function toObject(message2, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.arrays || options.defaults)
            object.deferred = [];
          if (options.defaults)
            object.primary = null;
          if (message2.primary != null && message2.hasOwnProperty("primary"))
            object.primary = $root.Trace.QueryPlanNode.DeferNodePrimary.toObject(message2.primary, options);
          if (message2.deferred && message2.deferred.length) {
            object.deferred = [];
            for (var j = 0;j < message2.deferred.length; ++j)
              object.deferred[j] = $root.Trace.QueryPlanNode.DeferredNode.toObject(message2.deferred[j], options);
          }
          return object;
        };
        DeferNode.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return DeferNode;
      }();
      QueryPlanNode.ConditionNode = function() {
        function ConditionNode(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        ConditionNode.prototype.condition = "";
        ConditionNode.prototype.ifClause = null;
        ConditionNode.prototype.elseClause = null;
        ConditionNode.create = function create(properties) {
          return new ConditionNode(properties);
        };
        ConditionNode.encode = function encode(message2, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message2.condition != null && Object.hasOwnProperty.call(message2, "condition"))
            writer.uint32(10).string(message2.condition);
          if (message2.ifClause != null && Object.hasOwnProperty.call(message2, "ifClause"))
            $root.Trace.QueryPlanNode.encode(message2.ifClause, writer.uint32(18).fork()).ldelim();
          if (message2.elseClause != null && Object.hasOwnProperty.call(message2, "elseClause"))
            $root.Trace.QueryPlanNode.encode(message2.elseClause, writer.uint32(26).fork()).ldelim();
          return writer;
        };
        ConditionNode.encodeDelimited = function encodeDelimited(message2, writer) {
          return this.encode(message2, writer).ldelim();
        };
        ConditionNode.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message2 = new $root.Trace.QueryPlanNode.ConditionNode;
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message2.condition = reader.string();
                break;
              case 2:
                message2.ifClause = $root.Trace.QueryPlanNode.decode(reader, reader.uint32());
                break;
              case 3:
                message2.elseClause = $root.Trace.QueryPlanNode.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message2;
        };
        ConditionNode.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        ConditionNode.verify = function verify(message2) {
          if (typeof message2 !== "object" || message2 === null)
            return "object expected";
          if (message2.condition != null && message2.hasOwnProperty("condition")) {
            if (!$util.isString(message2.condition))
              return "condition: string expected";
          }
          if (message2.ifClause != null && message2.hasOwnProperty("ifClause")) {
            var error = $root.Trace.QueryPlanNode.verify(message2.ifClause);
            if (error)
              return "ifClause." + error;
          }
          if (message2.elseClause != null && message2.hasOwnProperty("elseClause")) {
            var error = $root.Trace.QueryPlanNode.verify(message2.elseClause);
            if (error)
              return "elseClause." + error;
          }
          return null;
        };
        ConditionNode.toObject = function toObject(message2, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.defaults) {
            object.condition = "";
            object.ifClause = null;
            object.elseClause = null;
          }
          if (message2.condition != null && message2.hasOwnProperty("condition"))
            object.condition = message2.condition;
          if (message2.ifClause != null && message2.hasOwnProperty("ifClause"))
            object.ifClause = $root.Trace.QueryPlanNode.toObject(message2.ifClause, options);
          if (message2.elseClause != null && message2.hasOwnProperty("elseClause"))
            object.elseClause = $root.Trace.QueryPlanNode.toObject(message2.elseClause, options);
          return object;
        };
        ConditionNode.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return ConditionNode;
      }();
      QueryPlanNode.DeferNodePrimary = function() {
        function DeferNodePrimary(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        DeferNodePrimary.prototype.node = null;
        DeferNodePrimary.create = function create(properties) {
          return new DeferNodePrimary(properties);
        };
        DeferNodePrimary.encode = function encode(message2, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message2.node != null && Object.hasOwnProperty.call(message2, "node"))
            $root.Trace.QueryPlanNode.encode(message2.node, writer.uint32(10).fork()).ldelim();
          return writer;
        };
        DeferNodePrimary.encodeDelimited = function encodeDelimited(message2, writer) {
          return this.encode(message2, writer).ldelim();
        };
        DeferNodePrimary.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message2 = new $root.Trace.QueryPlanNode.DeferNodePrimary;
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message2.node = $root.Trace.QueryPlanNode.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message2;
        };
        DeferNodePrimary.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        DeferNodePrimary.verify = function verify(message2) {
          if (typeof message2 !== "object" || message2 === null)
            return "object expected";
          if (message2.node != null && message2.hasOwnProperty("node")) {
            var error = $root.Trace.QueryPlanNode.verify(message2.node);
            if (error)
              return "node." + error;
          }
          return null;
        };
        DeferNodePrimary.toObject = function toObject(message2, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.defaults)
            object.node = null;
          if (message2.node != null && message2.hasOwnProperty("node"))
            object.node = $root.Trace.QueryPlanNode.toObject(message2.node, options);
          return object;
        };
        DeferNodePrimary.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return DeferNodePrimary;
      }();
      QueryPlanNode.DeferredNode = function() {
        function DeferredNode(properties) {
          this.depends = [];
          this.path = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        DeferredNode.prototype.depends = $util.emptyArray;
        DeferredNode.prototype.label = "";
        DeferredNode.prototype.path = $util.emptyArray;
        DeferredNode.prototype.node = null;
        DeferredNode.create = function create(properties) {
          return new DeferredNode(properties);
        };
        DeferredNode.encode = function encode(message2, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message2.depends != null && message2.depends.length)
            for (var i = 0;i < message2.depends.length; ++i)
              $root.Trace.QueryPlanNode.DeferredNodeDepends.encode(message2.depends[i], writer.uint32(10).fork()).ldelim();
          if (message2.label != null && Object.hasOwnProperty.call(message2, "label"))
            writer.uint32(18).string(message2.label);
          if (message2.path != null && message2.path.length)
            for (var i = 0;i < message2.path.length; ++i)
              $root.Trace.QueryPlanNode.ResponsePathElement.encode(message2.path[i], writer.uint32(26).fork()).ldelim();
          if (message2.node != null && Object.hasOwnProperty.call(message2, "node"))
            $root.Trace.QueryPlanNode.encode(message2.node, writer.uint32(34).fork()).ldelim();
          return writer;
        };
        DeferredNode.encodeDelimited = function encodeDelimited(message2, writer) {
          return this.encode(message2, writer).ldelim();
        };
        DeferredNode.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message2 = new $root.Trace.QueryPlanNode.DeferredNode;
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                if (!(message2.depends && message2.depends.length))
                  message2.depends = [];
                message2.depends.push($root.Trace.QueryPlanNode.DeferredNodeDepends.decode(reader, reader.uint32()));
                break;
              case 2:
                message2.label = reader.string();
                break;
              case 3:
                if (!(message2.path && message2.path.length))
                  message2.path = [];
                message2.path.push($root.Trace.QueryPlanNode.ResponsePathElement.decode(reader, reader.uint32()));
                break;
              case 4:
                message2.node = $root.Trace.QueryPlanNode.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message2;
        };
        DeferredNode.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        DeferredNode.verify = function verify(message2) {
          if (typeof message2 !== "object" || message2 === null)
            return "object expected";
          if (message2.depends != null && message2.hasOwnProperty("depends")) {
            if (!Array.isArray(message2.depends))
              return "depends: array expected";
            for (var i = 0;i < message2.depends.length; ++i) {
              var error = $root.Trace.QueryPlanNode.DeferredNodeDepends.verify(message2.depends[i]);
              if (error)
                return "depends." + error;
            }
          }
          if (message2.label != null && message2.hasOwnProperty("label")) {
            if (!$util.isString(message2.label))
              return "label: string expected";
          }
          if (message2.path != null && message2.hasOwnProperty("path")) {
            if (!Array.isArray(message2.path))
              return "path: array expected";
            for (var i = 0;i < message2.path.length; ++i) {
              var error = $root.Trace.QueryPlanNode.ResponsePathElement.verify(message2.path[i]);
              if (error)
                return "path." + error;
            }
          }
          if (message2.node != null && message2.hasOwnProperty("node")) {
            var error = $root.Trace.QueryPlanNode.verify(message2.node);
            if (error)
              return "node." + error;
          }
          return null;
        };
        DeferredNode.toObject = function toObject(message2, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.arrays || options.defaults) {
            object.depends = [];
            object.path = [];
          }
          if (options.defaults) {
            object.label = "";
            object.node = null;
          }
          if (message2.depends && message2.depends.length) {
            object.depends = [];
            for (var j = 0;j < message2.depends.length; ++j)
              object.depends[j] = $root.Trace.QueryPlanNode.DeferredNodeDepends.toObject(message2.depends[j], options);
          }
          if (message2.label != null && message2.hasOwnProperty("label"))
            object.label = message2.label;
          if (message2.path && message2.path.length) {
            object.path = [];
            for (var j = 0;j < message2.path.length; ++j)
              object.path[j] = $root.Trace.QueryPlanNode.ResponsePathElement.toObject(message2.path[j], options);
          }
          if (message2.node != null && message2.hasOwnProperty("node"))
            object.node = $root.Trace.QueryPlanNode.toObject(message2.node, options);
          return object;
        };
        DeferredNode.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return DeferredNode;
      }();
      QueryPlanNode.DeferredNodeDepends = function() {
        function DeferredNodeDepends(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        DeferredNodeDepends.prototype.id = "";
        DeferredNodeDepends.prototype.deferLabel = "";
        DeferredNodeDepends.create = function create(properties) {
          return new DeferredNodeDepends(properties);
        };
        DeferredNodeDepends.encode = function encode(message2, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message2.id != null && Object.hasOwnProperty.call(message2, "id"))
            writer.uint32(10).string(message2.id);
          if (message2.deferLabel != null && Object.hasOwnProperty.call(message2, "deferLabel"))
            writer.uint32(18).string(message2.deferLabel);
          return writer;
        };
        DeferredNodeDepends.encodeDelimited = function encodeDelimited(message2, writer) {
          return this.encode(message2, writer).ldelim();
        };
        DeferredNodeDepends.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message2 = new $root.Trace.QueryPlanNode.DeferredNodeDepends;
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message2.id = reader.string();
                break;
              case 2:
                message2.deferLabel = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message2;
        };
        DeferredNodeDepends.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        DeferredNodeDepends.verify = function verify(message2) {
          if (typeof message2 !== "object" || message2 === null)
            return "object expected";
          if (message2.id != null && message2.hasOwnProperty("id")) {
            if (!$util.isString(message2.id))
              return "id: string expected";
          }
          if (message2.deferLabel != null && message2.hasOwnProperty("deferLabel")) {
            if (!$util.isString(message2.deferLabel))
              return "deferLabel: string expected";
          }
          return null;
        };
        DeferredNodeDepends.toObject = function toObject(message2, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.defaults) {
            object.id = "";
            object.deferLabel = "";
          }
          if (message2.id != null && message2.hasOwnProperty("id"))
            object.id = message2.id;
          if (message2.deferLabel != null && message2.hasOwnProperty("deferLabel"))
            object.deferLabel = message2.deferLabel;
          return object;
        };
        DeferredNodeDepends.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return DeferredNodeDepends;
      }();
      QueryPlanNode.ResponsePathElement = function() {
        function ResponsePathElement(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        ResponsePathElement.prototype.fieldName = "";
        ResponsePathElement.prototype.index = 0;
        var $oneOfFields2;
        Object.defineProperty(ResponsePathElement.prototype, "id", {
          get: $util.oneOfGetter($oneOfFields2 = ["fieldName", "index"]),
          set: $util.oneOfSetter($oneOfFields2)
        });
        ResponsePathElement.create = function create(properties) {
          return new ResponsePathElement(properties);
        };
        ResponsePathElement.encode = function encode(message2, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message2.fieldName != null && Object.hasOwnProperty.call(message2, "fieldName"))
            writer.uint32(10).string(message2.fieldName);
          if (message2.index != null && Object.hasOwnProperty.call(message2, "index"))
            writer.uint32(16).uint32(message2.index);
          return writer;
        };
        ResponsePathElement.encodeDelimited = function encodeDelimited(message2, writer) {
          return this.encode(message2, writer).ldelim();
        };
        ResponsePathElement.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message2 = new $root.Trace.QueryPlanNode.ResponsePathElement;
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message2.fieldName = reader.string();
                break;
              case 2:
                message2.index = reader.uint32();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message2;
        };
        ResponsePathElement.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        ResponsePathElement.verify = function verify(message2) {
          if (typeof message2 !== "object" || message2 === null)
            return "object expected";
          var properties = {};
          if (message2.fieldName != null && message2.hasOwnProperty("fieldName")) {
            properties.id = 1;
            if (!$util.isString(message2.fieldName))
              return "fieldName: string expected";
          }
          if (message2.index != null && message2.hasOwnProperty("index")) {
            if (properties.id === 1)
              return "id: multiple values";
            properties.id = 1;
            if (!$util.isInteger(message2.index))
              return "index: integer expected";
          }
          return null;
        };
        ResponsePathElement.toObject = function toObject(message2, options) {
          if (!options)
            options = {};
          var object = {};
          if (message2.fieldName != null && message2.hasOwnProperty("fieldName")) {
            object.fieldName = message2.fieldName;
            if (options.oneofs)
              object.id = "fieldName";
          }
          if (message2.index != null && message2.hasOwnProperty("index")) {
            object.index = message2.index;
            if (options.oneofs)
              object.id = "index";
          }
          return object;
        };
        ResponsePathElement.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return ResponsePathElement;
      }();
      return QueryPlanNode;
    }();
    return Trace;
  }();
  $root.ReportHeader = function() {
    function ReportHeader(properties) {
      if (properties) {
        for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    ReportHeader.prototype.graphRef = "";
    ReportHeader.prototype.hostname = "";
    ReportHeader.prototype.agentVersion = "";
    ReportHeader.prototype.serviceVersion = "";
    ReportHeader.prototype.runtimeVersion = "";
    ReportHeader.prototype.uname = "";
    ReportHeader.prototype.executableSchemaId = "";
    ReportHeader.create = function create(properties) {
      return new ReportHeader(properties);
    };
    ReportHeader.encode = function encode(message2, writer) {
      if (!writer)
        writer = $Writer.create();
      if (message2.hostname != null && Object.hasOwnProperty.call(message2, "hostname"))
        writer.uint32(42).string(message2.hostname);
      if (message2.agentVersion != null && Object.hasOwnProperty.call(message2, "agentVersion"))
        writer.uint32(50).string(message2.agentVersion);
      if (message2.serviceVersion != null && Object.hasOwnProperty.call(message2, "serviceVersion"))
        writer.uint32(58).string(message2.serviceVersion);
      if (message2.runtimeVersion != null && Object.hasOwnProperty.call(message2, "runtimeVersion"))
        writer.uint32(66).string(message2.runtimeVersion);
      if (message2.uname != null && Object.hasOwnProperty.call(message2, "uname"))
        writer.uint32(74).string(message2.uname);
      if (message2.executableSchemaId != null && Object.hasOwnProperty.call(message2, "executableSchemaId"))
        writer.uint32(90).string(message2.executableSchemaId);
      if (message2.graphRef != null && Object.hasOwnProperty.call(message2, "graphRef"))
        writer.uint32(98).string(message2.graphRef);
      return writer;
    };
    ReportHeader.encodeDelimited = function encodeDelimited(message2, writer) {
      return this.encode(message2, writer).ldelim();
    };
    ReportHeader.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader))
        reader = $Reader.create(reader);
      var end = length === undefined ? reader.len : reader.pos + length, message2 = new $root.ReportHeader;
      while (reader.pos < end) {
        var tag = reader.uint32();
        switch (tag >>> 3) {
          case 12:
            message2.graphRef = reader.string();
            break;
          case 5:
            message2.hostname = reader.string();
            break;
          case 6:
            message2.agentVersion = reader.string();
            break;
          case 7:
            message2.serviceVersion = reader.string();
            break;
          case 8:
            message2.runtimeVersion = reader.string();
            break;
          case 9:
            message2.uname = reader.string();
            break;
          case 11:
            message2.executableSchemaId = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message2;
    };
    ReportHeader.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader))
        reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };
    ReportHeader.verify = function verify(message2) {
      if (typeof message2 !== "object" || message2 === null)
        return "object expected";
      if (message2.graphRef != null && message2.hasOwnProperty("graphRef")) {
        if (!$util.isString(message2.graphRef))
          return "graphRef: string expected";
      }
      if (message2.hostname != null && message2.hasOwnProperty("hostname")) {
        if (!$util.isString(message2.hostname))
          return "hostname: string expected";
      }
      if (message2.agentVersion != null && message2.hasOwnProperty("agentVersion")) {
        if (!$util.isString(message2.agentVersion))
          return "agentVersion: string expected";
      }
      if (message2.serviceVersion != null && message2.hasOwnProperty("serviceVersion")) {
        if (!$util.isString(message2.serviceVersion))
          return "serviceVersion: string expected";
      }
      if (message2.runtimeVersion != null && message2.hasOwnProperty("runtimeVersion")) {
        if (!$util.isString(message2.runtimeVersion))
          return "runtimeVersion: string expected";
      }
      if (message2.uname != null && message2.hasOwnProperty("uname")) {
        if (!$util.isString(message2.uname))
          return "uname: string expected";
      }
      if (message2.executableSchemaId != null && message2.hasOwnProperty("executableSchemaId")) {
        if (!$util.isString(message2.executableSchemaId))
          return "executableSchemaId: string expected";
      }
      return null;
    };
    ReportHeader.toObject = function toObject(message2, options) {
      if (!options)
        options = {};
      var object = {};
      if (options.defaults) {
        object.hostname = "";
        object.agentVersion = "";
        object.serviceVersion = "";
        object.runtimeVersion = "";
        object.uname = "";
        object.executableSchemaId = "";
        object.graphRef = "";
      }
      if (message2.hostname != null && message2.hasOwnProperty("hostname"))
        object.hostname = message2.hostname;
      if (message2.agentVersion != null && message2.hasOwnProperty("agentVersion"))
        object.agentVersion = message2.agentVersion;
      if (message2.serviceVersion != null && message2.hasOwnProperty("serviceVersion"))
        object.serviceVersion = message2.serviceVersion;
      if (message2.runtimeVersion != null && message2.hasOwnProperty("runtimeVersion"))
        object.runtimeVersion = message2.runtimeVersion;
      if (message2.uname != null && message2.hasOwnProperty("uname"))
        object.uname = message2.uname;
      if (message2.executableSchemaId != null && message2.hasOwnProperty("executableSchemaId"))
        object.executableSchemaId = message2.executableSchemaId;
      if (message2.graphRef != null && message2.hasOwnProperty("graphRef"))
        object.graphRef = message2.graphRef;
      return object;
    };
    ReportHeader.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };
    return ReportHeader;
  }();
  $root.PathErrorStats = function() {
    function PathErrorStats(properties) {
      this.children = {};
      if (properties) {
        for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    PathErrorStats.prototype.children = $util.emptyObject;
    PathErrorStats.prototype.errorsCount = 0;
    PathErrorStats.prototype.requestsWithErrorsCount = 0;
    PathErrorStats.create = function create(properties) {
      return new PathErrorStats(properties);
    };
    PathErrorStats.encode = function encode(message2, writer) {
      if (!writer)
        writer = $Writer.create();
      if (message2.children != null && Object.hasOwnProperty.call(message2, "children"))
        for (var keys = Object.keys(message2.children), i = 0;i < keys.length; ++i) {
          writer.uint32(10).fork().uint32(10).string(keys[i]);
          $root.PathErrorStats.encode(message2.children[keys[i]], writer.uint32(18).fork()).ldelim().ldelim();
        }
      if (message2.errorsCount != null && Object.hasOwnProperty.call(message2, "errorsCount"))
        writer.uint32(32).uint64(message2.errorsCount);
      if (message2.requestsWithErrorsCount != null && Object.hasOwnProperty.call(message2, "requestsWithErrorsCount"))
        writer.uint32(40).uint64(message2.requestsWithErrorsCount);
      return writer;
    };
    PathErrorStats.encodeDelimited = function encodeDelimited(message2, writer) {
      return this.encode(message2, writer).ldelim();
    };
    PathErrorStats.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader))
        reader = $Reader.create(reader);
      var end = length === undefined ? reader.len : reader.pos + length, message2 = new $root.PathErrorStats, key;
      while (reader.pos < end) {
        var tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            reader.skip().pos++;
            if (message2.children === $util.emptyObject)
              message2.children = {};
            key = reader.string();
            reader.pos++;
            message2.children[key] = $root.PathErrorStats.decode(reader, reader.uint32());
            break;
          case 4:
            message2.errorsCount = reader.uint64();
            break;
          case 5:
            message2.requestsWithErrorsCount = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message2;
    };
    PathErrorStats.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader))
        reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };
    PathErrorStats.verify = function verify(message2) {
      if (typeof message2 !== "object" || message2 === null)
        return "object expected";
      if (message2.children != null && message2.hasOwnProperty("children")) {
        if (!$util.isObject(message2.children))
          return "children: object expected";
        var key = Object.keys(message2.children);
        for (var i = 0;i < key.length; ++i) {
          var error = $root.PathErrorStats.verify(message2.children[key[i]]);
          if (error)
            return "children." + error;
        }
      }
      if (message2.errorsCount != null && message2.hasOwnProperty("errorsCount")) {
        if (!$util.isInteger(message2.errorsCount) && !(message2.errorsCount && $util.isInteger(message2.errorsCount.low) && $util.isInteger(message2.errorsCount.high)))
          return "errorsCount: integer|Long expected";
      }
      if (message2.requestsWithErrorsCount != null && message2.hasOwnProperty("requestsWithErrorsCount")) {
        if (!$util.isInteger(message2.requestsWithErrorsCount) && !(message2.requestsWithErrorsCount && $util.isInteger(message2.requestsWithErrorsCount.low) && $util.isInteger(message2.requestsWithErrorsCount.high)))
          return "requestsWithErrorsCount: integer|Long expected";
      }
      return null;
    };
    PathErrorStats.toObject = function toObject(message2, options) {
      if (!options)
        options = {};
      var object = {};
      if (options.objects || options.defaults)
        object.children = {};
      if (options.defaults) {
        object.errorsCount = 0;
        object.requestsWithErrorsCount = 0;
      }
      var keys2;
      if (message2.children && (keys2 = Object.keys(message2.children)).length) {
        object.children = {};
        for (var j = 0;j < keys2.length; ++j)
          object.children[keys2[j]] = $root.PathErrorStats.toObject(message2.children[keys2[j]], options);
      }
      if (message2.errorsCount != null && message2.hasOwnProperty("errorsCount"))
        if (typeof message2.errorsCount === "number")
          object.errorsCount = options.longs === String ? String(message2.errorsCount) : message2.errorsCount;
        else
          object.errorsCount = options.longs === String ? $util.Long.prototype.toString.call(message2.errorsCount) : options.longs === Number ? new $util.LongBits(message2.errorsCount.low >>> 0, message2.errorsCount.high >>> 0).toNumber(true) : message2.errorsCount;
      if (message2.requestsWithErrorsCount != null && message2.hasOwnProperty("requestsWithErrorsCount"))
        if (typeof message2.requestsWithErrorsCount === "number")
          object.requestsWithErrorsCount = options.longs === String ? String(message2.requestsWithErrorsCount) : message2.requestsWithErrorsCount;
        else
          object.requestsWithErrorsCount = options.longs === String ? $util.Long.prototype.toString.call(message2.requestsWithErrorsCount) : options.longs === Number ? new $util.LongBits(message2.requestsWithErrorsCount.low >>> 0, message2.requestsWithErrorsCount.high >>> 0).toNumber(true) : message2.requestsWithErrorsCount;
      return object;
    };
    PathErrorStats.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };
    return PathErrorStats;
  }();
  $root.QueryLatencyStats = function() {
    function QueryLatencyStats(properties) {
      this.latencyCount = [];
      this.cacheLatencyCount = [];
      this.publicCacheTtlCount = [];
      this.privateCacheTtlCount = [];
      if (properties) {
        for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    QueryLatencyStats.prototype.latencyCount = $util.emptyArray;
    QueryLatencyStats.prototype.requestCount = 0;
    QueryLatencyStats.prototype.cacheHits = 0;
    QueryLatencyStats.prototype.persistedQueryHits = 0;
    QueryLatencyStats.prototype.persistedQueryMisses = 0;
    QueryLatencyStats.prototype.cacheLatencyCount = $util.emptyArray;
    QueryLatencyStats.prototype.rootErrorStats = null;
    QueryLatencyStats.prototype.requestsWithErrorsCount = 0;
    QueryLatencyStats.prototype.publicCacheTtlCount = $util.emptyArray;
    QueryLatencyStats.prototype.privateCacheTtlCount = $util.emptyArray;
    QueryLatencyStats.prototype.registeredOperationCount = 0;
    QueryLatencyStats.prototype.forbiddenOperationCount = 0;
    QueryLatencyStats.prototype.requestsWithoutFieldInstrumentation = 0;
    QueryLatencyStats.create = function create(properties) {
      return new QueryLatencyStats(properties);
    };
    QueryLatencyStats.encode = function encode(message2, writer) {
      if (!writer)
        writer = $Writer.create();
      if (message2.requestCount != null && Object.hasOwnProperty.call(message2, "requestCount"))
        writer.uint32(16).uint64(message2.requestCount);
      if (message2.cacheHits != null && Object.hasOwnProperty.call(message2, "cacheHits"))
        writer.uint32(24).uint64(message2.cacheHits);
      if (message2.persistedQueryHits != null && Object.hasOwnProperty.call(message2, "persistedQueryHits"))
        writer.uint32(32).uint64(message2.persistedQueryHits);
      if (message2.persistedQueryMisses != null && Object.hasOwnProperty.call(message2, "persistedQueryMisses"))
        writer.uint32(40).uint64(message2.persistedQueryMisses);
      if (message2.rootErrorStats != null && Object.hasOwnProperty.call(message2, "rootErrorStats"))
        $root.PathErrorStats.encode(message2.rootErrorStats, writer.uint32(58).fork()).ldelim();
      if (message2.requestsWithErrorsCount != null && Object.hasOwnProperty.call(message2, "requestsWithErrorsCount"))
        writer.uint32(64).uint64(message2.requestsWithErrorsCount);
      if (message2.registeredOperationCount != null && Object.hasOwnProperty.call(message2, "registeredOperationCount"))
        writer.uint32(88).uint64(message2.registeredOperationCount);
      if (message2.forbiddenOperationCount != null && Object.hasOwnProperty.call(message2, "forbiddenOperationCount"))
        writer.uint32(96).uint64(message2.forbiddenOperationCount);
      var array13;
      if (message2.latencyCount != null && message2.latencyCount.toArray)
        array13 = message2.latencyCount.toArray();
      else
        array13 = message2.latencyCount;
      if (array13 != null && array13.length) {
        writer.uint32(106).fork();
        for (var i = 0;i < array13.length; ++i)
          writer.sint64(array13[i]);
        writer.ldelim();
      }
      var array14;
      if (message2.cacheLatencyCount != null && message2.cacheLatencyCount.toArray)
        array14 = message2.cacheLatencyCount.toArray();
      else
        array14 = message2.cacheLatencyCount;
      if (array14 != null && array14.length) {
        writer.uint32(114).fork();
        for (var i = 0;i < array14.length; ++i)
          writer.sint64(array14[i]);
        writer.ldelim();
      }
      var array15;
      if (message2.publicCacheTtlCount != null && message2.publicCacheTtlCount.toArray)
        array15 = message2.publicCacheTtlCount.toArray();
      else
        array15 = message2.publicCacheTtlCount;
      if (array15 != null && array15.length) {
        writer.uint32(122).fork();
        for (var i = 0;i < array15.length; ++i)
          writer.sint64(array15[i]);
        writer.ldelim();
      }
      var array16;
      if (message2.privateCacheTtlCount != null && message2.privateCacheTtlCount.toArray)
        array16 = message2.privateCacheTtlCount.toArray();
      else
        array16 = message2.privateCacheTtlCount;
      if (array16 != null && array16.length) {
        writer.uint32(130).fork();
        for (var i = 0;i < array16.length; ++i)
          writer.sint64(array16[i]);
        writer.ldelim();
      }
      if (message2.requestsWithoutFieldInstrumentation != null && Object.hasOwnProperty.call(message2, "requestsWithoutFieldInstrumentation"))
        writer.uint32(136).uint64(message2.requestsWithoutFieldInstrumentation);
      return writer;
    };
    QueryLatencyStats.encodeDelimited = function encodeDelimited(message2, writer) {
      return this.encode(message2, writer).ldelim();
    };
    QueryLatencyStats.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader))
        reader = $Reader.create(reader);
      var end = length === undefined ? reader.len : reader.pos + length, message2 = new $root.QueryLatencyStats;
      while (reader.pos < end) {
        var tag = reader.uint32();
        switch (tag >>> 3) {
          case 13:
            if (!(message2.latencyCount && message2.latencyCount.length))
              message2.latencyCount = [];
            if ((tag & 7) === 2) {
              var end2 = reader.uint32() + reader.pos;
              while (reader.pos < end2)
                message2.latencyCount.push(reader.sint64());
            } else
              message2.latencyCount.push(reader.sint64());
            break;
          case 2:
            message2.requestCount = reader.uint64();
            break;
          case 3:
            message2.cacheHits = reader.uint64();
            break;
          case 4:
            message2.persistedQueryHits = reader.uint64();
            break;
          case 5:
            message2.persistedQueryMisses = reader.uint64();
            break;
          case 14:
            if (!(message2.cacheLatencyCount && message2.cacheLatencyCount.length))
              message2.cacheLatencyCount = [];
            if ((tag & 7) === 2) {
              var end2 = reader.uint32() + reader.pos;
              while (reader.pos < end2)
                message2.cacheLatencyCount.push(reader.sint64());
            } else
              message2.cacheLatencyCount.push(reader.sint64());
            break;
          case 7:
            message2.rootErrorStats = $root.PathErrorStats.decode(reader, reader.uint32());
            break;
          case 8:
            message2.requestsWithErrorsCount = reader.uint64();
            break;
          case 15:
            if (!(message2.publicCacheTtlCount && message2.publicCacheTtlCount.length))
              message2.publicCacheTtlCount = [];
            if ((tag & 7) === 2) {
              var end2 = reader.uint32() + reader.pos;
              while (reader.pos < end2)
                message2.publicCacheTtlCount.push(reader.sint64());
            } else
              message2.publicCacheTtlCount.push(reader.sint64());
            break;
          case 16:
            if (!(message2.privateCacheTtlCount && message2.privateCacheTtlCount.length))
              message2.privateCacheTtlCount = [];
            if ((tag & 7) === 2) {
              var end2 = reader.uint32() + reader.pos;
              while (reader.pos < end2)
                message2.privateCacheTtlCount.push(reader.sint64());
            } else
              message2.privateCacheTtlCount.push(reader.sint64());
            break;
          case 11:
            message2.registeredOperationCount = reader.uint64();
            break;
          case 12:
            message2.forbiddenOperationCount = reader.uint64();
            break;
          case 17:
            message2.requestsWithoutFieldInstrumentation = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message2;
    };
    QueryLatencyStats.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader))
        reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };
    QueryLatencyStats.verify = function verify(message2) {
      if (typeof message2 !== "object" || message2 === null)
        return "object expected";
      if (message2.latencyCount != null && message2.hasOwnProperty("latencyCount")) {
        var array13;
        if (message2.latencyCount != null && message2.latencyCount.toArray)
          array13 = message2.latencyCount.toArray();
        else
          array13 = message2.latencyCount;
        if (!Array.isArray(array13))
          return "latencyCount: array expected";
        for (var i = 0;i < array13.length; ++i)
          if (!$util.isInteger(array13[i]) && !(array13[i] && $util.isInteger(array13[i].low) && $util.isInteger(array13[i].high)))
            return "latencyCount: integer|Long[] expected";
      }
      if (message2.requestCount != null && message2.hasOwnProperty("requestCount")) {
        if (!$util.isInteger(message2.requestCount) && !(message2.requestCount && $util.isInteger(message2.requestCount.low) && $util.isInteger(message2.requestCount.high)))
          return "requestCount: integer|Long expected";
      }
      if (message2.cacheHits != null && message2.hasOwnProperty("cacheHits")) {
        if (!$util.isInteger(message2.cacheHits) && !(message2.cacheHits && $util.isInteger(message2.cacheHits.low) && $util.isInteger(message2.cacheHits.high)))
          return "cacheHits: integer|Long expected";
      }
      if (message2.persistedQueryHits != null && message2.hasOwnProperty("persistedQueryHits")) {
        if (!$util.isInteger(message2.persistedQueryHits) && !(message2.persistedQueryHits && $util.isInteger(message2.persistedQueryHits.low) && $util.isInteger(message2.persistedQueryHits.high)))
          return "persistedQueryHits: integer|Long expected";
      }
      if (message2.persistedQueryMisses != null && message2.hasOwnProperty("persistedQueryMisses")) {
        if (!$util.isInteger(message2.persistedQueryMisses) && !(message2.persistedQueryMisses && $util.isInteger(message2.persistedQueryMisses.low) && $util.isInteger(message2.persistedQueryMisses.high)))
          return "persistedQueryMisses: integer|Long expected";
      }
      if (message2.cacheLatencyCount != null && message2.hasOwnProperty("cacheLatencyCount")) {
        var array14;
        if (message2.cacheLatencyCount != null && message2.cacheLatencyCount.toArray)
          array14 = message2.cacheLatencyCount.toArray();
        else
          array14 = message2.cacheLatencyCount;
        if (!Array.isArray(array14))
          return "cacheLatencyCount: array expected";
        for (var i = 0;i < array14.length; ++i)
          if (!$util.isInteger(array14[i]) && !(array14[i] && $util.isInteger(array14[i].low) && $util.isInteger(array14[i].high)))
            return "cacheLatencyCount: integer|Long[] expected";
      }
      if (message2.rootErrorStats != null && message2.hasOwnProperty("rootErrorStats")) {
        var error = $root.PathErrorStats.verify(message2.rootErrorStats);
        if (error)
          return "rootErrorStats." + error;
      }
      if (message2.requestsWithErrorsCount != null && message2.hasOwnProperty("requestsWithErrorsCount")) {
        if (!$util.isInteger(message2.requestsWithErrorsCount) && !(message2.requestsWithErrorsCount && $util.isInteger(message2.requestsWithErrorsCount.low) && $util.isInteger(message2.requestsWithErrorsCount.high)))
          return "requestsWithErrorsCount: integer|Long expected";
      }
      if (message2.publicCacheTtlCount != null && message2.hasOwnProperty("publicCacheTtlCount")) {
        var array15;
        if (message2.publicCacheTtlCount != null && message2.publicCacheTtlCount.toArray)
          array15 = message2.publicCacheTtlCount.toArray();
        else
          array15 = message2.publicCacheTtlCount;
        if (!Array.isArray(array15))
          return "publicCacheTtlCount: array expected";
        for (var i = 0;i < array15.length; ++i)
          if (!$util.isInteger(array15[i]) && !(array15[i] && $util.isInteger(array15[i].low) && $util.isInteger(array15[i].high)))
            return "publicCacheTtlCount: integer|Long[] expected";
      }
      if (message2.privateCacheTtlCount != null && message2.hasOwnProperty("privateCacheTtlCount")) {
        var array16;
        if (message2.privateCacheTtlCount != null && message2.privateCacheTtlCount.toArray)
          array16 = message2.privateCacheTtlCount.toArray();
        else
          array16 = message2.privateCacheTtlCount;
        if (!Array.isArray(array16))
          return "privateCacheTtlCount: array expected";
        for (var i = 0;i < array16.length; ++i)
          if (!$util.isInteger(array16[i]) && !(array16[i] && $util.isInteger(array16[i].low) && $util.isInteger(array16[i].high)))
            return "privateCacheTtlCount: integer|Long[] expected";
      }
      if (message2.registeredOperationCount != null && message2.hasOwnProperty("registeredOperationCount")) {
        if (!$util.isInteger(message2.registeredOperationCount) && !(message2.registeredOperationCount && $util.isInteger(message2.registeredOperationCount.low) && $util.isInteger(message2.registeredOperationCount.high)))
          return "registeredOperationCount: integer|Long expected";
      }
      if (message2.forbiddenOperationCount != null && message2.hasOwnProperty("forbiddenOperationCount")) {
        if (!$util.isInteger(message2.forbiddenOperationCount) && !(message2.forbiddenOperationCount && $util.isInteger(message2.forbiddenOperationCount.low) && $util.isInteger(message2.forbiddenOperationCount.high)))
          return "forbiddenOperationCount: integer|Long expected";
      }
      if (message2.requestsWithoutFieldInstrumentation != null && message2.hasOwnProperty("requestsWithoutFieldInstrumentation")) {
        if (!$util.isInteger(message2.requestsWithoutFieldInstrumentation) && !(message2.requestsWithoutFieldInstrumentation && $util.isInteger(message2.requestsWithoutFieldInstrumentation.low) && $util.isInteger(message2.requestsWithoutFieldInstrumentation.high)))
          return "requestsWithoutFieldInstrumentation: integer|Long expected";
      }
      return null;
    };
    QueryLatencyStats.toObject = function toObject(message2, options) {
      if (!options)
        options = {};
      var object = {};
      if (options.arrays || options.defaults) {
        object.latencyCount = [];
        object.cacheLatencyCount = [];
        object.publicCacheTtlCount = [];
        object.privateCacheTtlCount = [];
      }
      if (options.defaults) {
        object.requestCount = 0;
        object.cacheHits = 0;
        object.persistedQueryHits = 0;
        object.persistedQueryMisses = 0;
        object.rootErrorStats = null;
        object.requestsWithErrorsCount = 0;
        object.registeredOperationCount = 0;
        object.forbiddenOperationCount = 0;
        object.requestsWithoutFieldInstrumentation = 0;
      }
      if (message2.requestCount != null && message2.hasOwnProperty("requestCount"))
        if (typeof message2.requestCount === "number")
          object.requestCount = options.longs === String ? String(message2.requestCount) : message2.requestCount;
        else
          object.requestCount = options.longs === String ? $util.Long.prototype.toString.call(message2.requestCount) : options.longs === Number ? new $util.LongBits(message2.requestCount.low >>> 0, message2.requestCount.high >>> 0).toNumber(true) : message2.requestCount;
      if (message2.cacheHits != null && message2.hasOwnProperty("cacheHits"))
        if (typeof message2.cacheHits === "number")
          object.cacheHits = options.longs === String ? String(message2.cacheHits) : message2.cacheHits;
        else
          object.cacheHits = options.longs === String ? $util.Long.prototype.toString.call(message2.cacheHits) : options.longs === Number ? new $util.LongBits(message2.cacheHits.low >>> 0, message2.cacheHits.high >>> 0).toNumber(true) : message2.cacheHits;
      if (message2.persistedQueryHits != null && message2.hasOwnProperty("persistedQueryHits"))
        if (typeof message2.persistedQueryHits === "number")
          object.persistedQueryHits = options.longs === String ? String(message2.persistedQueryHits) : message2.persistedQueryHits;
        else
          object.persistedQueryHits = options.longs === String ? $util.Long.prototype.toString.call(message2.persistedQueryHits) : options.longs === Number ? new $util.LongBits(message2.persistedQueryHits.low >>> 0, message2.persistedQueryHits.high >>> 0).toNumber(true) : message2.persistedQueryHits;
      if (message2.persistedQueryMisses != null && message2.hasOwnProperty("persistedQueryMisses"))
        if (typeof message2.persistedQueryMisses === "number")
          object.persistedQueryMisses = options.longs === String ? String(message2.persistedQueryMisses) : message2.persistedQueryMisses;
        else
          object.persistedQueryMisses = options.longs === String ? $util.Long.prototype.toString.call(message2.persistedQueryMisses) : options.longs === Number ? new $util.LongBits(message2.persistedQueryMisses.low >>> 0, message2.persistedQueryMisses.high >>> 0).toNumber(true) : message2.persistedQueryMisses;
      if (message2.rootErrorStats != null && message2.hasOwnProperty("rootErrorStats"))
        object.rootErrorStats = $root.PathErrorStats.toObject(message2.rootErrorStats, options);
      if (message2.requestsWithErrorsCount != null && message2.hasOwnProperty("requestsWithErrorsCount"))
        if (typeof message2.requestsWithErrorsCount === "number")
          object.requestsWithErrorsCount = options.longs === String ? String(message2.requestsWithErrorsCount) : message2.requestsWithErrorsCount;
        else
          object.requestsWithErrorsCount = options.longs === String ? $util.Long.prototype.toString.call(message2.requestsWithErrorsCount) : options.longs === Number ? new $util.LongBits(message2.requestsWithErrorsCount.low >>> 0, message2.requestsWithErrorsCount.high >>> 0).toNumber(true) : message2.requestsWithErrorsCount;
      if (message2.registeredOperationCount != null && message2.hasOwnProperty("registeredOperationCount"))
        if (typeof message2.registeredOperationCount === "number")
          object.registeredOperationCount = options.longs === String ? String(message2.registeredOperationCount) : message2.registeredOperationCount;
        else
          object.registeredOperationCount = options.longs === String ? $util.Long.prototype.toString.call(message2.registeredOperationCount) : options.longs === Number ? new $util.LongBits(message2.registeredOperationCount.low >>> 0, message2.registeredOperationCount.high >>> 0).toNumber(true) : message2.registeredOperationCount;
      if (message2.forbiddenOperationCount != null && message2.hasOwnProperty("forbiddenOperationCount"))
        if (typeof message2.forbiddenOperationCount === "number")
          object.forbiddenOperationCount = options.longs === String ? String(message2.forbiddenOperationCount) : message2.forbiddenOperationCount;
        else
          object.forbiddenOperationCount = options.longs === String ? $util.Long.prototype.toString.call(message2.forbiddenOperationCount) : options.longs === Number ? new $util.LongBits(message2.forbiddenOperationCount.low >>> 0, message2.forbiddenOperationCount.high >>> 0).toNumber(true) : message2.forbiddenOperationCount;
      if (message2.latencyCount && message2.latencyCount.length) {
        object.latencyCount = [];
        for (var j = 0;j < message2.latencyCount.length; ++j)
          if (typeof message2.latencyCount[j] === "number")
            object.latencyCount[j] = options.longs === String ? String(message2.latencyCount[j]) : message2.latencyCount[j];
          else
            object.latencyCount[j] = options.longs === String ? $util.Long.prototype.toString.call(message2.latencyCount[j]) : options.longs === Number ? new $util.LongBits(message2.latencyCount[j].low >>> 0, message2.latencyCount[j].high >>> 0).toNumber() : message2.latencyCount[j];
      }
      if (message2.cacheLatencyCount && message2.cacheLatencyCount.length) {
        object.cacheLatencyCount = [];
        for (var j = 0;j < message2.cacheLatencyCount.length; ++j)
          if (typeof message2.cacheLatencyCount[j] === "number")
            object.cacheLatencyCount[j] = options.longs === String ? String(message2.cacheLatencyCount[j]) : message2.cacheLatencyCount[j];
          else
            object.cacheLatencyCount[j] = options.longs === String ? $util.Long.prototype.toString.call(message2.cacheLatencyCount[j]) : options.longs === Number ? new $util.LongBits(message2.cacheLatencyCount[j].low >>> 0, message2.cacheLatencyCount[j].high >>> 0).toNumber() : message2.cacheLatencyCount[j];
      }
      if (message2.publicCacheTtlCount && message2.publicCacheTtlCount.length) {
        object.publicCacheTtlCount = [];
        for (var j = 0;j < message2.publicCacheTtlCount.length; ++j)
          if (typeof message2.publicCacheTtlCount[j] === "number")
            object.publicCacheTtlCount[j] = options.longs === String ? String(message2.publicCacheTtlCount[j]) : message2.publicCacheTtlCount[j];
          else
            object.publicCacheTtlCount[j] = options.longs === String ? $util.Long.prototype.toString.call(message2.publicCacheTtlCount[j]) : options.longs === Number ? new $util.LongBits(message2.publicCacheTtlCount[j].low >>> 0, message2.publicCacheTtlCount[j].high >>> 0).toNumber() : message2.publicCacheTtlCount[j];
      }
      if (message2.privateCacheTtlCount && message2.privateCacheTtlCount.length) {
        object.privateCacheTtlCount = [];
        for (var j = 0;j < message2.privateCacheTtlCount.length; ++j)
          if (typeof message2.privateCacheTtlCount[j] === "number")
            object.privateCacheTtlCount[j] = options.longs === String ? String(message2.privateCacheTtlCount[j]) : message2.privateCacheTtlCount[j];
          else
            object.privateCacheTtlCount[j] = options.longs === String ? $util.Long.prototype.toString.call(message2.privateCacheTtlCount[j]) : options.longs === Number ? new $util.LongBits(message2.privateCacheTtlCount[j].low >>> 0, message2.privateCacheTtlCount[j].high >>> 0).toNumber() : message2.privateCacheTtlCount[j];
      }
      if (message2.requestsWithoutFieldInstrumentation != null && message2.hasOwnProperty("requestsWithoutFieldInstrumentation"))
        if (typeof message2.requestsWithoutFieldInstrumentation === "number")
          object.requestsWithoutFieldInstrumentation = options.longs === String ? String(message2.requestsWithoutFieldInstrumentation) : message2.requestsWithoutFieldInstrumentation;
        else
          object.requestsWithoutFieldInstrumentation = options.longs === String ? $util.Long.prototype.toString.call(message2.requestsWithoutFieldInstrumentation) : options.longs === Number ? new $util.LongBits(message2.requestsWithoutFieldInstrumentation.low >>> 0, message2.requestsWithoutFieldInstrumentation.high >>> 0).toNumber(true) : message2.requestsWithoutFieldInstrumentation;
      return object;
    };
    QueryLatencyStats.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };
    return QueryLatencyStats;
  }();
  $root.StatsContext = function() {
    function StatsContext(properties) {
      if (properties) {
        for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    StatsContext.prototype.clientName = "";
    StatsContext.prototype.clientVersion = "";
    StatsContext.create = function create(properties) {
      return new StatsContext(properties);
    };
    StatsContext.encode = function encode(message2, writer) {
      if (!writer)
        writer = $Writer.create();
      if (message2.clientName != null && Object.hasOwnProperty.call(message2, "clientName"))
        writer.uint32(18).string(message2.clientName);
      if (message2.clientVersion != null && Object.hasOwnProperty.call(message2, "clientVersion"))
        writer.uint32(26).string(message2.clientVersion);
      return writer;
    };
    StatsContext.encodeDelimited = function encodeDelimited(message2, writer) {
      return this.encode(message2, writer).ldelim();
    };
    StatsContext.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader))
        reader = $Reader.create(reader);
      var end = length === undefined ? reader.len : reader.pos + length, message2 = new $root.StatsContext;
      while (reader.pos < end) {
        var tag = reader.uint32();
        switch (tag >>> 3) {
          case 2:
            message2.clientName = reader.string();
            break;
          case 3:
            message2.clientVersion = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message2;
    };
    StatsContext.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader))
        reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };
    StatsContext.verify = function verify(message2) {
      if (typeof message2 !== "object" || message2 === null)
        return "object expected";
      if (message2.clientName != null && message2.hasOwnProperty("clientName")) {
        if (!$util.isString(message2.clientName))
          return "clientName: string expected";
      }
      if (message2.clientVersion != null && message2.hasOwnProperty("clientVersion")) {
        if (!$util.isString(message2.clientVersion))
          return "clientVersion: string expected";
      }
      return null;
    };
    StatsContext.toObject = function toObject(message2, options) {
      if (!options)
        options = {};
      var object = {};
      if (options.defaults) {
        object.clientName = "";
        object.clientVersion = "";
      }
      if (message2.clientName != null && message2.hasOwnProperty("clientName"))
        object.clientName = message2.clientName;
      if (message2.clientVersion != null && message2.hasOwnProperty("clientVersion"))
        object.clientVersion = message2.clientVersion;
      return object;
    };
    StatsContext.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };
    return StatsContext;
  }();
  $root.ContextualizedQueryLatencyStats = function() {
    function ContextualizedQueryLatencyStats(properties) {
      if (properties) {
        for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    ContextualizedQueryLatencyStats.prototype.queryLatencyStats = null;
    ContextualizedQueryLatencyStats.prototype.context = null;
    ContextualizedQueryLatencyStats.create = function create(properties) {
      return new ContextualizedQueryLatencyStats(properties);
    };
    ContextualizedQueryLatencyStats.encode = function encode(message2, writer) {
      if (!writer)
        writer = $Writer.create();
      if (message2.queryLatencyStats != null && Object.hasOwnProperty.call(message2, "queryLatencyStats"))
        $root.QueryLatencyStats.encode(message2.queryLatencyStats, writer.uint32(10).fork()).ldelim();
      if (message2.context != null && Object.hasOwnProperty.call(message2, "context"))
        $root.StatsContext.encode(message2.context, writer.uint32(18).fork()).ldelim();
      return writer;
    };
    ContextualizedQueryLatencyStats.encodeDelimited = function encodeDelimited(message2, writer) {
      return this.encode(message2, writer).ldelim();
    };
    ContextualizedQueryLatencyStats.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader))
        reader = $Reader.create(reader);
      var end = length === undefined ? reader.len : reader.pos + length, message2 = new $root.ContextualizedQueryLatencyStats;
      while (reader.pos < end) {
        var tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message2.queryLatencyStats = $root.QueryLatencyStats.decode(reader, reader.uint32());
            break;
          case 2:
            message2.context = $root.StatsContext.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message2;
    };
    ContextualizedQueryLatencyStats.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader))
        reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };
    ContextualizedQueryLatencyStats.verify = function verify(message2) {
      if (typeof message2 !== "object" || message2 === null)
        return "object expected";
      if (message2.queryLatencyStats != null && message2.hasOwnProperty("queryLatencyStats")) {
        var error = $root.QueryLatencyStats.verify(message2.queryLatencyStats);
        if (error)
          return "queryLatencyStats." + error;
      }
      if (message2.context != null && message2.hasOwnProperty("context")) {
        var error = $root.StatsContext.verify(message2.context);
        if (error)
          return "context." + error;
      }
      return null;
    };
    ContextualizedQueryLatencyStats.toObject = function toObject(message2, options) {
      if (!options)
        options = {};
      var object = {};
      if (options.defaults) {
        object.queryLatencyStats = null;
        object.context = null;
      }
      if (message2.queryLatencyStats != null && message2.hasOwnProperty("queryLatencyStats"))
        object.queryLatencyStats = $root.QueryLatencyStats.toObject(message2.queryLatencyStats, options);
      if (message2.context != null && message2.hasOwnProperty("context"))
        object.context = $root.StatsContext.toObject(message2.context, options);
      return object;
    };
    ContextualizedQueryLatencyStats.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };
    return ContextualizedQueryLatencyStats;
  }();
  $root.ContextualizedTypeStats = function() {
    function ContextualizedTypeStats(properties) {
      this.perTypeStat = {};
      if (properties) {
        for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    ContextualizedTypeStats.prototype.context = null;
    ContextualizedTypeStats.prototype.perTypeStat = $util.emptyObject;
    ContextualizedTypeStats.create = function create(properties) {
      return new ContextualizedTypeStats(properties);
    };
    ContextualizedTypeStats.encode = function encode(message2, writer) {
      if (!writer)
        writer = $Writer.create();
      if (message2.context != null && Object.hasOwnProperty.call(message2, "context"))
        $root.StatsContext.encode(message2.context, writer.uint32(10).fork()).ldelim();
      if (message2.perTypeStat != null && Object.hasOwnProperty.call(message2, "perTypeStat"))
        for (var keys = Object.keys(message2.perTypeStat), i = 0;i < keys.length; ++i) {
          writer.uint32(18).fork().uint32(10).string(keys[i]);
          $root.TypeStat.encode(message2.perTypeStat[keys[i]], writer.uint32(18).fork()).ldelim().ldelim();
        }
      return writer;
    };
    ContextualizedTypeStats.encodeDelimited = function encodeDelimited(message2, writer) {
      return this.encode(message2, writer).ldelim();
    };
    ContextualizedTypeStats.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader))
        reader = $Reader.create(reader);
      var end = length === undefined ? reader.len : reader.pos + length, message2 = new $root.ContextualizedTypeStats, key;
      while (reader.pos < end) {
        var tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message2.context = $root.StatsContext.decode(reader, reader.uint32());
            break;
          case 2:
            reader.skip().pos++;
            if (message2.perTypeStat === $util.emptyObject)
              message2.perTypeStat = {};
            key = reader.string();
            reader.pos++;
            message2.perTypeStat[key] = $root.TypeStat.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message2;
    };
    ContextualizedTypeStats.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader))
        reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };
    ContextualizedTypeStats.verify = function verify(message2) {
      if (typeof message2 !== "object" || message2 === null)
        return "object expected";
      if (message2.context != null && message2.hasOwnProperty("context")) {
        var error = $root.StatsContext.verify(message2.context);
        if (error)
          return "context." + error;
      }
      if (message2.perTypeStat != null && message2.hasOwnProperty("perTypeStat")) {
        if (!$util.isObject(message2.perTypeStat))
          return "perTypeStat: object expected";
        var key = Object.keys(message2.perTypeStat);
        for (var i = 0;i < key.length; ++i) {
          var error = $root.TypeStat.verify(message2.perTypeStat[key[i]]);
          if (error)
            return "perTypeStat." + error;
        }
      }
      return null;
    };
    ContextualizedTypeStats.toObject = function toObject(message2, options) {
      if (!options)
        options = {};
      var object = {};
      if (options.objects || options.defaults)
        object.perTypeStat = {};
      if (options.defaults)
        object.context = null;
      if (message2.context != null && message2.hasOwnProperty("context"))
        object.context = $root.StatsContext.toObject(message2.context, options);
      var keys2;
      if (message2.perTypeStat && (keys2 = Object.keys(message2.perTypeStat)).length) {
        object.perTypeStat = {};
        for (var j = 0;j < keys2.length; ++j)
          object.perTypeStat[keys2[j]] = $root.TypeStat.toObject(message2.perTypeStat[keys2[j]], options);
      }
      return object;
    };
    ContextualizedTypeStats.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };
    return ContextualizedTypeStats;
  }();
  $root.FieldStat = function() {
    function FieldStat(properties) {
      this.latencyCount = [];
      if (properties) {
        for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    FieldStat.prototype.returnType = "";
    FieldStat.prototype.errorsCount = 0;
    FieldStat.prototype.observedExecutionCount = 0;
    FieldStat.prototype.estimatedExecutionCount = 0;
    FieldStat.prototype.requestsWithErrorsCount = 0;
    FieldStat.prototype.latencyCount = $util.emptyArray;
    FieldStat.create = function create(properties) {
      return new FieldStat(properties);
    };
    FieldStat.encode = function encode(message2, writer) {
      if (!writer)
        writer = $Writer.create();
      if (message2.returnType != null && Object.hasOwnProperty.call(message2, "returnType"))
        writer.uint32(26).string(message2.returnType);
      if (message2.errorsCount != null && Object.hasOwnProperty.call(message2, "errorsCount"))
        writer.uint32(32).uint64(message2.errorsCount);
      if (message2.observedExecutionCount != null && Object.hasOwnProperty.call(message2, "observedExecutionCount"))
        writer.uint32(40).uint64(message2.observedExecutionCount);
      if (message2.requestsWithErrorsCount != null && Object.hasOwnProperty.call(message2, "requestsWithErrorsCount"))
        writer.uint32(48).uint64(message2.requestsWithErrorsCount);
      var array9;
      if (message2.latencyCount != null && message2.latencyCount.toArray)
        array9 = message2.latencyCount.toArray();
      else
        array9 = message2.latencyCount;
      if (array9 != null && array9.length) {
        writer.uint32(74).fork();
        for (var i = 0;i < array9.length; ++i)
          writer.sint64(array9[i]);
        writer.ldelim();
      }
      if (message2.estimatedExecutionCount != null && Object.hasOwnProperty.call(message2, "estimatedExecutionCount"))
        writer.uint32(80).uint64(message2.estimatedExecutionCount);
      return writer;
    };
    FieldStat.encodeDelimited = function encodeDelimited(message2, writer) {
      return this.encode(message2, writer).ldelim();
    };
    FieldStat.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader))
        reader = $Reader.create(reader);
      var end = length === undefined ? reader.len : reader.pos + length, message2 = new $root.FieldStat;
      while (reader.pos < end) {
        var tag = reader.uint32();
        switch (tag >>> 3) {
          case 3:
            message2.returnType = reader.string();
            break;
          case 4:
            message2.errorsCount = reader.uint64();
            break;
          case 5:
            message2.observedExecutionCount = reader.uint64();
            break;
          case 10:
            message2.estimatedExecutionCount = reader.uint64();
            break;
          case 6:
            message2.requestsWithErrorsCount = reader.uint64();
            break;
          case 9:
            if (!(message2.latencyCount && message2.latencyCount.length))
              message2.latencyCount = [];
            if ((tag & 7) === 2) {
              var end2 = reader.uint32() + reader.pos;
              while (reader.pos < end2)
                message2.latencyCount.push(reader.sint64());
            } else
              message2.latencyCount.push(reader.sint64());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message2;
    };
    FieldStat.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader))
        reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };
    FieldStat.verify = function verify(message2) {
      if (typeof message2 !== "object" || message2 === null)
        return "object expected";
      if (message2.returnType != null && message2.hasOwnProperty("returnType")) {
        if (!$util.isString(message2.returnType))
          return "returnType: string expected";
      }
      if (message2.errorsCount != null && message2.hasOwnProperty("errorsCount")) {
        if (!$util.isInteger(message2.errorsCount) && !(message2.errorsCount && $util.isInteger(message2.errorsCount.low) && $util.isInteger(message2.errorsCount.high)))
          return "errorsCount: integer|Long expected";
      }
      if (message2.observedExecutionCount != null && message2.hasOwnProperty("observedExecutionCount")) {
        if (!$util.isInteger(message2.observedExecutionCount) && !(message2.observedExecutionCount && $util.isInteger(message2.observedExecutionCount.low) && $util.isInteger(message2.observedExecutionCount.high)))
          return "observedExecutionCount: integer|Long expected";
      }
      if (message2.estimatedExecutionCount != null && message2.hasOwnProperty("estimatedExecutionCount")) {
        if (!$util.isInteger(message2.estimatedExecutionCount) && !(message2.estimatedExecutionCount && $util.isInteger(message2.estimatedExecutionCount.low) && $util.isInteger(message2.estimatedExecutionCount.high)))
          return "estimatedExecutionCount: integer|Long expected";
      }
      if (message2.requestsWithErrorsCount != null && message2.hasOwnProperty("requestsWithErrorsCount")) {
        if (!$util.isInteger(message2.requestsWithErrorsCount) && !(message2.requestsWithErrorsCount && $util.isInteger(message2.requestsWithErrorsCount.low) && $util.isInteger(message2.requestsWithErrorsCount.high)))
          return "requestsWithErrorsCount: integer|Long expected";
      }
      if (message2.latencyCount != null && message2.hasOwnProperty("latencyCount")) {
        var array9;
        if (message2.latencyCount != null && message2.latencyCount.toArray)
          array9 = message2.latencyCount.toArray();
        else
          array9 = message2.latencyCount;
        if (!Array.isArray(array9))
          return "latencyCount: array expected";
        for (var i = 0;i < array9.length; ++i)
          if (!$util.isInteger(array9[i]) && !(array9[i] && $util.isInteger(array9[i].low) && $util.isInteger(array9[i].high)))
            return "latencyCount: integer|Long[] expected";
      }
      return null;
    };
    FieldStat.toObject = function toObject(message2, options) {
      if (!options)
        options = {};
      var object = {};
      if (options.arrays || options.defaults)
        object.latencyCount = [];
      if (options.defaults) {
        object.returnType = "";
        object.errorsCount = 0;
        object.observedExecutionCount = 0;
        object.requestsWithErrorsCount = 0;
        object.estimatedExecutionCount = 0;
      }
      if (message2.returnType != null && message2.hasOwnProperty("returnType"))
        object.returnType = message2.returnType;
      if (message2.errorsCount != null && message2.hasOwnProperty("errorsCount"))
        if (typeof message2.errorsCount === "number")
          object.errorsCount = options.longs === String ? String(message2.errorsCount) : message2.errorsCount;
        else
          object.errorsCount = options.longs === String ? $util.Long.prototype.toString.call(message2.errorsCount) : options.longs === Number ? new $util.LongBits(message2.errorsCount.low >>> 0, message2.errorsCount.high >>> 0).toNumber(true) : message2.errorsCount;
      if (message2.observedExecutionCount != null && message2.hasOwnProperty("observedExecutionCount"))
        if (typeof message2.observedExecutionCount === "number")
          object.observedExecutionCount = options.longs === String ? String(message2.observedExecutionCount) : message2.observedExecutionCount;
        else
          object.observedExecutionCount = options.longs === String ? $util.Long.prototype.toString.call(message2.observedExecutionCount) : options.longs === Number ? new $util.LongBits(message2.observedExecutionCount.low >>> 0, message2.observedExecutionCount.high >>> 0).toNumber(true) : message2.observedExecutionCount;
      if (message2.requestsWithErrorsCount != null && message2.hasOwnProperty("requestsWithErrorsCount"))
        if (typeof message2.requestsWithErrorsCount === "number")
          object.requestsWithErrorsCount = options.longs === String ? String(message2.requestsWithErrorsCount) : message2.requestsWithErrorsCount;
        else
          object.requestsWithErrorsCount = options.longs === String ? $util.Long.prototype.toString.call(message2.requestsWithErrorsCount) : options.longs === Number ? new $util.LongBits(message2.requestsWithErrorsCount.low >>> 0, message2.requestsWithErrorsCount.high >>> 0).toNumber(true) : message2.requestsWithErrorsCount;
      if (message2.latencyCount && message2.latencyCount.length) {
        object.latencyCount = [];
        for (var j = 0;j < message2.latencyCount.length; ++j)
          if (typeof message2.latencyCount[j] === "number")
            object.latencyCount[j] = options.longs === String ? String(message2.latencyCount[j]) : message2.latencyCount[j];
          else
            object.latencyCount[j] = options.longs === String ? $util.Long.prototype.toString.call(message2.latencyCount[j]) : options.longs === Number ? new $util.LongBits(message2.latencyCount[j].low >>> 0, message2.latencyCount[j].high >>> 0).toNumber() : message2.latencyCount[j];
      }
      if (message2.estimatedExecutionCount != null && message2.hasOwnProperty("estimatedExecutionCount"))
        if (typeof message2.estimatedExecutionCount === "number")
          object.estimatedExecutionCount = options.longs === String ? String(message2.estimatedExecutionCount) : message2.estimatedExecutionCount;
        else
          object.estimatedExecutionCount = options.longs === String ? $util.Long.prototype.toString.call(message2.estimatedExecutionCount) : options.longs === Number ? new $util.LongBits(message2.estimatedExecutionCount.low >>> 0, message2.estimatedExecutionCount.high >>> 0).toNumber(true) : message2.estimatedExecutionCount;
      return object;
    };
    FieldStat.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };
    return FieldStat;
  }();
  $root.TypeStat = function() {
    function TypeStat(properties) {
      this.perFieldStat = {};
      if (properties) {
        for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    TypeStat.prototype.perFieldStat = $util.emptyObject;
    TypeStat.create = function create(properties) {
      return new TypeStat(properties);
    };
    TypeStat.encode = function encode(message2, writer) {
      if (!writer)
        writer = $Writer.create();
      if (message2.perFieldStat != null && Object.hasOwnProperty.call(message2, "perFieldStat"))
        for (var keys = Object.keys(message2.perFieldStat), i = 0;i < keys.length; ++i) {
          writer.uint32(26).fork().uint32(10).string(keys[i]);
          $root.FieldStat.encode(message2.perFieldStat[keys[i]], writer.uint32(18).fork()).ldelim().ldelim();
        }
      return writer;
    };
    TypeStat.encodeDelimited = function encodeDelimited(message2, writer) {
      return this.encode(message2, writer).ldelim();
    };
    TypeStat.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader))
        reader = $Reader.create(reader);
      var end = length === undefined ? reader.len : reader.pos + length, message2 = new $root.TypeStat, key;
      while (reader.pos < end) {
        var tag = reader.uint32();
        switch (tag >>> 3) {
          case 3:
            reader.skip().pos++;
            if (message2.perFieldStat === $util.emptyObject)
              message2.perFieldStat = {};
            key = reader.string();
            reader.pos++;
            message2.perFieldStat[key] = $root.FieldStat.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message2;
    };
    TypeStat.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader))
        reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };
    TypeStat.verify = function verify(message2) {
      if (typeof message2 !== "object" || message2 === null)
        return "object expected";
      if (message2.perFieldStat != null && message2.hasOwnProperty("perFieldStat")) {
        if (!$util.isObject(message2.perFieldStat))
          return "perFieldStat: object expected";
        var key = Object.keys(message2.perFieldStat);
        for (var i = 0;i < key.length; ++i) {
          var error = $root.FieldStat.verify(message2.perFieldStat[key[i]]);
          if (error)
            return "perFieldStat." + error;
        }
      }
      return null;
    };
    TypeStat.toObject = function toObject(message2, options) {
      if (!options)
        options = {};
      var object = {};
      if (options.objects || options.defaults)
        object.perFieldStat = {};
      var keys2;
      if (message2.perFieldStat && (keys2 = Object.keys(message2.perFieldStat)).length) {
        object.perFieldStat = {};
        for (var j = 0;j < keys2.length; ++j)
          object.perFieldStat[keys2[j]] = $root.FieldStat.toObject(message2.perFieldStat[keys2[j]], options);
      }
      return object;
    };
    TypeStat.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };
    return TypeStat;
  }();
  $root.ReferencedFieldsForType = function() {
    function ReferencedFieldsForType(properties) {
      this.fieldNames = [];
      if (properties) {
        for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    ReferencedFieldsForType.prototype.fieldNames = $util.emptyArray;
    ReferencedFieldsForType.prototype.isInterface = false;
    ReferencedFieldsForType.create = function create(properties) {
      return new ReferencedFieldsForType(properties);
    };
    ReferencedFieldsForType.encode = function encode(message2, writer) {
      if (!writer)
        writer = $Writer.create();
      if (message2.fieldNames != null && message2.fieldNames.length)
        for (var i = 0;i < message2.fieldNames.length; ++i)
          writer.uint32(10).string(message2.fieldNames[i]);
      if (message2.isInterface != null && Object.hasOwnProperty.call(message2, "isInterface"))
        writer.uint32(16).bool(message2.isInterface);
      return writer;
    };
    ReferencedFieldsForType.encodeDelimited = function encodeDelimited(message2, writer) {
      return this.encode(message2, writer).ldelim();
    };
    ReferencedFieldsForType.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader))
        reader = $Reader.create(reader);
      var end = length === undefined ? reader.len : reader.pos + length, message2 = new $root.ReferencedFieldsForType;
      while (reader.pos < end) {
        var tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (!(message2.fieldNames && message2.fieldNames.length))
              message2.fieldNames = [];
            message2.fieldNames.push(reader.string());
            break;
          case 2:
            message2.isInterface = reader.bool();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message2;
    };
    ReferencedFieldsForType.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader))
        reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };
    ReferencedFieldsForType.verify = function verify(message2) {
      if (typeof message2 !== "object" || message2 === null)
        return "object expected";
      if (message2.fieldNames != null && message2.hasOwnProperty("fieldNames")) {
        if (!Array.isArray(message2.fieldNames))
          return "fieldNames: array expected";
        for (var i = 0;i < message2.fieldNames.length; ++i)
          if (!$util.isString(message2.fieldNames[i]))
            return "fieldNames: string[] expected";
      }
      if (message2.isInterface != null && message2.hasOwnProperty("isInterface")) {
        if (typeof message2.isInterface !== "boolean")
          return "isInterface: boolean expected";
      }
      return null;
    };
    ReferencedFieldsForType.toObject = function toObject(message2, options) {
      if (!options)
        options = {};
      var object = {};
      if (options.arrays || options.defaults)
        object.fieldNames = [];
      if (options.defaults)
        object.isInterface = false;
      if (message2.fieldNames && message2.fieldNames.length) {
        object.fieldNames = [];
        for (var j = 0;j < message2.fieldNames.length; ++j)
          object.fieldNames[j] = message2.fieldNames[j];
      }
      if (message2.isInterface != null && message2.hasOwnProperty("isInterface"))
        object.isInterface = message2.isInterface;
      return object;
    };
    ReferencedFieldsForType.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };
    return ReferencedFieldsForType;
  }();
  $root.Report = function() {
    function Report(properties) {
      this.tracesPerQuery = {};
      if (properties) {
        for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    Report.prototype.header = null;
    Report.prototype.tracesPerQuery = $util.emptyObject;
    Report.prototype.endTime = null;
    Report.prototype.operationCount = 0;
    Report.prototype.tracesPreAggregated = false;
    Report.create = function create(properties) {
      return new Report(properties);
    };
    Report.encode = function encode(message2, writer) {
      if (!writer)
        writer = $Writer.create();
      if (message2.header != null && Object.hasOwnProperty.call(message2, "header"))
        $root.ReportHeader.encode(message2.header, writer.uint32(10).fork()).ldelim();
      if (message2.endTime != null && Object.hasOwnProperty.call(message2, "endTime"))
        $root.google.protobuf.Timestamp.encode(message2.endTime, writer.uint32(18).fork()).ldelim();
      if (message2.tracesPerQuery != null && Object.hasOwnProperty.call(message2, "tracesPerQuery"))
        for (var keys = Object.keys(message2.tracesPerQuery), i = 0;i < keys.length; ++i) {
          writer.uint32(42).fork().uint32(10).string(keys[i]);
          $root.TracesAndStats.encode(message2.tracesPerQuery[keys[i]], writer.uint32(18).fork()).ldelim().ldelim();
        }
      if (message2.operationCount != null && Object.hasOwnProperty.call(message2, "operationCount"))
        writer.uint32(48).uint64(message2.operationCount);
      if (message2.tracesPreAggregated != null && Object.hasOwnProperty.call(message2, "tracesPreAggregated"))
        writer.uint32(56).bool(message2.tracesPreAggregated);
      return writer;
    };
    Report.encodeDelimited = function encodeDelimited(message2, writer) {
      return this.encode(message2, writer).ldelim();
    };
    Report.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader))
        reader = $Reader.create(reader);
      var end = length === undefined ? reader.len : reader.pos + length, message2 = new $root.Report, key;
      while (reader.pos < end) {
        var tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message2.header = $root.ReportHeader.decode(reader, reader.uint32());
            break;
          case 5:
            reader.skip().pos++;
            if (message2.tracesPerQuery === $util.emptyObject)
              message2.tracesPerQuery = {};
            key = reader.string();
            reader.pos++;
            message2.tracesPerQuery[key] = $root.TracesAndStats.decode(reader, reader.uint32());
            break;
          case 2:
            message2.endTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
            break;
          case 6:
            message2.operationCount = reader.uint64();
            break;
          case 7:
            message2.tracesPreAggregated = reader.bool();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message2;
    };
    Report.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader))
        reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };
    Report.verify = function verify(message2) {
      if (typeof message2 !== "object" || message2 === null)
        return "object expected";
      if (message2.header != null && message2.hasOwnProperty("header")) {
        var error = $root.ReportHeader.verify(message2.header);
        if (error)
          return "header." + error;
      }
      if (message2.tracesPerQuery != null && message2.hasOwnProperty("tracesPerQuery")) {
        if (!$util.isObject(message2.tracesPerQuery))
          return "tracesPerQuery: object expected";
        var key = Object.keys(message2.tracesPerQuery);
        for (var i = 0;i < key.length; ++i) {
          var error = $root.TracesAndStats.verify(message2.tracesPerQuery[key[i]]);
          if (error)
            return "tracesPerQuery." + error;
        }
      }
      if (message2.endTime != null && message2.hasOwnProperty("endTime")) {
        var error = $root.google.protobuf.Timestamp.verify(message2.endTime);
        if (error)
          return "endTime." + error;
      }
      if (message2.operationCount != null && message2.hasOwnProperty("operationCount")) {
        if (!$util.isInteger(message2.operationCount) && !(message2.operationCount && $util.isInteger(message2.operationCount.low) && $util.isInteger(message2.operationCount.high)))
          return "operationCount: integer|Long expected";
      }
      if (message2.tracesPreAggregated != null && message2.hasOwnProperty("tracesPreAggregated")) {
        if (typeof message2.tracesPreAggregated !== "boolean")
          return "tracesPreAggregated: boolean expected";
      }
      return null;
    };
    Report.toObject = function toObject(message2, options) {
      if (!options)
        options = {};
      var object = {};
      if (options.objects || options.defaults)
        object.tracesPerQuery = {};
      if (options.defaults) {
        object.header = null;
        object.endTime = null;
        object.operationCount = 0;
        object.tracesPreAggregated = false;
      }
      if (message2.header != null && message2.hasOwnProperty("header"))
        object.header = $root.ReportHeader.toObject(message2.header, options);
      if (message2.endTime != null && message2.hasOwnProperty("endTime"))
        object.endTime = $root.google.protobuf.Timestamp.toObject(message2.endTime, options);
      var keys2;
      if (message2.tracesPerQuery && (keys2 = Object.keys(message2.tracesPerQuery)).length) {
        object.tracesPerQuery = {};
        for (var j = 0;j < keys2.length; ++j)
          object.tracesPerQuery[keys2[j]] = $root.TracesAndStats.toObject(message2.tracesPerQuery[keys2[j]], options);
      }
      if (message2.operationCount != null && message2.hasOwnProperty("operationCount"))
        if (typeof message2.operationCount === "number")
          object.operationCount = options.longs === String ? String(message2.operationCount) : message2.operationCount;
        else
          object.operationCount = options.longs === String ? $util.Long.prototype.toString.call(message2.operationCount) : options.longs === Number ? new $util.LongBits(message2.operationCount.low >>> 0, message2.operationCount.high >>> 0).toNumber(true) : message2.operationCount;
      if (message2.tracesPreAggregated != null && message2.hasOwnProperty("tracesPreAggregated"))
        object.tracesPreAggregated = message2.tracesPreAggregated;
      return object;
    };
    Report.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };
    return Report;
  }();
  $root.ContextualizedStats = function() {
    function ContextualizedStats(properties) {
      this.perTypeStat = {};
      if (properties) {
        for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    ContextualizedStats.prototype.context = null;
    ContextualizedStats.prototype.queryLatencyStats = null;
    ContextualizedStats.prototype.perTypeStat = $util.emptyObject;
    ContextualizedStats.create = function create(properties) {
      return new ContextualizedStats(properties);
    };
    ContextualizedStats.encode = function encode(message2, writer) {
      if (!writer)
        writer = $Writer.create();
      if (message2.context != null && Object.hasOwnProperty.call(message2, "context"))
        $root.StatsContext.encode(message2.context, writer.uint32(10).fork()).ldelim();
      if (message2.queryLatencyStats != null && Object.hasOwnProperty.call(message2, "queryLatencyStats"))
        $root.QueryLatencyStats.encode(message2.queryLatencyStats, writer.uint32(18).fork()).ldelim();
      if (message2.perTypeStat != null && Object.hasOwnProperty.call(message2, "perTypeStat"))
        for (var keys = Object.keys(message2.perTypeStat), i = 0;i < keys.length; ++i) {
          writer.uint32(26).fork().uint32(10).string(keys[i]);
          $root.TypeStat.encode(message2.perTypeStat[keys[i]], writer.uint32(18).fork()).ldelim().ldelim();
        }
      return writer;
    };
    ContextualizedStats.encodeDelimited = function encodeDelimited(message2, writer) {
      return this.encode(message2, writer).ldelim();
    };
    ContextualizedStats.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader))
        reader = $Reader.create(reader);
      var end = length === undefined ? reader.len : reader.pos + length, message2 = new $root.ContextualizedStats, key;
      while (reader.pos < end) {
        var tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message2.context = $root.StatsContext.decode(reader, reader.uint32());
            break;
          case 2:
            message2.queryLatencyStats = $root.QueryLatencyStats.decode(reader, reader.uint32());
            break;
          case 3:
            reader.skip().pos++;
            if (message2.perTypeStat === $util.emptyObject)
              message2.perTypeStat = {};
            key = reader.string();
            reader.pos++;
            message2.perTypeStat[key] = $root.TypeStat.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message2;
    };
    ContextualizedStats.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader))
        reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };
    ContextualizedStats.verify = function verify(message2) {
      if (typeof message2 !== "object" || message2 === null)
        return "object expected";
      if (message2.context != null && message2.hasOwnProperty("context")) {
        var error = $root.StatsContext.verify(message2.context);
        if (error)
          return "context." + error;
      }
      if (message2.queryLatencyStats != null && message2.hasOwnProperty("queryLatencyStats")) {
        var error = $root.QueryLatencyStats.verify(message2.queryLatencyStats);
        if (error)
          return "queryLatencyStats." + error;
      }
      if (message2.perTypeStat != null && message2.hasOwnProperty("perTypeStat")) {
        if (!$util.isObject(message2.perTypeStat))
          return "perTypeStat: object expected";
        var key = Object.keys(message2.perTypeStat);
        for (var i = 0;i < key.length; ++i) {
          var error = $root.TypeStat.verify(message2.perTypeStat[key[i]]);
          if (error)
            return "perTypeStat." + error;
        }
      }
      return null;
    };
    ContextualizedStats.toObject = function toObject(message2, options) {
      if (!options)
        options = {};
      var object = {};
      if (options.objects || options.defaults)
        object.perTypeStat = {};
      if (options.defaults) {
        object.context = null;
        object.queryLatencyStats = null;
      }
      if (message2.context != null && message2.hasOwnProperty("context"))
        object.context = $root.StatsContext.toObject(message2.context, options);
      if (message2.queryLatencyStats != null && message2.hasOwnProperty("queryLatencyStats"))
        object.queryLatencyStats = $root.QueryLatencyStats.toObject(message2.queryLatencyStats, options);
      var keys2;
      if (message2.perTypeStat && (keys2 = Object.keys(message2.perTypeStat)).length) {
        object.perTypeStat = {};
        for (var j = 0;j < keys2.length; ++j)
          object.perTypeStat[keys2[j]] = $root.TypeStat.toObject(message2.perTypeStat[keys2[j]], options);
      }
      return object;
    };
    ContextualizedStats.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };
    return ContextualizedStats;
  }();
  $root.TracesAndStats = function() {
    function TracesAndStats(properties) {
      this.trace = [];
      this.statsWithContext = [];
      this.referencedFieldsByType = {};
      this.internalTracesContributingToStats = [];
      if (properties) {
        for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    TracesAndStats.prototype.trace = $util.emptyArray;
    TracesAndStats.prototype.statsWithContext = $util.emptyArray;
    TracesAndStats.prototype.referencedFieldsByType = $util.emptyObject;
    TracesAndStats.prototype.internalTracesContributingToStats = $util.emptyArray;
    TracesAndStats.create = function create(properties) {
      return new TracesAndStats(properties);
    };
    TracesAndStats.encode = function encode(message2, writer) {
      if (!writer)
        writer = $Writer.create();
      if (message2.trace != null && message2.trace.length)
        for (var i = 0;i < message2.trace.length; ++i)
          if (message2.trace[i] instanceof Uint8Array) {
            writer.uint32(10);
            writer.bytes(message2.trace[i]);
          } else
            $root.Trace.encode(message2.trace[i], writer.uint32(10).fork()).ldelim();
      var array2;
      if (message2.statsWithContext != null && message2.statsWithContext.toArray)
        array2 = message2.statsWithContext.toArray();
      else
        array2 = message2.statsWithContext;
      if (array2 != null && array2.length)
        for (var i = 0;i < array2.length; ++i)
          $root.ContextualizedStats.encode(array2[i], writer.uint32(18).fork()).ldelim();
      if (message2.internalTracesContributingToStats != null && message2.internalTracesContributingToStats.length)
        for (var i = 0;i < message2.internalTracesContributingToStats.length; ++i)
          if (message2.internalTracesContributingToStats[i] instanceof Uint8Array) {
            writer.uint32(26);
            writer.bytes(message2.internalTracesContributingToStats[i]);
          } else
            $root.Trace.encode(message2.internalTracesContributingToStats[i], writer.uint32(26).fork()).ldelim();
      if (message2.referencedFieldsByType != null && Object.hasOwnProperty.call(message2, "referencedFieldsByType"))
        for (var keys = Object.keys(message2.referencedFieldsByType), i = 0;i < keys.length; ++i) {
          writer.uint32(34).fork().uint32(10).string(keys[i]);
          $root.ReferencedFieldsForType.encode(message2.referencedFieldsByType[keys[i]], writer.uint32(18).fork()).ldelim().ldelim();
        }
      return writer;
    };
    TracesAndStats.encodeDelimited = function encodeDelimited(message2, writer) {
      return this.encode(message2, writer).ldelim();
    };
    TracesAndStats.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader))
        reader = $Reader.create(reader);
      var end = length === undefined ? reader.len : reader.pos + length, message2 = new $root.TracesAndStats, key;
      while (reader.pos < end) {
        var tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (!(message2.trace && message2.trace.length))
              message2.trace = [];
            message2.trace.push($root.Trace.decode(reader, reader.uint32()));
            break;
          case 2:
            if (!(message2.statsWithContext && message2.statsWithContext.length))
              message2.statsWithContext = [];
            message2.statsWithContext.push($root.ContextualizedStats.decode(reader, reader.uint32()));
            break;
          case 4:
            reader.skip().pos++;
            if (message2.referencedFieldsByType === $util.emptyObject)
              message2.referencedFieldsByType = {};
            key = reader.string();
            reader.pos++;
            message2.referencedFieldsByType[key] = $root.ReferencedFieldsForType.decode(reader, reader.uint32());
            break;
          case 3:
            if (!(message2.internalTracesContributingToStats && message2.internalTracesContributingToStats.length))
              message2.internalTracesContributingToStats = [];
            message2.internalTracesContributingToStats.push($root.Trace.decode(reader, reader.uint32()));
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message2;
    };
    TracesAndStats.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader))
        reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };
    TracesAndStats.verify = function verify(message2) {
      if (typeof message2 !== "object" || message2 === null)
        return "object expected";
      if (message2.trace != null && message2.hasOwnProperty("trace")) {
        if (!Array.isArray(message2.trace))
          return "trace: array expected";
        for (var i = 0;i < message2.trace.length; ++i)
          if (!(message2.trace[i] instanceof Uint8Array)) {
            var error = $root.Trace.verify(message2.trace[i]);
            if (error)
              return "trace." + error;
          }
      }
      if (message2.statsWithContext != null && message2.hasOwnProperty("statsWithContext")) {
        var array2;
        if (message2.statsWithContext != null && message2.statsWithContext.toArray)
          array2 = message2.statsWithContext.toArray();
        else
          array2 = message2.statsWithContext;
        if (!Array.isArray(array2))
          return "statsWithContext: array expected";
        for (var i = 0;i < array2.length; ++i) {
          var error = $root.ContextualizedStats.verify(array2[i]);
          if (error)
            return "statsWithContext." + error;
        }
      }
      if (message2.referencedFieldsByType != null && message2.hasOwnProperty("referencedFieldsByType")) {
        if (!$util.isObject(message2.referencedFieldsByType))
          return "referencedFieldsByType: object expected";
        var key = Object.keys(message2.referencedFieldsByType);
        for (var i = 0;i < key.length; ++i) {
          var error = $root.ReferencedFieldsForType.verify(message2.referencedFieldsByType[key[i]]);
          if (error)
            return "referencedFieldsByType." + error;
        }
      }
      if (message2.internalTracesContributingToStats != null && message2.hasOwnProperty("internalTracesContributingToStats")) {
        if (!Array.isArray(message2.internalTracesContributingToStats))
          return "internalTracesContributingToStats: array expected";
        for (var i = 0;i < message2.internalTracesContributingToStats.length; ++i)
          if (!(message2.internalTracesContributingToStats[i] instanceof Uint8Array)) {
            var error = $root.Trace.verify(message2.internalTracesContributingToStats[i]);
            if (error)
              return "internalTracesContributingToStats." + error;
          }
      }
      return null;
    };
    TracesAndStats.toObject = function toObject(message2, options) {
      if (!options)
        options = {};
      var object = {};
      if (options.arrays || options.defaults) {
        object.trace = [];
        object.statsWithContext = [];
        object.internalTracesContributingToStats = [];
      }
      if (options.objects || options.defaults)
        object.referencedFieldsByType = {};
      if (message2.trace && message2.trace.length) {
        object.trace = [];
        for (var j = 0;j < message2.trace.length; ++j)
          object.trace[j] = $root.Trace.toObject(message2.trace[j], options);
      }
      if (message2.statsWithContext && message2.statsWithContext.length) {
        object.statsWithContext = [];
        for (var j = 0;j < message2.statsWithContext.length; ++j)
          object.statsWithContext[j] = $root.ContextualizedStats.toObject(message2.statsWithContext[j], options);
      }
      if (message2.internalTracesContributingToStats && message2.internalTracesContributingToStats.length) {
        object.internalTracesContributingToStats = [];
        for (var j = 0;j < message2.internalTracesContributingToStats.length; ++j)
          object.internalTracesContributingToStats[j] = $root.Trace.toObject(message2.internalTracesContributingToStats[j], options);
      }
      var keys2;
      if (message2.referencedFieldsByType && (keys2 = Object.keys(message2.referencedFieldsByType)).length) {
        object.referencedFieldsByType = {};
        for (var j = 0;j < keys2.length; ++j)
          object.referencedFieldsByType[keys2[j]] = $root.ReferencedFieldsForType.toObject(message2.referencedFieldsByType[keys2[j]], options);
      }
      return object;
    };
    TracesAndStats.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };
    return TracesAndStats;
  }();
  $root.google = function() {
    var google = {};
    google.protobuf = function() {
      var protobuf = {};
      protobuf.Timestamp = function() {
        function Timestamp(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        Timestamp.prototype.seconds = 0;
        Timestamp.prototype.nanos = 0;
        Timestamp.create = function create(properties) {
          return new Timestamp(properties);
        };
        Timestamp.encode = function encode(message2, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message2.seconds != null && Object.hasOwnProperty.call(message2, "seconds"))
            writer.uint32(8).int64(message2.seconds);
          if (message2.nanos != null && Object.hasOwnProperty.call(message2, "nanos"))
            writer.uint32(16).int32(message2.nanos);
          return writer;
        };
        Timestamp.encodeDelimited = function encodeDelimited(message2, writer) {
          return this.encode(message2, writer).ldelim();
        };
        Timestamp.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message2 = new $root.google.protobuf.Timestamp;
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message2.seconds = reader.int64();
                break;
              case 2:
                message2.nanos = reader.int32();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message2;
        };
        Timestamp.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        Timestamp.verify = function verify(message2) {
          if (typeof message2 !== "object" || message2 === null)
            return "object expected";
          if (message2.seconds != null && message2.hasOwnProperty("seconds")) {
            if (!$util.isInteger(message2.seconds) && !(message2.seconds && $util.isInteger(message2.seconds.low) && $util.isInteger(message2.seconds.high)))
              return "seconds: integer|Long expected";
          }
          if (message2.nanos != null && message2.hasOwnProperty("nanos")) {
            if (!$util.isInteger(message2.nanos))
              return "nanos: integer expected";
          }
          return null;
        };
        Timestamp.toObject = function toObject(message2, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.defaults) {
            object.seconds = 0;
            object.nanos = 0;
          }
          if (message2.seconds != null && message2.hasOwnProperty("seconds"))
            if (typeof message2.seconds === "number")
              object.seconds = options.longs === String ? String(message2.seconds) : message2.seconds;
            else
              object.seconds = options.longs === String ? $util.Long.prototype.toString.call(message2.seconds) : options.longs === Number ? new $util.LongBits(message2.seconds.low >>> 0, message2.seconds.high >>> 0).toNumber() : message2.seconds;
          if (message2.nanos != null && message2.hasOwnProperty("nanos"))
            object.nanos = message2.nanos;
          return object;
        };
        Timestamp.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return Timestamp;
      }();
      return protobuf;
    }();
    return google;
  }();
  module.exports = $root;
});

// node_modules/apollo-reporting-protobuf/generated/index.js
var require_generated = __commonJS((exports, module) => {
  var protobuf = require_protobuf();
  var protobufJS = require_index_minimal();
  protobufJS.util.Long = undefined;
  protobufJS.configure();
  module.exports = protobuf;
});

// node_modules/node-abort-controller/index.js
var require_node_abort_controller = __commonJS((exports, module) => {
  var { EventEmitter } = __require("events");

  class AbortSignal2 {
    constructor() {
      this.eventEmitter = new EventEmitter;
      this.onabort = null;
      this.aborted = false;
      this.reason = undefined;
    }
    toString() {
      return "[object AbortSignal]";
    }
    get [Symbol.toStringTag]() {
      return "AbortSignal";
    }
    removeEventListener(name, handler) {
      this.eventEmitter.removeListener(name, handler);
    }
    addEventListener(name, handler) {
      this.eventEmitter.on(name, handler);
    }
    dispatchEvent(type) {
      const event = { type, target: this };
      const handlerName = `on${type}`;
      if (typeof this[handlerName] === "function")
        this[handlerName](event);
      this.eventEmitter.emit(type, event);
    }
    throwIfAborted() {
      if (this.aborted) {
        throw this.reason;
      }
    }
    static abort(reason) {
      const controller = new AbortController2;
      controller.abort();
      return controller.signal;
    }
    static timeout(time) {
      const controller = new AbortController2;
      setTimeout(() => controller.abort(new Error("TimeoutError")), time);
      return controller.signal;
    }
  }

  class AbortController2 {
    constructor() {
      this.signal = new AbortSignal2;
    }
    abort(reason) {
      if (this.signal.aborted)
        return;
      this.signal.aborted = true;
      if (reason)
        this.signal.reason = reason;
      else
        this.signal.reason = new Error("AbortError");
      this.signal.dispatchEvent("abort");
    }
    toString() {
      return "[object AbortController]";
    }
    get [Symbol.toStringTag]() {
      return "AbortController";
    }
  }
  module.exports = { AbortController: AbortController2, AbortSignal: AbortSignal2 };
});

// node_modules/yallist/iterator.js
var require_iterator = __commonJS((exports, module) => {
  module.exports = function(Yallist) {
    Yallist.prototype[Symbol.iterator] = function* () {
      for (let walker = this.head;walker; walker = walker.next) {
        yield walker.value;
      }
    };
  };
});

// node_modules/yallist/yallist.js
var require_yallist = __commonJS((exports, module) => {
  module.exports = Yallist;
  Yallist.Node = Node;
  Yallist.create = Yallist;
  function Yallist(list) {
    var self2 = this;
    if (!(self2 instanceof Yallist)) {
      self2 = new Yallist;
    }
    self2.tail = null;
    self2.head = null;
    self2.length = 0;
    if (list && typeof list.forEach === "function") {
      list.forEach(function(item) {
        self2.push(item);
      });
    } else if (arguments.length > 0) {
      for (var i = 0, l = arguments.length;i < l; i++) {
        self2.push(arguments[i]);
      }
    }
    return self2;
  }
  Yallist.prototype.removeNode = function(node) {
    if (node.list !== this) {
      throw new Error("removing node which does not belong to this list");
    }
    var next = node.next;
    var prev = node.prev;
    if (next) {
      next.prev = prev;
    }
    if (prev) {
      prev.next = next;
    }
    if (node === this.head) {
      this.head = next;
    }
    if (node === this.tail) {
      this.tail = prev;
    }
    node.list.length--;
    node.next = null;
    node.prev = null;
    node.list = null;
    return next;
  };
  Yallist.prototype.unshiftNode = function(node) {
    if (node === this.head) {
      return;
    }
    if (node.list) {
      node.list.removeNode(node);
    }
    var head = this.head;
    node.list = this;
    node.next = head;
    if (head) {
      head.prev = node;
    }
    this.head = node;
    if (!this.tail) {
      this.tail = node;
    }
    this.length++;
  };
  Yallist.prototype.pushNode = function(node) {
    if (node === this.tail) {
      return;
    }
    if (node.list) {
      node.list.removeNode(node);
    }
    var tail = this.tail;
    node.list = this;
    node.prev = tail;
    if (tail) {
      tail.next = node;
    }
    this.tail = node;
    if (!this.head) {
      this.head = node;
    }
    this.length++;
  };
  Yallist.prototype.push = function() {
    for (var i = 0, l = arguments.length;i < l; i++) {
      push(this, arguments[i]);
    }
    return this.length;
  };
  Yallist.prototype.unshift = function() {
    for (var i = 0, l = arguments.length;i < l; i++) {
      unshift(this, arguments[i]);
    }
    return this.length;
  };
  Yallist.prototype.pop = function() {
    if (!this.tail) {
      return;
    }
    var res = this.tail.value;
    this.tail = this.tail.prev;
    if (this.tail) {
      this.tail.next = null;
    } else {
      this.head = null;
    }
    this.length--;
    return res;
  };
  Yallist.prototype.shift = function() {
    if (!this.head) {
      return;
    }
    var res = this.head.value;
    this.head = this.head.next;
    if (this.head) {
      this.head.prev = null;
    } else {
      this.tail = null;
    }
    this.length--;
    return res;
  };
  Yallist.prototype.forEach = function(fn2, thisp) {
    thisp = thisp || this;
    for (var walker = this.head, i = 0;walker !== null; i++) {
      fn2.call(thisp, walker.value, i, this);
      walker = walker.next;
    }
  };
  Yallist.prototype.forEachReverse = function(fn2, thisp) {
    thisp = thisp || this;
    for (var walker = this.tail, i = this.length - 1;walker !== null; i--) {
      fn2.call(thisp, walker.value, i, this);
      walker = walker.prev;
    }
  };
  Yallist.prototype.get = function(n) {
    for (var i = 0, walker = this.head;walker !== null && i < n; i++) {
      walker = walker.next;
    }
    if (i === n && walker !== null) {
      return walker.value;
    }
  };
  Yallist.prototype.getReverse = function(n) {
    for (var i = 0, walker = this.tail;walker !== null && i < n; i++) {
      walker = walker.prev;
    }
    if (i === n && walker !== null) {
      return walker.value;
    }
  };
  Yallist.prototype.map = function(fn2, thisp) {
    thisp = thisp || this;
    var res = new Yallist;
    for (var walker = this.head;walker !== null; ) {
      res.push(fn2.call(thisp, walker.value, this));
      walker = walker.next;
    }
    return res;
  };
  Yallist.prototype.mapReverse = function(fn2, thisp) {
    thisp = thisp || this;
    var res = new Yallist;
    for (var walker = this.tail;walker !== null; ) {
      res.push(fn2.call(thisp, walker.value, this));
      walker = walker.prev;
    }
    return res;
  };
  Yallist.prototype.reduce = function(fn2, initial) {
    var acc;
    var walker = this.head;
    if (arguments.length > 1) {
      acc = initial;
    } else if (this.head) {
      walker = this.head.next;
      acc = this.head.value;
    } else {
      throw new TypeError("Reduce of empty list with no initial value");
    }
    for (var i = 0;walker !== null; i++) {
      acc = fn2(acc, walker.value, i);
      walker = walker.next;
    }
    return acc;
  };
  Yallist.prototype.reduceReverse = function(fn2, initial) {
    var acc;
    var walker = this.tail;
    if (arguments.length > 1) {
      acc = initial;
    } else if (this.tail) {
      walker = this.tail.prev;
      acc = this.tail.value;
    } else {
      throw new TypeError("Reduce of empty list with no initial value");
    }
    for (var i = this.length - 1;walker !== null; i--) {
      acc = fn2(acc, walker.value, i);
      walker = walker.prev;
    }
    return acc;
  };
  Yallist.prototype.toArray = function() {
    var arr = new Array(this.length);
    for (var i = 0, walker = this.head;walker !== null; i++) {
      arr[i] = walker.value;
      walker = walker.next;
    }
    return arr;
  };
  Yallist.prototype.toArrayReverse = function() {
    var arr = new Array(this.length);
    for (var i = 0, walker = this.tail;walker !== null; i++) {
      arr[i] = walker.value;
      walker = walker.prev;
    }
    return arr;
  };
  Yallist.prototype.slice = function(from, to) {
    to = to || this.length;
    if (to < 0) {
      to += this.length;
    }
    from = from || 0;
    if (from < 0) {
      from += this.length;
    }
    var ret = new Yallist;
    if (to < from || to < 0) {
      return ret;
    }
    if (from < 0) {
      from = 0;
    }
    if (to > this.length) {
      to = this.length;
    }
    for (var i = 0, walker = this.head;walker !== null && i < from; i++) {
      walker = walker.next;
    }
    for (;walker !== null && i < to; i++, walker = walker.next) {
      ret.push(walker.value);
    }
    return ret;
  };
  Yallist.prototype.sliceReverse = function(from, to) {
    to = to || this.length;
    if (to < 0) {
      to += this.length;
    }
    from = from || 0;
    if (from < 0) {
      from += this.length;
    }
    var ret = new Yallist;
    if (to < from || to < 0) {
      return ret;
    }
    if (from < 0) {
      from = 0;
    }
    if (to > this.length) {
      to = this.length;
    }
    for (var i = this.length, walker = this.tail;walker !== null && i > to; i--) {
      walker = walker.prev;
    }
    for (;walker !== null && i > from; i--, walker = walker.prev) {
      ret.push(walker.value);
    }
    return ret;
  };
  Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
    if (start > this.length) {
      start = this.length - 1;
    }
    if (start < 0) {
      start = this.length + start;
    }
    for (var i = 0, walker = this.head;walker !== null && i < start; i++) {
      walker = walker.next;
    }
    var ret = [];
    for (var i = 0;walker && i < deleteCount; i++) {
      ret.push(walker.value);
      walker = this.removeNode(walker);
    }
    if (walker === null) {
      walker = this.tail;
    }
    if (walker !== this.head && walker !== this.tail) {
      walker = walker.prev;
    }
    for (var i = 0;i < nodes.length; i++) {
      walker = insert(this, walker, nodes[i]);
    }
    return ret;
  };
  Yallist.prototype.reverse = function() {
    var head = this.head;
    var tail = this.tail;
    for (var walker = head;walker !== null; walker = walker.prev) {
      var p = walker.prev;
      walker.prev = walker.next;
      walker.next = p;
    }
    this.head = tail;
    this.tail = head;
    return this;
  };
  function insert(self2, node, value) {
    var inserted = node === self2.head ? new Node(value, null, node, self2) : new Node(value, node, node.next, self2);
    if (inserted.next === null) {
      self2.tail = inserted;
    }
    if (inserted.prev === null) {
      self2.head = inserted;
    }
    self2.length++;
    return inserted;
  }
  function push(self2, item) {
    self2.tail = new Node(item, self2.tail, null, self2);
    if (!self2.head) {
      self2.head = self2.tail;
    }
    self2.length++;
  }
  function unshift(self2, item) {
    self2.head = new Node(item, null, self2.head, self2);
    if (!self2.tail) {
      self2.tail = self2.head;
    }
    self2.length++;
  }
  function Node(value, prev, next, list) {
    if (!(this instanceof Node)) {
      return new Node(value, prev, next, list);
    }
    this.list = list;
    this.value = value;
    if (prev) {
      prev.next = this;
      this.prev = prev;
    } else {
      this.prev = null;
    }
    if (next) {
      next.prev = this;
      this.next = next;
    } else {
      this.next = null;
    }
  }
  try {
    require_iterator()(Yallist);
  } catch (er) {}
});

// node_modules/lru-cache/index.js
var require_lru_cache2 = __commonJS((exports, module) => {
  var Yallist = require_yallist();
  var MAX = Symbol("max");
  var LENGTH = Symbol("length");
  var LENGTH_CALCULATOR = Symbol("lengthCalculator");
  var ALLOW_STALE = Symbol("allowStale");
  var MAX_AGE = Symbol("maxAge");
  var DISPOSE = Symbol("dispose");
  var NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
  var LRU_LIST = Symbol("lruList");
  var CACHE = Symbol("cache");
  var UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
  var naiveLength = () => 1;

  class LRUCache {
    constructor(options) {
      if (typeof options === "number")
        options = { max: options };
      if (!options)
        options = {};
      if (options.max && (typeof options.max !== "number" || options.max < 0))
        throw new TypeError("max must be a non-negative number");
      const max = this[MAX] = options.max || Infinity;
      const lc = options.length || naiveLength;
      this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
      this[ALLOW_STALE] = options.stale || false;
      if (options.maxAge && typeof options.maxAge !== "number")
        throw new TypeError("maxAge must be a number");
      this[MAX_AGE] = options.maxAge || 0;
      this[DISPOSE] = options.dispose;
      this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
      this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
      this.reset();
    }
    set max(mL) {
      if (typeof mL !== "number" || mL < 0)
        throw new TypeError("max must be a non-negative number");
      this[MAX] = mL || Infinity;
      trim(this);
    }
    get max() {
      return this[MAX];
    }
    set allowStale(allowStale) {
      this[ALLOW_STALE] = !!allowStale;
    }
    get allowStale() {
      return this[ALLOW_STALE];
    }
    set maxAge(mA) {
      if (typeof mA !== "number")
        throw new TypeError("maxAge must be a non-negative number");
      this[MAX_AGE] = mA;
      trim(this);
    }
    get maxAge() {
      return this[MAX_AGE];
    }
    set lengthCalculator(lC) {
      if (typeof lC !== "function")
        lC = naiveLength;
      if (lC !== this[LENGTH_CALCULATOR]) {
        this[LENGTH_CALCULATOR] = lC;
        this[LENGTH] = 0;
        this[LRU_LIST].forEach((hit) => {
          hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
          this[LENGTH] += hit.length;
        });
      }
      trim(this);
    }
    get lengthCalculator() {
      return this[LENGTH_CALCULATOR];
    }
    get length() {
      return this[LENGTH];
    }
    get itemCount() {
      return this[LRU_LIST].length;
    }
    rforEach(fn2, thisp) {
      thisp = thisp || this;
      for (let walker = this[LRU_LIST].tail;walker !== null; ) {
        const prev = walker.prev;
        forEachStep(this, fn2, walker, thisp);
        walker = prev;
      }
    }
    forEach(fn2, thisp) {
      thisp = thisp || this;
      for (let walker = this[LRU_LIST].head;walker !== null; ) {
        const next = walker.next;
        forEachStep(this, fn2, walker, thisp);
        walker = next;
      }
    }
    keys() {
      return this[LRU_LIST].toArray().map((k) => k.key);
    }
    values() {
      return this[LRU_LIST].toArray().map((k) => k.value);
    }
    reset() {
      if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
        this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
      }
      this[CACHE] = new Map;
      this[LRU_LIST] = new Yallist;
      this[LENGTH] = 0;
    }
    dump() {
      return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
        k: hit.key,
        v: hit.value,
        e: hit.now + (hit.maxAge || 0)
      }).toArray().filter((h) => h);
    }
    dumpLru() {
      return this[LRU_LIST];
    }
    set(key, value, maxAge) {
      maxAge = maxAge || this[MAX_AGE];
      if (maxAge && typeof maxAge !== "number")
        throw new TypeError("maxAge must be a number");
      const now = maxAge ? Date.now() : 0;
      const len = this[LENGTH_CALCULATOR](value, key);
      if (this[CACHE].has(key)) {
        if (len > this[MAX]) {
          del(this, this[CACHE].get(key));
          return false;
        }
        const node = this[CACHE].get(key);
        const item = node.value;
        if (this[DISPOSE]) {
          if (!this[NO_DISPOSE_ON_SET])
            this[DISPOSE](key, item.value);
        }
        item.now = now;
        item.maxAge = maxAge;
        item.value = value;
        this[LENGTH] += len - item.length;
        item.length = len;
        this.get(key);
        trim(this);
        return true;
      }
      const hit = new Entry(key, value, len, now, maxAge);
      if (hit.length > this[MAX]) {
        if (this[DISPOSE])
          this[DISPOSE](key, value);
        return false;
      }
      this[LENGTH] += hit.length;
      this[LRU_LIST].unshift(hit);
      this[CACHE].set(key, this[LRU_LIST].head);
      trim(this);
      return true;
    }
    has(key) {
      if (!this[CACHE].has(key))
        return false;
      const hit = this[CACHE].get(key).value;
      return !isStale(this, hit);
    }
    get(key) {
      return get(this, key, true);
    }
    peek(key) {
      return get(this, key, false);
    }
    pop() {
      const node = this[LRU_LIST].tail;
      if (!node)
        return null;
      del(this, node);
      return node.value;
    }
    del(key) {
      del(this, this[CACHE].get(key));
    }
    load(arr) {
      this.reset();
      const now = Date.now();
      for (let l = arr.length - 1;l >= 0; l--) {
        const hit = arr[l];
        const expiresAt = hit.e || 0;
        if (expiresAt === 0)
          this.set(hit.k, hit.v);
        else {
          const maxAge = expiresAt - now;
          if (maxAge > 0) {
            this.set(hit.k, hit.v, maxAge);
          }
        }
      }
    }
    prune() {
      this[CACHE].forEach((value, key) => get(this, key, false));
    }
  }
  var get = (self2, key, doUse) => {
    const node = self2[CACHE].get(key);
    if (node) {
      const hit = node.value;
      if (isStale(self2, hit)) {
        del(self2, node);
        if (!self2[ALLOW_STALE])
          return;
      } else {
        if (doUse) {
          if (self2[UPDATE_AGE_ON_GET])
            node.value.now = Date.now();
          self2[LRU_LIST].unshiftNode(node);
        }
      }
      return hit.value;
    }
  };
  var isStale = (self2, hit) => {
    if (!hit || !hit.maxAge && !self2[MAX_AGE])
      return false;
    const diff = Date.now() - hit.now;
    return hit.maxAge ? diff > hit.maxAge : self2[MAX_AGE] && diff > self2[MAX_AGE];
  };
  var trim = (self2) => {
    if (self2[LENGTH] > self2[MAX]) {
      for (let walker = self2[LRU_LIST].tail;self2[LENGTH] > self2[MAX] && walker !== null; ) {
        const prev = walker.prev;
        del(self2, walker);
        walker = prev;
      }
    }
  };
  var del = (self2, node) => {
    if (node) {
      const hit = node.value;
      if (self2[DISPOSE])
        self2[DISPOSE](hit.key, hit.value);
      self2[LENGTH] -= hit.length;
      self2[CACHE].delete(hit.key);
      self2[LRU_LIST].removeNode(node);
    }
  };

  class Entry {
    constructor(key, value, length, now, maxAge) {
      this.key = key;
      this.value = value;
      this.length = length;
      this.now = now;
      this.maxAge = maxAge || 0;
    }
  }
  var forEachStep = (self2, fn2, node, thisp) => {
    let hit = node.value;
    if (isStale(self2, hit)) {
      del(self2, node);
      if (!self2[ALLOW_STALE])
        hit = undefined;
    }
    if (hit)
      fn2.call(thisp, hit.value, hit.key, self2);
  };
  module.exports = LRUCache;
});

// node_modules/apollo-server-core/dist/plugin/usageReporting/operationDerivedDataCache.js
var require_operationDerivedDataCache = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.operationDerivedDataCacheKey = exports.createOperationDerivedDataCache = undefined;
  var lru_cache_1 = __importDefault(require_lru_cache2());
  function createOperationDerivedDataCache({ logger }) {
    let lastWarn;
    let lastDisposals = 0;
    return new lru_cache_1.default({
      length(obj) {
        return Buffer.byteLength(JSON.stringify(obj), "utf8");
      },
      max: Math.pow(2, 20) * 10,
      dispose() {
        lastDisposals++;
        if (!lastWarn || new Date().getTime() - lastWarn.getTime() > 60000) {
          lastWarn = new Date;
          logger.warn([
            "This server is processing a high number of unique operations.  ",
            `A total of ${lastDisposals} records have been `,
            "ejected from the ApolloServerPluginUsageReporting signature cache in the past ",
            "interval.  If you see this warning frequently, please open an ",
            "issue on the Apollo Server repository."
          ].join(""));
          lastDisposals = 0;
        }
      }
    });
  }
  exports.createOperationDerivedDataCache = createOperationDerivedDataCache;
  function operationDerivedDataCacheKey(queryHash, operationName) {
    return `${queryHash}${operationName && ":" + operationName}`;
  }
  exports.operationDerivedDataCacheKey = operationDerivedDataCacheKey;
});

// node_modules/@apollo/usage-reporting-protobuf/node_modules/@apollo/protobufjs/src/util/longbits.js
var require_longbits2 = __commonJS((exports, module) => {
  module.exports = LongBits;
  var util = require_minimal2();
  function LongBits(lo, hi) {
    this.lo = lo >>> 0;
    this.hi = hi >>> 0;
  }
  var zero = LongBits.zero = new LongBits(0, 0);
  zero.toNumber = function() {
    return 0;
  };
  zero.zzEncode = zero.zzDecode = function() {
    return this;
  };
  zero.length = function() {
    return 1;
  };
  var zeroHash = LongBits.zeroHash = "\x00\x00\x00\x00\x00\x00\x00\x00";
  LongBits.fromNumber = function fromNumber(value) {
    if (value === 0)
      return zero;
    var sign = value < 0;
    if (sign)
      value = -value;
    var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
    if (sign) {
      hi = ~hi >>> 0;
      lo = ~lo >>> 0;
      if (++lo > 4294967295) {
        lo = 0;
        if (++hi > 4294967295)
          hi = 0;
      }
    }
    return new LongBits(lo, hi);
  };
  LongBits.from = function from(value) {
    if (typeof value === "number")
      return LongBits.fromNumber(value);
    if (util.isString(value)) {
      if (util.Long)
        value = util.Long.fromString(value);
      else
        return LongBits.fromNumber(parseInt(value, 10));
    }
    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
  };
  LongBits.prototype.toNumber = function toNumber(unsigned) {
    if (!unsigned && this.hi >>> 31) {
      var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
      if (!lo)
        hi = hi + 1 >>> 0;
      return -(lo + hi * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
  };
  LongBits.prototype.toLong = function toLong(unsigned) {
    return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
  };
  var charCodeAt = String.prototype.charCodeAt;
  LongBits.fromHash = function fromHash(hash) {
    if (hash === zeroHash)
      return zero;
    return new LongBits((charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0, (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0);
  };
  LongBits.prototype.toHash = function toHash() {
    return String.fromCharCode(this.lo & 255, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, this.hi & 255, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24);
  };
  LongBits.prototype.zzEncode = function zzEncode() {
    var mask = this.hi >> 31;
    this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
    this.lo = (this.lo << 1 ^ mask) >>> 0;
    return this;
  };
  LongBits.prototype.zzDecode = function zzDecode() {
    var mask = -(this.lo & 1);
    this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
    this.hi = (this.hi >>> 1 ^ mask) >>> 0;
    return this;
  };
  LongBits.prototype.length = function length() {
    var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
    return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
  };
});

// node_modules/@apollo/usage-reporting-protobuf/node_modules/@apollo/protobufjs/src/util/minimal.js
var require_minimal2 = __commonJS((exports) => {
  var util = exports;
  util.asPromise = require_aspromise();
  util.base64 = require_base64();
  util.EventEmitter = require_eventemitter();
  util.float = require_float();
  util.inquire = require_inquire();
  util.utf8 = require_utf8();
  util.pool = require_pool();
  util.LongBits = require_longbits2();
  util.global = typeof window !== "undefined" && window || typeof global !== "undefined" && global || typeof self !== "undefined" && self || exports;
  util.emptyArray = Object.freeze ? Object.freeze([]) : [];
  util.emptyObject = Object.freeze ? Object.freeze({}) : {};
  util.isNode = Boolean(util.global.process && util.global.process.versions && util.global.process.versions.node);
  util.isInteger = Number.isInteger || function isInteger(value) {
    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
  };
  util.isString = function isString(value) {
    return typeof value === "string" || value instanceof String;
  };
  util.isObject = function isObject(value) {
    return value && typeof value === "object";
  };
  util.isset = util.isSet = function isSet(obj, prop) {
    var value = obj[prop];
    if (value != null && obj.hasOwnProperty(prop))
      return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
    return false;
  };
  util.Buffer = function() {
    try {
      var Buffer2 = util.inquire("buffer").Buffer;
      return Buffer2.prototype.utf8Write ? Buffer2 : null;
    } catch (e) {
      return null;
    }
  }();
  util._Buffer_from = null;
  util._Buffer_allocUnsafe = null;
  util.newBuffer = function newBuffer(sizeOrArray) {
    return typeof sizeOrArray === "number" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
  };
  util.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
  util.Long = typeof process === "undefined" || process.env.ENABLE_LONG ? util.global.dcodeIO && util.global.dcodeIO.Long || util.global.Long || util.inquire("long") : undefined;
  util.key2Re = /^true|false|0|1$/;
  util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
  util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
  util.longToHash = function longToHash(value) {
    return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;
  };
  util.longFromHash = function longFromHash(hash, unsigned) {
    var bits = util.LongBits.fromHash(hash);
    if (util.Long)
      return util.Long.fromBits(bits.lo, bits.hi, unsigned);
    return bits.toNumber(Boolean(unsigned));
  };
  function merge(dst, src, ifNotSet) {
    for (var keys = Object.keys(src), i = 0;i < keys.length; ++i)
      if (dst[keys[i]] === undefined || !ifNotSet)
        dst[keys[i]] = src[keys[i]];
    return dst;
  }
  util.merge = merge;
  util.lcFirst = function lcFirst(str) {
    return str.charAt(0).toLowerCase() + str.substring(1);
  };
  function newError(name) {
    function CustomError(message2, properties) {
      if (!(this instanceof CustomError))
        return new CustomError(message2, properties);
      Object.defineProperty(this, "message", { get: function() {
        return message2;
      } });
      if (Error.captureStackTrace)
        Error.captureStackTrace(this, CustomError);
      else
        Object.defineProperty(this, "stack", { value: new Error().stack || "" });
      if (properties)
        merge(this, properties);
    }
    (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;
    Object.defineProperty(CustomError.prototype, "name", { get: function() {
      return name;
    } });
    CustomError.prototype.toString = function toString() {
      return this.name + ": " + this.message;
    };
    return CustomError;
  }
  util.newError = newError;
  util.ProtocolError = newError("ProtocolError");
  util.oneOfGetter = function getOneOf(fieldNames) {
    var fieldMap = {};
    for (var i = 0;i < fieldNames.length; ++i)
      fieldMap[fieldNames[i]] = 1;
    return function() {
      for (var keys = Object.keys(this), i2 = keys.length - 1;i2 > -1; --i2)
        if (fieldMap[keys[i2]] === 1 && this[keys[i2]] !== undefined && this[keys[i2]] !== null)
          return keys[i2];
    };
  };
  util.oneOfSetter = function setOneOf(fieldNames) {
    return function(name) {
      for (var i = 0;i < fieldNames.length; ++i)
        if (fieldNames[i] !== name)
          delete this[fieldNames[i]];
    };
  };
  util.toJSONOptions = {
    longs: String,
    enums: String,
    bytes: String,
    json: true
  };
  util._configure = function() {
    var Buffer2 = util.Buffer;
    if (!Buffer2) {
      util._Buffer_from = util._Buffer_allocUnsafe = null;
      return;
    }
    util._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || function Buffer_from(value, encoding) {
      return new Buffer2(value, encoding);
    };
    util._Buffer_allocUnsafe = Buffer2.allocUnsafe || function Buffer_allocUnsafe(size) {
      return new Buffer2(size);
    };
  };
});

// node_modules/@apollo/usage-reporting-protobuf/node_modules/@apollo/protobufjs/src/writer.js
var require_writer2 = __commonJS((exports, module) => {
  module.exports = Writer;
  var util = require_minimal2();
  var BufferWriter;
  var LongBits = util.LongBits;
  var base64 = util.base64;
  var utf8 = util.utf8;
  function Op(fn2, len, val) {
    this.fn = fn2;
    this.len = len;
    this.next = undefined;
    this.val = val;
  }
  function noop() {}
  function State(writer) {
    this.head = writer.head;
    this.tail = writer.tail;
    this.len = writer.len;
    this.next = writer.states;
  }
  function Writer() {
    this.len = 0;
    this.head = new Op(noop, 0, 0);
    this.tail = this.head;
    this.states = null;
  }
  Writer.create = util.Buffer ? function create_buffer_setup() {
    return (Writer.create = function create_buffer() {
      return new BufferWriter;
    })();
  } : function create_array() {
    return new Writer;
  };
  Writer.alloc = function alloc(size) {
    return new util.Array(size);
  };
  if (util.Array !== Array)
    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);
  Writer.prototype._push = function push(fn2, len, val) {
    this.tail = this.tail.next = new Op(fn2, len, val);
    this.len += len;
    return this;
  };
  function writeByte(val, buf, pos) {
    buf[pos] = val & 255;
  }
  function writeVarint32(val, buf, pos) {
    while (val > 127) {
      buf[pos++] = val & 127 | 128;
      val >>>= 7;
    }
    buf[pos] = val;
  }
  function VarintOp(len, val) {
    this.len = len;
    this.next = undefined;
    this.val = val;
  }
  VarintOp.prototype = Object.create(Op.prototype);
  VarintOp.prototype.fn = writeVarint32;
  Writer.prototype.uint32 = function write_uint32(value) {
    this.len += (this.tail = this.tail.next = new VarintOp((value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5, value)).len;
    return this;
  };
  Writer.prototype.int32 = function write_int32(value) {
    return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);
  };
  Writer.prototype.sint32 = function write_sint32(value) {
    return this.uint32((value << 1 ^ value >> 31) >>> 0);
  };
  function writeVarint64(val, buf, pos) {
    while (val.hi) {
      buf[pos++] = val.lo & 127 | 128;
      val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
      val.hi >>>= 7;
    }
    while (val.lo > 127) {
      buf[pos++] = val.lo & 127 | 128;
      val.lo = val.lo >>> 7;
    }
    buf[pos++] = val.lo;
  }
  Writer.prototype.uint64 = function write_uint64(value) {
    var bits = LongBits.from(value);
    return this._push(writeVarint64, bits.length(), bits);
  };
  Writer.prototype.int64 = Writer.prototype.uint64;
  Writer.prototype.sint64 = function write_sint64(value) {
    var bits = LongBits.from(value).zzEncode();
    return this._push(writeVarint64, bits.length(), bits);
  };
  Writer.prototype.bool = function write_bool(value) {
    return this._push(writeByte, 1, value ? 1 : 0);
  };
  function writeFixed32(val, buf, pos) {
    buf[pos] = val & 255;
    buf[pos + 1] = val >>> 8 & 255;
    buf[pos + 2] = val >>> 16 & 255;
    buf[pos + 3] = val >>> 24;
  }
  Writer.prototype.fixed32 = function write_fixed32(value) {
    return this._push(writeFixed32, 4, value >>> 0);
  };
  Writer.prototype.sfixed32 = Writer.prototype.fixed32;
  Writer.prototype.fixed64 = function write_fixed64(value) {
    var bits = LongBits.from(value);
    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
  };
  Writer.prototype.sfixed64 = Writer.prototype.fixed64;
  Writer.prototype.float = function write_float(value) {
    return this._push(util.float.writeFloatLE, 4, value);
  };
  Writer.prototype.double = function write_double(value) {
    return this._push(util.float.writeDoubleLE, 8, value);
  };
  var writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf, pos) {
    buf.set(val, pos);
  } : function writeBytes_for(val, buf, pos) {
    for (var i = 0;i < val.length; ++i)
      buf[pos + i] = val[i];
  };
  Writer.prototype.bytes = function write_bytes(value) {
    var len = value.length >>> 0;
    if (!len)
      return this._push(writeByte, 1, 0);
    if (util.isString(value)) {
      var buf = Writer.alloc(len = base64.length(value));
      base64.decode(value, buf, 0);
      value = buf;
    }
    return this.uint32(len)._push(writeBytes, len, value);
  };
  Writer.prototype.string = function write_string(value) {
    var len = utf8.length(value);
    return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);
  };
  Writer.prototype.fork = function fork() {
    this.states = new State(this);
    this.head = this.tail = new Op(noop, 0, 0);
    this.len = 0;
    return this;
  };
  Writer.prototype.reset = function reset() {
    if (this.states) {
      this.head = this.states.head;
      this.tail = this.states.tail;
      this.len = this.states.len;
      this.states = this.states.next;
    } else {
      this.head = this.tail = new Op(noop, 0, 0);
      this.len = 0;
    }
    return this;
  };
  Writer.prototype.ldelim = function ldelim() {
    var head = this.head, tail = this.tail, len = this.len;
    this.reset().uint32(len);
    if (len) {
      this.tail.next = head.next;
      this.tail = tail;
      this.len += len;
    }
    return this;
  };
  Writer.prototype.finish = function finish() {
    var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;
    while (head) {
      head.fn(head.val, buf, pos);
      pos += head.len;
      head = head.next;
    }
    return buf;
  };
  Writer._configure = function(BufferWriter_) {
    BufferWriter = BufferWriter_;
  };
});

// node_modules/@apollo/usage-reporting-protobuf/node_modules/@apollo/protobufjs/src/writer_buffer.js
var require_writer_buffer2 = __commonJS((exports, module) => {
  module.exports = BufferWriter;
  var Writer = require_writer2();
  (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
  var util = require_minimal2();
  var Buffer2 = util.Buffer;
  function BufferWriter() {
    Writer.call(this);
  }
  BufferWriter.alloc = function alloc_buffer(size) {
    return (BufferWriter.alloc = util._Buffer_allocUnsafe)(size);
  };
  var writeBytesBuffer = Buffer2 && Buffer2.prototype instanceof Uint8Array && Buffer2.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf, pos) {
    buf.set(val, pos);
  } : function writeBytesBuffer_copy(val, buf, pos) {
    if (val.copy)
      val.copy(buf, pos, 0, val.length);
    else
      for (var i = 0;i < val.length; )
        buf[pos++] = val[i++];
  };
  BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
    if (util.isString(value))
      value = util._Buffer_from(value, "base64");
    var len = value.length >>> 0;
    this.uint32(len);
    if (len)
      this._push(writeBytesBuffer, len, value);
    return this;
  };
  function writeStringBuffer(val, buf, pos) {
    if (val.length < 40)
      util.utf8.write(val, buf, pos);
    else
      buf.utf8Write(val, pos);
  }
  BufferWriter.prototype.string = function write_string_buffer(value) {
    var len = Buffer2.byteLength(value);
    this.uint32(len);
    if (len)
      this._push(writeStringBuffer, len, value);
    return this;
  };
});

// node_modules/@apollo/usage-reporting-protobuf/node_modules/@apollo/protobufjs/src/reader.js
var require_reader2 = __commonJS((exports, module) => {
  module.exports = Reader;
  var util = require_minimal2();
  var BufferReader;
  var LongBits = util.LongBits;
  var utf8 = util.utf8;
  function indexOutOfRange(reader, writeLength) {
    return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
  }
  function Reader(buffer) {
    this.buf = buffer;
    this.pos = 0;
    this.len = buffer.length;
  }
  var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer) {
    if (buffer instanceof Uint8Array || Array.isArray(buffer))
      return new Reader(buffer);
    throw Error("illegal buffer");
  } : function create_array(buffer) {
    if (Array.isArray(buffer))
      return new Reader(buffer);
    throw Error("illegal buffer");
  };
  Reader.create = util.Buffer ? function create_buffer_setup(buffer) {
    return (Reader.create = function create_buffer(buffer2) {
      return util.Buffer.isBuffer(buffer2) ? new BufferReader(buffer2) : create_array(buffer2);
    })(buffer);
  } : create_array;
  Reader.prototype._slice = util.Array.prototype.subarray || util.Array.prototype.slice;
  Reader.prototype.uint32 = function read_uint32_setup() {
    var value = 4294967295;
    return function read_uint32() {
      value = (this.buf[this.pos] & 127) >>> 0;
      if (this.buf[this.pos++] < 128)
        return value;
      value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
      if (this.buf[this.pos++] < 128)
        return value;
      value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
      if (this.buf[this.pos++] < 128)
        return value;
      value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
      if (this.buf[this.pos++] < 128)
        return value;
      value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
      if (this.buf[this.pos++] < 128)
        return value;
      if ((this.pos += 5) > this.len) {
        this.pos = this.len;
        throw indexOutOfRange(this, 10);
      }
      return value;
    };
  }();
  Reader.prototype.int32 = function read_int32() {
    return this.uint32() | 0;
  };
  Reader.prototype.sint32 = function read_sint32() {
    var value = this.uint32();
    return value >>> 1 ^ -(value & 1) | 0;
  };
  function readLongVarint() {
    var bits = new LongBits(0, 0);
    var i = 0;
    if (this.len - this.pos > 4) {
      for (;i < 4; ++i) {
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
      }
      bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
      bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
      if (this.buf[this.pos++] < 128)
        return bits;
      i = 0;
    } else {
      for (;i < 3; ++i) {
        if (this.pos >= this.len)
          throw indexOutOfRange(this);
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
      }
      bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
      return bits;
    }
    if (this.len - this.pos > 4) {
      for (;i < 5; ++i) {
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
      }
    } else {
      for (;i < 5; ++i) {
        if (this.pos >= this.len)
          throw indexOutOfRange(this);
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
      }
    }
    throw Error("invalid varint encoding");
  }
  Reader.prototype.bool = function read_bool() {
    return this.uint32() !== 0;
  };
  function readFixed32_end(buf, end) {
    return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;
  }
  Reader.prototype.fixed32 = function read_fixed32() {
    if (this.pos + 4 > this.len)
      throw indexOutOfRange(this, 4);
    return readFixed32_end(this.buf, this.pos += 4);
  };
  Reader.prototype.sfixed32 = function read_sfixed32() {
    if (this.pos + 4 > this.len)
      throw indexOutOfRange(this, 4);
    return readFixed32_end(this.buf, this.pos += 4) | 0;
  };
  function readFixed64() {
    if (this.pos + 8 > this.len)
      throw indexOutOfRange(this, 8);
    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
  }
  Reader.prototype.float = function read_float() {
    if (this.pos + 4 > this.len)
      throw indexOutOfRange(this, 4);
    var value = util.float.readFloatLE(this.buf, this.pos);
    this.pos += 4;
    return value;
  };
  Reader.prototype.double = function read_double() {
    if (this.pos + 8 > this.len)
      throw indexOutOfRange(this, 4);
    var value = util.float.readDoubleLE(this.buf, this.pos);
    this.pos += 8;
    return value;
  };
  Reader.prototype.bytes = function read_bytes() {
    var length = this.uint32(), start = this.pos, end = this.pos + length;
    if (end > this.len)
      throw indexOutOfRange(this, length);
    this.pos += length;
    if (Array.isArray(this.buf))
      return this.buf.slice(start, end);
    return start === end ? new this.buf.constructor(0) : this._slice.call(this.buf, start, end);
  };
  Reader.prototype.string = function read_string() {
    var bytes = this.bytes();
    return utf8.read(bytes, 0, bytes.length);
  };
  Reader.prototype.skip = function skip(length) {
    if (typeof length === "number") {
      if (this.pos + length > this.len)
        throw indexOutOfRange(this, length);
      this.pos += length;
    } else {
      do {
        if (this.pos >= this.len)
          throw indexOutOfRange(this);
      } while (this.buf[this.pos++] & 128);
    }
    return this;
  };
  Reader.prototype.skipType = function(wireType) {
    switch (wireType) {
      case 0:
        this.skip();
        break;
      case 1:
        this.skip(8);
        break;
      case 2:
        this.skip(this.uint32());
        break;
      case 3:
        while ((wireType = this.uint32() & 7) !== 4) {
          this.skipType(wireType);
        }
        break;
      case 5:
        this.skip(4);
        break;
      default:
        throw Error("invalid wire type " + wireType + " at offset " + this.pos);
    }
    return this;
  };
  Reader._configure = function(BufferReader_) {
    BufferReader = BufferReader_;
    var fn2 = util.Long ? "toLong" : "toNumber";
    util.merge(Reader.prototype, {
      int64: function read_int64() {
        return readLongVarint.call(this)[fn2](false);
      },
      uint64: function read_uint64() {
        return readLongVarint.call(this)[fn2](true);
      },
      sint64: function read_sint64() {
        return readLongVarint.call(this).zzDecode()[fn2](false);
      },
      fixed64: function read_fixed64() {
        return readFixed64.call(this)[fn2](true);
      },
      sfixed64: function read_sfixed64() {
        return readFixed64.call(this)[fn2](false);
      }
    });
  };
});

// node_modules/@apollo/usage-reporting-protobuf/node_modules/@apollo/protobufjs/src/reader_buffer.js
var require_reader_buffer2 = __commonJS((exports, module) => {
  module.exports = BufferReader;
  var Reader = require_reader2();
  (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
  var util = require_minimal2();
  function BufferReader(buffer) {
    Reader.call(this, buffer);
  }
  if (util.Buffer)
    BufferReader.prototype._slice = util.Buffer.prototype.slice;
  BufferReader.prototype.string = function read_string_buffer() {
    var len = this.uint32();
    return this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len));
  };
});

// node_modules/@apollo/usage-reporting-protobuf/node_modules/@apollo/protobufjs/src/rpc/service.js
var require_service2 = __commonJS((exports, module) => {
  module.exports = Service;
  var util = require_minimal2();
  (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
  function Service(rpcImpl, requestDelimited, responseDelimited) {
    if (typeof rpcImpl !== "function")
      throw TypeError("rpcImpl must be a function");
    util.EventEmitter.call(this);
    this.rpcImpl = rpcImpl;
    this.requestDelimited = Boolean(requestDelimited);
    this.responseDelimited = Boolean(responseDelimited);
  }
  Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {
    if (!request)
      throw TypeError("request must be specified");
    var self2 = this;
    if (!callback)
      return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);
    if (!self2.rpcImpl) {
      setTimeout(function() {
        callback(Error("already ended"));
      }, 0);
      return;
    }
    try {
      return self2.rpcImpl(method, requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request).finish(), function rpcCallback(err, response) {
        if (err) {
          self2.emit("error", err, method);
          return callback(err);
        }
        if (response === null) {
          self2.end(true);
          return;
        }
        if (!(response instanceof responseCtor)) {
          try {
            response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
          } catch (err2) {
            self2.emit("error", err2, method);
            return callback(err2);
          }
        }
        self2.emit("data", response, method);
        return callback(null, response);
      });
    } catch (err) {
      self2.emit("error", err, method);
      setTimeout(function() {
        callback(err);
      }, 0);
      return;
    }
  };
  Service.prototype.end = function end(endedByRPC) {
    if (this.rpcImpl) {
      if (!endedByRPC)
        this.rpcImpl(null, null, null);
      this.rpcImpl = null;
      this.emit("end").off();
    }
    return this;
  };
});

// node_modules/@apollo/usage-reporting-protobuf/node_modules/@apollo/protobufjs/src/rpc.js
var require_rpc2 = __commonJS((exports) => {
  var rpc = exports;
  rpc.Service = require_service2();
});

// node_modules/@apollo/usage-reporting-protobuf/node_modules/@apollo/protobufjs/src/roots.js
var require_roots2 = __commonJS((exports, module) => {
  module.exports = {};
});

// node_modules/@apollo/usage-reporting-protobuf/node_modules/@apollo/protobufjs/src/index-minimal.js
var require_index_minimal2 = __commonJS((exports) => {
  var protobuf = exports;
  protobuf.build = "minimal";
  protobuf.Writer = require_writer2();
  protobuf.BufferWriter = require_writer_buffer2();
  protobuf.Reader = require_reader2();
  protobuf.BufferReader = require_reader_buffer2();
  protobuf.util = require_minimal2();
  protobuf.rpc = require_rpc2();
  protobuf.roots = require_roots2();
  protobuf.configure = configure;
  function configure() {
    protobuf.Reader._configure(protobuf.BufferReader);
    protobuf.util._configure();
  }
  protobuf.Writer._configure(protobuf.BufferWriter);
  configure();
});

// node_modules/@apollo/usage-reporting-protobuf/generated/cjs/protobuf.js
var require_protobuf2 = __commonJS((exports, module) => {
  var $protobuf = require_index_minimal2();
  var $Reader = $protobuf.Reader;
  var $Writer = $protobuf.Writer;
  var $util = $protobuf.util;
  var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
  $root.Trace = function() {
    function Trace(properties) {
      if (properties) {
        for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    Trace.prototype.startTime = null;
    Trace.prototype.endTime = null;
    Trace.prototype.durationNs = 0;
    Trace.prototype.root = null;
    Trace.prototype.isIncomplete = false;
    Trace.prototype.signature = "";
    Trace.prototype.unexecutedOperationBody = "";
    Trace.prototype.unexecutedOperationName = "";
    Trace.prototype.details = null;
    Trace.prototype.clientName = "";
    Trace.prototype.clientVersion = "";
    Trace.prototype.http = null;
    Trace.prototype.cachePolicy = null;
    Trace.prototype.queryPlan = null;
    Trace.prototype.fullQueryCacheHit = false;
    Trace.prototype.persistedQueryHit = false;
    Trace.prototype.persistedQueryRegister = false;
    Trace.prototype.registeredOperation = false;
    Trace.prototype.forbiddenOperation = false;
    Trace.prototype.fieldExecutionWeight = 0;
    Trace.create = function create(properties) {
      return new Trace(properties);
    };
    Trace.encode = function encode(message2, writer) {
      if (!writer)
        writer = $Writer.create();
      if (message2.endTime != null && Object.hasOwnProperty.call(message2, "endTime"))
        $root.google.protobuf.Timestamp.encode(message2.endTime, writer.uint32(26).fork()).ldelim();
      if (message2.startTime != null && Object.hasOwnProperty.call(message2, "startTime"))
        $root.google.protobuf.Timestamp.encode(message2.startTime, writer.uint32(34).fork()).ldelim();
      if (message2.details != null && Object.hasOwnProperty.call(message2, "details"))
        $root.Trace.Details.encode(message2.details, writer.uint32(50).fork()).ldelim();
      if (message2.clientName != null && Object.hasOwnProperty.call(message2, "clientName"))
        writer.uint32(58).string(message2.clientName);
      if (message2.clientVersion != null && Object.hasOwnProperty.call(message2, "clientVersion"))
        writer.uint32(66).string(message2.clientVersion);
      if (message2.http != null && Object.hasOwnProperty.call(message2, "http"))
        $root.Trace.HTTP.encode(message2.http, writer.uint32(82).fork()).ldelim();
      if (message2.durationNs != null && Object.hasOwnProperty.call(message2, "durationNs"))
        writer.uint32(88).uint64(message2.durationNs);
      if (message2.root != null && Object.hasOwnProperty.call(message2, "root"))
        $root.Trace.Node.encode(message2.root, writer.uint32(114).fork()).ldelim();
      if (message2.cachePolicy != null && Object.hasOwnProperty.call(message2, "cachePolicy"))
        $root.Trace.CachePolicy.encode(message2.cachePolicy, writer.uint32(146).fork()).ldelim();
      if (message2.signature != null && Object.hasOwnProperty.call(message2, "signature"))
        writer.uint32(154).string(message2.signature);
      if (message2.fullQueryCacheHit != null && Object.hasOwnProperty.call(message2, "fullQueryCacheHit"))
        writer.uint32(160).bool(message2.fullQueryCacheHit);
      if (message2.persistedQueryHit != null && Object.hasOwnProperty.call(message2, "persistedQueryHit"))
        writer.uint32(168).bool(message2.persistedQueryHit);
      if (message2.persistedQueryRegister != null && Object.hasOwnProperty.call(message2, "persistedQueryRegister"))
        writer.uint32(176).bool(message2.persistedQueryRegister);
      if (message2.registeredOperation != null && Object.hasOwnProperty.call(message2, "registeredOperation"))
        writer.uint32(192).bool(message2.registeredOperation);
      if (message2.forbiddenOperation != null && Object.hasOwnProperty.call(message2, "forbiddenOperation"))
        writer.uint32(200).bool(message2.forbiddenOperation);
      if (message2.queryPlan != null && Object.hasOwnProperty.call(message2, "queryPlan"))
        $root.Trace.QueryPlanNode.encode(message2.queryPlan, writer.uint32(210).fork()).ldelim();
      if (message2.unexecutedOperationBody != null && Object.hasOwnProperty.call(message2, "unexecutedOperationBody"))
        writer.uint32(218).string(message2.unexecutedOperationBody);
      if (message2.unexecutedOperationName != null && Object.hasOwnProperty.call(message2, "unexecutedOperationName"))
        writer.uint32(226).string(message2.unexecutedOperationName);
      if (message2.fieldExecutionWeight != null && Object.hasOwnProperty.call(message2, "fieldExecutionWeight"))
        writer.uint32(249).double(message2.fieldExecutionWeight);
      if (message2.isIncomplete != null && Object.hasOwnProperty.call(message2, "isIncomplete"))
        writer.uint32(264).bool(message2.isIncomplete);
      return writer;
    };
    Trace.encodeDelimited = function encodeDelimited(message2, writer) {
      return this.encode(message2, writer).ldelim();
    };
    Trace.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader))
        reader = $Reader.create(reader);
      var end = length === undefined ? reader.len : reader.pos + length, message2 = new $root.Trace;
      while (reader.pos < end) {
        var tag = reader.uint32();
        switch (tag >>> 3) {
          case 4:
            message2.startTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
            break;
          case 3:
            message2.endTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
            break;
          case 11:
            message2.durationNs = reader.uint64();
            break;
          case 14:
            message2.root = $root.Trace.Node.decode(reader, reader.uint32());
            break;
          case 33:
            message2.isIncomplete = reader.bool();
            break;
          case 19:
            message2.signature = reader.string();
            break;
          case 27:
            message2.unexecutedOperationBody = reader.string();
            break;
          case 28:
            message2.unexecutedOperationName = reader.string();
            break;
          case 6:
            message2.details = $root.Trace.Details.decode(reader, reader.uint32());
            break;
          case 7:
            message2.clientName = reader.string();
            break;
          case 8:
            message2.clientVersion = reader.string();
            break;
          case 10:
            message2.http = $root.Trace.HTTP.decode(reader, reader.uint32());
            break;
          case 18:
            message2.cachePolicy = $root.Trace.CachePolicy.decode(reader, reader.uint32());
            break;
          case 26:
            message2.queryPlan = $root.Trace.QueryPlanNode.decode(reader, reader.uint32());
            break;
          case 20:
            message2.fullQueryCacheHit = reader.bool();
            break;
          case 21:
            message2.persistedQueryHit = reader.bool();
            break;
          case 22:
            message2.persistedQueryRegister = reader.bool();
            break;
          case 24:
            message2.registeredOperation = reader.bool();
            break;
          case 25:
            message2.forbiddenOperation = reader.bool();
            break;
          case 31:
            message2.fieldExecutionWeight = reader.double();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message2;
    };
    Trace.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader))
        reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };
    Trace.verify = function verify(message2) {
      if (typeof message2 !== "object" || message2 === null)
        return "object expected";
      if (message2.startTime != null && message2.hasOwnProperty("startTime")) {
        var error = $root.google.protobuf.Timestamp.verify(message2.startTime);
        if (error)
          return "startTime." + error;
      }
      if (message2.endTime != null && message2.hasOwnProperty("endTime")) {
        var error = $root.google.protobuf.Timestamp.verify(message2.endTime);
        if (error)
          return "endTime." + error;
      }
      if (message2.durationNs != null && message2.hasOwnProperty("durationNs")) {
        if (!$util.isInteger(message2.durationNs) && !(message2.durationNs && $util.isInteger(message2.durationNs.low) && $util.isInteger(message2.durationNs.high)))
          return "durationNs: integer|Long expected";
      }
      if (message2.root != null && message2.hasOwnProperty("root")) {
        var error = $root.Trace.Node.verify(message2.root);
        if (error)
          return "root." + error;
      }
      if (message2.isIncomplete != null && message2.hasOwnProperty("isIncomplete")) {
        if (typeof message2.isIncomplete !== "boolean")
          return "isIncomplete: boolean expected";
      }
      if (message2.signature != null && message2.hasOwnProperty("signature")) {
        if (!$util.isString(message2.signature))
          return "signature: string expected";
      }
      if (message2.unexecutedOperationBody != null && message2.hasOwnProperty("unexecutedOperationBody")) {
        if (!$util.isString(message2.unexecutedOperationBody))
          return "unexecutedOperationBody: string expected";
      }
      if (message2.unexecutedOperationName != null && message2.hasOwnProperty("unexecutedOperationName")) {
        if (!$util.isString(message2.unexecutedOperationName))
          return "unexecutedOperationName: string expected";
      }
      if (message2.details != null && message2.hasOwnProperty("details")) {
        var error = $root.Trace.Details.verify(message2.details);
        if (error)
          return "details." + error;
      }
      if (message2.clientName != null && message2.hasOwnProperty("clientName")) {
        if (!$util.isString(message2.clientName))
          return "clientName: string expected";
      }
      if (message2.clientVersion != null && message2.hasOwnProperty("clientVersion")) {
        if (!$util.isString(message2.clientVersion))
          return "clientVersion: string expected";
      }
      if (message2.http != null && message2.hasOwnProperty("http")) {
        var error = $root.Trace.HTTP.verify(message2.http);
        if (error)
          return "http." + error;
      }
      if (message2.cachePolicy != null && message2.hasOwnProperty("cachePolicy")) {
        var error = $root.Trace.CachePolicy.verify(message2.cachePolicy);
        if (error)
          return "cachePolicy." + error;
      }
      if (message2.queryPlan != null && message2.hasOwnProperty("queryPlan")) {
        var error = $root.Trace.QueryPlanNode.verify(message2.queryPlan);
        if (error)
          return "queryPlan." + error;
      }
      if (message2.fullQueryCacheHit != null && message2.hasOwnProperty("fullQueryCacheHit")) {
        if (typeof message2.fullQueryCacheHit !== "boolean")
          return "fullQueryCacheHit: boolean expected";
      }
      if (message2.persistedQueryHit != null && message2.hasOwnProperty("persistedQueryHit")) {
        if (typeof message2.persistedQueryHit !== "boolean")
          return "persistedQueryHit: boolean expected";
      }
      if (message2.persistedQueryRegister != null && message2.hasOwnProperty("persistedQueryRegister")) {
        if (typeof message2.persistedQueryRegister !== "boolean")
          return "persistedQueryRegister: boolean expected";
      }
      if (message2.registeredOperation != null && message2.hasOwnProperty("registeredOperation")) {
        if (typeof message2.registeredOperation !== "boolean")
          return "registeredOperation: boolean expected";
      }
      if (message2.forbiddenOperation != null && message2.hasOwnProperty("forbiddenOperation")) {
        if (typeof message2.forbiddenOperation !== "boolean")
          return "forbiddenOperation: boolean expected";
      }
      if (message2.fieldExecutionWeight != null && message2.hasOwnProperty("fieldExecutionWeight")) {
        if (typeof message2.fieldExecutionWeight !== "number")
          return "fieldExecutionWeight: number expected";
      }
      return null;
    };
    Trace.toObject = function toObject(message2, options) {
      if (!options)
        options = {};
      var object = {};
      if (options.defaults) {
        object.endTime = null;
        object.startTime = null;
        object.details = null;
        object.clientName = "";
        object.clientVersion = "";
        object.http = null;
        object.durationNs = 0;
        object.root = null;
        object.cachePolicy = null;
        object.signature = "";
        object.fullQueryCacheHit = false;
        object.persistedQueryHit = false;
        object.persistedQueryRegister = false;
        object.registeredOperation = false;
        object.forbiddenOperation = false;
        object.queryPlan = null;
        object.unexecutedOperationBody = "";
        object.unexecutedOperationName = "";
        object.fieldExecutionWeight = 0;
        object.isIncomplete = false;
      }
      if (message2.endTime != null && message2.hasOwnProperty("endTime"))
        object.endTime = $root.google.protobuf.Timestamp.toObject(message2.endTime, options);
      if (message2.startTime != null && message2.hasOwnProperty("startTime"))
        object.startTime = $root.google.protobuf.Timestamp.toObject(message2.startTime, options);
      if (message2.details != null && message2.hasOwnProperty("details"))
        object.details = $root.Trace.Details.toObject(message2.details, options);
      if (message2.clientName != null && message2.hasOwnProperty("clientName"))
        object.clientName = message2.clientName;
      if (message2.clientVersion != null && message2.hasOwnProperty("clientVersion"))
        object.clientVersion = message2.clientVersion;
      if (message2.http != null && message2.hasOwnProperty("http"))
        object.http = $root.Trace.HTTP.toObject(message2.http, options);
      if (message2.durationNs != null && message2.hasOwnProperty("durationNs"))
        if (typeof message2.durationNs === "number")
          object.durationNs = options.longs === String ? String(message2.durationNs) : message2.durationNs;
        else
          object.durationNs = options.longs === String ? $util.Long.prototype.toString.call(message2.durationNs) : options.longs === Number ? new $util.LongBits(message2.durationNs.low >>> 0, message2.durationNs.high >>> 0).toNumber(true) : message2.durationNs;
      if (message2.root != null && message2.hasOwnProperty("root"))
        object.root = $root.Trace.Node.toObject(message2.root, options);
      if (message2.cachePolicy != null && message2.hasOwnProperty("cachePolicy"))
        object.cachePolicy = $root.Trace.CachePolicy.toObject(message2.cachePolicy, options);
      if (message2.signature != null && message2.hasOwnProperty("signature"))
        object.signature = message2.signature;
      if (message2.fullQueryCacheHit != null && message2.hasOwnProperty("fullQueryCacheHit"))
        object.fullQueryCacheHit = message2.fullQueryCacheHit;
      if (message2.persistedQueryHit != null && message2.hasOwnProperty("persistedQueryHit"))
        object.persistedQueryHit = message2.persistedQueryHit;
      if (message2.persistedQueryRegister != null && message2.hasOwnProperty("persistedQueryRegister"))
        object.persistedQueryRegister = message2.persistedQueryRegister;
      if (message2.registeredOperation != null && message2.hasOwnProperty("registeredOperation"))
        object.registeredOperation = message2.registeredOperation;
      if (message2.forbiddenOperation != null && message2.hasOwnProperty("forbiddenOperation"))
        object.forbiddenOperation = message2.forbiddenOperation;
      if (message2.queryPlan != null && message2.hasOwnProperty("queryPlan"))
        object.queryPlan = $root.Trace.QueryPlanNode.toObject(message2.queryPlan, options);
      if (message2.unexecutedOperationBody != null && message2.hasOwnProperty("unexecutedOperationBody"))
        object.unexecutedOperationBody = message2.unexecutedOperationBody;
      if (message2.unexecutedOperationName != null && message2.hasOwnProperty("unexecutedOperationName"))
        object.unexecutedOperationName = message2.unexecutedOperationName;
      if (message2.fieldExecutionWeight != null && message2.hasOwnProperty("fieldExecutionWeight"))
        object.fieldExecutionWeight = options.json && !isFinite(message2.fieldExecutionWeight) ? String(message2.fieldExecutionWeight) : message2.fieldExecutionWeight;
      if (message2.isIncomplete != null && message2.hasOwnProperty("isIncomplete"))
        object.isIncomplete = message2.isIncomplete;
      return object;
    };
    Trace.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };
    Trace.CachePolicy = function() {
      function CachePolicy(properties) {
        if (properties) {
          for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      CachePolicy.prototype.scope = 0;
      CachePolicy.prototype.maxAgeNs = 0;
      CachePolicy.create = function create(properties) {
        return new CachePolicy(properties);
      };
      CachePolicy.encode = function encode(message2, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message2.scope != null && Object.hasOwnProperty.call(message2, "scope"))
          writer.uint32(8).int32(message2.scope);
        if (message2.maxAgeNs != null && Object.hasOwnProperty.call(message2, "maxAgeNs"))
          writer.uint32(16).int64(message2.maxAgeNs);
        return writer;
      };
      CachePolicy.encodeDelimited = function encodeDelimited(message2, writer) {
        return this.encode(message2, writer).ldelim();
      };
      CachePolicy.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message2 = new $root.Trace.CachePolicy;
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message2.scope = reader.int32();
              break;
            case 2:
              message2.maxAgeNs = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message2;
      };
      CachePolicy.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };
      CachePolicy.verify = function verify(message2) {
        if (typeof message2 !== "object" || message2 === null)
          return "object expected";
        if (message2.scope != null && message2.hasOwnProperty("scope"))
          switch (message2.scope) {
            default:
              return "scope: enum value expected";
            case 0:
            case 1:
            case 2:
              break;
          }
        if (message2.maxAgeNs != null && message2.hasOwnProperty("maxAgeNs")) {
          if (!$util.isInteger(message2.maxAgeNs) && !(message2.maxAgeNs && $util.isInteger(message2.maxAgeNs.low) && $util.isInteger(message2.maxAgeNs.high)))
            return "maxAgeNs: integer|Long expected";
        }
        return null;
      };
      CachePolicy.toObject = function toObject(message2, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.defaults) {
          object.scope = options.enums === String ? "UNKNOWN" : 0;
          object.maxAgeNs = 0;
        }
        if (message2.scope != null && message2.hasOwnProperty("scope"))
          object.scope = options.enums === String ? $root.Trace.CachePolicy.Scope[message2.scope] : message2.scope;
        if (message2.maxAgeNs != null && message2.hasOwnProperty("maxAgeNs"))
          if (typeof message2.maxAgeNs === "number")
            object.maxAgeNs = options.longs === String ? String(message2.maxAgeNs) : message2.maxAgeNs;
          else
            object.maxAgeNs = options.longs === String ? $util.Long.prototype.toString.call(message2.maxAgeNs) : options.longs === Number ? new $util.LongBits(message2.maxAgeNs.low >>> 0, message2.maxAgeNs.high >>> 0).toNumber() : message2.maxAgeNs;
        return object;
      };
      CachePolicy.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };
      CachePolicy.Scope = function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "UNKNOWN"] = 0;
        values[valuesById[1] = "PUBLIC"] = 1;
        values[valuesById[2] = "PRIVATE"] = 2;
        return values;
      }();
      return CachePolicy;
    }();
    Trace.Details = function() {
      function Details(properties) {
        this.variablesJson = {};
        if (properties) {
          for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      Details.prototype.variablesJson = $util.emptyObject;
      Details.prototype.operationName = "";
      Details.create = function create(properties) {
        return new Details(properties);
      };
      Details.encode = function encode(message2, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message2.operationName != null && Object.hasOwnProperty.call(message2, "operationName"))
          writer.uint32(26).string(message2.operationName);
        if (message2.variablesJson != null && Object.hasOwnProperty.call(message2, "variablesJson"))
          for (var keys = Object.keys(message2.variablesJson), i = 0;i < keys.length; ++i)
            writer.uint32(34).fork().uint32(10).string(keys[i]).uint32(18).string(message2.variablesJson[keys[i]]).ldelim();
        return writer;
      };
      Details.encodeDelimited = function encodeDelimited(message2, writer) {
        return this.encode(message2, writer).ldelim();
      };
      Details.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message2 = new $root.Trace.Details, key;
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 4:
              reader.skip().pos++;
              if (message2.variablesJson === $util.emptyObject)
                message2.variablesJson = {};
              key = reader.string();
              reader.pos++;
              message2.variablesJson[key] = reader.string();
              break;
            case 3:
              message2.operationName = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message2;
      };
      Details.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };
      Details.verify = function verify(message2) {
        if (typeof message2 !== "object" || message2 === null)
          return "object expected";
        if (message2.variablesJson != null && message2.hasOwnProperty("variablesJson")) {
          if (!$util.isObject(message2.variablesJson))
            return "variablesJson: object expected";
          var key = Object.keys(message2.variablesJson);
          for (var i = 0;i < key.length; ++i)
            if (!$util.isString(message2.variablesJson[key[i]]))
              return "variablesJson: string{k:string} expected";
        }
        if (message2.operationName != null && message2.hasOwnProperty("operationName")) {
          if (!$util.isString(message2.operationName))
            return "operationName: string expected";
        }
        return null;
      };
      Details.toObject = function toObject(message2, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.objects || options.defaults)
          object.variablesJson = {};
        if (options.defaults)
          object.operationName = "";
        if (message2.operationName != null && message2.hasOwnProperty("operationName"))
          object.operationName = message2.operationName;
        var keys2;
        if (message2.variablesJson && (keys2 = Object.keys(message2.variablesJson)).length) {
          object.variablesJson = {};
          for (var j = 0;j < keys2.length; ++j)
            object.variablesJson[keys2[j]] = message2.variablesJson[keys2[j]];
        }
        return object;
      };
      Details.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };
      return Details;
    }();
    Trace.Error = function() {
      function Error2(properties) {
        this.location = [];
        if (properties) {
          for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      Error2.prototype.message = "";
      Error2.prototype.location = $util.emptyArray;
      Error2.prototype.timeNs = 0;
      Error2.prototype.json = "";
      Error2.create = function create(properties) {
        return new Error2(properties);
      };
      Error2.encode = function encode(message2, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message2.message != null && Object.hasOwnProperty.call(message2, "message"))
          writer.uint32(10).string(message2.message);
        if (message2.location != null && message2.location.length)
          for (var i = 0;i < message2.location.length; ++i)
            $root.Trace.Location.encode(message2.location[i], writer.uint32(18).fork()).ldelim();
        if (message2.timeNs != null && Object.hasOwnProperty.call(message2, "timeNs"))
          writer.uint32(24).uint64(message2.timeNs);
        if (message2.json != null && Object.hasOwnProperty.call(message2, "json"))
          writer.uint32(34).string(message2.json);
        return writer;
      };
      Error2.encodeDelimited = function encodeDelimited(message2, writer) {
        return this.encode(message2, writer).ldelim();
      };
      Error2.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message2 = new $root.Trace.Error;
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message2.message = reader.string();
              break;
            case 2:
              if (!(message2.location && message2.location.length))
                message2.location = [];
              message2.location.push($root.Trace.Location.decode(reader, reader.uint32()));
              break;
            case 3:
              message2.timeNs = reader.uint64();
              break;
            case 4:
              message2.json = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message2;
      };
      Error2.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };
      Error2.verify = function verify(message2) {
        if (typeof message2 !== "object" || message2 === null)
          return "object expected";
        if (message2.message != null && message2.hasOwnProperty("message")) {
          if (!$util.isString(message2.message))
            return "message: string expected";
        }
        if (message2.location != null && message2.hasOwnProperty("location")) {
          if (!Array.isArray(message2.location))
            return "location: array expected";
          for (var i = 0;i < message2.location.length; ++i) {
            var error = $root.Trace.Location.verify(message2.location[i]);
            if (error)
              return "location." + error;
          }
        }
        if (message2.timeNs != null && message2.hasOwnProperty("timeNs")) {
          if (!$util.isInteger(message2.timeNs) && !(message2.timeNs && $util.isInteger(message2.timeNs.low) && $util.isInteger(message2.timeNs.high)))
            return "timeNs: integer|Long expected";
        }
        if (message2.json != null && message2.hasOwnProperty("json")) {
          if (!$util.isString(message2.json))
            return "json: string expected";
        }
        return null;
      };
      Error2.toObject = function toObject(message2, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.arrays || options.defaults)
          object.location = [];
        if (options.defaults) {
          object.message = "";
          object.timeNs = 0;
          object.json = "";
        }
        if (message2.message != null && message2.hasOwnProperty("message"))
          object.message = message2.message;
        if (message2.location && message2.location.length) {
          object.location = [];
          for (var j = 0;j < message2.location.length; ++j)
            object.location[j] = $root.Trace.Location.toObject(message2.location[j], options);
        }
        if (message2.timeNs != null && message2.hasOwnProperty("timeNs"))
          if (typeof message2.timeNs === "number")
            object.timeNs = options.longs === String ? String(message2.timeNs) : message2.timeNs;
          else
            object.timeNs = options.longs === String ? $util.Long.prototype.toString.call(message2.timeNs) : options.longs === Number ? new $util.LongBits(message2.timeNs.low >>> 0, message2.timeNs.high >>> 0).toNumber(true) : message2.timeNs;
        if (message2.json != null && message2.hasOwnProperty("json"))
          object.json = message2.json;
        return object;
      };
      Error2.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };
      return Error2;
    }();
    Trace.HTTP = function() {
      function HTTP(properties) {
        this.requestHeaders = {};
        this.responseHeaders = {};
        if (properties) {
          for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      HTTP.prototype.method = 0;
      HTTP.prototype.requestHeaders = $util.emptyObject;
      HTTP.prototype.responseHeaders = $util.emptyObject;
      HTTP.prototype.statusCode = 0;
      HTTP.create = function create(properties) {
        return new HTTP(properties);
      };
      HTTP.encode = function encode(message2, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message2.method != null && Object.hasOwnProperty.call(message2, "method"))
          writer.uint32(8).int32(message2.method);
        if (message2.requestHeaders != null && Object.hasOwnProperty.call(message2, "requestHeaders"))
          for (var keys = Object.keys(message2.requestHeaders), i = 0;i < keys.length; ++i) {
            writer.uint32(34).fork().uint32(10).string(keys[i]);
            $root.Trace.HTTP.Values.encode(message2.requestHeaders[keys[i]], writer.uint32(18).fork()).ldelim().ldelim();
          }
        if (message2.responseHeaders != null && Object.hasOwnProperty.call(message2, "responseHeaders"))
          for (var keys = Object.keys(message2.responseHeaders), i = 0;i < keys.length; ++i) {
            writer.uint32(42).fork().uint32(10).string(keys[i]);
            $root.Trace.HTTP.Values.encode(message2.responseHeaders[keys[i]], writer.uint32(18).fork()).ldelim().ldelim();
          }
        if (message2.statusCode != null && Object.hasOwnProperty.call(message2, "statusCode"))
          writer.uint32(48).uint32(message2.statusCode);
        return writer;
      };
      HTTP.encodeDelimited = function encodeDelimited(message2, writer) {
        return this.encode(message2, writer).ldelim();
      };
      HTTP.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message2 = new $root.Trace.HTTP, key;
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message2.method = reader.int32();
              break;
            case 4:
              reader.skip().pos++;
              if (message2.requestHeaders === $util.emptyObject)
                message2.requestHeaders = {};
              key = reader.string();
              reader.pos++;
              message2.requestHeaders[key] = $root.Trace.HTTP.Values.decode(reader, reader.uint32());
              break;
            case 5:
              reader.skip().pos++;
              if (message2.responseHeaders === $util.emptyObject)
                message2.responseHeaders = {};
              key = reader.string();
              reader.pos++;
              message2.responseHeaders[key] = $root.Trace.HTTP.Values.decode(reader, reader.uint32());
              break;
            case 6:
              message2.statusCode = reader.uint32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message2;
      };
      HTTP.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };
      HTTP.verify = function verify(message2) {
        if (typeof message2 !== "object" || message2 === null)
          return "object expected";
        if (message2.method != null && message2.hasOwnProperty("method"))
          switch (message2.method) {
            default:
              return "method: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
              break;
          }
        if (message2.requestHeaders != null && message2.hasOwnProperty("requestHeaders")) {
          if (!$util.isObject(message2.requestHeaders))
            return "requestHeaders: object expected";
          var key = Object.keys(message2.requestHeaders);
          for (var i = 0;i < key.length; ++i) {
            var error = $root.Trace.HTTP.Values.verify(message2.requestHeaders[key[i]]);
            if (error)
              return "requestHeaders." + error;
          }
        }
        if (message2.responseHeaders != null && message2.hasOwnProperty("responseHeaders")) {
          if (!$util.isObject(message2.responseHeaders))
            return "responseHeaders: object expected";
          var key = Object.keys(message2.responseHeaders);
          for (var i = 0;i < key.length; ++i) {
            var error = $root.Trace.HTTP.Values.verify(message2.responseHeaders[key[i]]);
            if (error)
              return "responseHeaders." + error;
          }
        }
        if (message2.statusCode != null && message2.hasOwnProperty("statusCode")) {
          if (!$util.isInteger(message2.statusCode))
            return "statusCode: integer expected";
        }
        return null;
      };
      HTTP.toObject = function toObject(message2, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.objects || options.defaults) {
          object.requestHeaders = {};
          object.responseHeaders = {};
        }
        if (options.defaults) {
          object.method = options.enums === String ? "UNKNOWN" : 0;
          object.statusCode = 0;
        }
        if (message2.method != null && message2.hasOwnProperty("method"))
          object.method = options.enums === String ? $root.Trace.HTTP.Method[message2.method] : message2.method;
        var keys2;
        if (message2.requestHeaders && (keys2 = Object.keys(message2.requestHeaders)).length) {
          object.requestHeaders = {};
          for (var j = 0;j < keys2.length; ++j)
            object.requestHeaders[keys2[j]] = $root.Trace.HTTP.Values.toObject(message2.requestHeaders[keys2[j]], options);
        }
        if (message2.responseHeaders && (keys2 = Object.keys(message2.responseHeaders)).length) {
          object.responseHeaders = {};
          for (var j = 0;j < keys2.length; ++j)
            object.responseHeaders[keys2[j]] = $root.Trace.HTTP.Values.toObject(message2.responseHeaders[keys2[j]], options);
        }
        if (message2.statusCode != null && message2.hasOwnProperty("statusCode"))
          object.statusCode = message2.statusCode;
        return object;
      };
      HTTP.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };
      HTTP.Values = function() {
        function Values(properties) {
          this.value = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        Values.prototype.value = $util.emptyArray;
        Values.create = function create(properties) {
          return new Values(properties);
        };
        Values.encode = function encode(message2, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message2.value != null && message2.value.length)
            for (var i = 0;i < message2.value.length; ++i)
              writer.uint32(10).string(message2.value[i]);
          return writer;
        };
        Values.encodeDelimited = function encodeDelimited(message2, writer) {
          return this.encode(message2, writer).ldelim();
        };
        Values.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message2 = new $root.Trace.HTTP.Values;
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                if (!(message2.value && message2.value.length))
                  message2.value = [];
                message2.value.push(reader.string());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message2;
        };
        Values.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        Values.verify = function verify(message2) {
          if (typeof message2 !== "object" || message2 === null)
            return "object expected";
          if (message2.value != null && message2.hasOwnProperty("value")) {
            if (!Array.isArray(message2.value))
              return "value: array expected";
            for (var i = 0;i < message2.value.length; ++i)
              if (!$util.isString(message2.value[i]))
                return "value: string[] expected";
          }
          return null;
        };
        Values.toObject = function toObject(message2, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.arrays || options.defaults)
            object.value = [];
          if (message2.value && message2.value.length) {
            object.value = [];
            for (var j = 0;j < message2.value.length; ++j)
              object.value[j] = message2.value[j];
          }
          return object;
        };
        Values.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return Values;
      }();
      HTTP.Method = function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "UNKNOWN"] = 0;
        values[valuesById[1] = "OPTIONS"] = 1;
        values[valuesById[2] = "GET"] = 2;
        values[valuesById[3] = "HEAD"] = 3;
        values[valuesById[4] = "POST"] = 4;
        values[valuesById[5] = "PUT"] = 5;
        values[valuesById[6] = "DELETE"] = 6;
        values[valuesById[7] = "TRACE"] = 7;
        values[valuesById[8] = "CONNECT"] = 8;
        values[valuesById[9] = "PATCH"] = 9;
        return values;
      }();
      return HTTP;
    }();
    Trace.Location = function() {
      function Location(properties) {
        if (properties) {
          for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      Location.prototype.line = 0;
      Location.prototype.column = 0;
      Location.create = function create(properties) {
        return new Location(properties);
      };
      Location.encode = function encode(message2, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message2.line != null && Object.hasOwnProperty.call(message2, "line"))
          writer.uint32(8).uint32(message2.line);
        if (message2.column != null && Object.hasOwnProperty.call(message2, "column"))
          writer.uint32(16).uint32(message2.column);
        return writer;
      };
      Location.encodeDelimited = function encodeDelimited(message2, writer) {
        return this.encode(message2, writer).ldelim();
      };
      Location.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message2 = new $root.Trace.Location;
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message2.line = reader.uint32();
              break;
            case 2:
              message2.column = reader.uint32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message2;
      };
      Location.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };
      Location.verify = function verify(message2) {
        if (typeof message2 !== "object" || message2 === null)
          return "object expected";
        if (message2.line != null && message2.hasOwnProperty("line")) {
          if (!$util.isInteger(message2.line))
            return "line: integer expected";
        }
        if (message2.column != null && message2.hasOwnProperty("column")) {
          if (!$util.isInteger(message2.column))
            return "column: integer expected";
        }
        return null;
      };
      Location.toObject = function toObject(message2, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.defaults) {
          object.line = 0;
          object.column = 0;
        }
        if (message2.line != null && message2.hasOwnProperty("line"))
          object.line = message2.line;
        if (message2.column != null && message2.hasOwnProperty("column"))
          object.column = message2.column;
        return object;
      };
      Location.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };
      return Location;
    }();
    Trace.Node = function() {
      function Node(properties) {
        this.error = [];
        this.child = [];
        if (properties) {
          for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      Node.prototype.responseName = "";
      Node.prototype.index = 0;
      Node.prototype.originalFieldName = "";
      Node.prototype.type = "";
      Node.prototype.parentType = "";
      Node.prototype.cachePolicy = null;
      Node.prototype.startTime = 0;
      Node.prototype.endTime = 0;
      Node.prototype.error = $util.emptyArray;
      Node.prototype.child = $util.emptyArray;
      var $oneOfFields;
      Object.defineProperty(Node.prototype, "id", {
        get: $util.oneOfGetter($oneOfFields = ["responseName", "index"]),
        set: $util.oneOfSetter($oneOfFields)
      });
      Node.create = function create(properties) {
        return new Node(properties);
      };
      Node.encode = function encode(message2, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message2.responseName != null && Object.hasOwnProperty.call(message2, "responseName"))
          writer.uint32(10).string(message2.responseName);
        if (message2.index != null && Object.hasOwnProperty.call(message2, "index"))
          writer.uint32(16).uint32(message2.index);
        if (message2.type != null && Object.hasOwnProperty.call(message2, "type"))
          writer.uint32(26).string(message2.type);
        if (message2.cachePolicy != null && Object.hasOwnProperty.call(message2, "cachePolicy"))
          $root.Trace.CachePolicy.encode(message2.cachePolicy, writer.uint32(42).fork()).ldelim();
        if (message2.startTime != null && Object.hasOwnProperty.call(message2, "startTime"))
          writer.uint32(64).uint64(message2.startTime);
        if (message2.endTime != null && Object.hasOwnProperty.call(message2, "endTime"))
          writer.uint32(72).uint64(message2.endTime);
        if (message2.error != null && message2.error.length)
          for (var i = 0;i < message2.error.length; ++i)
            $root.Trace.Error.encode(message2.error[i], writer.uint32(90).fork()).ldelim();
        if (message2.child != null && message2.child.length)
          for (var i = 0;i < message2.child.length; ++i)
            $root.Trace.Node.encode(message2.child[i], writer.uint32(98).fork()).ldelim();
        if (message2.parentType != null && Object.hasOwnProperty.call(message2, "parentType"))
          writer.uint32(106).string(message2.parentType);
        if (message2.originalFieldName != null && Object.hasOwnProperty.call(message2, "originalFieldName"))
          writer.uint32(114).string(message2.originalFieldName);
        return writer;
      };
      Node.encodeDelimited = function encodeDelimited(message2, writer) {
        return this.encode(message2, writer).ldelim();
      };
      Node.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message2 = new $root.Trace.Node;
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message2.responseName = reader.string();
              break;
            case 2:
              message2.index = reader.uint32();
              break;
            case 14:
              message2.originalFieldName = reader.string();
              break;
            case 3:
              message2.type = reader.string();
              break;
            case 13:
              message2.parentType = reader.string();
              break;
            case 5:
              message2.cachePolicy = $root.Trace.CachePolicy.decode(reader, reader.uint32());
              break;
            case 8:
              message2.startTime = reader.uint64();
              break;
            case 9:
              message2.endTime = reader.uint64();
              break;
            case 11:
              if (!(message2.error && message2.error.length))
                message2.error = [];
              message2.error.push($root.Trace.Error.decode(reader, reader.uint32()));
              break;
            case 12:
              if (!(message2.child && message2.child.length))
                message2.child = [];
              message2.child.push($root.Trace.Node.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message2;
      };
      Node.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };
      Node.verify = function verify(message2) {
        if (typeof message2 !== "object" || message2 === null)
          return "object expected";
        var properties = {};
        if (message2.responseName != null && message2.hasOwnProperty("responseName")) {
          properties.id = 1;
          if (!$util.isString(message2.responseName))
            return "responseName: string expected";
        }
        if (message2.index != null && message2.hasOwnProperty("index")) {
          if (properties.id === 1)
            return "id: multiple values";
          properties.id = 1;
          if (!$util.isInteger(message2.index))
            return "index: integer expected";
        }
        if (message2.originalFieldName != null && message2.hasOwnProperty("originalFieldName")) {
          if (!$util.isString(message2.originalFieldName))
            return "originalFieldName: string expected";
        }
        if (message2.type != null && message2.hasOwnProperty("type")) {
          if (!$util.isString(message2.type))
            return "type: string expected";
        }
        if (message2.parentType != null && message2.hasOwnProperty("parentType")) {
          if (!$util.isString(message2.parentType))
            return "parentType: string expected";
        }
        if (message2.cachePolicy != null && message2.hasOwnProperty("cachePolicy")) {
          var error = $root.Trace.CachePolicy.verify(message2.cachePolicy);
          if (error)
            return "cachePolicy." + error;
        }
        if (message2.startTime != null && message2.hasOwnProperty("startTime")) {
          if (!$util.isInteger(message2.startTime) && !(message2.startTime && $util.isInteger(message2.startTime.low) && $util.isInteger(message2.startTime.high)))
            return "startTime: integer|Long expected";
        }
        if (message2.endTime != null && message2.hasOwnProperty("endTime")) {
          if (!$util.isInteger(message2.endTime) && !(message2.endTime && $util.isInteger(message2.endTime.low) && $util.isInteger(message2.endTime.high)))
            return "endTime: integer|Long expected";
        }
        if (message2.error != null && message2.hasOwnProperty("error")) {
          if (!Array.isArray(message2.error))
            return "error: array expected";
          for (var i = 0;i < message2.error.length; ++i) {
            var error = $root.Trace.Error.verify(message2.error[i]);
            if (error)
              return "error." + error;
          }
        }
        if (message2.child != null && message2.hasOwnProperty("child")) {
          if (!Array.isArray(message2.child))
            return "child: array expected";
          for (var i = 0;i < message2.child.length; ++i) {
            var error = $root.Trace.Node.verify(message2.child[i]);
            if (error)
              return "child." + error;
          }
        }
        return null;
      };
      Node.toObject = function toObject(message2, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.arrays || options.defaults) {
          object.error = [];
          object.child = [];
        }
        if (options.defaults) {
          object.type = "";
          object.cachePolicy = null;
          object.startTime = 0;
          object.endTime = 0;
          object.parentType = "";
          object.originalFieldName = "";
        }
        if (message2.responseName != null && message2.hasOwnProperty("responseName")) {
          object.responseName = message2.responseName;
          if (options.oneofs)
            object.id = "responseName";
        }
        if (message2.index != null && message2.hasOwnProperty("index")) {
          object.index = message2.index;
          if (options.oneofs)
            object.id = "index";
        }
        if (message2.type != null && message2.hasOwnProperty("type"))
          object.type = message2.type;
        if (message2.cachePolicy != null && message2.hasOwnProperty("cachePolicy"))
          object.cachePolicy = $root.Trace.CachePolicy.toObject(message2.cachePolicy, options);
        if (message2.startTime != null && message2.hasOwnProperty("startTime"))
          if (typeof message2.startTime === "number")
            object.startTime = options.longs === String ? String(message2.startTime) : message2.startTime;
          else
            object.startTime = options.longs === String ? $util.Long.prototype.toString.call(message2.startTime) : options.longs === Number ? new $util.LongBits(message2.startTime.low >>> 0, message2.startTime.high >>> 0).toNumber(true) : message2.startTime;
        if (message2.endTime != null && message2.hasOwnProperty("endTime"))
          if (typeof message2.endTime === "number")
            object.endTime = options.longs === String ? String(message2.endTime) : message2.endTime;
          else
            object.endTime = options.longs === String ? $util.Long.prototype.toString.call(message2.endTime) : options.longs === Number ? new $util.LongBits(message2.endTime.low >>> 0, message2.endTime.high >>> 0).toNumber(true) : message2.endTime;
        if (message2.error && message2.error.length) {
          object.error = [];
          for (var j = 0;j < message2.error.length; ++j)
            object.error[j] = $root.Trace.Error.toObject(message2.error[j], options);
        }
        if (message2.child && message2.child.length) {
          object.child = [];
          for (var j = 0;j < message2.child.length; ++j)
            object.child[j] = $root.Trace.Node.toObject(message2.child[j], options);
        }
        if (message2.parentType != null && message2.hasOwnProperty("parentType"))
          object.parentType = message2.parentType;
        if (message2.originalFieldName != null && message2.hasOwnProperty("originalFieldName"))
          object.originalFieldName = message2.originalFieldName;
        return object;
      };
      Node.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };
      return Node;
    }();
    Trace.QueryPlanNode = function() {
      function QueryPlanNode(properties) {
        if (properties) {
          for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      QueryPlanNode.prototype.sequence = null;
      QueryPlanNode.prototype.parallel = null;
      QueryPlanNode.prototype.fetch = null;
      QueryPlanNode.prototype.flatten = null;
      QueryPlanNode.prototype.defer = null;
      QueryPlanNode.prototype.condition = null;
      var $oneOfFields;
      Object.defineProperty(QueryPlanNode.prototype, "node", {
        get: $util.oneOfGetter($oneOfFields = ["sequence", "parallel", "fetch", "flatten", "defer", "condition"]),
        set: $util.oneOfSetter($oneOfFields)
      });
      QueryPlanNode.create = function create(properties) {
        return new QueryPlanNode(properties);
      };
      QueryPlanNode.encode = function encode(message2, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message2.sequence != null && Object.hasOwnProperty.call(message2, "sequence"))
          $root.Trace.QueryPlanNode.SequenceNode.encode(message2.sequence, writer.uint32(10).fork()).ldelim();
        if (message2.parallel != null && Object.hasOwnProperty.call(message2, "parallel"))
          $root.Trace.QueryPlanNode.ParallelNode.encode(message2.parallel, writer.uint32(18).fork()).ldelim();
        if (message2.fetch != null && Object.hasOwnProperty.call(message2, "fetch"))
          $root.Trace.QueryPlanNode.FetchNode.encode(message2.fetch, writer.uint32(26).fork()).ldelim();
        if (message2.flatten != null && Object.hasOwnProperty.call(message2, "flatten"))
          $root.Trace.QueryPlanNode.FlattenNode.encode(message2.flatten, writer.uint32(34).fork()).ldelim();
        if (message2.defer != null && Object.hasOwnProperty.call(message2, "defer"))
          $root.Trace.QueryPlanNode.DeferNode.encode(message2.defer, writer.uint32(42).fork()).ldelim();
        if (message2.condition != null && Object.hasOwnProperty.call(message2, "condition"))
          $root.Trace.QueryPlanNode.ConditionNode.encode(message2.condition, writer.uint32(50).fork()).ldelim();
        return writer;
      };
      QueryPlanNode.encodeDelimited = function encodeDelimited(message2, writer) {
        return this.encode(message2, writer).ldelim();
      };
      QueryPlanNode.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message2 = new $root.Trace.QueryPlanNode;
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message2.sequence = $root.Trace.QueryPlanNode.SequenceNode.decode(reader, reader.uint32());
              break;
            case 2:
              message2.parallel = $root.Trace.QueryPlanNode.ParallelNode.decode(reader, reader.uint32());
              break;
            case 3:
              message2.fetch = $root.Trace.QueryPlanNode.FetchNode.decode(reader, reader.uint32());
              break;
            case 4:
              message2.flatten = $root.Trace.QueryPlanNode.FlattenNode.decode(reader, reader.uint32());
              break;
            case 5:
              message2.defer = $root.Trace.QueryPlanNode.DeferNode.decode(reader, reader.uint32());
              break;
            case 6:
              message2.condition = $root.Trace.QueryPlanNode.ConditionNode.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message2;
      };
      QueryPlanNode.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };
      QueryPlanNode.verify = function verify(message2) {
        if (typeof message2 !== "object" || message2 === null)
          return "object expected";
        var properties = {};
        if (message2.sequence != null && message2.hasOwnProperty("sequence")) {
          properties.node = 1;
          {
            var error = $root.Trace.QueryPlanNode.SequenceNode.verify(message2.sequence);
            if (error)
              return "sequence." + error;
          }
        }
        if (message2.parallel != null && message2.hasOwnProperty("parallel")) {
          if (properties.node === 1)
            return "node: multiple values";
          properties.node = 1;
          {
            var error = $root.Trace.QueryPlanNode.ParallelNode.verify(message2.parallel);
            if (error)
              return "parallel." + error;
          }
        }
        if (message2.fetch != null && message2.hasOwnProperty("fetch")) {
          if (properties.node === 1)
            return "node: multiple values";
          properties.node = 1;
          {
            var error = $root.Trace.QueryPlanNode.FetchNode.verify(message2.fetch);
            if (error)
              return "fetch." + error;
          }
        }
        if (message2.flatten != null && message2.hasOwnProperty("flatten")) {
          if (properties.node === 1)
            return "node: multiple values";
          properties.node = 1;
          {
            var error = $root.Trace.QueryPlanNode.FlattenNode.verify(message2.flatten);
            if (error)
              return "flatten." + error;
          }
        }
        if (message2.defer != null && message2.hasOwnProperty("defer")) {
          if (properties.node === 1)
            return "node: multiple values";
          properties.node = 1;
          {
            var error = $root.Trace.QueryPlanNode.DeferNode.verify(message2.defer);
            if (error)
              return "defer." + error;
          }
        }
        if (message2.condition != null && message2.hasOwnProperty("condition")) {
          if (properties.node === 1)
            return "node: multiple values";
          properties.node = 1;
          {
            var error = $root.Trace.QueryPlanNode.ConditionNode.verify(message2.condition);
            if (error)
              return "condition." + error;
          }
        }
        return null;
      };
      QueryPlanNode.toObject = function toObject(message2, options) {
        if (!options)
          options = {};
        var object = {};
        if (message2.sequence != null && message2.hasOwnProperty("sequence")) {
          object.sequence = $root.Trace.QueryPlanNode.SequenceNode.toObject(message2.sequence, options);
          if (options.oneofs)
            object.node = "sequence";
        }
        if (message2.parallel != null && message2.hasOwnProperty("parallel")) {
          object.parallel = $root.Trace.QueryPlanNode.ParallelNode.toObject(message2.parallel, options);
          if (options.oneofs)
            object.node = "parallel";
        }
        if (message2.fetch != null && message2.hasOwnProperty("fetch")) {
          object.fetch = $root.Trace.QueryPlanNode.FetchNode.toObject(message2.fetch, options);
          if (options.oneofs)
            object.node = "fetch";
        }
        if (message2.flatten != null && message2.hasOwnProperty("flatten")) {
          object.flatten = $root.Trace.QueryPlanNode.FlattenNode.toObject(message2.flatten, options);
          if (options.oneofs)
            object.node = "flatten";
        }
        if (message2.defer != null && message2.hasOwnProperty("defer")) {
          object.defer = $root.Trace.QueryPlanNode.DeferNode.toObject(message2.defer, options);
          if (options.oneofs)
            object.node = "defer";
        }
        if (message2.condition != null && message2.hasOwnProperty("condition")) {
          object.condition = $root.Trace.QueryPlanNode.ConditionNode.toObject(message2.condition, options);
          if (options.oneofs)
            object.node = "condition";
        }
        return object;
      };
      QueryPlanNode.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };
      QueryPlanNode.SequenceNode = function() {
        function SequenceNode(properties) {
          this.nodes = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        SequenceNode.prototype.nodes = $util.emptyArray;
        SequenceNode.create = function create(properties) {
          return new SequenceNode(properties);
        };
        SequenceNode.encode = function encode(message2, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message2.nodes != null && message2.nodes.length)
            for (var i = 0;i < message2.nodes.length; ++i)
              $root.Trace.QueryPlanNode.encode(message2.nodes[i], writer.uint32(10).fork()).ldelim();
          return writer;
        };
        SequenceNode.encodeDelimited = function encodeDelimited(message2, writer) {
          return this.encode(message2, writer).ldelim();
        };
        SequenceNode.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message2 = new $root.Trace.QueryPlanNode.SequenceNode;
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                if (!(message2.nodes && message2.nodes.length))
                  message2.nodes = [];
                message2.nodes.push($root.Trace.QueryPlanNode.decode(reader, reader.uint32()));
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message2;
        };
        SequenceNode.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        SequenceNode.verify = function verify(message2) {
          if (typeof message2 !== "object" || message2 === null)
            return "object expected";
          if (message2.nodes != null && message2.hasOwnProperty("nodes")) {
            if (!Array.isArray(message2.nodes))
              return "nodes: array expected";
            for (var i = 0;i < message2.nodes.length; ++i) {
              var error = $root.Trace.QueryPlanNode.verify(message2.nodes[i]);
              if (error)
                return "nodes." + error;
            }
          }
          return null;
        };
        SequenceNode.toObject = function toObject(message2, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.arrays || options.defaults)
            object.nodes = [];
          if (message2.nodes && message2.nodes.length) {
            object.nodes = [];
            for (var j = 0;j < message2.nodes.length; ++j)
              object.nodes[j] = $root.Trace.QueryPlanNode.toObject(message2.nodes[j], options);
          }
          return object;
        };
        SequenceNode.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return SequenceNode;
      }();
      QueryPlanNode.ParallelNode = function() {
        function ParallelNode(properties) {
          this.nodes = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        ParallelNode.prototype.nodes = $util.emptyArray;
        ParallelNode.create = function create(properties) {
          return new ParallelNode(properties);
        };
        ParallelNode.encode = function encode(message2, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message2.nodes != null && message2.nodes.length)
            for (var i = 0;i < message2.nodes.length; ++i)
              $root.Trace.QueryPlanNode.encode(message2.nodes[i], writer.uint32(10).fork()).ldelim();
          return writer;
        };
        ParallelNode.encodeDelimited = function encodeDelimited(message2, writer) {
          return this.encode(message2, writer).ldelim();
        };
        ParallelNode.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message2 = new $root.Trace.QueryPlanNode.ParallelNode;
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                if (!(message2.nodes && message2.nodes.length))
                  message2.nodes = [];
                message2.nodes.push($root.Trace.QueryPlanNode.decode(reader, reader.uint32()));
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message2;
        };
        ParallelNode.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        ParallelNode.verify = function verify(message2) {
          if (typeof message2 !== "object" || message2 === null)
            return "object expected";
          if (message2.nodes != null && message2.hasOwnProperty("nodes")) {
            if (!Array.isArray(message2.nodes))
              return "nodes: array expected";
            for (var i = 0;i < message2.nodes.length; ++i) {
              var error = $root.Trace.QueryPlanNode.verify(message2.nodes[i]);
              if (error)
                return "nodes." + error;
            }
          }
          return null;
        };
        ParallelNode.toObject = function toObject(message2, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.arrays || options.defaults)
            object.nodes = [];
          if (message2.nodes && message2.nodes.length) {
            object.nodes = [];
            for (var j = 0;j < message2.nodes.length; ++j)
              object.nodes[j] = $root.Trace.QueryPlanNode.toObject(message2.nodes[j], options);
          }
          return object;
        };
        ParallelNode.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return ParallelNode;
      }();
      QueryPlanNode.FetchNode = function() {
        function FetchNode(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        FetchNode.prototype.serviceName = "";
        FetchNode.prototype.traceParsingFailed = false;
        FetchNode.prototype.trace = null;
        FetchNode.prototype.sentTimeOffset = 0;
        FetchNode.prototype.sentTime = null;
        FetchNode.prototype.receivedTime = null;
        FetchNode.create = function create(properties) {
          return new FetchNode(properties);
        };
        FetchNode.encode = function encode(message2, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message2.serviceName != null && Object.hasOwnProperty.call(message2, "serviceName"))
            writer.uint32(10).string(message2.serviceName);
          if (message2.traceParsingFailed != null && Object.hasOwnProperty.call(message2, "traceParsingFailed"))
            writer.uint32(16).bool(message2.traceParsingFailed);
          if (message2.trace != null && Object.hasOwnProperty.call(message2, "trace"))
            $root.Trace.encode(message2.trace, writer.uint32(26).fork()).ldelim();
          if (message2.sentTimeOffset != null && Object.hasOwnProperty.call(message2, "sentTimeOffset"))
            writer.uint32(32).uint64(message2.sentTimeOffset);
          if (message2.sentTime != null && Object.hasOwnProperty.call(message2, "sentTime"))
            $root.google.protobuf.Timestamp.encode(message2.sentTime, writer.uint32(42).fork()).ldelim();
          if (message2.receivedTime != null && Object.hasOwnProperty.call(message2, "receivedTime"))
            $root.google.protobuf.Timestamp.encode(message2.receivedTime, writer.uint32(50).fork()).ldelim();
          return writer;
        };
        FetchNode.encodeDelimited = function encodeDelimited(message2, writer) {
          return this.encode(message2, writer).ldelim();
        };
        FetchNode.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message2 = new $root.Trace.QueryPlanNode.FetchNode;
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message2.serviceName = reader.string();
                break;
              case 2:
                message2.traceParsingFailed = reader.bool();
                break;
              case 3:
                message2.trace = $root.Trace.decode(reader, reader.uint32());
                break;
              case 4:
                message2.sentTimeOffset = reader.uint64();
                break;
              case 5:
                message2.sentTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                break;
              case 6:
                message2.receivedTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message2;
        };
        FetchNode.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        FetchNode.verify = function verify(message2) {
          if (typeof message2 !== "object" || message2 === null)
            return "object expected";
          if (message2.serviceName != null && message2.hasOwnProperty("serviceName")) {
            if (!$util.isString(message2.serviceName))
              return "serviceName: string expected";
          }
          if (message2.traceParsingFailed != null && message2.hasOwnProperty("traceParsingFailed")) {
            if (typeof message2.traceParsingFailed !== "boolean")
              return "traceParsingFailed: boolean expected";
          }
          if (message2.trace != null && message2.hasOwnProperty("trace")) {
            var error = $root.Trace.verify(message2.trace);
            if (error)
              return "trace." + error;
          }
          if (message2.sentTimeOffset != null && message2.hasOwnProperty("sentTimeOffset")) {
            if (!$util.isInteger(message2.sentTimeOffset) && !(message2.sentTimeOffset && $util.isInteger(message2.sentTimeOffset.low) && $util.isInteger(message2.sentTimeOffset.high)))
              return "sentTimeOffset: integer|Long expected";
          }
          if (message2.sentTime != null && message2.hasOwnProperty("sentTime")) {
            var error = $root.google.protobuf.Timestamp.verify(message2.sentTime);
            if (error)
              return "sentTime." + error;
          }
          if (message2.receivedTime != null && message2.hasOwnProperty("receivedTime")) {
            var error = $root.google.protobuf.Timestamp.verify(message2.receivedTime);
            if (error)
              return "receivedTime." + error;
          }
          return null;
        };
        FetchNode.toObject = function toObject(message2, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.defaults) {
            object.serviceName = "";
            object.traceParsingFailed = false;
            object.trace = null;
            object.sentTimeOffset = 0;
            object.sentTime = null;
            object.receivedTime = null;
          }
          if (message2.serviceName != null && message2.hasOwnProperty("serviceName"))
            object.serviceName = message2.serviceName;
          if (message2.traceParsingFailed != null && message2.hasOwnProperty("traceParsingFailed"))
            object.traceParsingFailed = message2.traceParsingFailed;
          if (message2.trace != null && message2.hasOwnProperty("trace"))
            object.trace = $root.Trace.toObject(message2.trace, options);
          if (message2.sentTimeOffset != null && message2.hasOwnProperty("sentTimeOffset"))
            if (typeof message2.sentTimeOffset === "number")
              object.sentTimeOffset = options.longs === String ? String(message2.sentTimeOffset) : message2.sentTimeOffset;
            else
              object.sentTimeOffset = options.longs === String ? $util.Long.prototype.toString.call(message2.sentTimeOffset) : options.longs === Number ? new $util.LongBits(message2.sentTimeOffset.low >>> 0, message2.sentTimeOffset.high >>> 0).toNumber(true) : message2.sentTimeOffset;
          if (message2.sentTime != null && message2.hasOwnProperty("sentTime"))
            object.sentTime = $root.google.protobuf.Timestamp.toObject(message2.sentTime, options);
          if (message2.receivedTime != null && message2.hasOwnProperty("receivedTime"))
            object.receivedTime = $root.google.protobuf.Timestamp.toObject(message2.receivedTime, options);
          return object;
        };
        FetchNode.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return FetchNode;
      }();
      QueryPlanNode.FlattenNode = function() {
        function FlattenNode(properties) {
          this.responsePath = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        FlattenNode.prototype.responsePath = $util.emptyArray;
        FlattenNode.prototype.node = null;
        FlattenNode.create = function create(properties) {
          return new FlattenNode(properties);
        };
        FlattenNode.encode = function encode(message2, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message2.responsePath != null && message2.responsePath.length)
            for (var i = 0;i < message2.responsePath.length; ++i)
              $root.Trace.QueryPlanNode.ResponsePathElement.encode(message2.responsePath[i], writer.uint32(10).fork()).ldelim();
          if (message2.node != null && Object.hasOwnProperty.call(message2, "node"))
            $root.Trace.QueryPlanNode.encode(message2.node, writer.uint32(18).fork()).ldelim();
          return writer;
        };
        FlattenNode.encodeDelimited = function encodeDelimited(message2, writer) {
          return this.encode(message2, writer).ldelim();
        };
        FlattenNode.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message2 = new $root.Trace.QueryPlanNode.FlattenNode;
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                if (!(message2.responsePath && message2.responsePath.length))
                  message2.responsePath = [];
                message2.responsePath.push($root.Trace.QueryPlanNode.ResponsePathElement.decode(reader, reader.uint32()));
                break;
              case 2:
                message2.node = $root.Trace.QueryPlanNode.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message2;
        };
        FlattenNode.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        FlattenNode.verify = function verify(message2) {
          if (typeof message2 !== "object" || message2 === null)
            return "object expected";
          if (message2.responsePath != null && message2.hasOwnProperty("responsePath")) {
            if (!Array.isArray(message2.responsePath))
              return "responsePath: array expected";
            for (var i = 0;i < message2.responsePath.length; ++i) {
              var error = $root.Trace.QueryPlanNode.ResponsePathElement.verify(message2.responsePath[i]);
              if (error)
                return "responsePath." + error;
            }
          }
          if (message2.node != null && message2.hasOwnProperty("node")) {
            var error = $root.Trace.QueryPlanNode.verify(message2.node);
            if (error)
              return "node." + error;
          }
          return null;
        };
        FlattenNode.toObject = function toObject(message2, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.arrays || options.defaults)
            object.responsePath = [];
          if (options.defaults)
            object.node = null;
          if (message2.responsePath && message2.responsePath.length) {
            object.responsePath = [];
            for (var j = 0;j < message2.responsePath.length; ++j)
              object.responsePath[j] = $root.Trace.QueryPlanNode.ResponsePathElement.toObject(message2.responsePath[j], options);
          }
          if (message2.node != null && message2.hasOwnProperty("node"))
            object.node = $root.Trace.QueryPlanNode.toObject(message2.node, options);
          return object;
        };
        FlattenNode.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return FlattenNode;
      }();
      QueryPlanNode.DeferNode = function() {
        function DeferNode(properties) {
          this.deferred = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        DeferNode.prototype.primary = null;
        DeferNode.prototype.deferred = $util.emptyArray;
        DeferNode.create = function create(properties) {
          return new DeferNode(properties);
        };
        DeferNode.encode = function encode(message2, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message2.primary != null && Object.hasOwnProperty.call(message2, "primary"))
            $root.Trace.QueryPlanNode.DeferNodePrimary.encode(message2.primary, writer.uint32(10).fork()).ldelim();
          if (message2.deferred != null && message2.deferred.length)
            for (var i = 0;i < message2.deferred.length; ++i)
              $root.Trace.QueryPlanNode.DeferredNode.encode(message2.deferred[i], writer.uint32(18).fork()).ldelim();
          return writer;
        };
        DeferNode.encodeDelimited = function encodeDelimited(message2, writer) {
          return this.encode(message2, writer).ldelim();
        };
        DeferNode.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message2 = new $root.Trace.QueryPlanNode.DeferNode;
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message2.primary = $root.Trace.QueryPlanNode.DeferNodePrimary.decode(reader, reader.uint32());
                break;
              case 2:
                if (!(message2.deferred && message2.deferred.length))
                  message2.deferred = [];
                message2.deferred.push($root.Trace.QueryPlanNode.DeferredNode.decode(reader, reader.uint32()));
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message2;
        };
        DeferNode.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        DeferNode.verify = function verify(message2) {
          if (typeof message2 !== "object" || message2 === null)
            return "object expected";
          if (message2.primary != null && message2.hasOwnProperty("primary")) {
            var error = $root.Trace.QueryPlanNode.DeferNodePrimary.verify(message2.primary);
            if (error)
              return "primary." + error;
          }
          if (message2.deferred != null && message2.hasOwnProperty("deferred")) {
            if (!Array.isArray(message2.deferred))
              return "deferred: array expected";
            for (var i = 0;i < message2.deferred.length; ++i) {
              var error = $root.Trace.QueryPlanNode.DeferredNode.verify(message2.deferred[i]);
              if (error)
                return "deferred." + error;
            }
          }
          return null;
        };
        DeferNode.toObject = function toObject(message2, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.arrays || options.defaults)
            object.deferred = [];
          if (options.defaults)
            object.primary = null;
          if (message2.primary != null && message2.hasOwnProperty("primary"))
            object.primary = $root.Trace.QueryPlanNode.DeferNodePrimary.toObject(message2.primary, options);
          if (message2.deferred && message2.deferred.length) {
            object.deferred = [];
            for (var j = 0;j < message2.deferred.length; ++j)
              object.deferred[j] = $root.Trace.QueryPlanNode.DeferredNode.toObject(message2.deferred[j], options);
          }
          return object;
        };
        DeferNode.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return DeferNode;
      }();
      QueryPlanNode.ConditionNode = function() {
        function ConditionNode(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        ConditionNode.prototype.condition = "";
        ConditionNode.prototype.ifClause = null;
        ConditionNode.prototype.elseClause = null;
        ConditionNode.create = function create(properties) {
          return new ConditionNode(properties);
        };
        ConditionNode.encode = function encode(message2, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message2.condition != null && Object.hasOwnProperty.call(message2, "condition"))
            writer.uint32(10).string(message2.condition);
          if (message2.ifClause != null && Object.hasOwnProperty.call(message2, "ifClause"))
            $root.Trace.QueryPlanNode.encode(message2.ifClause, writer.uint32(18).fork()).ldelim();
          if (message2.elseClause != null && Object.hasOwnProperty.call(message2, "elseClause"))
            $root.Trace.QueryPlanNode.encode(message2.elseClause, writer.uint32(26).fork()).ldelim();
          return writer;
        };
        ConditionNode.encodeDelimited = function encodeDelimited(message2, writer) {
          return this.encode(message2, writer).ldelim();
        };
        ConditionNode.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message2 = new $root.Trace.QueryPlanNode.ConditionNode;
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message2.condition = reader.string();
                break;
              case 2:
                message2.ifClause = $root.Trace.QueryPlanNode.decode(reader, reader.uint32());
                break;
              case 3:
                message2.elseClause = $root.Trace.QueryPlanNode.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message2;
        };
        ConditionNode.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        ConditionNode.verify = function verify(message2) {
          if (typeof message2 !== "object" || message2 === null)
            return "object expected";
          if (message2.condition != null && message2.hasOwnProperty("condition")) {
            if (!$util.isString(message2.condition))
              return "condition: string expected";
          }
          if (message2.ifClause != null && message2.hasOwnProperty("ifClause")) {
            var error = $root.Trace.QueryPlanNode.verify(message2.ifClause);
            if (error)
              return "ifClause." + error;
          }
          if (message2.elseClause != null && message2.hasOwnProperty("elseClause")) {
            var error = $root.Trace.QueryPlanNode.verify(message2.elseClause);
            if (error)
              return "elseClause." + error;
          }
          return null;
        };
        ConditionNode.toObject = function toObject(message2, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.defaults) {
            object.condition = "";
            object.ifClause = null;
            object.elseClause = null;
          }
          if (message2.condition != null && message2.hasOwnProperty("condition"))
            object.condition = message2.condition;
          if (message2.ifClause != null && message2.hasOwnProperty("ifClause"))
            object.ifClause = $root.Trace.QueryPlanNode.toObject(message2.ifClause, options);
          if (message2.elseClause != null && message2.hasOwnProperty("elseClause"))
            object.elseClause = $root.Trace.QueryPlanNode.toObject(message2.elseClause, options);
          return object;
        };
        ConditionNode.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return ConditionNode;
      }();
      QueryPlanNode.DeferNodePrimary = function() {
        function DeferNodePrimary(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        DeferNodePrimary.prototype.node = null;
        DeferNodePrimary.create = function create(properties) {
          return new DeferNodePrimary(properties);
        };
        DeferNodePrimary.encode = function encode(message2, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message2.node != null && Object.hasOwnProperty.call(message2, "node"))
            $root.Trace.QueryPlanNode.encode(message2.node, writer.uint32(10).fork()).ldelim();
          return writer;
        };
        DeferNodePrimary.encodeDelimited = function encodeDelimited(message2, writer) {
          return this.encode(message2, writer).ldelim();
        };
        DeferNodePrimary.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message2 = new $root.Trace.QueryPlanNode.DeferNodePrimary;
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message2.node = $root.Trace.QueryPlanNode.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message2;
        };
        DeferNodePrimary.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        DeferNodePrimary.verify = function verify(message2) {
          if (typeof message2 !== "object" || message2 === null)
            return "object expected";
          if (message2.node != null && message2.hasOwnProperty("node")) {
            var error = $root.Trace.QueryPlanNode.verify(message2.node);
            if (error)
              return "node." + error;
          }
          return null;
        };
        DeferNodePrimary.toObject = function toObject(message2, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.defaults)
            object.node = null;
          if (message2.node != null && message2.hasOwnProperty("node"))
            object.node = $root.Trace.QueryPlanNode.toObject(message2.node, options);
          return object;
        };
        DeferNodePrimary.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return DeferNodePrimary;
      }();
      QueryPlanNode.DeferredNode = function() {
        function DeferredNode(properties) {
          this.depends = [];
          this.path = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        DeferredNode.prototype.depends = $util.emptyArray;
        DeferredNode.prototype.label = "";
        DeferredNode.prototype.path = $util.emptyArray;
        DeferredNode.prototype.node = null;
        DeferredNode.create = function create(properties) {
          return new DeferredNode(properties);
        };
        DeferredNode.encode = function encode(message2, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message2.depends != null && message2.depends.length)
            for (var i = 0;i < message2.depends.length; ++i)
              $root.Trace.QueryPlanNode.DeferredNodeDepends.encode(message2.depends[i], writer.uint32(10).fork()).ldelim();
          if (message2.label != null && Object.hasOwnProperty.call(message2, "label"))
            writer.uint32(18).string(message2.label);
          if (message2.path != null && message2.path.length)
            for (var i = 0;i < message2.path.length; ++i)
              $root.Trace.QueryPlanNode.ResponsePathElement.encode(message2.path[i], writer.uint32(26).fork()).ldelim();
          if (message2.node != null && Object.hasOwnProperty.call(message2, "node"))
            $root.Trace.QueryPlanNode.encode(message2.node, writer.uint32(34).fork()).ldelim();
          return writer;
        };
        DeferredNode.encodeDelimited = function encodeDelimited(message2, writer) {
          return this.encode(message2, writer).ldelim();
        };
        DeferredNode.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message2 = new $root.Trace.QueryPlanNode.DeferredNode;
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                if (!(message2.depends && message2.depends.length))
                  message2.depends = [];
                message2.depends.push($root.Trace.QueryPlanNode.DeferredNodeDepends.decode(reader, reader.uint32()));
                break;
              case 2:
                message2.label = reader.string();
                break;
              case 3:
                if (!(message2.path && message2.path.length))
                  message2.path = [];
                message2.path.push($root.Trace.QueryPlanNode.ResponsePathElement.decode(reader, reader.uint32()));
                break;
              case 4:
                message2.node = $root.Trace.QueryPlanNode.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message2;
        };
        DeferredNode.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        DeferredNode.verify = function verify(message2) {
          if (typeof message2 !== "object" || message2 === null)
            return "object expected";
          if (message2.depends != null && message2.hasOwnProperty("depends")) {
            if (!Array.isArray(message2.depends))
              return "depends: array expected";
            for (var i = 0;i < message2.depends.length; ++i) {
              var error = $root.Trace.QueryPlanNode.DeferredNodeDepends.verify(message2.depends[i]);
              if (error)
                return "depends." + error;
            }
          }
          if (message2.label != null && message2.hasOwnProperty("label")) {
            if (!$util.isString(message2.label))
              return "label: string expected";
          }
          if (message2.path != null && message2.hasOwnProperty("path")) {
            if (!Array.isArray(message2.path))
              return "path: array expected";
            for (var i = 0;i < message2.path.length; ++i) {
              var error = $root.Trace.QueryPlanNode.ResponsePathElement.verify(message2.path[i]);
              if (error)
                return "path." + error;
            }
          }
          if (message2.node != null && message2.hasOwnProperty("node")) {
            var error = $root.Trace.QueryPlanNode.verify(message2.node);
            if (error)
              return "node." + error;
          }
          return null;
        };
        DeferredNode.toObject = function toObject(message2, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.arrays || options.defaults) {
            object.depends = [];
            object.path = [];
          }
          if (options.defaults) {
            object.label = "";
            object.node = null;
          }
          if (message2.depends && message2.depends.length) {
            object.depends = [];
            for (var j = 0;j < message2.depends.length; ++j)
              object.depends[j] = $root.Trace.QueryPlanNode.DeferredNodeDepends.toObject(message2.depends[j], options);
          }
          if (message2.label != null && message2.hasOwnProperty("label"))
            object.label = message2.label;
          if (message2.path && message2.path.length) {
            object.path = [];
            for (var j = 0;j < message2.path.length; ++j)
              object.path[j] = $root.Trace.QueryPlanNode.ResponsePathElement.toObject(message2.path[j], options);
          }
          if (message2.node != null && message2.hasOwnProperty("node"))
            object.node = $root.Trace.QueryPlanNode.toObject(message2.node, options);
          return object;
        };
        DeferredNode.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return DeferredNode;
      }();
      QueryPlanNode.DeferredNodeDepends = function() {
        function DeferredNodeDepends(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        DeferredNodeDepends.prototype.id = "";
        DeferredNodeDepends.prototype.deferLabel = "";
        DeferredNodeDepends.create = function create(properties) {
          return new DeferredNodeDepends(properties);
        };
        DeferredNodeDepends.encode = function encode(message2, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message2.id != null && Object.hasOwnProperty.call(message2, "id"))
            writer.uint32(10).string(message2.id);
          if (message2.deferLabel != null && Object.hasOwnProperty.call(message2, "deferLabel"))
            writer.uint32(18).string(message2.deferLabel);
          return writer;
        };
        DeferredNodeDepends.encodeDelimited = function encodeDelimited(message2, writer) {
          return this.encode(message2, writer).ldelim();
        };
        DeferredNodeDepends.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message2 = new $root.Trace.QueryPlanNode.DeferredNodeDepends;
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message2.id = reader.string();
                break;
              case 2:
                message2.deferLabel = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message2;
        };
        DeferredNodeDepends.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        DeferredNodeDepends.verify = function verify(message2) {
          if (typeof message2 !== "object" || message2 === null)
            return "object expected";
          if (message2.id != null && message2.hasOwnProperty("id")) {
            if (!$util.isString(message2.id))
              return "id: string expected";
          }
          if (message2.deferLabel != null && message2.hasOwnProperty("deferLabel")) {
            if (!$util.isString(message2.deferLabel))
              return "deferLabel: string expected";
          }
          return null;
        };
        DeferredNodeDepends.toObject = function toObject(message2, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.defaults) {
            object.id = "";
            object.deferLabel = "";
          }
          if (message2.id != null && message2.hasOwnProperty("id"))
            object.id = message2.id;
          if (message2.deferLabel != null && message2.hasOwnProperty("deferLabel"))
            object.deferLabel = message2.deferLabel;
          return object;
        };
        DeferredNodeDepends.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return DeferredNodeDepends;
      }();
      QueryPlanNode.ResponsePathElement = function() {
        function ResponsePathElement(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        ResponsePathElement.prototype.fieldName = "";
        ResponsePathElement.prototype.index = 0;
        var $oneOfFields2;
        Object.defineProperty(ResponsePathElement.prototype, "id", {
          get: $util.oneOfGetter($oneOfFields2 = ["fieldName", "index"]),
          set: $util.oneOfSetter($oneOfFields2)
        });
        ResponsePathElement.create = function create(properties) {
          return new ResponsePathElement(properties);
        };
        ResponsePathElement.encode = function encode(message2, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message2.fieldName != null && Object.hasOwnProperty.call(message2, "fieldName"))
            writer.uint32(10).string(message2.fieldName);
          if (message2.index != null && Object.hasOwnProperty.call(message2, "index"))
            writer.uint32(16).uint32(message2.index);
          return writer;
        };
        ResponsePathElement.encodeDelimited = function encodeDelimited(message2, writer) {
          return this.encode(message2, writer).ldelim();
        };
        ResponsePathElement.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message2 = new $root.Trace.QueryPlanNode.ResponsePathElement;
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message2.fieldName = reader.string();
                break;
              case 2:
                message2.index = reader.uint32();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message2;
        };
        ResponsePathElement.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        ResponsePathElement.verify = function verify(message2) {
          if (typeof message2 !== "object" || message2 === null)
            return "object expected";
          var properties = {};
          if (message2.fieldName != null && message2.hasOwnProperty("fieldName")) {
            properties.id = 1;
            if (!$util.isString(message2.fieldName))
              return "fieldName: string expected";
          }
          if (message2.index != null && message2.hasOwnProperty("index")) {
            if (properties.id === 1)
              return "id: multiple values";
            properties.id = 1;
            if (!$util.isInteger(message2.index))
              return "index: integer expected";
          }
          return null;
        };
        ResponsePathElement.toObject = function toObject(message2, options) {
          if (!options)
            options = {};
          var object = {};
          if (message2.fieldName != null && message2.hasOwnProperty("fieldName")) {
            object.fieldName = message2.fieldName;
            if (options.oneofs)
              object.id = "fieldName";
          }
          if (message2.index != null && message2.hasOwnProperty("index")) {
            object.index = message2.index;
            if (options.oneofs)
              object.id = "index";
          }
          return object;
        };
        ResponsePathElement.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return ResponsePathElement;
      }();
      return QueryPlanNode;
    }();
    return Trace;
  }();
  $root.ReportHeader = function() {
    function ReportHeader(properties) {
      if (properties) {
        for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    ReportHeader.prototype.graphRef = "";
    ReportHeader.prototype.hostname = "";
    ReportHeader.prototype.agentVersion = "";
    ReportHeader.prototype.serviceVersion = "";
    ReportHeader.prototype.runtimeVersion = "";
    ReportHeader.prototype.uname = "";
    ReportHeader.prototype.executableSchemaId = "";
    ReportHeader.create = function create(properties) {
      return new ReportHeader(properties);
    };
    ReportHeader.encode = function encode(message2, writer) {
      if (!writer)
        writer = $Writer.create();
      if (message2.hostname != null && Object.hasOwnProperty.call(message2, "hostname"))
        writer.uint32(42).string(message2.hostname);
      if (message2.agentVersion != null && Object.hasOwnProperty.call(message2, "agentVersion"))
        writer.uint32(50).string(message2.agentVersion);
      if (message2.serviceVersion != null && Object.hasOwnProperty.call(message2, "serviceVersion"))
        writer.uint32(58).string(message2.serviceVersion);
      if (message2.runtimeVersion != null && Object.hasOwnProperty.call(message2, "runtimeVersion"))
        writer.uint32(66).string(message2.runtimeVersion);
      if (message2.uname != null && Object.hasOwnProperty.call(message2, "uname"))
        writer.uint32(74).string(message2.uname);
      if (message2.executableSchemaId != null && Object.hasOwnProperty.call(message2, "executableSchemaId"))
        writer.uint32(90).string(message2.executableSchemaId);
      if (message2.graphRef != null && Object.hasOwnProperty.call(message2, "graphRef"))
        writer.uint32(98).string(message2.graphRef);
      return writer;
    };
    ReportHeader.encodeDelimited = function encodeDelimited(message2, writer) {
      return this.encode(message2, writer).ldelim();
    };
    ReportHeader.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader))
        reader = $Reader.create(reader);
      var end = length === undefined ? reader.len : reader.pos + length, message2 = new $root.ReportHeader;
      while (reader.pos < end) {
        var tag = reader.uint32();
        switch (tag >>> 3) {
          case 12:
            message2.graphRef = reader.string();
            break;
          case 5:
            message2.hostname = reader.string();
            break;
          case 6:
            message2.agentVersion = reader.string();
            break;
          case 7:
            message2.serviceVersion = reader.string();
            break;
          case 8:
            message2.runtimeVersion = reader.string();
            break;
          case 9:
            message2.uname = reader.string();
            break;
          case 11:
            message2.executableSchemaId = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message2;
    };
    ReportHeader.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader))
        reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };
    ReportHeader.verify = function verify(message2) {
      if (typeof message2 !== "object" || message2 === null)
        return "object expected";
      if (message2.graphRef != null && message2.hasOwnProperty("graphRef")) {
        if (!$util.isString(message2.graphRef))
          return "graphRef: string expected";
      }
      if (message2.hostname != null && message2.hasOwnProperty("hostname")) {
        if (!$util.isString(message2.hostname))
          return "hostname: string expected";
      }
      if (message2.agentVersion != null && message2.hasOwnProperty("agentVersion")) {
        if (!$util.isString(message2.agentVersion))
          return "agentVersion: string expected";
      }
      if (message2.serviceVersion != null && message2.hasOwnProperty("serviceVersion")) {
        if (!$util.isString(message2.serviceVersion))
          return "serviceVersion: string expected";
      }
      if (message2.runtimeVersion != null && message2.hasOwnProperty("runtimeVersion")) {
        if (!$util.isString(message2.runtimeVersion))
          return "runtimeVersion: string expected";
      }
      if (message2.uname != null && message2.hasOwnProperty("uname")) {
        if (!$util.isString(message2.uname))
          return "uname: string expected";
      }
      if (message2.executableSchemaId != null && message2.hasOwnProperty("executableSchemaId")) {
        if (!$util.isString(message2.executableSchemaId))
          return "executableSchemaId: string expected";
      }
      return null;
    };
    ReportHeader.toObject = function toObject(message2, options) {
      if (!options)
        options = {};
      var object = {};
      if (options.defaults) {
        object.hostname = "";
        object.agentVersion = "";
        object.serviceVersion = "";
        object.runtimeVersion = "";
        object.uname = "";
        object.executableSchemaId = "";
        object.graphRef = "";
      }
      if (message2.hostname != null && message2.hasOwnProperty("hostname"))
        object.hostname = message2.hostname;
      if (message2.agentVersion != null && message2.hasOwnProperty("agentVersion"))
        object.agentVersion = message2.agentVersion;
      if (message2.serviceVersion != null && message2.hasOwnProperty("serviceVersion"))
        object.serviceVersion = message2.serviceVersion;
      if (message2.runtimeVersion != null && message2.hasOwnProperty("runtimeVersion"))
        object.runtimeVersion = message2.runtimeVersion;
      if (message2.uname != null && message2.hasOwnProperty("uname"))
        object.uname = message2.uname;
      if (message2.executableSchemaId != null && message2.hasOwnProperty("executableSchemaId"))
        object.executableSchemaId = message2.executableSchemaId;
      if (message2.graphRef != null && message2.hasOwnProperty("graphRef"))
        object.graphRef = message2.graphRef;
      return object;
    };
    ReportHeader.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };
    return ReportHeader;
  }();
  $root.PathErrorStats = function() {
    function PathErrorStats(properties) {
      this.children = {};
      if (properties) {
        for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    PathErrorStats.prototype.children = $util.emptyObject;
    PathErrorStats.prototype.errorsCount = 0;
    PathErrorStats.prototype.requestsWithErrorsCount = 0;
    PathErrorStats.create = function create(properties) {
      return new PathErrorStats(properties);
    };
    PathErrorStats.encode = function encode(message2, writer) {
      if (!writer)
        writer = $Writer.create();
      if (message2.children != null && Object.hasOwnProperty.call(message2, "children"))
        for (var keys = Object.keys(message2.children), i = 0;i < keys.length; ++i) {
          writer.uint32(10).fork().uint32(10).string(keys[i]);
          $root.PathErrorStats.encode(message2.children[keys[i]], writer.uint32(18).fork()).ldelim().ldelim();
        }
      if (message2.errorsCount != null && Object.hasOwnProperty.call(message2, "errorsCount"))
        writer.uint32(32).uint64(message2.errorsCount);
      if (message2.requestsWithErrorsCount != null && Object.hasOwnProperty.call(message2, "requestsWithErrorsCount"))
        writer.uint32(40).uint64(message2.requestsWithErrorsCount);
      return writer;
    };
    PathErrorStats.encodeDelimited = function encodeDelimited(message2, writer) {
      return this.encode(message2, writer).ldelim();
    };
    PathErrorStats.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader))
        reader = $Reader.create(reader);
      var end = length === undefined ? reader.len : reader.pos + length, message2 = new $root.PathErrorStats, key;
      while (reader.pos < end) {
        var tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            reader.skip().pos++;
            if (message2.children === $util.emptyObject)
              message2.children = {};
            key = reader.string();
            reader.pos++;
            message2.children[key] = $root.PathErrorStats.decode(reader, reader.uint32());
            break;
          case 4:
            message2.errorsCount = reader.uint64();
            break;
          case 5:
            message2.requestsWithErrorsCount = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message2;
    };
    PathErrorStats.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader))
        reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };
    PathErrorStats.verify = function verify(message2) {
      if (typeof message2 !== "object" || message2 === null)
        return "object expected";
      if (message2.children != null && message2.hasOwnProperty("children")) {
        if (!$util.isObject(message2.children))
          return "children: object expected";
        var key = Object.keys(message2.children);
        for (var i = 0;i < key.length; ++i) {
          var error = $root.PathErrorStats.verify(message2.children[key[i]]);
          if (error)
            return "children." + error;
        }
      }
      if (message2.errorsCount != null && message2.hasOwnProperty("errorsCount")) {
        if (!$util.isInteger(message2.errorsCount) && !(message2.errorsCount && $util.isInteger(message2.errorsCount.low) && $util.isInteger(message2.errorsCount.high)))
          return "errorsCount: integer|Long expected";
      }
      if (message2.requestsWithErrorsCount != null && message2.hasOwnProperty("requestsWithErrorsCount")) {
        if (!$util.isInteger(message2.requestsWithErrorsCount) && !(message2.requestsWithErrorsCount && $util.isInteger(message2.requestsWithErrorsCount.low) && $util.isInteger(message2.requestsWithErrorsCount.high)))
          return "requestsWithErrorsCount: integer|Long expected";
      }
      return null;
    };
    PathErrorStats.toObject = function toObject(message2, options) {
      if (!options)
        options = {};
      var object = {};
      if (options.objects || options.defaults)
        object.children = {};
      if (options.defaults) {
        object.errorsCount = 0;
        object.requestsWithErrorsCount = 0;
      }
      var keys2;
      if (message2.children && (keys2 = Object.keys(message2.children)).length) {
        object.children = {};
        for (var j = 0;j < keys2.length; ++j)
          object.children[keys2[j]] = $root.PathErrorStats.toObject(message2.children[keys2[j]], options);
      }
      if (message2.errorsCount != null && message2.hasOwnProperty("errorsCount"))
        if (typeof message2.errorsCount === "number")
          object.errorsCount = options.longs === String ? String(message2.errorsCount) : message2.errorsCount;
        else
          object.errorsCount = options.longs === String ? $util.Long.prototype.toString.call(message2.errorsCount) : options.longs === Number ? new $util.LongBits(message2.errorsCount.low >>> 0, message2.errorsCount.high >>> 0).toNumber(true) : message2.errorsCount;
      if (message2.requestsWithErrorsCount != null && message2.hasOwnProperty("requestsWithErrorsCount"))
        if (typeof message2.requestsWithErrorsCount === "number")
          object.requestsWithErrorsCount = options.longs === String ? String(message2.requestsWithErrorsCount) : message2.requestsWithErrorsCount;
        else
          object.requestsWithErrorsCount = options.longs === String ? $util.Long.prototype.toString.call(message2.requestsWithErrorsCount) : options.longs === Number ? new $util.LongBits(message2.requestsWithErrorsCount.low >>> 0, message2.requestsWithErrorsCount.high >>> 0).toNumber(true) : message2.requestsWithErrorsCount;
      return object;
    };
    PathErrorStats.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };
    return PathErrorStats;
  }();
  $root.QueryLatencyStats = function() {
    function QueryLatencyStats(properties) {
      this.latencyCount = [];
      this.cacheLatencyCount = [];
      this.publicCacheTtlCount = [];
      this.privateCacheTtlCount = [];
      if (properties) {
        for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    QueryLatencyStats.prototype.latencyCount = $util.emptyArray;
    QueryLatencyStats.prototype.requestCount = 0;
    QueryLatencyStats.prototype.cacheHits = 0;
    QueryLatencyStats.prototype.persistedQueryHits = 0;
    QueryLatencyStats.prototype.persistedQueryMisses = 0;
    QueryLatencyStats.prototype.cacheLatencyCount = $util.emptyArray;
    QueryLatencyStats.prototype.rootErrorStats = null;
    QueryLatencyStats.prototype.requestsWithErrorsCount = 0;
    QueryLatencyStats.prototype.publicCacheTtlCount = $util.emptyArray;
    QueryLatencyStats.prototype.privateCacheTtlCount = $util.emptyArray;
    QueryLatencyStats.prototype.registeredOperationCount = 0;
    QueryLatencyStats.prototype.forbiddenOperationCount = 0;
    QueryLatencyStats.prototype.requestsWithoutFieldInstrumentation = 0;
    QueryLatencyStats.create = function create(properties) {
      return new QueryLatencyStats(properties);
    };
    QueryLatencyStats.encode = function encode(message2, writer) {
      if (!writer)
        writer = $Writer.create();
      if (message2.requestCount != null && Object.hasOwnProperty.call(message2, "requestCount"))
        writer.uint32(16).uint64(message2.requestCount);
      if (message2.cacheHits != null && Object.hasOwnProperty.call(message2, "cacheHits"))
        writer.uint32(24).uint64(message2.cacheHits);
      if (message2.persistedQueryHits != null && Object.hasOwnProperty.call(message2, "persistedQueryHits"))
        writer.uint32(32).uint64(message2.persistedQueryHits);
      if (message2.persistedQueryMisses != null && Object.hasOwnProperty.call(message2, "persistedQueryMisses"))
        writer.uint32(40).uint64(message2.persistedQueryMisses);
      if (message2.rootErrorStats != null && Object.hasOwnProperty.call(message2, "rootErrorStats"))
        $root.PathErrorStats.encode(message2.rootErrorStats, writer.uint32(58).fork()).ldelim();
      if (message2.requestsWithErrorsCount != null && Object.hasOwnProperty.call(message2, "requestsWithErrorsCount"))
        writer.uint32(64).uint64(message2.requestsWithErrorsCount);
      if (message2.registeredOperationCount != null && Object.hasOwnProperty.call(message2, "registeredOperationCount"))
        writer.uint32(88).uint64(message2.registeredOperationCount);
      if (message2.forbiddenOperationCount != null && Object.hasOwnProperty.call(message2, "forbiddenOperationCount"))
        writer.uint32(96).uint64(message2.forbiddenOperationCount);
      var array13;
      if (message2.latencyCount != null && message2.latencyCount.toArray)
        array13 = message2.latencyCount.toArray();
      else
        array13 = message2.latencyCount;
      if (array13 != null && array13.length) {
        writer.uint32(106).fork();
        for (var i = 0;i < array13.length; ++i)
          writer.sint64(array13[i]);
        writer.ldelim();
      }
      var array14;
      if (message2.cacheLatencyCount != null && message2.cacheLatencyCount.toArray)
        array14 = message2.cacheLatencyCount.toArray();
      else
        array14 = message2.cacheLatencyCount;
      if (array14 != null && array14.length) {
        writer.uint32(114).fork();
        for (var i = 0;i < array14.length; ++i)
          writer.sint64(array14[i]);
        writer.ldelim();
      }
      var array15;
      if (message2.publicCacheTtlCount != null && message2.publicCacheTtlCount.toArray)
        array15 = message2.publicCacheTtlCount.toArray();
      else
        array15 = message2.publicCacheTtlCount;
      if (array15 != null && array15.length) {
        writer.uint32(122).fork();
        for (var i = 0;i < array15.length; ++i)
          writer.sint64(array15[i]);
        writer.ldelim();
      }
      var array16;
      if (message2.privateCacheTtlCount != null && message2.privateCacheTtlCount.toArray)
        array16 = message2.privateCacheTtlCount.toArray();
      else
        array16 = message2.privateCacheTtlCount;
      if (array16 != null && array16.length) {
        writer.uint32(130).fork();
        for (var i = 0;i < array16.length; ++i)
          writer.sint64(array16[i]);
        writer.ldelim();
      }
      if (message2.requestsWithoutFieldInstrumentation != null && Object.hasOwnProperty.call(message2, "requestsWithoutFieldInstrumentation"))
        writer.uint32(136).uint64(message2.requestsWithoutFieldInstrumentation);
      return writer;
    };
    QueryLatencyStats.encodeDelimited = function encodeDelimited(message2, writer) {
      return this.encode(message2, writer).ldelim();
    };
    QueryLatencyStats.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader))
        reader = $Reader.create(reader);
      var end = length === undefined ? reader.len : reader.pos + length, message2 = new $root.QueryLatencyStats;
      while (reader.pos < end) {
        var tag = reader.uint32();
        switch (tag >>> 3) {
          case 13:
            if (!(message2.latencyCount && message2.latencyCount.length))
              message2.latencyCount = [];
            if ((tag & 7) === 2) {
              var end2 = reader.uint32() + reader.pos;
              while (reader.pos < end2)
                message2.latencyCount.push(reader.sint64());
            } else
              message2.latencyCount.push(reader.sint64());
            break;
          case 2:
            message2.requestCount = reader.uint64();
            break;
          case 3:
            message2.cacheHits = reader.uint64();
            break;
          case 4:
            message2.persistedQueryHits = reader.uint64();
            break;
          case 5:
            message2.persistedQueryMisses = reader.uint64();
            break;
          case 14:
            if (!(message2.cacheLatencyCount && message2.cacheLatencyCount.length))
              message2.cacheLatencyCount = [];
            if ((tag & 7) === 2) {
              var end2 = reader.uint32() + reader.pos;
              while (reader.pos < end2)
                message2.cacheLatencyCount.push(reader.sint64());
            } else
              message2.cacheLatencyCount.push(reader.sint64());
            break;
          case 7:
            message2.rootErrorStats = $root.PathErrorStats.decode(reader, reader.uint32());
            break;
          case 8:
            message2.requestsWithErrorsCount = reader.uint64();
            break;
          case 15:
            if (!(message2.publicCacheTtlCount && message2.publicCacheTtlCount.length))
              message2.publicCacheTtlCount = [];
            if ((tag & 7) === 2) {
              var end2 = reader.uint32() + reader.pos;
              while (reader.pos < end2)
                message2.publicCacheTtlCount.push(reader.sint64());
            } else
              message2.publicCacheTtlCount.push(reader.sint64());
            break;
          case 16:
            if (!(message2.privateCacheTtlCount && message2.privateCacheTtlCount.length))
              message2.privateCacheTtlCount = [];
            if ((tag & 7) === 2) {
              var end2 = reader.uint32() + reader.pos;
              while (reader.pos < end2)
                message2.privateCacheTtlCount.push(reader.sint64());
            } else
              message2.privateCacheTtlCount.push(reader.sint64());
            break;
          case 11:
            message2.registeredOperationCount = reader.uint64();
            break;
          case 12:
            message2.forbiddenOperationCount = reader.uint64();
            break;
          case 17:
            message2.requestsWithoutFieldInstrumentation = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message2;
    };
    QueryLatencyStats.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader))
        reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };
    QueryLatencyStats.verify = function verify(message2) {
      if (typeof message2 !== "object" || message2 === null)
        return "object expected";
      if (message2.latencyCount != null && message2.hasOwnProperty("latencyCount")) {
        var array13;
        if (message2.latencyCount != null && message2.latencyCount.toArray)
          array13 = message2.latencyCount.toArray();
        else
          array13 = message2.latencyCount;
        if (!Array.isArray(array13))
          return "latencyCount: array expected";
        for (var i = 0;i < array13.length; ++i)
          if (!$util.isInteger(array13[i]) && !(array13[i] && $util.isInteger(array13[i].low) && $util.isInteger(array13[i].high)))
            return "latencyCount: integer|Long[] expected";
      }
      if (message2.requestCount != null && message2.hasOwnProperty("requestCount")) {
        if (!$util.isInteger(message2.requestCount) && !(message2.requestCount && $util.isInteger(message2.requestCount.low) && $util.isInteger(message2.requestCount.high)))
          return "requestCount: integer|Long expected";
      }
      if (message2.cacheHits != null && message2.hasOwnProperty("cacheHits")) {
        if (!$util.isInteger(message2.cacheHits) && !(message2.cacheHits && $util.isInteger(message2.cacheHits.low) && $util.isInteger(message2.cacheHits.high)))
          return "cacheHits: integer|Long expected";
      }
      if (message2.persistedQueryHits != null && message2.hasOwnProperty("persistedQueryHits")) {
        if (!$util.isInteger(message2.persistedQueryHits) && !(message2.persistedQueryHits && $util.isInteger(message2.persistedQueryHits.low) && $util.isInteger(message2.persistedQueryHits.high)))
          return "persistedQueryHits: integer|Long expected";
      }
      if (message2.persistedQueryMisses != null && message2.hasOwnProperty("persistedQueryMisses")) {
        if (!$util.isInteger(message2.persistedQueryMisses) && !(message2.persistedQueryMisses && $util.isInteger(message2.persistedQueryMisses.low) && $util.isInteger(message2.persistedQueryMisses.high)))
          return "persistedQueryMisses: integer|Long expected";
      }
      if (message2.cacheLatencyCount != null && message2.hasOwnProperty("cacheLatencyCount")) {
        var array14;
        if (message2.cacheLatencyCount != null && message2.cacheLatencyCount.toArray)
          array14 = message2.cacheLatencyCount.toArray();
        else
          array14 = message2.cacheLatencyCount;
        if (!Array.isArray(array14))
          return "cacheLatencyCount: array expected";
        for (var i = 0;i < array14.length; ++i)
          if (!$util.isInteger(array14[i]) && !(array14[i] && $util.isInteger(array14[i].low) && $util.isInteger(array14[i].high)))
            return "cacheLatencyCount: integer|Long[] expected";
      }
      if (message2.rootErrorStats != null && message2.hasOwnProperty("rootErrorStats")) {
        var error = $root.PathErrorStats.verify(message2.rootErrorStats);
        if (error)
          return "rootErrorStats." + error;
      }
      if (message2.requestsWithErrorsCount != null && message2.hasOwnProperty("requestsWithErrorsCount")) {
        if (!$util.isInteger(message2.requestsWithErrorsCount) && !(message2.requestsWithErrorsCount && $util.isInteger(message2.requestsWithErrorsCount.low) && $util.isInteger(message2.requestsWithErrorsCount.high)))
          return "requestsWithErrorsCount: integer|Long expected";
      }
      if (message2.publicCacheTtlCount != null && message2.hasOwnProperty("publicCacheTtlCount")) {
        var array15;
        if (message2.publicCacheTtlCount != null && message2.publicCacheTtlCount.toArray)
          array15 = message2.publicCacheTtlCount.toArray();
        else
          array15 = message2.publicCacheTtlCount;
        if (!Array.isArray(array15))
          return "publicCacheTtlCount: array expected";
        for (var i = 0;i < array15.length; ++i)
          if (!$util.isInteger(array15[i]) && !(array15[i] && $util.isInteger(array15[i].low) && $util.isInteger(array15[i].high)))
            return "publicCacheTtlCount: integer|Long[] expected";
      }
      if (message2.privateCacheTtlCount != null && message2.hasOwnProperty("privateCacheTtlCount")) {
        var array16;
        if (message2.privateCacheTtlCount != null && message2.privateCacheTtlCount.toArray)
          array16 = message2.privateCacheTtlCount.toArray();
        else
          array16 = message2.privateCacheTtlCount;
        if (!Array.isArray(array16))
          return "privateCacheTtlCount: array expected";
        for (var i = 0;i < array16.length; ++i)
          if (!$util.isInteger(array16[i]) && !(array16[i] && $util.isInteger(array16[i].low) && $util.isInteger(array16[i].high)))
            return "privateCacheTtlCount: integer|Long[] expected";
      }
      if (message2.registeredOperationCount != null && message2.hasOwnProperty("registeredOperationCount")) {
        if (!$util.isInteger(message2.registeredOperationCount) && !(message2.registeredOperationCount && $util.isInteger(message2.registeredOperationCount.low) && $util.isInteger(message2.registeredOperationCount.high)))
          return "registeredOperationCount: integer|Long expected";
      }
      if (message2.forbiddenOperationCount != null && message2.hasOwnProperty("forbiddenOperationCount")) {
        if (!$util.isInteger(message2.forbiddenOperationCount) && !(message2.forbiddenOperationCount && $util.isInteger(message2.forbiddenOperationCount.low) && $util.isInteger(message2.forbiddenOperationCount.high)))
          return "forbiddenOperationCount: integer|Long expected";
      }
      if (message2.requestsWithoutFieldInstrumentation != null && message2.hasOwnProperty("requestsWithoutFieldInstrumentation")) {
        if (!$util.isInteger(message2.requestsWithoutFieldInstrumentation) && !(message2.requestsWithoutFieldInstrumentation && $util.isInteger(message2.requestsWithoutFieldInstrumentation.low) && $util.isInteger(message2.requestsWithoutFieldInstrumentation.high)))
          return "requestsWithoutFieldInstrumentation: integer|Long expected";
      }
      return null;
    };
    QueryLatencyStats.toObject = function toObject(message2, options) {
      if (!options)
        options = {};
      var object = {};
      if (options.arrays || options.defaults) {
        object.latencyCount = [];
        object.cacheLatencyCount = [];
        object.publicCacheTtlCount = [];
        object.privateCacheTtlCount = [];
      }
      if (options.defaults) {
        object.requestCount = 0;
        object.cacheHits = 0;
        object.persistedQueryHits = 0;
        object.persistedQueryMisses = 0;
        object.rootErrorStats = null;
        object.requestsWithErrorsCount = 0;
        object.registeredOperationCount = 0;
        object.forbiddenOperationCount = 0;
        object.requestsWithoutFieldInstrumentation = 0;
      }
      if (message2.requestCount != null && message2.hasOwnProperty("requestCount"))
        if (typeof message2.requestCount === "number")
          object.requestCount = options.longs === String ? String(message2.requestCount) : message2.requestCount;
        else
          object.requestCount = options.longs === String ? $util.Long.prototype.toString.call(message2.requestCount) : options.longs === Number ? new $util.LongBits(message2.requestCount.low >>> 0, message2.requestCount.high >>> 0).toNumber(true) : message2.requestCount;
      if (message2.cacheHits != null && message2.hasOwnProperty("cacheHits"))
        if (typeof message2.cacheHits === "number")
          object.cacheHits = options.longs === String ? String(message2.cacheHits) : message2.cacheHits;
        else
          object.cacheHits = options.longs === String ? $util.Long.prototype.toString.call(message2.cacheHits) : options.longs === Number ? new $util.LongBits(message2.cacheHits.low >>> 0, message2.cacheHits.high >>> 0).toNumber(true) : message2.cacheHits;
      if (message2.persistedQueryHits != null && message2.hasOwnProperty("persistedQueryHits"))
        if (typeof message2.persistedQueryHits === "number")
          object.persistedQueryHits = options.longs === String ? String(message2.persistedQueryHits) : message2.persistedQueryHits;
        else
          object.persistedQueryHits = options.longs === String ? $util.Long.prototype.toString.call(message2.persistedQueryHits) : options.longs === Number ? new $util.LongBits(message2.persistedQueryHits.low >>> 0, message2.persistedQueryHits.high >>> 0).toNumber(true) : message2.persistedQueryHits;
      if (message2.persistedQueryMisses != null && message2.hasOwnProperty("persistedQueryMisses"))
        if (typeof message2.persistedQueryMisses === "number")
          object.persistedQueryMisses = options.longs === String ? String(message2.persistedQueryMisses) : message2.persistedQueryMisses;
        else
          object.persistedQueryMisses = options.longs === String ? $util.Long.prototype.toString.call(message2.persistedQueryMisses) : options.longs === Number ? new $util.LongBits(message2.persistedQueryMisses.low >>> 0, message2.persistedQueryMisses.high >>> 0).toNumber(true) : message2.persistedQueryMisses;
      if (message2.rootErrorStats != null && message2.hasOwnProperty("rootErrorStats"))
        object.rootErrorStats = $root.PathErrorStats.toObject(message2.rootErrorStats, options);
      if (message2.requestsWithErrorsCount != null && message2.hasOwnProperty("requestsWithErrorsCount"))
        if (typeof message2.requestsWithErrorsCount === "number")
          object.requestsWithErrorsCount = options.longs === String ? String(message2.requestsWithErrorsCount) : message2.requestsWithErrorsCount;
        else
          object.requestsWithErrorsCount = options.longs === String ? $util.Long.prototype.toString.call(message2.requestsWithErrorsCount) : options.longs === Number ? new $util.LongBits(message2.requestsWithErrorsCount.low >>> 0, message2.requestsWithErrorsCount.high >>> 0).toNumber(true) : message2.requestsWithErrorsCount;
      if (message2.registeredOperationCount != null && message2.hasOwnProperty("registeredOperationCount"))
        if (typeof message2.registeredOperationCount === "number")
          object.registeredOperationCount = options.longs === String ? String(message2.registeredOperationCount) : message2.registeredOperationCount;
        else
          object.registeredOperationCount = options.longs === String ? $util.Long.prototype.toString.call(message2.registeredOperationCount) : options.longs === Number ? new $util.LongBits(message2.registeredOperationCount.low >>> 0, message2.registeredOperationCount.high >>> 0).toNumber(true) : message2.registeredOperationCount;
      if (message2.forbiddenOperationCount != null && message2.hasOwnProperty("forbiddenOperationCount"))
        if (typeof message2.forbiddenOperationCount === "number")
          object.forbiddenOperationCount = options.longs === String ? String(message2.forbiddenOperationCount) : message2.forbiddenOperationCount;
        else
          object.forbiddenOperationCount = options.longs === String ? $util.Long.prototype.toString.call(message2.forbiddenOperationCount) : options.longs === Number ? new $util.LongBits(message2.forbiddenOperationCount.low >>> 0, message2.forbiddenOperationCount.high >>> 0).toNumber(true) : message2.forbiddenOperationCount;
      if (message2.latencyCount && message2.latencyCount.length) {
        object.latencyCount = [];
        for (var j = 0;j < message2.latencyCount.length; ++j)
          if (typeof message2.latencyCount[j] === "number")
            object.latencyCount[j] = options.longs === String ? String(message2.latencyCount[j]) : message2.latencyCount[j];
          else
            object.latencyCount[j] = options.longs === String ? $util.Long.prototype.toString.call(message2.latencyCount[j]) : options.longs === Number ? new $util.LongBits(message2.latencyCount[j].low >>> 0, message2.latencyCount[j].high >>> 0).toNumber() : message2.latencyCount[j];
      }
      if (message2.cacheLatencyCount && message2.cacheLatencyCount.length) {
        object.cacheLatencyCount = [];
        for (var j = 0;j < message2.cacheLatencyCount.length; ++j)
          if (typeof message2.cacheLatencyCount[j] === "number")
            object.cacheLatencyCount[j] = options.longs === String ? String(message2.cacheLatencyCount[j]) : message2.cacheLatencyCount[j];
          else
            object.cacheLatencyCount[j] = options.longs === String ? $util.Long.prototype.toString.call(message2.cacheLatencyCount[j]) : options.longs === Number ? new $util.LongBits(message2.cacheLatencyCount[j].low >>> 0, message2.cacheLatencyCount[j].high >>> 0).toNumber() : message2.cacheLatencyCount[j];
      }
      if (message2.publicCacheTtlCount && message2.publicCacheTtlCount.length) {
        object.publicCacheTtlCount = [];
        for (var j = 0;j < message2.publicCacheTtlCount.length; ++j)
          if (typeof message2.publicCacheTtlCount[j] === "number")
            object.publicCacheTtlCount[j] = options.longs === String ? String(message2.publicCacheTtlCount[j]) : message2.publicCacheTtlCount[j];
          else
            object.publicCacheTtlCount[j] = options.longs === String ? $util.Long.prototype.toString.call(message2.publicCacheTtlCount[j]) : options.longs === Number ? new $util.LongBits(message2.publicCacheTtlCount[j].low >>> 0, message2.publicCacheTtlCount[j].high >>> 0).toNumber() : message2.publicCacheTtlCount[j];
      }
      if (message2.privateCacheTtlCount && message2.privateCacheTtlCount.length) {
        object.privateCacheTtlCount = [];
        for (var j = 0;j < message2.privateCacheTtlCount.length; ++j)
          if (typeof message2.privateCacheTtlCount[j] === "number")
            object.privateCacheTtlCount[j] = options.longs === String ? String(message2.privateCacheTtlCount[j]) : message2.privateCacheTtlCount[j];
          else
            object.privateCacheTtlCount[j] = options.longs === String ? $util.Long.prototype.toString.call(message2.privateCacheTtlCount[j]) : options.longs === Number ? new $util.LongBits(message2.privateCacheTtlCount[j].low >>> 0, message2.privateCacheTtlCount[j].high >>> 0).toNumber() : message2.privateCacheTtlCount[j];
      }
      if (message2.requestsWithoutFieldInstrumentation != null && message2.hasOwnProperty("requestsWithoutFieldInstrumentation"))
        if (typeof message2.requestsWithoutFieldInstrumentation === "number")
          object.requestsWithoutFieldInstrumentation = options.longs === String ? String(message2.requestsWithoutFieldInstrumentation) : message2.requestsWithoutFieldInstrumentation;
        else
          object.requestsWithoutFieldInstrumentation = options.longs === String ? $util.Long.prototype.toString.call(message2.requestsWithoutFieldInstrumentation) : options.longs === Number ? new $util.LongBits(message2.requestsWithoutFieldInstrumentation.low >>> 0, message2.requestsWithoutFieldInstrumentation.high >>> 0).toNumber(true) : message2.requestsWithoutFieldInstrumentation;
      return object;
    };
    QueryLatencyStats.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };
    return QueryLatencyStats;
  }();
  $root.StatsContext = function() {
    function StatsContext(properties) {
      if (properties) {
        for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    StatsContext.prototype.clientName = "";
    StatsContext.prototype.clientVersion = "";
    StatsContext.create = function create(properties) {
      return new StatsContext(properties);
    };
    StatsContext.encode = function encode(message2, writer) {
      if (!writer)
        writer = $Writer.create();
      if (message2.clientName != null && Object.hasOwnProperty.call(message2, "clientName"))
        writer.uint32(18).string(message2.clientName);
      if (message2.clientVersion != null && Object.hasOwnProperty.call(message2, "clientVersion"))
        writer.uint32(26).string(message2.clientVersion);
      return writer;
    };
    StatsContext.encodeDelimited = function encodeDelimited(message2, writer) {
      return this.encode(message2, writer).ldelim();
    };
    StatsContext.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader))
        reader = $Reader.create(reader);
      var end = length === undefined ? reader.len : reader.pos + length, message2 = new $root.StatsContext;
      while (reader.pos < end) {
        var tag = reader.uint32();
        switch (tag >>> 3) {
          case 2:
            message2.clientName = reader.string();
            break;
          case 3:
            message2.clientVersion = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message2;
    };
    StatsContext.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader))
        reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };
    StatsContext.verify = function verify(message2) {
      if (typeof message2 !== "object" || message2 === null)
        return "object expected";
      if (message2.clientName != null && message2.hasOwnProperty("clientName")) {
        if (!$util.isString(message2.clientName))
          return "clientName: string expected";
      }
      if (message2.clientVersion != null && message2.hasOwnProperty("clientVersion")) {
        if (!$util.isString(message2.clientVersion))
          return "clientVersion: string expected";
      }
      return null;
    };
    StatsContext.toObject = function toObject(message2, options) {
      if (!options)
        options = {};
      var object = {};
      if (options.defaults) {
        object.clientName = "";
        object.clientVersion = "";
      }
      if (message2.clientName != null && message2.hasOwnProperty("clientName"))
        object.clientName = message2.clientName;
      if (message2.clientVersion != null && message2.hasOwnProperty("clientVersion"))
        object.clientVersion = message2.clientVersion;
      return object;
    };
    StatsContext.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };
    return StatsContext;
  }();
  $root.ContextualizedQueryLatencyStats = function() {
    function ContextualizedQueryLatencyStats(properties) {
      if (properties) {
        for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    ContextualizedQueryLatencyStats.prototype.queryLatencyStats = null;
    ContextualizedQueryLatencyStats.prototype.context = null;
    ContextualizedQueryLatencyStats.create = function create(properties) {
      return new ContextualizedQueryLatencyStats(properties);
    };
    ContextualizedQueryLatencyStats.encode = function encode(message2, writer) {
      if (!writer)
        writer = $Writer.create();
      if (message2.queryLatencyStats != null && Object.hasOwnProperty.call(message2, "queryLatencyStats"))
        $root.QueryLatencyStats.encode(message2.queryLatencyStats, writer.uint32(10).fork()).ldelim();
      if (message2.context != null && Object.hasOwnProperty.call(message2, "context"))
        $root.StatsContext.encode(message2.context, writer.uint32(18).fork()).ldelim();
      return writer;
    };
    ContextualizedQueryLatencyStats.encodeDelimited = function encodeDelimited(message2, writer) {
      return this.encode(message2, writer).ldelim();
    };
    ContextualizedQueryLatencyStats.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader))
        reader = $Reader.create(reader);
      var end = length === undefined ? reader.len : reader.pos + length, message2 = new $root.ContextualizedQueryLatencyStats;
      while (reader.pos < end) {
        var tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message2.queryLatencyStats = $root.QueryLatencyStats.decode(reader, reader.uint32());
            break;
          case 2:
            message2.context = $root.StatsContext.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message2;
    };
    ContextualizedQueryLatencyStats.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader))
        reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };
    ContextualizedQueryLatencyStats.verify = function verify(message2) {
      if (typeof message2 !== "object" || message2 === null)
        return "object expected";
      if (message2.queryLatencyStats != null && message2.hasOwnProperty("queryLatencyStats")) {
        var error = $root.QueryLatencyStats.verify(message2.queryLatencyStats);
        if (error)
          return "queryLatencyStats." + error;
      }
      if (message2.context != null && message2.hasOwnProperty("context")) {
        var error = $root.StatsContext.verify(message2.context);
        if (error)
          return "context." + error;
      }
      return null;
    };
    ContextualizedQueryLatencyStats.toObject = function toObject(message2, options) {
      if (!options)
        options = {};
      var object = {};
      if (options.defaults) {
        object.queryLatencyStats = null;
        object.context = null;
      }
      if (message2.queryLatencyStats != null && message2.hasOwnProperty("queryLatencyStats"))
        object.queryLatencyStats = $root.QueryLatencyStats.toObject(message2.queryLatencyStats, options);
      if (message2.context != null && message2.hasOwnProperty("context"))
        object.context = $root.StatsContext.toObject(message2.context, options);
      return object;
    };
    ContextualizedQueryLatencyStats.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };
    return ContextualizedQueryLatencyStats;
  }();
  $root.ContextualizedTypeStats = function() {
    function ContextualizedTypeStats(properties) {
      this.perTypeStat = {};
      if (properties) {
        for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    ContextualizedTypeStats.prototype.context = null;
    ContextualizedTypeStats.prototype.perTypeStat = $util.emptyObject;
    ContextualizedTypeStats.create = function create(properties) {
      return new ContextualizedTypeStats(properties);
    };
    ContextualizedTypeStats.encode = function encode(message2, writer) {
      if (!writer)
        writer = $Writer.create();
      if (message2.context != null && Object.hasOwnProperty.call(message2, "context"))
        $root.StatsContext.encode(message2.context, writer.uint32(10).fork()).ldelim();
      if (message2.perTypeStat != null && Object.hasOwnProperty.call(message2, "perTypeStat"))
        for (var keys = Object.keys(message2.perTypeStat), i = 0;i < keys.length; ++i) {
          writer.uint32(18).fork().uint32(10).string(keys[i]);
          $root.TypeStat.encode(message2.perTypeStat[keys[i]], writer.uint32(18).fork()).ldelim().ldelim();
        }
      return writer;
    };
    ContextualizedTypeStats.encodeDelimited = function encodeDelimited(message2, writer) {
      return this.encode(message2, writer).ldelim();
    };
    ContextualizedTypeStats.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader))
        reader = $Reader.create(reader);
      var end = length === undefined ? reader.len : reader.pos + length, message2 = new $root.ContextualizedTypeStats, key;
      while (reader.pos < end) {
        var tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message2.context = $root.StatsContext.decode(reader, reader.uint32());
            break;
          case 2:
            reader.skip().pos++;
            if (message2.perTypeStat === $util.emptyObject)
              message2.perTypeStat = {};
            key = reader.string();
            reader.pos++;
            message2.perTypeStat[key] = $root.TypeStat.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message2;
    };
    ContextualizedTypeStats.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader))
        reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };
    ContextualizedTypeStats.verify = function verify(message2) {
      if (typeof message2 !== "object" || message2 === null)
        return "object expected";
      if (message2.context != null && message2.hasOwnProperty("context")) {
        var error = $root.StatsContext.verify(message2.context);
        if (error)
          return "context." + error;
      }
      if (message2.perTypeStat != null && message2.hasOwnProperty("perTypeStat")) {
        if (!$util.isObject(message2.perTypeStat))
          return "perTypeStat: object expected";
        var key = Object.keys(message2.perTypeStat);
        for (var i = 0;i < key.length; ++i) {
          var error = $root.TypeStat.verify(message2.perTypeStat[key[i]]);
          if (error)
            return "perTypeStat." + error;
        }
      }
      return null;
    };
    ContextualizedTypeStats.toObject = function toObject(message2, options) {
      if (!options)
        options = {};
      var object = {};
      if (options.objects || options.defaults)
        object.perTypeStat = {};
      if (options.defaults)
        object.context = null;
      if (message2.context != null && message2.hasOwnProperty("context"))
        object.context = $root.StatsContext.toObject(message2.context, options);
      var keys2;
      if (message2.perTypeStat && (keys2 = Object.keys(message2.perTypeStat)).length) {
        object.perTypeStat = {};
        for (var j = 0;j < keys2.length; ++j)
          object.perTypeStat[keys2[j]] = $root.TypeStat.toObject(message2.perTypeStat[keys2[j]], options);
      }
      return object;
    };
    ContextualizedTypeStats.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };
    return ContextualizedTypeStats;
  }();
  $root.FieldStat = function() {
    function FieldStat(properties) {
      this.latencyCount = [];
      if (properties) {
        for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    FieldStat.prototype.returnType = "";
    FieldStat.prototype.errorsCount = 0;
    FieldStat.prototype.observedExecutionCount = 0;
    FieldStat.prototype.estimatedExecutionCount = 0;
    FieldStat.prototype.requestsWithErrorsCount = 0;
    FieldStat.prototype.latencyCount = $util.emptyArray;
    FieldStat.create = function create(properties) {
      return new FieldStat(properties);
    };
    FieldStat.encode = function encode(message2, writer) {
      if (!writer)
        writer = $Writer.create();
      if (message2.returnType != null && Object.hasOwnProperty.call(message2, "returnType"))
        writer.uint32(26).string(message2.returnType);
      if (message2.errorsCount != null && Object.hasOwnProperty.call(message2, "errorsCount"))
        writer.uint32(32).uint64(message2.errorsCount);
      if (message2.observedExecutionCount != null && Object.hasOwnProperty.call(message2, "observedExecutionCount"))
        writer.uint32(40).uint64(message2.observedExecutionCount);
      if (message2.requestsWithErrorsCount != null && Object.hasOwnProperty.call(message2, "requestsWithErrorsCount"))
        writer.uint32(48).uint64(message2.requestsWithErrorsCount);
      var array9;
      if (message2.latencyCount != null && message2.latencyCount.toArray)
        array9 = message2.latencyCount.toArray();
      else
        array9 = message2.latencyCount;
      if (array9 != null && array9.length) {
        writer.uint32(74).fork();
        for (var i = 0;i < array9.length; ++i)
          writer.sint64(array9[i]);
        writer.ldelim();
      }
      if (message2.estimatedExecutionCount != null && Object.hasOwnProperty.call(message2, "estimatedExecutionCount"))
        writer.uint32(80).uint64(message2.estimatedExecutionCount);
      return writer;
    };
    FieldStat.encodeDelimited = function encodeDelimited(message2, writer) {
      return this.encode(message2, writer).ldelim();
    };
    FieldStat.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader))
        reader = $Reader.create(reader);
      var end = length === undefined ? reader.len : reader.pos + length, message2 = new $root.FieldStat;
      while (reader.pos < end) {
        var tag = reader.uint32();
        switch (tag >>> 3) {
          case 3:
            message2.returnType = reader.string();
            break;
          case 4:
            message2.errorsCount = reader.uint64();
            break;
          case 5:
            message2.observedExecutionCount = reader.uint64();
            break;
          case 10:
            message2.estimatedExecutionCount = reader.uint64();
            break;
          case 6:
            message2.requestsWithErrorsCount = reader.uint64();
            break;
          case 9:
            if (!(message2.latencyCount && message2.latencyCount.length))
              message2.latencyCount = [];
            if ((tag & 7) === 2) {
              var end2 = reader.uint32() + reader.pos;
              while (reader.pos < end2)
                message2.latencyCount.push(reader.sint64());
            } else
              message2.latencyCount.push(reader.sint64());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message2;
    };
    FieldStat.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader))
        reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };
    FieldStat.verify = function verify(message2) {
      if (typeof message2 !== "object" || message2 === null)
        return "object expected";
      if (message2.returnType != null && message2.hasOwnProperty("returnType")) {
        if (!$util.isString(message2.returnType))
          return "returnType: string expected";
      }
      if (message2.errorsCount != null && message2.hasOwnProperty("errorsCount")) {
        if (!$util.isInteger(message2.errorsCount) && !(message2.errorsCount && $util.isInteger(message2.errorsCount.low) && $util.isInteger(message2.errorsCount.high)))
          return "errorsCount: integer|Long expected";
      }
      if (message2.observedExecutionCount != null && message2.hasOwnProperty("observedExecutionCount")) {
        if (!$util.isInteger(message2.observedExecutionCount) && !(message2.observedExecutionCount && $util.isInteger(message2.observedExecutionCount.low) && $util.isInteger(message2.observedExecutionCount.high)))
          return "observedExecutionCount: integer|Long expected";
      }
      if (message2.estimatedExecutionCount != null && message2.hasOwnProperty("estimatedExecutionCount")) {
        if (!$util.isInteger(message2.estimatedExecutionCount) && !(message2.estimatedExecutionCount && $util.isInteger(message2.estimatedExecutionCount.low) && $util.isInteger(message2.estimatedExecutionCount.high)))
          return "estimatedExecutionCount: integer|Long expected";
      }
      if (message2.requestsWithErrorsCount != null && message2.hasOwnProperty("requestsWithErrorsCount")) {
        if (!$util.isInteger(message2.requestsWithErrorsCount) && !(message2.requestsWithErrorsCount && $util.isInteger(message2.requestsWithErrorsCount.low) && $util.isInteger(message2.requestsWithErrorsCount.high)))
          return "requestsWithErrorsCount: integer|Long expected";
      }
      if (message2.latencyCount != null && message2.hasOwnProperty("latencyCount")) {
        var array9;
        if (message2.latencyCount != null && message2.latencyCount.toArray)
          array9 = message2.latencyCount.toArray();
        else
          array9 = message2.latencyCount;
        if (!Array.isArray(array9))
          return "latencyCount: array expected";
        for (var i = 0;i < array9.length; ++i)
          if (!$util.isInteger(array9[i]) && !(array9[i] && $util.isInteger(array9[i].low) && $util.isInteger(array9[i].high)))
            return "latencyCount: integer|Long[] expected";
      }
      return null;
    };
    FieldStat.toObject = function toObject(message2, options) {
      if (!options)
        options = {};
      var object = {};
      if (options.arrays || options.defaults)
        object.latencyCount = [];
      if (options.defaults) {
        object.returnType = "";
        object.errorsCount = 0;
        object.observedExecutionCount = 0;
        object.requestsWithErrorsCount = 0;
        object.estimatedExecutionCount = 0;
      }
      if (message2.returnType != null && message2.hasOwnProperty("returnType"))
        object.returnType = message2.returnType;
      if (message2.errorsCount != null && message2.hasOwnProperty("errorsCount"))
        if (typeof message2.errorsCount === "number")
          object.errorsCount = options.longs === String ? String(message2.errorsCount) : message2.errorsCount;
        else
          object.errorsCount = options.longs === String ? $util.Long.prototype.toString.call(message2.errorsCount) : options.longs === Number ? new $util.LongBits(message2.errorsCount.low >>> 0, message2.errorsCount.high >>> 0).toNumber(true) : message2.errorsCount;
      if (message2.observedExecutionCount != null && message2.hasOwnProperty("observedExecutionCount"))
        if (typeof message2.observedExecutionCount === "number")
          object.observedExecutionCount = options.longs === String ? String(message2.observedExecutionCount) : message2.observedExecutionCount;
        else
          object.observedExecutionCount = options.longs === String ? $util.Long.prototype.toString.call(message2.observedExecutionCount) : options.longs === Number ? new $util.LongBits(message2.observedExecutionCount.low >>> 0, message2.observedExecutionCount.high >>> 0).toNumber(true) : message2.observedExecutionCount;
      if (message2.requestsWithErrorsCount != null && message2.hasOwnProperty("requestsWithErrorsCount"))
        if (typeof message2.requestsWithErrorsCount === "number")
          object.requestsWithErrorsCount = options.longs === String ? String(message2.requestsWithErrorsCount) : message2.requestsWithErrorsCount;
        else
          object.requestsWithErrorsCount = options.longs === String ? $util.Long.prototype.toString.call(message2.requestsWithErrorsCount) : options.longs === Number ? new $util.LongBits(message2.requestsWithErrorsCount.low >>> 0, message2.requestsWithErrorsCount.high >>> 0).toNumber(true) : message2.requestsWithErrorsCount;
      if (message2.latencyCount && message2.latencyCount.length) {
        object.latencyCount = [];
        for (var j = 0;j < message2.latencyCount.length; ++j)
          if (typeof message2.latencyCount[j] === "number")
            object.latencyCount[j] = options.longs === String ? String(message2.latencyCount[j]) : message2.latencyCount[j];
          else
            object.latencyCount[j] = options.longs === String ? $util.Long.prototype.toString.call(message2.latencyCount[j]) : options.longs === Number ? new $util.LongBits(message2.latencyCount[j].low >>> 0, message2.latencyCount[j].high >>> 0).toNumber() : message2.latencyCount[j];
      }
      if (message2.estimatedExecutionCount != null && message2.hasOwnProperty("estimatedExecutionCount"))
        if (typeof message2.estimatedExecutionCount === "number")
          object.estimatedExecutionCount = options.longs === String ? String(message2.estimatedExecutionCount) : message2.estimatedExecutionCount;
        else
          object.estimatedExecutionCount = options.longs === String ? $util.Long.prototype.toString.call(message2.estimatedExecutionCount) : options.longs === Number ? new $util.LongBits(message2.estimatedExecutionCount.low >>> 0, message2.estimatedExecutionCount.high >>> 0).toNumber(true) : message2.estimatedExecutionCount;
      return object;
    };
    FieldStat.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };
    return FieldStat;
  }();
  $root.TypeStat = function() {
    function TypeStat(properties) {
      this.perFieldStat = {};
      if (properties) {
        for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    TypeStat.prototype.perFieldStat = $util.emptyObject;
    TypeStat.create = function create(properties) {
      return new TypeStat(properties);
    };
    TypeStat.encode = function encode(message2, writer) {
      if (!writer)
        writer = $Writer.create();
      if (message2.perFieldStat != null && Object.hasOwnProperty.call(message2, "perFieldStat"))
        for (var keys = Object.keys(message2.perFieldStat), i = 0;i < keys.length; ++i) {
          writer.uint32(26).fork().uint32(10).string(keys[i]);
          $root.FieldStat.encode(message2.perFieldStat[keys[i]], writer.uint32(18).fork()).ldelim().ldelim();
        }
      return writer;
    };
    TypeStat.encodeDelimited = function encodeDelimited(message2, writer) {
      return this.encode(message2, writer).ldelim();
    };
    TypeStat.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader))
        reader = $Reader.create(reader);
      var end = length === undefined ? reader.len : reader.pos + length, message2 = new $root.TypeStat, key;
      while (reader.pos < end) {
        var tag = reader.uint32();
        switch (tag >>> 3) {
          case 3:
            reader.skip().pos++;
            if (message2.perFieldStat === $util.emptyObject)
              message2.perFieldStat = {};
            key = reader.string();
            reader.pos++;
            message2.perFieldStat[key] = $root.FieldStat.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message2;
    };
    TypeStat.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader))
        reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };
    TypeStat.verify = function verify(message2) {
      if (typeof message2 !== "object" || message2 === null)
        return "object expected";
      if (message2.perFieldStat != null && message2.hasOwnProperty("perFieldStat")) {
        if (!$util.isObject(message2.perFieldStat))
          return "perFieldStat: object expected";
        var key = Object.keys(message2.perFieldStat);
        for (var i = 0;i < key.length; ++i) {
          var error = $root.FieldStat.verify(message2.perFieldStat[key[i]]);
          if (error)
            return "perFieldStat." + error;
        }
      }
      return null;
    };
    TypeStat.toObject = function toObject(message2, options) {
      if (!options)
        options = {};
      var object = {};
      if (options.objects || options.defaults)
        object.perFieldStat = {};
      var keys2;
      if (message2.perFieldStat && (keys2 = Object.keys(message2.perFieldStat)).length) {
        object.perFieldStat = {};
        for (var j = 0;j < keys2.length; ++j)
          object.perFieldStat[keys2[j]] = $root.FieldStat.toObject(message2.perFieldStat[keys2[j]], options);
      }
      return object;
    };
    TypeStat.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };
    return TypeStat;
  }();
  $root.ReferencedFieldsForType = function() {
    function ReferencedFieldsForType(properties) {
      this.fieldNames = [];
      if (properties) {
        for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    ReferencedFieldsForType.prototype.fieldNames = $util.emptyArray;
    ReferencedFieldsForType.prototype.isInterface = false;
    ReferencedFieldsForType.create = function create(properties) {
      return new ReferencedFieldsForType(properties);
    };
    ReferencedFieldsForType.encode = function encode(message2, writer) {
      if (!writer)
        writer = $Writer.create();
      if (message2.fieldNames != null && message2.fieldNames.length)
        for (var i = 0;i < message2.fieldNames.length; ++i)
          writer.uint32(10).string(message2.fieldNames[i]);
      if (message2.isInterface != null && Object.hasOwnProperty.call(message2, "isInterface"))
        writer.uint32(16).bool(message2.isInterface);
      return writer;
    };
    ReferencedFieldsForType.encodeDelimited = function encodeDelimited(message2, writer) {
      return this.encode(message2, writer).ldelim();
    };
    ReferencedFieldsForType.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader))
        reader = $Reader.create(reader);
      var end = length === undefined ? reader.len : reader.pos + length, message2 = new $root.ReferencedFieldsForType;
      while (reader.pos < end) {
        var tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (!(message2.fieldNames && message2.fieldNames.length))
              message2.fieldNames = [];
            message2.fieldNames.push(reader.string());
            break;
          case 2:
            message2.isInterface = reader.bool();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message2;
    };
    ReferencedFieldsForType.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader))
        reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };
    ReferencedFieldsForType.verify = function verify(message2) {
      if (typeof message2 !== "object" || message2 === null)
        return "object expected";
      if (message2.fieldNames != null && message2.hasOwnProperty("fieldNames")) {
        if (!Array.isArray(message2.fieldNames))
          return "fieldNames: array expected";
        for (var i = 0;i < message2.fieldNames.length; ++i)
          if (!$util.isString(message2.fieldNames[i]))
            return "fieldNames: string[] expected";
      }
      if (message2.isInterface != null && message2.hasOwnProperty("isInterface")) {
        if (typeof message2.isInterface !== "boolean")
          return "isInterface: boolean expected";
      }
      return null;
    };
    ReferencedFieldsForType.toObject = function toObject(message2, options) {
      if (!options)
        options = {};
      var object = {};
      if (options.arrays || options.defaults)
        object.fieldNames = [];
      if (options.defaults)
        object.isInterface = false;
      if (message2.fieldNames && message2.fieldNames.length) {
        object.fieldNames = [];
        for (var j = 0;j < message2.fieldNames.length; ++j)
          object.fieldNames[j] = message2.fieldNames[j];
      }
      if (message2.isInterface != null && message2.hasOwnProperty("isInterface"))
        object.isInterface = message2.isInterface;
      return object;
    };
    ReferencedFieldsForType.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };
    return ReferencedFieldsForType;
  }();
  $root.Report = function() {
    function Report(properties) {
      this.tracesPerQuery = {};
      if (properties) {
        for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    Report.prototype.header = null;
    Report.prototype.tracesPerQuery = $util.emptyObject;
    Report.prototype.endTime = null;
    Report.prototype.operationCount = 0;
    Report.prototype.tracesPreAggregated = false;
    Report.create = function create(properties) {
      return new Report(properties);
    };
    Report.encode = function encode(message2, writer) {
      if (!writer)
        writer = $Writer.create();
      if (message2.header != null && Object.hasOwnProperty.call(message2, "header"))
        $root.ReportHeader.encode(message2.header, writer.uint32(10).fork()).ldelim();
      if (message2.endTime != null && Object.hasOwnProperty.call(message2, "endTime"))
        $root.google.protobuf.Timestamp.encode(message2.endTime, writer.uint32(18).fork()).ldelim();
      if (message2.tracesPerQuery != null && Object.hasOwnProperty.call(message2, "tracesPerQuery"))
        for (var keys = Object.keys(message2.tracesPerQuery), i = 0;i < keys.length; ++i) {
          writer.uint32(42).fork().uint32(10).string(keys[i]);
          $root.TracesAndStats.encode(message2.tracesPerQuery[keys[i]], writer.uint32(18).fork()).ldelim().ldelim();
        }
      if (message2.operationCount != null && Object.hasOwnProperty.call(message2, "operationCount"))
        writer.uint32(48).uint64(message2.operationCount);
      if (message2.tracesPreAggregated != null && Object.hasOwnProperty.call(message2, "tracesPreAggregated"))
        writer.uint32(56).bool(message2.tracesPreAggregated);
      return writer;
    };
    Report.encodeDelimited = function encodeDelimited(message2, writer) {
      return this.encode(message2, writer).ldelim();
    };
    Report.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader))
        reader = $Reader.create(reader);
      var end = length === undefined ? reader.len : reader.pos + length, message2 = new $root.Report, key;
      while (reader.pos < end) {
        var tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message2.header = $root.ReportHeader.decode(reader, reader.uint32());
            break;
          case 5:
            reader.skip().pos++;
            if (message2.tracesPerQuery === $util.emptyObject)
              message2.tracesPerQuery = {};
            key = reader.string();
            reader.pos++;
            message2.tracesPerQuery[key] = $root.TracesAndStats.decode(reader, reader.uint32());
            break;
          case 2:
            message2.endTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
            break;
          case 6:
            message2.operationCount = reader.uint64();
            break;
          case 7:
            message2.tracesPreAggregated = reader.bool();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message2;
    };
    Report.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader))
        reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };
    Report.verify = function verify(message2) {
      if (typeof message2 !== "object" || message2 === null)
        return "object expected";
      if (message2.header != null && message2.hasOwnProperty("header")) {
        var error = $root.ReportHeader.verify(message2.header);
        if (error)
          return "header." + error;
      }
      if (message2.tracesPerQuery != null && message2.hasOwnProperty("tracesPerQuery")) {
        if (!$util.isObject(message2.tracesPerQuery))
          return "tracesPerQuery: object expected";
        var key = Object.keys(message2.tracesPerQuery);
        for (var i = 0;i < key.length; ++i) {
          var error = $root.TracesAndStats.verify(message2.tracesPerQuery[key[i]]);
          if (error)
            return "tracesPerQuery." + error;
        }
      }
      if (message2.endTime != null && message2.hasOwnProperty("endTime")) {
        var error = $root.google.protobuf.Timestamp.verify(message2.endTime);
        if (error)
          return "endTime." + error;
      }
      if (message2.operationCount != null && message2.hasOwnProperty("operationCount")) {
        if (!$util.isInteger(message2.operationCount) && !(message2.operationCount && $util.isInteger(message2.operationCount.low) && $util.isInteger(message2.operationCount.high)))
          return "operationCount: integer|Long expected";
      }
      if (message2.tracesPreAggregated != null && message2.hasOwnProperty("tracesPreAggregated")) {
        if (typeof message2.tracesPreAggregated !== "boolean")
          return "tracesPreAggregated: boolean expected";
      }
      return null;
    };
    Report.toObject = function toObject(message2, options) {
      if (!options)
        options = {};
      var object = {};
      if (options.objects || options.defaults)
        object.tracesPerQuery = {};
      if (options.defaults) {
        object.header = null;
        object.endTime = null;
        object.operationCount = 0;
        object.tracesPreAggregated = false;
      }
      if (message2.header != null && message2.hasOwnProperty("header"))
        object.header = $root.ReportHeader.toObject(message2.header, options);
      if (message2.endTime != null && message2.hasOwnProperty("endTime"))
        object.endTime = $root.google.protobuf.Timestamp.toObject(message2.endTime, options);
      var keys2;
      if (message2.tracesPerQuery && (keys2 = Object.keys(message2.tracesPerQuery)).length) {
        object.tracesPerQuery = {};
        for (var j = 0;j < keys2.length; ++j)
          object.tracesPerQuery[keys2[j]] = $root.TracesAndStats.toObject(message2.tracesPerQuery[keys2[j]], options);
      }
      if (message2.operationCount != null && message2.hasOwnProperty("operationCount"))
        if (typeof message2.operationCount === "number")
          object.operationCount = options.longs === String ? String(message2.operationCount) : message2.operationCount;
        else
          object.operationCount = options.longs === String ? $util.Long.prototype.toString.call(message2.operationCount) : options.longs === Number ? new $util.LongBits(message2.operationCount.low >>> 0, message2.operationCount.high >>> 0).toNumber(true) : message2.operationCount;
      if (message2.tracesPreAggregated != null && message2.hasOwnProperty("tracesPreAggregated"))
        object.tracesPreAggregated = message2.tracesPreAggregated;
      return object;
    };
    Report.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };
    return Report;
  }();
  $root.ContextualizedStats = function() {
    function ContextualizedStats(properties) {
      this.perTypeStat = {};
      if (properties) {
        for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    ContextualizedStats.prototype.context = null;
    ContextualizedStats.prototype.queryLatencyStats = null;
    ContextualizedStats.prototype.perTypeStat = $util.emptyObject;
    ContextualizedStats.create = function create(properties) {
      return new ContextualizedStats(properties);
    };
    ContextualizedStats.encode = function encode(message2, writer) {
      if (!writer)
        writer = $Writer.create();
      if (message2.context != null && Object.hasOwnProperty.call(message2, "context"))
        $root.StatsContext.encode(message2.context, writer.uint32(10).fork()).ldelim();
      if (message2.queryLatencyStats != null && Object.hasOwnProperty.call(message2, "queryLatencyStats"))
        $root.QueryLatencyStats.encode(message2.queryLatencyStats, writer.uint32(18).fork()).ldelim();
      if (message2.perTypeStat != null && Object.hasOwnProperty.call(message2, "perTypeStat"))
        for (var keys = Object.keys(message2.perTypeStat), i = 0;i < keys.length; ++i) {
          writer.uint32(26).fork().uint32(10).string(keys[i]);
          $root.TypeStat.encode(message2.perTypeStat[keys[i]], writer.uint32(18).fork()).ldelim().ldelim();
        }
      return writer;
    };
    ContextualizedStats.encodeDelimited = function encodeDelimited(message2, writer) {
      return this.encode(message2, writer).ldelim();
    };
    ContextualizedStats.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader))
        reader = $Reader.create(reader);
      var end = length === undefined ? reader.len : reader.pos + length, message2 = new $root.ContextualizedStats, key;
      while (reader.pos < end) {
        var tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message2.context = $root.StatsContext.decode(reader, reader.uint32());
            break;
          case 2:
            message2.queryLatencyStats = $root.QueryLatencyStats.decode(reader, reader.uint32());
            break;
          case 3:
            reader.skip().pos++;
            if (message2.perTypeStat === $util.emptyObject)
              message2.perTypeStat = {};
            key = reader.string();
            reader.pos++;
            message2.perTypeStat[key] = $root.TypeStat.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message2;
    };
    ContextualizedStats.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader))
        reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };
    ContextualizedStats.verify = function verify(message2) {
      if (typeof message2 !== "object" || message2 === null)
        return "object expected";
      if (message2.context != null && message2.hasOwnProperty("context")) {
        var error = $root.StatsContext.verify(message2.context);
        if (error)
          return "context." + error;
      }
      if (message2.queryLatencyStats != null && message2.hasOwnProperty("queryLatencyStats")) {
        var error = $root.QueryLatencyStats.verify(message2.queryLatencyStats);
        if (error)
          return "queryLatencyStats." + error;
      }
      if (message2.perTypeStat != null && message2.hasOwnProperty("perTypeStat")) {
        if (!$util.isObject(message2.perTypeStat))
          return "perTypeStat: object expected";
        var key = Object.keys(message2.perTypeStat);
        for (var i = 0;i < key.length; ++i) {
          var error = $root.TypeStat.verify(message2.perTypeStat[key[i]]);
          if (error)
            return "perTypeStat." + error;
        }
      }
      return null;
    };
    ContextualizedStats.toObject = function toObject(message2, options) {
      if (!options)
        options = {};
      var object = {};
      if (options.objects || options.defaults)
        object.perTypeStat = {};
      if (options.defaults) {
        object.context = null;
        object.queryLatencyStats = null;
      }
      if (message2.context != null && message2.hasOwnProperty("context"))
        object.context = $root.StatsContext.toObject(message2.context, options);
      if (message2.queryLatencyStats != null && message2.hasOwnProperty("queryLatencyStats"))
        object.queryLatencyStats = $root.QueryLatencyStats.toObject(message2.queryLatencyStats, options);
      var keys2;
      if (message2.perTypeStat && (keys2 = Object.keys(message2.perTypeStat)).length) {
        object.perTypeStat = {};
        for (var j = 0;j < keys2.length; ++j)
          object.perTypeStat[keys2[j]] = $root.TypeStat.toObject(message2.perTypeStat[keys2[j]], options);
      }
      return object;
    };
    ContextualizedStats.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };
    return ContextualizedStats;
  }();
  $root.TracesAndStats = function() {
    function TracesAndStats(properties) {
      this.trace = [];
      this.statsWithContext = [];
      this.referencedFieldsByType = {};
      this.internalTracesContributingToStats = [];
      if (properties) {
        for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    TracesAndStats.prototype.trace = $util.emptyArray;
    TracesAndStats.prototype.statsWithContext = $util.emptyArray;
    TracesAndStats.prototype.referencedFieldsByType = $util.emptyObject;
    TracesAndStats.prototype.internalTracesContributingToStats = $util.emptyArray;
    TracesAndStats.create = function create(properties) {
      return new TracesAndStats(properties);
    };
    TracesAndStats.encode = function encode(message2, writer) {
      if (!writer)
        writer = $Writer.create();
      if (message2.trace != null && message2.trace.length)
        for (var i = 0;i < message2.trace.length; ++i)
          if (message2.trace[i] instanceof Uint8Array) {
            writer.uint32(10);
            writer.bytes(message2.trace[i]);
          } else
            $root.Trace.encode(message2.trace[i], writer.uint32(10).fork()).ldelim();
      var array2;
      if (message2.statsWithContext != null && message2.statsWithContext.toArray)
        array2 = message2.statsWithContext.toArray();
      else
        array2 = message2.statsWithContext;
      if (array2 != null && array2.length)
        for (var i = 0;i < array2.length; ++i)
          $root.ContextualizedStats.encode(array2[i], writer.uint32(18).fork()).ldelim();
      if (message2.internalTracesContributingToStats != null && message2.internalTracesContributingToStats.length)
        for (var i = 0;i < message2.internalTracesContributingToStats.length; ++i)
          if (message2.internalTracesContributingToStats[i] instanceof Uint8Array) {
            writer.uint32(26);
            writer.bytes(message2.internalTracesContributingToStats[i]);
          } else
            $root.Trace.encode(message2.internalTracesContributingToStats[i], writer.uint32(26).fork()).ldelim();
      if (message2.referencedFieldsByType != null && Object.hasOwnProperty.call(message2, "referencedFieldsByType"))
        for (var keys = Object.keys(message2.referencedFieldsByType), i = 0;i < keys.length; ++i) {
          writer.uint32(34).fork().uint32(10).string(keys[i]);
          $root.ReferencedFieldsForType.encode(message2.referencedFieldsByType[keys[i]], writer.uint32(18).fork()).ldelim().ldelim();
        }
      return writer;
    };
    TracesAndStats.encodeDelimited = function encodeDelimited(message2, writer) {
      return this.encode(message2, writer).ldelim();
    };
    TracesAndStats.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader))
        reader = $Reader.create(reader);
      var end = length === undefined ? reader.len : reader.pos + length, message2 = new $root.TracesAndStats, key;
      while (reader.pos < end) {
        var tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (!(message2.trace && message2.trace.length))
              message2.trace = [];
            message2.trace.push($root.Trace.decode(reader, reader.uint32()));
            break;
          case 2:
            if (!(message2.statsWithContext && message2.statsWithContext.length))
              message2.statsWithContext = [];
            message2.statsWithContext.push($root.ContextualizedStats.decode(reader, reader.uint32()));
            break;
          case 4:
            reader.skip().pos++;
            if (message2.referencedFieldsByType === $util.emptyObject)
              message2.referencedFieldsByType = {};
            key = reader.string();
            reader.pos++;
            message2.referencedFieldsByType[key] = $root.ReferencedFieldsForType.decode(reader, reader.uint32());
            break;
          case 3:
            if (!(message2.internalTracesContributingToStats && message2.internalTracesContributingToStats.length))
              message2.internalTracesContributingToStats = [];
            message2.internalTracesContributingToStats.push($root.Trace.decode(reader, reader.uint32()));
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message2;
    };
    TracesAndStats.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader))
        reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };
    TracesAndStats.verify = function verify(message2) {
      if (typeof message2 !== "object" || message2 === null)
        return "object expected";
      if (message2.trace != null && message2.hasOwnProperty("trace")) {
        if (!Array.isArray(message2.trace))
          return "trace: array expected";
        for (var i = 0;i < message2.trace.length; ++i)
          if (!(message2.trace[i] instanceof Uint8Array)) {
            var error = $root.Trace.verify(message2.trace[i]);
            if (error)
              return "trace." + error;
          }
      }
      if (message2.statsWithContext != null && message2.hasOwnProperty("statsWithContext")) {
        var array2;
        if (message2.statsWithContext != null && message2.statsWithContext.toArray)
          array2 = message2.statsWithContext.toArray();
        else
          array2 = message2.statsWithContext;
        if (!Array.isArray(array2))
          return "statsWithContext: array expected";
        for (var i = 0;i < array2.length; ++i) {
          var error = $root.ContextualizedStats.verify(array2[i]);
          if (error)
            return "statsWithContext." + error;
        }
      }
      if (message2.referencedFieldsByType != null && message2.hasOwnProperty("referencedFieldsByType")) {
        if (!$util.isObject(message2.referencedFieldsByType))
          return "referencedFieldsByType: object expected";
        var key = Object.keys(message2.referencedFieldsByType);
        for (var i = 0;i < key.length; ++i) {
          var error = $root.ReferencedFieldsForType.verify(message2.referencedFieldsByType[key[i]]);
          if (error)
            return "referencedFieldsByType." + error;
        }
      }
      if (message2.internalTracesContributingToStats != null && message2.hasOwnProperty("internalTracesContributingToStats")) {
        if (!Array.isArray(message2.internalTracesContributingToStats))
          return "internalTracesContributingToStats: array expected";
        for (var i = 0;i < message2.internalTracesContributingToStats.length; ++i)
          if (!(message2.internalTracesContributingToStats[i] instanceof Uint8Array)) {
            var error = $root.Trace.verify(message2.internalTracesContributingToStats[i]);
            if (error)
              return "internalTracesContributingToStats." + error;
          }
      }
      return null;
    };
    TracesAndStats.toObject = function toObject(message2, options) {
      if (!options)
        options = {};
      var object = {};
      if (options.arrays || options.defaults) {
        object.trace = [];
        object.statsWithContext = [];
        object.internalTracesContributingToStats = [];
      }
      if (options.objects || options.defaults)
        object.referencedFieldsByType = {};
      if (message2.trace && message2.trace.length) {
        object.trace = [];
        for (var j = 0;j < message2.trace.length; ++j)
          object.trace[j] = $root.Trace.toObject(message2.trace[j], options);
      }
      if (message2.statsWithContext && message2.statsWithContext.length) {
        object.statsWithContext = [];
        for (var j = 0;j < message2.statsWithContext.length; ++j)
          object.statsWithContext[j] = $root.ContextualizedStats.toObject(message2.statsWithContext[j], options);
      }
      if (message2.internalTracesContributingToStats && message2.internalTracesContributingToStats.length) {
        object.internalTracesContributingToStats = [];
        for (var j = 0;j < message2.internalTracesContributingToStats.length; ++j)
          object.internalTracesContributingToStats[j] = $root.Trace.toObject(message2.internalTracesContributingToStats[j], options);
      }
      var keys2;
      if (message2.referencedFieldsByType && (keys2 = Object.keys(message2.referencedFieldsByType)).length) {
        object.referencedFieldsByType = {};
        for (var j = 0;j < keys2.length; ++j)
          object.referencedFieldsByType[keys2[j]] = $root.ReferencedFieldsForType.toObject(message2.referencedFieldsByType[keys2[j]], options);
      }
      return object;
    };
    TracesAndStats.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };
    return TracesAndStats;
  }();
  $root.google = function() {
    var google = {};
    google.protobuf = function() {
      var protobuf = {};
      protobuf.Timestamp = function() {
        function Timestamp(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        Timestamp.prototype.seconds = 0;
        Timestamp.prototype.nanos = 0;
        Timestamp.create = function create(properties) {
          return new Timestamp(properties);
        };
        Timestamp.encode = function encode(message2, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message2.seconds != null && Object.hasOwnProperty.call(message2, "seconds"))
            writer.uint32(8).int64(message2.seconds);
          if (message2.nanos != null && Object.hasOwnProperty.call(message2, "nanos"))
            writer.uint32(16).int32(message2.nanos);
          return writer;
        };
        Timestamp.encodeDelimited = function encodeDelimited(message2, writer) {
          return this.encode(message2, writer).ldelim();
        };
        Timestamp.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message2 = new $root.google.protobuf.Timestamp;
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message2.seconds = reader.int64();
                break;
              case 2:
                message2.nanos = reader.int32();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message2;
        };
        Timestamp.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        Timestamp.verify = function verify(message2) {
          if (typeof message2 !== "object" || message2 === null)
            return "object expected";
          if (message2.seconds != null && message2.hasOwnProperty("seconds")) {
            if (!$util.isInteger(message2.seconds) && !(message2.seconds && $util.isInteger(message2.seconds.low) && $util.isInteger(message2.seconds.high)))
              return "seconds: integer|Long expected";
          }
          if (message2.nanos != null && message2.hasOwnProperty("nanos")) {
            if (!$util.isInteger(message2.nanos))
              return "nanos: integer expected";
          }
          return null;
        };
        Timestamp.toObject = function toObject(message2, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.defaults) {
            object.seconds = 0;
            object.nanos = 0;
          }
          if (message2.seconds != null && message2.hasOwnProperty("seconds"))
            if (typeof message2.seconds === "number")
              object.seconds = options.longs === String ? String(message2.seconds) : message2.seconds;
            else
              object.seconds = options.longs === String ? $util.Long.prototype.toString.call(message2.seconds) : options.longs === Number ? new $util.LongBits(message2.seconds.low >>> 0, message2.seconds.high >>> 0).toNumber() : message2.seconds;
          if (message2.nanos != null && message2.hasOwnProperty("nanos"))
            object.nanos = message2.nanos;
          return object;
        };
        Timestamp.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return Timestamp;
      }();
      return protobuf;
    }();
    return google;
  }();
  module.exports = $root;
});

// node_modules/@apollo/utils.usagereporting/dist/calculateReferencedFieldsByType.js
var require_calculateReferencedFieldsByType = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.calculateReferencedFieldsByType = undefined;
  var graphql_1 = require_graphql2();
  var usage_reporting_protobuf_1 = require_protobuf2();
  function calculateReferencedFieldsByType({ document: document2, schema, resolvedOperationName }) {
    const documentSeparatedByOperation = (0, graphql_1.separateOperations)(document2);
    const filteredDocument = documentSeparatedByOperation[resolvedOperationName !== null && resolvedOperationName !== undefined ? resolvedOperationName : ""];
    if (!filteredDocument) {
      throw Error(`shouldn't happen: operation '${resolvedOperationName !== null && resolvedOperationName !== undefined ? resolvedOperationName : ""}' not found`);
    }
    const typeInfo = new graphql_1.TypeInfo(schema);
    const interfaces = new Set;
    const referencedFieldSetByType = Object.create(null);
    (0, graphql_1.visit)(filteredDocument, (0, graphql_1.visitWithTypeInfo)(typeInfo, {
      Field(field) {
        const fieldName = field.name.value;
        const parentType = typeInfo.getParentType();
        if (!parentType) {
          throw Error(`shouldn't happen: missing parent type for field ${fieldName}`);
        }
        const parentTypeName = parentType.name;
        if (!referencedFieldSetByType[parentTypeName]) {
          referencedFieldSetByType[parentTypeName] = new Set;
          if ((0, graphql_1.isInterfaceType)(parentType)) {
            interfaces.add(parentTypeName);
          }
        }
        referencedFieldSetByType[parentTypeName].add(fieldName);
      }
    }));
    const referencedFieldsByType = Object.create(null);
    for (const [typeName, fieldNames] of Object.entries(referencedFieldSetByType)) {
      referencedFieldsByType[typeName] = new usage_reporting_protobuf_1.ReferencedFieldsForType({
        fieldNames: [...fieldNames],
        isInterface: interfaces.has(typeName)
      });
    }
    return referencedFieldsByType;
  }
  exports.calculateReferencedFieldsByType = calculateReferencedFieldsByType;
});

// node_modules/@apollo/utils.dropunuseddefinitions/dist/index.js
var require_dist5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.dropUnusedDefinitions = undefined;
  var graphql_1 = require_graphql2();
  function dropUnusedDefinitions(ast, operationName) {
    const separated = (0, graphql_1.separateOperations)(ast)[operationName];
    if (!separated) {
      return ast;
    }
    return separated;
  }
  exports.dropUnusedDefinitions = dropUnusedDefinitions;
});

// node_modules/@apollo/utils.stripsensitiveliterals/dist/index.js
var require_dist6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.stripSensitiveLiterals = undefined;
  var graphql_1 = require_graphql2();
  function stripSensitiveLiterals(ast, options = {
    hideListAndObjectLiterals: false
  }) {
    const listAndObjectVisitorIfEnabled = options.hideListAndObjectLiterals ? {
      ListValue(node) {
        return { ...node, values: [] };
      },
      ObjectValue(node) {
        return { ...node, fields: [] };
      }
    } : {};
    return (0, graphql_1.visit)(ast, {
      IntValue(node) {
        return { ...node, value: "0" };
      },
      FloatValue(node) {
        return { ...node, value: "0" };
      },
      StringValue(node) {
        return { ...node, value: "", block: false };
      },
      ...listAndObjectVisitorIfEnabled
    });
  }
  exports.stripSensitiveLiterals = stripSensitiveLiterals;
});

// node_modules/@apollo/utils.printwithreducedwhitespace/dist/index.js
var require_dist7 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.printWithReducedWhitespace = undefined;
  var graphql_1 = require_graphql2();
  function printWithReducedWhitespace(ast) {
    const sanitizedAST = (0, graphql_1.visit)(ast, {
      StringValue(node) {
        return {
          ...node,
          value: Buffer.from(node.value, "utf8").toString("hex"),
          block: false
        };
      }
    });
    const withWhitespace = (0, graphql_1.print)(sanitizedAST);
    const minimizedButStillHex = withWhitespace.replace(/\s+/g, " ").replace(/([^_a-zA-Z0-9]) /g, (_, c) => c).replace(/ ([^_a-zA-Z0-9])/g, (_, c) => c);
    return minimizedButStillHex.replace(/"([a-f0-9]+)"/g, (_, hex) => JSON.stringify(Buffer.from(hex, "hex").toString("utf8")));
  }
  exports.printWithReducedWhitespace = printWithReducedWhitespace;
});

// node_modules/@apollo/utils.removealiases/dist/index.js
var require_dist8 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.removeAliases = undefined;
  var graphql_1 = require_graphql2();
  function removeAliases(ast) {
    return (0, graphql_1.visit)(ast, {
      Field(node) {
        const { alias, ...rest } = node;
        return rest;
      }
    });
  }
  exports.removeAliases = removeAliases;
});

// node_modules/lodash.sortby/index.js
var require_lodash = __commonJS((exports, module) => {
  var LARGE_ARRAY_SIZE = 200;
  var FUNC_ERROR_TEXT = "Expected a function";
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  var UNORDERED_COMPARE_FLAG = 1;
  var PARTIAL_COMPARE_FLAG = 2;
  var INFINITY = 1 / 0;
  var MAX_SAFE_INTEGER = 9007199254740991;
  var argsTag = "[object Arguments]";
  var arrayTag = "[object Array]";
  var boolTag = "[object Boolean]";
  var dateTag = "[object Date]";
  var errorTag = "[object Error]";
  var funcTag = "[object Function]";
  var genTag = "[object GeneratorFunction]";
  var mapTag = "[object Map]";
  var numberTag = "[object Number]";
  var objectTag = "[object Object]";
  var promiseTag = "[object Promise]";
  var regexpTag = "[object RegExp]";
  var setTag = "[object Set]";
  var stringTag = "[object String]";
  var symbolTag = "[object Symbol]";
  var weakMapTag = "[object WeakMap]";
  var arrayBufferTag = "[object ArrayBuffer]";
  var dataViewTag = "[object DataView]";
  var float32Tag = "[object Float32Array]";
  var float64Tag = "[object Float64Array]";
  var int8Tag = "[object Int8Array]";
  var int16Tag = "[object Int16Array]";
  var int32Tag = "[object Int32Array]";
  var uint8Tag = "[object Uint8Array]";
  var uint8ClampedTag = "[object Uint8ClampedArray]";
  var uint16Tag = "[object Uint16Array]";
  var uint32Tag = "[object Uint32Array]";
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
  var reIsPlainProp = /^\w*$/;
  var reLeadingDot = /^\./;
  var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reEscapeChar = /\\(\\)?/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
  var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
  var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var freeProcess = moduleExports && freeGlobal.process;
  var nodeUtil = function() {
    try {
      return freeProcess && freeProcess.binding("util");
    } catch (e) {}
  }();
  var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
  function apply(func, thisArg, args2) {
    switch (args2.length) {
      case 0:
        return func.call(thisArg);
      case 1:
        return func.call(thisArg, args2[0]);
      case 2:
        return func.call(thisArg, args2[0], args2[1]);
      case 3:
        return func.call(thisArg, args2[0], args2[1], args2[2]);
    }
    return func.apply(thisArg, args2);
  }
  function arrayMap(array, iteratee) {
    var index = -1, length = array ? array.length : 0, result = Array(length);
    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }
    return result;
  }
  function arrayPush(array, values) {
    var index = -1, length = values.length, offset = array.length;
    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
  }
  function arraySome(array, predicate) {
    var index = -1, length = array ? array.length : 0;
    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }
    return false;
  }
  function baseProperty(key) {
    return function(object) {
      return object == null ? undefined : object[key];
    };
  }
  function baseSortBy(array, comparer) {
    var length = array.length;
    array.sort(comparer);
    while (length--) {
      array[length] = array[length].value;
    }
    return array;
  }
  function baseTimes(n, iteratee) {
    var index = -1, result = Array(n);
    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }
  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }
  function isHostObject(value) {
    var result = false;
    if (value != null && typeof value.toString != "function") {
      try {
        result = !!(value + "");
      } catch (e) {}
    }
    return result;
  }
  function mapToArray(map) {
    var index = -1, result = Array(map.size);
    map.forEach(function(value, key) {
      result[++index] = [key, value];
    });
    return result;
  }
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }
  function setToArray(set) {
    var index = -1, result = Array(set.size);
    set.forEach(function(value) {
      result[++index] = value;
    });
    return result;
  }
  var arrayProto = Array.prototype;
  var funcProto = Function.prototype;
  var objectProto = Object.prototype;
  var coreJsData = root["__core-js_shared__"];
  var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  var funcToString = funcProto.toString;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objectToString = objectProto.toString;
  var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
  var Symbol2 = root.Symbol;
  var Uint8Array2 = root.Uint8Array;
  var propertyIsEnumerable = objectProto.propertyIsEnumerable;
  var splice = arrayProto.splice;
  var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined;
  var nativeKeys = overArg(Object.keys, Object);
  var nativeMax = Math.max;
  var DataView = getNative(root, "DataView");
  var Map2 = getNative(root, "Map");
  var Promise2 = getNative(root, "Promise");
  var Set2 = getNative(root, "Set");
  var WeakMap2 = getNative(root, "WeakMap");
  var nativeCreate = getNative(Object, "create");
  var dataViewCtorString = toSource(DataView);
  var mapCtorString = toSource(Map2);
  var promiseCtorString = toSource(Promise2);
  var setCtorString = toSource(Set2);
  var weakMapCtorString = toSource(WeakMap2);
  var symbolProto = Symbol2 ? Symbol2.prototype : undefined;
  var symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
  var symbolToString = symbolProto ? symbolProto.toString : undefined;
  function Hash(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
  }
  function hashDelete(key) {
    return this.has(key) && delete this.__data__[key];
  }
  function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? undefined : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : undefined;
  }
  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
  }
  function hashSet(key, value) {
    var data = this.__data__;
    data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
    return this;
  }
  Hash.prototype.clear = hashClear;
  Hash.prototype["delete"] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;
  function ListCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function listCacheClear() {
    this.__data__ = [];
  }
  function listCacheDelete(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    return true;
  }
  function listCacheGet(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    return index < 0 ? undefined : data[index][1];
  }
  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }
  function listCacheSet(key, value) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype["delete"] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  function MapCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function mapCacheClear() {
    this.__data__ = {
      hash: new Hash,
      map: new (Map2 || ListCache),
      string: new Hash
    };
  }
  function mapCacheDelete(key) {
    return getMapData(this, key)["delete"](key);
  }
  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }
  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }
  function mapCacheSet(key, value) {
    getMapData(this, key).set(key, value);
    return this;
  }
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype["delete"] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  function SetCache(values) {
    var index = -1, length = values ? values.length : 0;
    this.__data__ = new MapCache;
    while (++index < length) {
      this.add(values[index]);
    }
  }
  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
  }
  function setCacheHas(value) {
    return this.__data__.has(value);
  }
  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
  SetCache.prototype.has = setCacheHas;
  function Stack(entries) {
    this.__data__ = new ListCache(entries);
  }
  function stackClear() {
    this.__data__ = new ListCache;
  }
  function stackDelete(key) {
    return this.__data__["delete"](key);
  }
  function stackGet(key) {
    return this.__data__.get(key);
  }
  function stackHas(key) {
    return this.__data__.has(key);
  }
  function stackSet(key, value) {
    var cache = this.__data__;
    if (cache instanceof ListCache) {
      var pairs = cache.__data__;
      if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
        pairs.push([key, value]);
        return this;
      }
      cache = this.__data__ = new MapCache(pairs);
    }
    cache.set(key, value);
    return this;
  }
  Stack.prototype.clear = stackClear;
  Stack.prototype["delete"] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;
  function arrayLikeKeys(value, inherited) {
    var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
    var length = result.length, skipIndexes = !!length;
    for (var key in value) {
      if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
        result.push(key);
      }
    }
    return result;
  }
  function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }
  var baseEach = createBaseEach(baseForOwn);
  function baseFlatten(array, depth, predicate, isStrict, result) {
    var index = -1, length = array.length;
    predicate || (predicate = isFlattenable);
    result || (result = []);
    while (++index < length) {
      var value = array[index];
      if (depth > 0 && predicate(value)) {
        if (depth > 1) {
          baseFlatten(value, depth - 1, predicate, isStrict, result);
        } else {
          arrayPush(result, value);
        }
      } else if (!isStrict) {
        result[result.length] = value;
      }
    }
    return result;
  }
  var baseFor = createBaseFor();
  function baseForOwn(object, iteratee) {
    return object && baseFor(object, iteratee, keys);
  }
  function baseGet(object, path) {
    path = isKey(path, object) ? [path] : castPath(path);
    var index = 0, length = path.length;
    while (object != null && index < length) {
      object = object[toKey(path[index++])];
    }
    return index && index == length ? object : undefined;
  }
  function baseGetTag(value) {
    return objectToString.call(value);
  }
  function baseHasIn(object, key) {
    return object != null && key in Object(object);
  }
  function baseIsEqual(value, other, customizer, bitmask, stack2) {
    if (value === other) {
      return true;
    }
    if (value == null || other == null || !isObject(value) && !isObjectLike(other)) {
      return value !== value && other !== other;
    }
    return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack2);
  }
  function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack2) {
    var objIsArr = isArray(object), othIsArr = isArray(other), objTag = arrayTag, othTag = arrayTag;
    if (!objIsArr) {
      objTag = getTag(object);
      objTag = objTag == argsTag ? objectTag : objTag;
    }
    if (!othIsArr) {
      othTag = getTag(other);
      othTag = othTag == argsTag ? objectTag : othTag;
    }
    var objIsObj = objTag == objectTag && !isHostObject(object), othIsObj = othTag == objectTag && !isHostObject(other), isSameTag = objTag == othTag;
    if (isSameTag && !objIsObj) {
      stack2 || (stack2 = new Stack);
      return objIsArr || isTypedArray(object) ? equalArrays(object, other, equalFunc, customizer, bitmask, stack2) : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack2);
    }
    if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
      var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
        stack2 || (stack2 = new Stack);
        return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack2);
      }
    }
    if (!isSameTag) {
      return false;
    }
    stack2 || (stack2 = new Stack);
    return equalObjects(object, other, equalFunc, customizer, bitmask, stack2);
  }
  function baseIsMatch(object, source, matchData, customizer) {
    var index = matchData.length, length = index, noCustomizer = !customizer;
    if (object == null) {
      return !length;
    }
    object = Object(object);
    while (index--) {
      var data = matchData[index];
      if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
        return false;
      }
    }
    while (++index < length) {
      data = matchData[index];
      var key = data[0], objValue = object[key], srcValue = data[1];
      if (noCustomizer && data[2]) {
        if (objValue === undefined && !(key in object)) {
          return false;
        }
      } else {
        var stack2 = new Stack;
        if (customizer) {
          var result = customizer(objValue, srcValue, key, object, source, stack2);
        }
        if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack2) : result)) {
          return false;
        }
      }
    }
    return true;
  }
  function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }
  function baseIsTypedArray(value) {
    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
  }
  function baseIteratee(value) {
    if (typeof value == "function") {
      return value;
    }
    if (value == null) {
      return identity;
    }
    if (typeof value == "object") {
      return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
    }
    return property(value);
  }
  function baseKeys(object) {
    if (!isPrototype(object)) {
      return nativeKeys(object);
    }
    var result = [];
    for (var key in Object(object)) {
      if (hasOwnProperty.call(object, key) && key != "constructor") {
        result.push(key);
      }
    }
    return result;
  }
  function baseMap(collection, iteratee) {
    var index = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
    baseEach(collection, function(value, key, collection2) {
      result[++index] = iteratee(value, key, collection2);
    });
    return result;
  }
  function baseMatches(source) {
    var matchData = getMatchData(source);
    if (matchData.length == 1 && matchData[0][2]) {
      return matchesStrictComparable(matchData[0][0], matchData[0][1]);
    }
    return function(object) {
      return object === source || baseIsMatch(object, source, matchData);
    };
  }
  function baseMatchesProperty(path, srcValue) {
    if (isKey(path) && isStrictComparable(srcValue)) {
      return matchesStrictComparable(toKey(path), srcValue);
    }
    return function(object) {
      var objValue = get(object, path);
      return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, undefined, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
    };
  }
  function baseOrderBy(collection, iteratees, orders) {
    var index = -1;
    iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(baseIteratee));
    var result = baseMap(collection, function(value, key, collection2) {
      var criteria = arrayMap(iteratees, function(iteratee) {
        return iteratee(value);
      });
      return { criteria, index: ++index, value };
    });
    return baseSortBy(result, function(object, other) {
      return compareMultiple(object, other, orders);
    });
  }
  function basePropertyDeep(path) {
    return function(object) {
      return baseGet(object, path);
    };
  }
  function baseRest(func, start) {
    start = nativeMax(start === undefined ? func.length - 1 : start, 0);
    return function() {
      var args2 = arguments, index = -1, length = nativeMax(args2.length - start, 0), array = Array(length);
      while (++index < length) {
        array[index] = args2[start + index];
      }
      index = -1;
      var otherArgs = Array(start + 1);
      while (++index < start) {
        otherArgs[index] = args2[index];
      }
      otherArgs[start] = array;
      return apply(func, this, otherArgs);
    };
  }
  function baseToString(value) {
    if (typeof value == "string") {
      return value;
    }
    if (isSymbol(value)) {
      return symbolToString ? symbolToString.call(value) : "";
    }
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY ? "-0" : result;
  }
  function castPath(value) {
    return isArray(value) ? value : stringToPath(value);
  }
  function compareAscending(value, other) {
    if (value !== other) {
      var valIsDefined = value !== undefined, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
      var othIsDefined = other !== undefined, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
      if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
        return 1;
      }
      if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
        return -1;
      }
    }
    return 0;
  }
  function compareMultiple(object, other, orders) {
    var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
    while (++index < length) {
      var result = compareAscending(objCriteria[index], othCriteria[index]);
      if (result) {
        if (index >= ordersLength) {
          return result;
        }
        var order = orders[index];
        return result * (order == "desc" ? -1 : 1);
      }
    }
    return object.index - other.index;
  }
  function createBaseEach(eachFunc, fromRight) {
    return function(collection, iteratee) {
      if (collection == null) {
        return collection;
      }
      if (!isArrayLike(collection)) {
        return eachFunc(collection, iteratee);
      }
      var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
      while (fromRight ? index-- : ++index < length) {
        if (iteratee(iterable[index], index, iterable) === false) {
          break;
        }
      }
      return collection;
    };
  }
  function createBaseFor(fromRight) {
    return function(object, iteratee, keysFunc) {
      var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
      while (length--) {
        var key = props[fromRight ? length : ++index];
        if (iteratee(iterable[key], key, iterable) === false) {
          break;
        }
      }
      return object;
    };
  }
  function equalArrays(array, other, equalFunc, customizer, bitmask, stack2) {
    var isPartial = bitmask & PARTIAL_COMPARE_FLAG, arrLength = array.length, othLength = other.length;
    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    }
    var stacked = stack2.get(array);
    if (stacked && stack2.get(other)) {
      return stacked == other;
    }
    var index = -1, result = true, seen = bitmask & UNORDERED_COMPARE_FLAG ? new SetCache : undefined;
    stack2.set(array, other);
    stack2.set(other, array);
    while (++index < arrLength) {
      var arrValue = array[index], othValue = other[index];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack2) : customizer(arrValue, othValue, index, array, other, stack2);
      }
      if (compared !== undefined) {
        if (compared) {
          continue;
        }
        result = false;
        break;
      }
      if (seen) {
        if (!arraySome(other, function(othValue2, othIndex) {
          if (!seen.has(othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, customizer, bitmask, stack2))) {
            return seen.add(othIndex);
          }
        })) {
          result = false;
          break;
        }
      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack2))) {
        result = false;
        break;
      }
    }
    stack2["delete"](array);
    stack2["delete"](other);
    return result;
  }
  function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack2) {
    switch (tag) {
      case dataViewTag:
        if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
          return false;
        }
        object = object.buffer;
        other = other.buffer;
      case arrayBufferTag:
        if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
          return false;
        }
        return true;
      case boolTag:
      case dateTag:
      case numberTag:
        return eq(+object, +other);
      case errorTag:
        return object.name == other.name && object.message == other.message;
      case regexpTag:
      case stringTag:
        return object == other + "";
      case mapTag:
        var convert = mapToArray;
      case setTag:
        var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
        convert || (convert = setToArray);
        if (object.size != other.size && !isPartial) {
          return false;
        }
        var stacked = stack2.get(object);
        if (stacked) {
          return stacked == other;
        }
        bitmask |= UNORDERED_COMPARE_FLAG;
        stack2.set(object, other);
        var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack2);
        stack2["delete"](object);
        return result;
      case symbolTag:
        if (symbolValueOf) {
          return symbolValueOf.call(object) == symbolValueOf.call(other);
        }
    }
    return false;
  }
  function equalObjects(object, other, equalFunc, customizer, bitmask, stack2) {
    var isPartial = bitmask & PARTIAL_COMPARE_FLAG, objProps = keys(object), objLength = objProps.length, othProps = keys(other), othLength = othProps.length;
    if (objLength != othLength && !isPartial) {
      return false;
    }
    var index = objLength;
    while (index--) {
      var key = objProps[index];
      if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
        return false;
      }
    }
    var stacked = stack2.get(object);
    if (stacked && stack2.get(other)) {
      return stacked == other;
    }
    var result = true;
    stack2.set(object, other);
    stack2.set(other, object);
    var skipCtor = isPartial;
    while (++index < objLength) {
      key = objProps[index];
      var objValue = object[key], othValue = other[key];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack2) : customizer(objValue, othValue, key, object, other, stack2);
      }
      if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack2) : compared)) {
        result = false;
        break;
      }
      skipCtor || (skipCtor = key == "constructor");
    }
    if (result && !skipCtor) {
      var objCtor = object.constructor, othCtor = other.constructor;
      if (objCtor != othCtor && (("constructor" in object) && ("constructor" in other)) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
        result = false;
      }
    }
    stack2["delete"](object);
    stack2["delete"](other);
    return result;
  }
  function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
  }
  function getMatchData(object) {
    var result = keys(object), length = result.length;
    while (length--) {
      var key = result[length], value = object[key];
      result[length] = [key, value, isStrictComparable(value)];
    }
    return result;
  }
  function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
  }
  var getTag = baseGetTag;
  if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2) != setTag || WeakMap2 && getTag(new WeakMap2) != weakMapTag) {
    getTag = function(value) {
      var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : undefined, ctorString = Ctor ? toSource(Ctor) : undefined;
      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag;
          case mapCtorString:
            return mapTag;
          case promiseCtorString:
            return promiseTag;
          case setCtorString:
            return setTag;
          case weakMapCtorString:
            return weakMapTag;
        }
      }
      return result;
    };
  }
  function hasPath(object, path, hasFunc) {
    path = isKey(path, object) ? [path] : castPath(path);
    var result, index = -1, length = path.length;
    while (++index < length) {
      var key = toKey(path[index]);
      if (!(result = object != null && hasFunc(object, key))) {
        break;
      }
      object = object[key];
    }
    if (result) {
      return result;
    }
    var length = object ? object.length : 0;
    return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
  }
  function isFlattenable(value) {
    return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
  }
  function isIndex(value, length) {
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
  }
  function isIterateeCall(value, index, object) {
    if (!isObject(object)) {
      return false;
    }
    var type = typeof index;
    if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && (index in object)) {
      return eq(object[index], value);
    }
    return false;
  }
  function isKey(value, object) {
    if (isArray(value)) {
      return false;
    }
    var type = typeof value;
    if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
      return true;
    }
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
  }
  function isKeyable(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
  }
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
    return value === proto;
  }
  function isStrictComparable(value) {
    return value === value && !isObject(value);
  }
  function matchesStrictComparable(key, srcValue) {
    return function(object) {
      if (object == null) {
        return false;
      }
      return object[key] === srcValue && (srcValue !== undefined || (key in Object(object)));
    };
  }
  var stringToPath = memoize(function(string) {
    string = toString(string);
    var result = [];
    if (reLeadingDot.test(string)) {
      result.push("");
    }
    string.replace(rePropName, function(match, number, quote, string2) {
      result.push(quote ? string2.replace(reEscapeChar, "$1") : number || match);
    });
    return result;
  });
  function toKey(value) {
    if (typeof value == "string" || isSymbol(value)) {
      return value;
    }
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY ? "-0" : result;
  }
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {}
      try {
        return func + "";
      } catch (e) {}
    }
    return "";
  }
  var sortBy = baseRest(function(collection, iteratees) {
    if (collection == null) {
      return [];
    }
    var length = iteratees.length;
    if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
      iteratees = [];
    } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
      iteratees = [iteratees[0]];
    }
    return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
  });
  function memoize(func, resolver) {
    if (typeof func != "function" || resolver && typeof resolver != "function") {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    var memoized = function() {
      var args2 = arguments, key = resolver ? resolver.apply(this, args2) : args2[0], cache = memoized.cache;
      if (cache.has(key)) {
        return cache.get(key);
      }
      var result = func.apply(this, args2);
      memoized.cache = cache.set(key, result);
      return result;
    };
    memoized.cache = new (memoize.Cache || MapCache);
    return memoized;
  }
  memoize.Cache = MapCache;
  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }
  function isArguments(value) {
    return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
  }
  var isArray = Array.isArray;
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  }
  function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
  }
  function isFunction(value) {
    var tag = isObject(value) ? objectToString.call(value) : "";
    return tag == funcTag || tag == genTag;
  }
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  function isObject(value) {
    var type = typeof value;
    return !!value && (type == "object" || type == "function");
  }
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  function isSymbol(value) {
    return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
  }
  var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
  function toString(value) {
    return value == null ? "" : baseToString(value);
  }
  function get(object, path, defaultValue) {
    var result = object == null ? undefined : baseGet(object, path);
    return result === undefined ? defaultValue : result;
  }
  function hasIn(object, path) {
    return object != null && hasPath(object, path, baseHasIn);
  }
  function keys(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
  }
  function identity(value) {
    return value;
  }
  function property(path) {
    return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
  }
  module.exports = sortBy;
});

// node_modules/@apollo/utils.sortast/dist/index.js
var require_dist9 = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.sortAST = undefined;
  var graphql_1 = require_graphql2();
  var lodash_sortby_1 = __importDefault(require_lodash());
  function sortAST(ast) {
    return (0, graphql_1.visit)(ast, {
      Document(node) {
        return {
          ...node,
          definitions: (0, lodash_sortby_1.default)(node.definitions, "kind", "name.value")
        };
      },
      OperationDefinition(node) {
        return sortVariableDefinitions(node);
      },
      SelectionSet(node) {
        return {
          ...node,
          selections: (0, lodash_sortby_1.default)(node.selections, "kind", "name.value")
        };
      },
      Field(node) {
        return sortArguments(node);
      },
      FragmentSpread(node) {
        return sortDirectives(node);
      },
      InlineFragment(node) {
        return sortDirectives(node);
      },
      FragmentDefinition(node) {
        return sortDirectives(sortVariableDefinitions(node));
      },
      Directive(node) {
        return sortArguments(node);
      }
    });
  }
  exports.sortAST = sortAST;
  function sortDirectives(node) {
    return "directives" in node ? { ...node, directives: (0, lodash_sortby_1.default)(node.directives, "name.value") } : node;
  }
  function sortArguments(node) {
    return "arguments" in node ? { ...node, arguments: (0, lodash_sortby_1.default)(node.arguments, "name.value") } : node;
  }
  function sortVariableDefinitions(node) {
    return "variableDefinitions" in node ? {
      ...node,
      variableDefinitions: (0, lodash_sortby_1.default)(node.variableDefinitions, "variable.name.value")
    } : node;
  }
});

// node_modules/@apollo/utils.usagereporting/dist/signature.js
var require_signature = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.usageReportingSignature = undefined;
  var utils_dropunuseddefinitions_1 = require_dist5();
  var utils_stripsensitiveliterals_1 = require_dist6();
  var utils_printwithreducedwhitespace_1 = require_dist7();
  var utils_removealiases_1 = require_dist8();
  var utils_sortast_1 = require_dist9();
  function usageReportingSignature(ast, operationName) {
    return (0, utils_printwithreducedwhitespace_1.printWithReducedWhitespace)((0, utils_sortast_1.sortAST)((0, utils_removealiases_1.removeAliases)((0, utils_stripsensitiveliterals_1.stripSensitiveLiterals)((0, utils_dropunuseddefinitions_1.dropUnusedDefinitions)(ast, operationName), {
      hideListAndObjectLiterals: true
    }))));
  }
  exports.usageReportingSignature = usageReportingSignature;
});

// node_modules/@apollo/utils.usagereporting/dist/index.js
var require_dist10 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.usageReportingSignature = exports.calculateReferencedFieldsByType = undefined;
  var calculateReferencedFieldsByType_1 = require_calculateReferencedFieldsByType();
  Object.defineProperty(exports, "calculateReferencedFieldsByType", { enumerable: true, get: function() {
    return calculateReferencedFieldsByType_1.calculateReferencedFieldsByType;
  } });
  var signature_1 = require_signature();
  Object.defineProperty(exports, "usageReportingSignature", { enumerable: true, get: function() {
    return signature_1.usageReportingSignature;
  } });
});

// node_modules/apollo-server-core/dist/plugin/traceTreeBuilder.js
var require_traceTreeBuilder = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.dateToProtoTimestamp = exports.TraceTreeBuilder = undefined;
  var graphql_1 = require_graphql2();
  var apollo_reporting_protobuf_1 = require_generated();
  function internalError(message2) {
    return new Error(`[internal apollo-server error] ${message2}`);
  }

  class TraceTreeBuilder {
    constructor(options) {
      this.rootNode = new apollo_reporting_protobuf_1.Trace.Node;
      this.logger = console;
      this.trace = new apollo_reporting_protobuf_1.Trace({
        root: this.rootNode,
        fieldExecutionWeight: 1
      });
      this.stopped = false;
      this.nodes = new Map([
        [responsePathAsString(), this.rootNode]
      ]);
      this.rewriteError = options.rewriteError;
      if (options.logger)
        this.logger = options.logger;
    }
    startTiming() {
      if (this.startHrTime) {
        throw internalError("startTiming called twice!");
      }
      if (this.stopped) {
        throw internalError("startTiming called after stopTiming!");
      }
      this.trace.startTime = dateToProtoTimestamp(new Date);
      this.startHrTime = process.hrtime();
    }
    stopTiming() {
      if (!this.startHrTime) {
        throw internalError("stopTiming called before startTiming!");
      }
      if (this.stopped) {
        throw internalError("stopTiming called twice!");
      }
      this.trace.durationNs = durationHrTimeToNanos(process.hrtime(this.startHrTime));
      this.trace.endTime = dateToProtoTimestamp(new Date);
      this.stopped = true;
    }
    willResolveField(info) {
      if (!this.startHrTime) {
        throw internalError("willResolveField called before startTiming!");
      }
      if (this.stopped) {
        return () => {};
      }
      const path = info.path;
      const node = this.newNode(path);
      node.type = info.returnType.toString();
      node.parentType = info.parentType.toString();
      node.startTime = durationHrTimeToNanos(process.hrtime(this.startHrTime));
      if (typeof path.key === "string" && path.key !== info.fieldName) {
        node.originalFieldName = info.fieldName;
      }
      return () => {
        node.endTime = durationHrTimeToNanos(process.hrtime(this.startHrTime));
      };
    }
    didEncounterErrors(errors) {
      errors.forEach((err) => {
        var _a;
        if ((_a = err.extensions) === null || _a === undefined ? undefined : _a.serviceName) {
          return;
        }
        const errorForReporting = this.rewriteAndNormalizeError(err);
        if (errorForReporting === null) {
          return;
        }
        this.addProtobufError(errorForReporting.path, errorToProtobufError(errorForReporting));
      });
    }
    addProtobufError(path, error) {
      if (!this.startHrTime) {
        throw internalError("addProtobufError called before startTiming!");
      }
      if (this.stopped) {
        throw internalError("addProtobufError called after stopTiming!");
      }
      let node = this.rootNode;
      if (Array.isArray(path)) {
        const specificNode = this.nodes.get(path.join("."));
        if (specificNode) {
          node = specificNode;
        } else {
          this.logger.warn(`Could not find node with path ${path.join(".")}; defaulting to put errors on root node.`);
        }
      }
      node.error.push(error);
    }
    newNode(path) {
      const node = new apollo_reporting_protobuf_1.Trace.Node;
      const id = path.key;
      if (typeof id === "number") {
        node.index = id;
      } else {
        node.responseName = id;
      }
      this.nodes.set(responsePathAsString(path), node);
      const parentNode = this.ensureParentNode(path);
      parentNode.child.push(node);
      return node;
    }
    ensureParentNode(path) {
      const parentPath = responsePathAsString(path.prev);
      const parentNode = this.nodes.get(parentPath);
      if (parentNode) {
        return parentNode;
      }
      return this.newNode(path.prev);
    }
    rewriteAndNormalizeError(err) {
      if (this.rewriteError) {
        const clonedError = Object.assign(Object.create(Object.getPrototypeOf(err)), err);
        const rewrittenError = this.rewriteError(clonedError);
        if (rewrittenError === null) {
          return null;
        }
        if (!(rewrittenError instanceof graphql_1.GraphQLError)) {
          return err;
        }
        return new graphql_1.GraphQLError(rewrittenError.message, err.nodes, err.source, err.positions, err.path, err.originalError, rewrittenError.extensions || err.extensions);
      }
      return err;
    }
  }
  exports.TraceTreeBuilder = TraceTreeBuilder;
  function durationHrTimeToNanos(hrtime) {
    return hrtime[0] * 1e9 + hrtime[1];
  }
  function responsePathAsString(p) {
    if (p === undefined) {
      return "";
    }
    let res = String(p.key);
    while ((p = p.prev) !== undefined) {
      res = `${p.key}.${res}`;
    }
    return res;
  }
  function errorToProtobufError(error) {
    return new apollo_reporting_protobuf_1.Trace.Error({
      message: error.message,
      location: (error.locations || []).map(({ line, column }) => new apollo_reporting_protobuf_1.Trace.Location({ line, column })),
      json: JSON.stringify(error)
    });
  }
  function dateToProtoTimestamp(date) {
    const totalMillis = +date;
    const millis = totalMillis % 1000;
    return new apollo_reporting_protobuf_1.google.protobuf.Timestamp({
      seconds: (totalMillis - millis) / 1000,
      nanos: millis * 1e6
    });
  }
  exports.dateToProtoTimestamp = dateToProtoTimestamp;
});

// node_modules/apollo-server-core/dist/plugin/usageReporting/traceDetails.js
var require_traceDetails = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.makeTraceDetails = undefined;
  var apollo_reporting_protobuf_1 = require_generated();
  function makeTraceDetails(variables, sendVariableValues, operationString) {
    const details = new apollo_reporting_protobuf_1.Trace.Details;
    const variablesToRecord = (() => {
      if (sendVariableValues && "transform" in sendVariableValues) {
        const originalKeys = Object.keys(variables);
        try {
          const modifiedVariables = sendVariableValues.transform({
            variables,
            operationString
          });
          return cleanModifiedVariables(originalKeys, modifiedVariables);
        } catch (e) {
          return handleVariableValueTransformError(originalKeys);
        }
      } else {
        return variables;
      }
    })();
    Object.keys(variablesToRecord).forEach((name) => {
      if (!sendVariableValues || "none" in sendVariableValues && sendVariableValues.none || "all" in sendVariableValues && !sendVariableValues.all || "exceptNames" in sendVariableValues && sendVariableValues.exceptNames.includes(name) || "onlyNames" in sendVariableValues && !sendVariableValues.onlyNames.includes(name)) {
        details.variablesJson[name] = "";
      } else {
        try {
          details.variablesJson[name] = typeof variablesToRecord[name] === "undefined" ? "" : JSON.stringify(variablesToRecord[name]);
        } catch (e) {
          details.variablesJson[name] = JSON.stringify("[Unable to convert value to JSON]");
        }
      }
    });
    return details;
  }
  exports.makeTraceDetails = makeTraceDetails;
  function handleVariableValueTransformError(variableNames) {
    const modifiedVariables = Object.create(null);
    variableNames.forEach((name) => {
      modifiedVariables[name] = "[PREDICATE_FUNCTION_ERROR]";
    });
    return modifiedVariables;
  }
  function cleanModifiedVariables(originalKeys, modifiedVariables) {
    const cleanedVariables = Object.create(null);
    originalKeys.forEach((name) => {
      cleanedVariables[name] = modifiedVariables[name];
    });
    return cleanedVariables;
  }
});

// node_modules/uuid/dist/rng.js
var require_rng = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = rng;
  var _crypto = _interopRequireDefault(__require("crypto"));
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var rnds8Pool = new Uint8Array(256);
  var poolPtr = rnds8Pool.length;
  function rng() {
    if (poolPtr > rnds8Pool.length - 16) {
      _crypto.default.randomFillSync(rnds8Pool);
      poolPtr = 0;
    }
    return rnds8Pool.slice(poolPtr, poolPtr += 16);
  }
});

// node_modules/uuid/dist/regex.js
var require_regex = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  exports.default = _default;
});

// node_modules/uuid/dist/validate.js
var require_validate3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _regex = _interopRequireDefault(require_regex());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function validate(uuid) {
    return typeof uuid === "string" && _regex.default.test(uuid);
  }
  var _default = validate;
  exports.default = _default;
});

// node_modules/uuid/dist/stringify.js
var require_stringify2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  exports.unsafeStringify = unsafeStringify;
  var _validate = _interopRequireDefault(require_validate3());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var byteToHex = [];
  for (let i = 0;i < 256; ++i) {
    byteToHex.push((i + 256).toString(16).slice(1));
  }
  function unsafeStringify(arr, offset = 0) {
    return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
  }
  function stringify(arr, offset = 0) {
    const uuid = unsafeStringify(arr, offset);
    if (!(0, _validate.default)(uuid)) {
      throw TypeError("Stringified UUID is invalid");
    }
    return uuid;
  }
  var _default = stringify;
  exports.default = _default;
});

// node_modules/uuid/dist/v1.js
var require_v1 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _rng = _interopRequireDefault(require_rng());
  var _stringify = require_stringify2();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var _nodeId;
  var _clockseq;
  var _lastMSecs = 0;
  var _lastNSecs = 0;
  function v1(options, buf, offset) {
    let i = buf && offset || 0;
    const b = buf || new Array(16);
    options = options || {};
    let node = options.node || _nodeId;
    let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;
    if (node == null || clockseq == null) {
      const seedBytes = options.random || (options.rng || _rng.default)();
      if (node == null) {
        node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
      }
      if (clockseq == null) {
        clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
      }
    }
    let msecs = options.msecs !== undefined ? options.msecs : Date.now();
    let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;
    const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
    if (dt < 0 && options.clockseq === undefined) {
      clockseq = clockseq + 1 & 16383;
    }
    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
      nsecs = 0;
    }
    if (nsecs >= 1e4) {
      throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
    }
    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq;
    msecs += 12219292800000;
    const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
    b[i++] = tl >>> 24 & 255;
    b[i++] = tl >>> 16 & 255;
    b[i++] = tl >>> 8 & 255;
    b[i++] = tl & 255;
    const tmh = msecs / 4294967296 * 1e4 & 268435455;
    b[i++] = tmh >>> 8 & 255;
    b[i++] = tmh & 255;
    b[i++] = tmh >>> 24 & 15 | 16;
    b[i++] = tmh >>> 16 & 255;
    b[i++] = clockseq >>> 8 | 128;
    b[i++] = clockseq & 255;
    for (let n = 0;n < 6; ++n) {
      b[i + n] = node[n];
    }
    return buf || (0, _stringify.unsafeStringify)(b);
  }
  var _default = v1;
  exports.default = _default;
});

// node_modules/uuid/dist/parse.js
var require_parse2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _validate = _interopRequireDefault(require_validate3());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function parse(uuid) {
    if (!(0, _validate.default)(uuid)) {
      throw TypeError("Invalid UUID");
    }
    let v;
    const arr = new Uint8Array(16);
    arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
    arr[1] = v >>> 16 & 255;
    arr[2] = v >>> 8 & 255;
    arr[3] = v & 255;
    arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
    arr[5] = v & 255;
    arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
    arr[7] = v & 255;
    arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
    arr[9] = v & 255;
    arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
    arr[11] = v / 4294967296 & 255;
    arr[12] = v >>> 24 & 255;
    arr[13] = v >>> 16 & 255;
    arr[14] = v >>> 8 & 255;
    arr[15] = v & 255;
    return arr;
  }
  var _default = parse;
  exports.default = _default;
});

// node_modules/uuid/dist/v35.js
var require_v35 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.URL = exports.DNS = undefined;
  exports.default = v35;
  var _stringify = require_stringify2();
  var _parse = _interopRequireDefault(require_parse2());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function stringToBytes(str) {
    str = unescape(encodeURIComponent(str));
    const bytes = [];
    for (let i = 0;i < str.length; ++i) {
      bytes.push(str.charCodeAt(i));
    }
    return bytes;
  }
  var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
  exports.DNS = DNS;
  var URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
  exports.URL = URL;
  function v35(name, version, hashfunc) {
    function generateUUID(value, namespace, buf, offset) {
      var _namespace;
      if (typeof value === "string") {
        value = stringToBytes(value);
      }
      if (typeof namespace === "string") {
        namespace = (0, _parse.default)(namespace);
      }
      if (((_namespace = namespace) === null || _namespace === undefined ? undefined : _namespace.length) !== 16) {
        throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
      }
      let bytes = new Uint8Array(16 + value.length);
      bytes.set(namespace);
      bytes.set(value, namespace.length);
      bytes = hashfunc(bytes);
      bytes[6] = bytes[6] & 15 | version;
      bytes[8] = bytes[8] & 63 | 128;
      if (buf) {
        offset = offset || 0;
        for (let i = 0;i < 16; ++i) {
          buf[offset + i] = bytes[i];
        }
        return buf;
      }
      return (0, _stringify.unsafeStringify)(bytes);
    }
    try {
      generateUUID.name = name;
    } catch (err) {}
    generateUUID.DNS = DNS;
    generateUUID.URL = URL;
    return generateUUID;
  }
});

// node_modules/uuid/dist/md5.js
var require_md5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _crypto = _interopRequireDefault(__require("crypto"));
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function md5(bytes) {
    if (Array.isArray(bytes)) {
      bytes = Buffer.from(bytes);
    } else if (typeof bytes === "string") {
      bytes = Buffer.from(bytes, "utf8");
    }
    return _crypto.default.createHash("md5").update(bytes).digest();
  }
  var _default = md5;
  exports.default = _default;
});

// node_modules/uuid/dist/v3.js
var require_v3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _v = _interopRequireDefault(require_v35());
  var _md = _interopRequireDefault(require_md5());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var v3 = (0, _v.default)("v3", 48, _md.default);
  var _default = v3;
  exports.default = _default;
});

// node_modules/uuid/dist/native.js
var require_native = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _crypto = _interopRequireDefault(__require("crypto"));
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var _default = {
    randomUUID: _crypto.default.randomUUID
  };
  exports.default = _default;
});

// node_modules/uuid/dist/v4.js
var require_v4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _native = _interopRequireDefault(require_native());
  var _rng = _interopRequireDefault(require_rng());
  var _stringify = require_stringify2();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function v4(options, buf, offset) {
    if (_native.default.randomUUID && !buf && !options) {
      return _native.default.randomUUID();
    }
    options = options || {};
    const rnds = options.random || (options.rng || _rng.default)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i = 0;i < 16; ++i) {
        buf[offset + i] = rnds[i];
      }
      return buf;
    }
    return (0, _stringify.unsafeStringify)(rnds);
  }
  var _default = v4;
  exports.default = _default;
});

// node_modules/uuid/dist/sha1.js
var require_sha12 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _crypto = _interopRequireDefault(__require("crypto"));
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function sha1(bytes) {
    if (Array.isArray(bytes)) {
      bytes = Buffer.from(bytes);
    } else if (typeof bytes === "string") {
      bytes = Buffer.from(bytes, "utf8");
    }
    return _crypto.default.createHash("sha1").update(bytes).digest();
  }
  var _default = sha1;
  exports.default = _default;
});

// node_modules/uuid/dist/v5.js
var require_v5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _v = _interopRequireDefault(require_v35());
  var _sha = _interopRequireDefault(require_sha12());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var v5 = (0, _v.default)("v5", 80, _sha.default);
  var _default = v5;
  exports.default = _default;
});

// node_modules/uuid/dist/nil.js
var require_nil = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _default = "00000000-0000-0000-0000-000000000000";
  exports.default = _default;
});

// node_modules/uuid/dist/version.js
var require_version2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _validate = _interopRequireDefault(require_validate3());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function version(uuid) {
    if (!(0, _validate.default)(uuid)) {
      throw TypeError("Invalid UUID");
    }
    return parseInt(uuid.slice(14, 15), 16);
  }
  var _default = version;
  exports.default = _default;
});

// node_modules/uuid/dist/index.js
var require_dist11 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "NIL", {
    enumerable: true,
    get: function() {
      return _nil.default;
    }
  });
  Object.defineProperty(exports, "parse", {
    enumerable: true,
    get: function() {
      return _parse.default;
    }
  });
  Object.defineProperty(exports, "stringify", {
    enumerable: true,
    get: function() {
      return _stringify.default;
    }
  });
  Object.defineProperty(exports, "v1", {
    enumerable: true,
    get: function() {
      return _v.default;
    }
  });
  Object.defineProperty(exports, "v3", {
    enumerable: true,
    get: function() {
      return _v2.default;
    }
  });
  Object.defineProperty(exports, "v4", {
    enumerable: true,
    get: function() {
      return _v3.default;
    }
  });
  Object.defineProperty(exports, "v5", {
    enumerable: true,
    get: function() {
      return _v4.default;
    }
  });
  Object.defineProperty(exports, "validate", {
    enumerable: true,
    get: function() {
      return _validate.default;
    }
  });
  Object.defineProperty(exports, "version", {
    enumerable: true,
    get: function() {
      return _version.default;
    }
  });
  var _v = _interopRequireDefault(require_v1());
  var _v2 = _interopRequireDefault(require_v3());
  var _v3 = _interopRequireDefault(require_v4());
  var _v4 = _interopRequireDefault(require_v5());
  var _nil = _interopRequireDefault(require_nil());
  var _version = _interopRequireDefault(require_version2());
  var _validate = _interopRequireDefault(require_validate3());
  var _stringify = _interopRequireDefault(require_stringify2());
  var _parse = _interopRequireDefault(require_parse2());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
});

// node_modules/graphql-tag/node_modules/tslib/tslib.js
var require_tslib = __commonJS((exports, module) => {
  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */
  var __extends;
  var __assign;
  var __rest;
  var __decorate;
  var __param;
  var __metadata;
  var __awaiter;
  var __generator;
  var __exportStar;
  var __values;
  var __read;
  var __spread;
  var __spreadArrays;
  var __spreadArray;
  var __await;
  var __asyncGenerator;
  var __asyncDelegator;
  var __asyncValues;
  var __makeTemplateObject;
  var __importStar;
  var __importDefault;
  var __classPrivateFieldGet;
  var __classPrivateFieldSet;
  var __createBinding;
  (function(factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) {
      define("tslib", ["exports"], function(exports2) {
        factory(createExporter(root, createExporter(exports2)));
      });
    } else if (typeof module === "object" && typeof exports === "object") {
      factory(createExporter(root, createExporter(exports)));
    } else {
      factory(createExporter(root));
    }
    function createExporter(exports2, previous) {
      if (exports2 !== root) {
        if (typeof Object.create === "function") {
          Object.defineProperty(exports2, "__esModule", { value: true });
        } else {
          exports2.__esModule = true;
        }
      }
      return function(id, v) {
        return exports2[id] = previous ? previous(id, v) : v;
      };
    }
  })(function(exporter) {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
      d.__proto__ = b;
    } || function(d, b) {
      for (var p in b)
        if (Object.prototype.hasOwnProperty.call(b, p))
          d[p] = b[p];
    };
    __extends = function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
    __assign = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length;i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    __rest = function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s);i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };
    __decorate = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1;i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    __metadata = function(metadataKey, metadataValue) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(metadataKey, metadataValue);
    };
    __awaiter = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    __generator = function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : undefined, done: true };
      }
    };
    __exportStar = function(m, o) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
          __createBinding(o, m, p);
    };
    __createBinding = Object.create ? function(o, m, k, k2) {
      if (k2 === undefined)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === undefined)
        k2 = k;
      o[k2] = m[k];
    };
    __values = function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = undefined;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    __read = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === undefined || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    __spread = function() {
      for (var ar = [], i = 0;i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
      return ar;
    };
    __spreadArrays = function() {
      for (var s = 0, i = 0, il = arguments.length;i < il; i++)
        s += arguments[i].length;
      for (var r = Array(s), k = 0, i = 0;i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length;j < jl; j++, k++)
          r[k] = a[j];
      return r;
    };
    __spreadArray = function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar;i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    __await = function(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    };
    __asyncGenerator = function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i, q = [];
      return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i;
      function verb(n) {
        if (g[n])
          i[n] = function(v) {
            return new Promise(function(a, b) {
              q.push([n, v, a, b]) > 1 || resume(n, v);
            });
          };
      }
      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }
      function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle(f, v) {
        if (f(v), q.shift(), q.length)
          resume(q[0][0], q[0][1]);
      }
    };
    __asyncDelegator = function(o) {
      var i, p;
      return i = {}, verb("next"), verb("throw", function(e) {
        throw e;
      }), verb("return"), i[Symbol.iterator] = function() {
        return this;
      }, i;
      function verb(n, f) {
        i[n] = o[n] ? function(v) {
          return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v;
        } : f;
      }
    };
    __asyncValues = function(o) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator], i;
      return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i);
      function verb(n) {
        i[n] = o[n] && function(v) {
          return new Promise(function(resolve, reject) {
            v = o[n](v), settle(resolve, reject, v.done, v.value);
          });
        };
      }
      function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v2) {
          resolve({ value: v2, done: d });
        }, reject);
      }
    };
    __makeTemplateObject = function(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw });
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    var __setModuleDefault = Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    };
    __importStar = function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k in mod2)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
            __createBinding(result, mod2, k);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    __importDefault = function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
    };
    __classPrivateFieldGet = function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    __classPrivateFieldSet = function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    exporter("__extends", __extends);
    exporter("__assign", __assign);
    exporter("__rest", __rest);
    exporter("__decorate", __decorate);
    exporter("__param", __param);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter);
    exporter("__generator", __generator);
    exporter("__exportStar", __exportStar);
    exporter("__createBinding", __createBinding);
    exporter("__values", __values);
    exporter("__read", __read);
    exporter("__spread", __spread);
    exporter("__spreadArrays", __spreadArrays);
    exporter("__spreadArray", __spreadArray);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
    exporter("__makeTemplateObject", __makeTemplateObject);
    exporter("__importStar", __importStar);
    exporter("__importDefault", __importDefault);
    exporter("__classPrivateFieldGet", __classPrivateFieldGet);
    exporter("__classPrivateFieldSet", __classPrivateFieldSet);
  });
});

// node_modules/graphql-tag/lib/graphql-tag.umd.js
var require_graphql_tag_umd = __commonJS((exports, module) => {
  (function(global2, factory) {
    typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require_tslib(), require_graphql2()) : typeof define === "function" && define.amd ? define(["exports", "tslib", "graphql"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2["graphql-tag"] = {}, global2.tslib, global2.graphql));
  })(exports, function(exports2, tslib, graphql) {
    var docCache = new Map;
    var fragmentSourceMap = new Map;
    var printFragmentWarnings = true;
    var experimentalFragmentVariables = false;
    function normalize(string) {
      return string.replace(/[\s,]+/g, " ").trim();
    }
    function cacheKeyFromLoc(loc) {
      return normalize(loc.source.body.substring(loc.start, loc.end));
    }
    function processFragments(ast) {
      var seenKeys = new Set;
      var definitions = [];
      ast.definitions.forEach(function(fragmentDefinition) {
        if (fragmentDefinition.kind === "FragmentDefinition") {
          var fragmentName = fragmentDefinition.name.value;
          var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc);
          var sourceKeySet = fragmentSourceMap.get(fragmentName);
          if (sourceKeySet && !sourceKeySet.has(sourceKey)) {
            if (printFragmentWarnings) {
              console.warn("Warning: fragment with name " + fragmentName + ` already exists.
` + `graphql-tag enforces all fragment names across your application to be unique; read more about
` + "this in the docs: http://dev.apollodata.com/core/fragments.html#unique-names");
            }
          } else if (!sourceKeySet) {
            fragmentSourceMap.set(fragmentName, sourceKeySet = new Set);
          }
          sourceKeySet.add(sourceKey);
          if (!seenKeys.has(sourceKey)) {
            seenKeys.add(sourceKey);
            definitions.push(fragmentDefinition);
          }
        } else {
          definitions.push(fragmentDefinition);
        }
      });
      return tslib.__assign(tslib.__assign({}, ast), { definitions });
    }
    function stripLoc(doc) {
      var workSet = new Set(doc.definitions);
      workSet.forEach(function(node) {
        if (node.loc)
          delete node.loc;
        Object.keys(node).forEach(function(key) {
          var value = node[key];
          if (value && typeof value === "object") {
            workSet.add(value);
          }
        });
      });
      var loc = doc.loc;
      if (loc) {
        delete loc.startToken;
        delete loc.endToken;
      }
      return doc;
    }
    function parseDocument(source) {
      var cacheKey = normalize(source);
      if (!docCache.has(cacheKey)) {
        var parsed = graphql.parse(source, {
          experimentalFragmentVariables
        });
        if (!parsed || parsed.kind !== "Document") {
          throw new Error("Not a valid GraphQL document.");
        }
        docCache.set(cacheKey, stripLoc(processFragments(parsed)));
      }
      return docCache.get(cacheKey);
    }
    function gql(literals) {
      var args2 = [];
      for (var _i = 1;_i < arguments.length; _i++) {
        args2[_i - 1] = arguments[_i];
      }
      if (typeof literals === "string") {
        literals = [literals];
      }
      var result = literals[0];
      args2.forEach(function(arg, i) {
        if (arg && arg.kind === "Document") {
          result += arg.loc.source.body;
        } else {
          result += arg;
        }
        result += literals[i + 1];
      });
      return parseDocument(result);
    }
    function resetCaches() {
      docCache.clear();
      fragmentSourceMap.clear();
    }
    function disableFragmentWarnings() {
      printFragmentWarnings = false;
    }
    function enableExperimentalFragmentVariables() {
      experimentalFragmentVariables = true;
    }
    function disableExperimentalFragmentVariables() {
      experimentalFragmentVariables = false;
    }
    var extras = {
      gql,
      resetCaches,
      disableFragmentWarnings,
      enableExperimentalFragmentVariables,
      disableExperimentalFragmentVariables
    };
    (function(gql_1) {
      gql_1.gql = extras.gql, gql_1.resetCaches = extras.resetCaches, gql_1.disableFragmentWarnings = extras.disableFragmentWarnings, gql_1.enableExperimentalFragmentVariables = extras.enableExperimentalFragmentVariables, gql_1.disableExperimentalFragmentVariables = extras.disableExperimentalFragmentVariables;
    })(gql || (gql = {}));
    gql["default"] = gql;
    var gql$1 = gql;
    exports2.default = gql$1;
    exports2.disableExperimentalFragmentVariables = disableExperimentalFragmentVariables;
    exports2.disableFragmentWarnings = disableFragmentWarnings;
    exports2.enableExperimentalFragmentVariables = enableExperimentalFragmentVariables;
    exports2.gql = gql;
    exports2.resetCaches = resetCaches;
    Object.defineProperty(exports2, "__esModule", { value: true });
  });
});

// node_modules/graphql-tag/main.js
var require_main = __commonJS((exports, module) => {
  module.exports = require_graphql_tag_umd().gql;
});

// node_modules/apollo-server-core/dist/gql.js
var require_gql = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.gql = undefined;
  var graphql_tag_1 = __importDefault(require_main());
  exports.gql = graphql_tag_1.default;
});

// node_modules/apollo-server-core/package.json
var require_package = __commonJS((exports, module) => {
  module.exports = {
    name: "apollo-server-core",
    version: "3.13.0",
    description: "Core engine for Apollo GraphQL server",
    main: "dist/index.js",
    types: "dist/index.d.ts",
    repository: {
      type: "git",
      url: "https://github.com/apollographql/apollo-server",
      directory: "packages/apollo-server-core"
    },
    keywords: [
      "GraphQL",
      "Apollo",
      "Server",
      "Javascript"
    ],
    author: "Apollo <packages@apollographql.com>",
    license: "MIT",
    bugs: {
      url: "https://github.com/apollographql/apollo-server/issues"
    },
    homepage: "https://github.com/apollographql/apollo-server#readme",
    engines: {
      node: ">=12.0"
    },
    dependencies: {
      "@apollo/utils.keyvaluecache": "^1.0.1",
      "@apollo/utils.logger": "^1.0.0",
      "@apollo/utils.usagereporting": "^1.0.0",
      "@apollographql/apollo-tools": "^0.5.3",
      "@apollographql/graphql-playground-html": "1.6.29",
      "@graphql-tools/mock": "^8.1.2",
      "@graphql-tools/schema": "^8.0.0",
      "@josephg/resolvable": "^1.0.0",
      "apollo-datasource": "^3.3.2",
      "apollo-reporting-protobuf": "^3.4.0",
      "apollo-server-env": "^4.2.1",
      "apollo-server-errors": "^3.3.1",
      "apollo-server-plugin-base": "^3.7.2",
      "apollo-server-types": "^3.8.0",
      "async-retry": "^1.2.1",
      "fast-json-stable-stringify": "^2.1.0",
      "graphql-tag": "^2.11.0",
      loglevel: "^1.6.8",
      "lru-cache": "^6.0.0",
      "node-abort-controller": "^3.0.1",
      "sha.js": "^2.4.11",
      uuid: "^9.0.0",
      "whatwg-mimetype": "^3.0.0"
    },
    peerDependencies: {
      graphql: "^15.3.0 || ^16.0.0"
    },
    gitHead: "f93284e853efd6da46d91ae40da47a2dd15b61fe"
  };
});

// node_modules/apollo-server-core/dist/plugin/schemaReporting/schemaReporter.js
var require_schemaReporter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SchemaReporter = exports.schemaReportGql = undefined;
  var gql_1 = require_gql();
  var apollo_server_env_1 = require_dist();
  var graphql_1 = require_graphql2();
  exports.schemaReportGql = (0, graphql_1.print)((0, gql_1.gql)`
  mutation SchemaReport($report: SchemaReport!, $coreSchema: String) {
    reportSchema(report: $report, coreSchema: $coreSchema) {
      __typename
      ... on ReportSchemaError {
        message
        code
      }
      ... on ReportSchemaResponse {
        inSeconds
        withCoreSchema
      }
    }
  }
`);

  class SchemaReporter {
    constructor(options) {
      var _a;
      this.headers = new apollo_server_env_1.Headers;
      this.headers.set("Content-Type", "application/json");
      this.headers.set("x-api-key", options.apiKey);
      this.headers.set("apollographql-client-name", "ApolloServerPluginSchemaReporting");
      this.headers.set("apollographql-client-version", require_package().version);
      this.endpointUrl = options.endpointUrl || "https://schema-reporting.api.apollographql.com/api/graphql";
      this.schemaReport = options.schemaReport;
      this.coreSchema = options.coreSchema;
      this.isStopped = false;
      this.logger = options.logger;
      this.initialReportingDelayInMs = options.initialReportingDelayInMs;
      this.fallbackReportingDelayInMs = options.fallbackReportingDelayInMs;
      this.fetcher = (_a = options.fetcher) !== null && _a !== undefined ? _a : apollo_server_env_1.fetch;
    }
    stopped() {
      return this.isStopped;
    }
    start() {
      this.pollTimer = setTimeout(() => this.sendOneReportAndScheduleNext(false), this.initialReportingDelayInMs);
    }
    stop() {
      this.isStopped = true;
      if (this.pollTimer) {
        clearTimeout(this.pollTimer);
        this.pollTimer = undefined;
      }
    }
    async sendOneReportAndScheduleNext(sendNextWithCoreSchema) {
      this.pollTimer = undefined;
      if (this.stopped())
        return;
      try {
        const result = await this.reportSchema(sendNextWithCoreSchema);
        if (!result) {
          return;
        }
        if (!this.stopped()) {
          this.pollTimer = setTimeout(() => this.sendOneReportAndScheduleNext(result.withCoreSchema), result.inSeconds * 1000);
        }
        return;
      } catch (error) {
        this.logger.error(`Error reporting server info to Apollo during schema reporting: ${error}`);
        if (!this.stopped()) {
          this.pollTimer = setTimeout(() => this.sendOneReportAndScheduleNext(false), this.fallbackReportingDelayInMs);
        }
      }
    }
    async reportSchema(withCoreSchema) {
      const { data, errors } = await this.apolloQuery({
        report: this.schemaReport,
        coreSchema: withCoreSchema ? this.coreSchema : null
      });
      if (errors) {
        throw new Error(errors.map((x) => x.message).join(`
`));
      }
      function msgForUnexpectedResponse(data2) {
        return [
          "Unexpected response shape from Apollo when",
          "reporting schema. If this continues, please reach",
          "out to support@apollographql.com.",
          "Received response:",
          JSON.stringify(data2)
        ].join(" ");
      }
      if (!data || !data.reportSchema) {
        throw new Error(msgForUnexpectedResponse(data));
      }
      if (data.reportSchema.__typename === "ReportSchemaResponse") {
        return data.reportSchema;
      } else if (data.reportSchema.__typename === "ReportSchemaError") {
        this.logger.error([
          "Received input validation error from Apollo:",
          data.reportSchema.message,
          "Stopping reporting. Please fix the input errors."
        ].join(" "));
        this.stop();
        return null;
      }
      throw new Error(msgForUnexpectedResponse(data));
    }
    async apolloQuery(variables) {
      const request = {
        query: exports.schemaReportGql,
        variables
      };
      const httpRequest = new apollo_server_env_1.Request(this.endpointUrl, {
        method: "POST",
        headers: this.headers,
        body: JSON.stringify(request)
      });
      const httpResponse = await this.fetcher(httpRequest);
      if (!httpResponse.ok) {
        throw new Error([
          `An unexpected HTTP status code (${httpResponse.status}) was`,
          "encountered during schema reporting."
        ].join(" "));
      }
      try {
        return await httpResponse.json();
      } catch (error) {
        throw new Error([
          "Couldn't report schema to Apollo.",
          "Parsing response as JSON failed.",
          "If this continues please reach out to support@apollographql.com",
          error
        ].join(" "));
      }
    }
  }
  exports.SchemaReporter = SchemaReporter;
});

// node_modules/apollo-server-core/dist/plugin/schemaIsFederated.js
var require_schemaIsFederated = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.schemaIsFederated = undefined;
  var graphql_1 = require_graphql2();
  function schemaIsFederated(schema) {
    const serviceType = schema.getType("_Service");
    if (!(0, graphql_1.isObjectType)(serviceType)) {
      return false;
    }
    const sdlField = serviceType.getFields().sdl;
    if (!sdlField) {
      return false;
    }
    const sdlFieldType = sdlField.type;
    if (!(0, graphql_1.isScalarType)(sdlFieldType)) {
      return false;
    }
    return sdlFieldType.name == "String";
  }
  exports.schemaIsFederated = schemaIsFederated;
});

// node_modules/apollo-server-core/dist/plugin/schemaReporting/index.js
var require_schemaReporting = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.computeCoreSchemaHash = exports.ApolloServerPluginSchemaReporting = undefined;
  var os_1 = __importDefault(__require("os"));
  var uuid_1 = require_dist11();
  var graphql_1 = require_graphql2();
  var schemaReporter_1 = require_schemaReporter();
  var createSHA_1 = __importDefault(require_createSHA());
  var schemaIsFederated_1 = require_schemaIsFederated();
  function ApolloServerPluginSchemaReporting({ initialDelayMaxMs, overrideReportedSchema, endpointUrl, fetcher } = Object.create(null)) {
    const bootId = (0, uuid_1.v4)();
    return {
      __internal_plugin_id__() {
        return "SchemaReporting";
      },
      async serverWillStart({ apollo, schema, logger }) {
        const { key, graphRef } = apollo;
        if (!key) {
          throw Error("To use ApolloServerPluginSchemaReporting, you must provide an Apollo API " + "key, via the APOLLO_KEY environment variable or via `new ApolloServer({apollo: {key})`");
        }
        if (!graphRef) {
          throw Error("To use ApolloServerPluginSchemaReporting, you must provide your graph ref (eg, " + "'my-graph-id@my-graph-variant'). Try setting the APOLLO_GRAPH_REF environment " + "variable or passing `new ApolloServer({apollo: {graphRef}})`.");
        }
        if (overrideReportedSchema) {
          try {
            const validationErrors = (0, graphql_1.validateSchema)((0, graphql_1.buildSchema)(overrideReportedSchema, { noLocation: true }));
            if (validationErrors.length) {
              throw new Error(validationErrors.map((error) => error.message).join(`
`));
            }
          } catch (err) {
            throw new Error("The schema provided to overrideReportedSchema failed to parse or " + `validate: ${err.message}`);
          }
        }
        if ((0, schemaIsFederated_1.schemaIsFederated)(schema)) {
          throw Error([
            "Schema reporting is not yet compatible with federated services.",
            "If you're interested in using schema reporting with federated",
            "services, please contact Apollo support. To set up managed federation, see",
            "https://go.apollo.dev/s/managed-federation"
          ].join(" "));
        }
        if (endpointUrl !== undefined) {
          logger.info(`Apollo schema reporting: schema reporting URL override: ${endpointUrl}`);
        }
        const baseSchemaReport = {
          bootId,
          graphRef,
          platform: process.env.APOLLO_SERVER_PLATFORM || "local",
          runtimeVersion: `node ${process.version}`,
          userVersion: process.env.APOLLO_SERVER_USER_VERSION,
          serverId: process.env.APOLLO_SERVER_ID || process.env.HOSTNAME || os_1.default.hostname(),
          libraryVersion: `apollo-server-core@${require_package().version}`
        };
        let currentSchemaReporter;
        return {
          schemaDidLoadOrUpdate({ apiSchema, coreSupergraphSdl }) {
            var _a;
            if (overrideReportedSchema !== undefined) {
              if (currentSchemaReporter) {
                return;
              } else {
                logger.info("Apollo schema reporting: schema to report has been overridden");
              }
            }
            const coreSchema = (_a = overrideReportedSchema !== null && overrideReportedSchema !== undefined ? overrideReportedSchema : coreSupergraphSdl) !== null && _a !== undefined ? _a : (0, graphql_1.printSchema)(apiSchema);
            const coreSchemaHash = computeCoreSchemaHash(coreSchema);
            const schemaReport = {
              ...baseSchemaReport,
              coreSchemaHash
            };
            currentSchemaReporter === null || currentSchemaReporter === undefined || currentSchemaReporter.stop();
            currentSchemaReporter = new schemaReporter_1.SchemaReporter({
              schemaReport,
              coreSchema,
              apiKey: key,
              endpointUrl,
              logger,
              initialReportingDelayInMs: Math.floor(Math.random() * (initialDelayMaxMs !== null && initialDelayMaxMs !== undefined ? initialDelayMaxMs : 1e4)),
              fallbackReportingDelayInMs: 20000,
              fetcher
            });
            currentSchemaReporter.start();
            logger.info("Apollo schema reporting: reporting a new schema to Studio! See your graph at " + `https://studio.apollographql.com/graph/${encodeURI(graphRef)}/ with server info ${JSON.stringify(schemaReport)}`);
          },
          async serverWillStop() {
            currentSchemaReporter === null || currentSchemaReporter === undefined || currentSchemaReporter.stop();
          }
        };
      }
    };
  }
  exports.ApolloServerPluginSchemaReporting = ApolloServerPluginSchemaReporting;
  function computeCoreSchemaHash(schema) {
    return (0, createSHA_1.default)("sha256").update(schema).digest("hex");
  }
  exports.computeCoreSchemaHash = computeCoreSchemaHash;
});

// node_modules/apollo-server-core/dist/plugin/usageReporting/durationHistogram.js
var require_durationHistogram = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DurationHistogram = undefined;

  class DurationHistogram {
    constructor(options) {
      const initSize = (options === null || options === undefined ? undefined : options.initSize) || 74;
      const buckets = options === null || options === undefined ? undefined : options.buckets;
      const arrayInitSize = Math.max((buckets === null || buckets === undefined ? undefined : buckets.length) || 0, initSize);
      this.buckets = Array(arrayInitSize).fill(0);
      if (buckets) {
        buckets.forEach((val, index) => this.buckets[index] = val);
      }
    }
    toArray() {
      let bufferedZeroes = 0;
      const outputArray = [];
      for (const value of this.buckets) {
        if (value === 0) {
          bufferedZeroes++;
        } else {
          if (bufferedZeroes === 1) {
            outputArray.push(0);
          } else if (bufferedZeroes !== 0) {
            outputArray.push(-bufferedZeroes);
          }
          outputArray.push(Math.floor(value));
          bufferedZeroes = 0;
        }
      }
      return outputArray;
    }
    static durationToBucket(durationNs) {
      const log = Math.log(durationNs / 1000);
      const unboundedBucket = Math.ceil(log / DurationHistogram.EXPONENT_LOG);
      return unboundedBucket <= 0 || Number.isNaN(unboundedBucket) ? 0 : unboundedBucket >= DurationHistogram.BUCKET_COUNT ? DurationHistogram.BUCKET_COUNT - 1 : unboundedBucket;
    }
    incrementDuration(durationNs, value = 1) {
      this.incrementBucket(DurationHistogram.durationToBucket(durationNs), value);
      return this;
    }
    incrementBucket(bucket, value = 1) {
      if (bucket >= DurationHistogram.BUCKET_COUNT) {
        throw Error("Bucket is out of bounds of the buckets array");
      }
      if (bucket >= this.buckets.length) {
        const oldLength = this.buckets.length;
        this.buckets.length = bucket + 1;
        this.buckets.fill(0, oldLength);
      }
      this.buckets[bucket] += value;
    }
    combine(otherHistogram) {
      for (let i = 0;i < otherHistogram.buckets.length; i++) {
        this.incrementBucket(i, otherHistogram.buckets[i]);
      }
    }
  }
  exports.DurationHistogram = DurationHistogram;
  DurationHistogram.BUCKET_COUNT = 384;
  DurationHistogram.EXPONENT_LOG = Math.log(1.1);
});

// node_modules/apollo-server-core/dist/plugin/usageReporting/iterateOverTrace.js
var require_iterateOverTrace = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.iterateOverTrace = undefined;
  function iterateOverTrace(trace, f, includePath) {
    const rootPath = includePath ? new RootCollectingPathsResponseNamePath : notCollectingPathsResponseNamePath;
    if (trace.root) {
      if (iterateOverTraceNode(trace.root, rootPath, f))
        return;
    }
    if (trace.queryPlan) {
      if (iterateOverQueryPlan(trace.queryPlan, rootPath, f))
        return;
    }
  }
  exports.iterateOverTrace = iterateOverTrace;
  function iterateOverQueryPlan(node, rootPath, f) {
    var _a, _b, _c, _d, _e;
    if (!node)
      return false;
    if (((_b = (_a = node.fetch) === null || _a === undefined ? undefined : _a.trace) === null || _b === undefined ? undefined : _b.root) && node.fetch.serviceName) {
      return iterateOverTraceNode(node.fetch.trace.root, rootPath.child(`service:${node.fetch.serviceName}`), f);
    }
    if ((_c = node.flatten) === null || _c === undefined ? undefined : _c.node) {
      return iterateOverQueryPlan(node.flatten.node, rootPath, f);
    }
    if ((_d = node.parallel) === null || _d === undefined ? undefined : _d.nodes) {
      return node.parallel.nodes.some((node2) => iterateOverQueryPlan(node2, rootPath, f));
    }
    if ((_e = node.sequence) === null || _e === undefined ? undefined : _e.nodes) {
      return node.sequence.nodes.some((node2) => iterateOverQueryPlan(node2, rootPath, f));
    }
    return false;
  }
  function iterateOverTraceNode(node, path, f) {
    var _a, _b;
    if (f(node, path)) {
      return true;
    }
    return (_b = (_a = node.child) === null || _a === undefined ? undefined : _a.some((child) => {
      const childPath = child.responseName ? path.child(child.responseName) : path;
      return iterateOverTraceNode(child, childPath, f);
    })) !== null && _b !== undefined ? _b : false;
  }
  var notCollectingPathsResponseNamePath = {
    toArray() {
      throw Error("not collecting paths!");
    },
    child() {
      return this;
    }
  };

  class RootCollectingPathsResponseNamePath {
    toArray() {
      return [];
    }
    child(responseName) {
      return new ChildCollectingPathsResponseNamePath(responseName, this);
    }
  }

  class ChildCollectingPathsResponseNamePath {
    constructor(responseName, prev) {
      this.responseName = responseName;
      this.prev = prev;
    }
    toArray() {
      const out = [];
      let curr = this;
      while (curr instanceof ChildCollectingPathsResponseNamePath) {
        out.push(curr.responseName);
        curr = curr.prev;
      }
      return out.reverse();
    }
    child(responseName) {
      return new ChildCollectingPathsResponseNamePath(responseName, this);
    }
  }
});

// node_modules/apollo-server-core/dist/plugin/usageReporting/stats.js
var require_stats = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OurContextualizedStats = exports.OurReport = exports.SizeEstimator = undefined;
  var durationHistogram_1 = require_durationHistogram();
  var apollo_reporting_protobuf_1 = require_generated();
  var iterateOverTrace_1 = require_iterateOverTrace();

  class SizeEstimator {
    constructor() {
      this.bytes = 0;
    }
  }
  exports.SizeEstimator = SizeEstimator;

  class OurReport {
    constructor(header) {
      this.header = header;
      this.tracesPreAggregated = false;
      this.tracesPerQuery = Object.create(null);
      this.endTime = null;
      this.operationCount = 0;
      this.sizeEstimator = new SizeEstimator;
    }
    ensureCountsAreIntegers() {
      for (const tracesAndStats of Object.values(this.tracesPerQuery)) {
        tracesAndStats.ensureCountsAreIntegers();
      }
    }
    addTrace({ statsReportKey, trace, asTrace, includeTracesContributingToStats, referencedFieldsByType }) {
      const tracesAndStats = this.getTracesAndStats({
        statsReportKey,
        referencedFieldsByType
      });
      if (asTrace) {
        const encodedTrace = apollo_reporting_protobuf_1.Trace.encode(trace).finish();
        tracesAndStats.trace.push(encodedTrace);
        this.sizeEstimator.bytes += 2 + encodedTrace.length;
      } else {
        tracesAndStats.statsWithContext.addTrace(trace, this.sizeEstimator);
        if (includeTracesContributingToStats) {
          const encodedTrace = apollo_reporting_protobuf_1.Trace.encode(trace).finish();
          tracesAndStats.internalTracesContributingToStats.push(encodedTrace);
          this.sizeEstimator.bytes += 2 + encodedTrace.length;
        }
      }
    }
    getTracesAndStats({ statsReportKey, referencedFieldsByType }) {
      const existing = this.tracesPerQuery[statsReportKey];
      if (existing) {
        return existing;
      }
      this.sizeEstimator.bytes += estimatedBytesForString(statsReportKey);
      for (const [typeName, referencedFieldsForType] of Object.entries(referencedFieldsByType)) {
        this.sizeEstimator.bytes += 2 + 2;
        if (referencedFieldsForType.isInterface) {
          this.sizeEstimator.bytes += 2;
        }
        this.sizeEstimator.bytes += estimatedBytesForString(typeName);
        for (const fieldName of referencedFieldsForType.fieldNames) {
          this.sizeEstimator.bytes += estimatedBytesForString(fieldName);
        }
      }
      return this.tracesPerQuery[statsReportKey] = new OurTracesAndStats(referencedFieldsByType);
    }
  }
  exports.OurReport = OurReport;

  class OurTracesAndStats {
    constructor(referencedFieldsByType) {
      this.referencedFieldsByType = referencedFieldsByType;
      this.trace = [];
      this.statsWithContext = new StatsByContext;
      this.internalTracesContributingToStats = [];
    }
    ensureCountsAreIntegers() {
      this.statsWithContext.ensureCountsAreIntegers();
    }
  }

  class StatsByContext {
    constructor() {
      this.map = Object.create(null);
    }
    toArray() {
      return Object.values(this.map);
    }
    ensureCountsAreIntegers() {
      for (const contextualizedStats of Object.values(this.map)) {
        contextualizedStats.ensureCountsAreIntegers();
      }
    }
    addTrace(trace, sizeEstimator) {
      this.getContextualizedStats(trace, sizeEstimator).addTrace(trace, sizeEstimator);
    }
    getContextualizedStats(trace, sizeEstimator) {
      const statsContext = {
        clientName: trace.clientName,
        clientVersion: trace.clientVersion
      };
      const statsContextKey = JSON.stringify(statsContext);
      const existing = this.map[statsContextKey];
      if (existing) {
        return existing;
      }
      sizeEstimator.bytes += 20 + estimatedBytesForString(trace.clientName) + estimatedBytesForString(trace.clientVersion);
      const contextualizedStats = new OurContextualizedStats(statsContext);
      this.map[statsContextKey] = contextualizedStats;
      return contextualizedStats;
    }
  }

  class OurContextualizedStats {
    constructor(context) {
      this.context = context;
      this.queryLatencyStats = new OurQueryLatencyStats;
      this.perTypeStat = Object.create(null);
    }
    ensureCountsAreIntegers() {
      for (const typeStat of Object.values(this.perTypeStat)) {
        typeStat.ensureCountsAreIntegers();
      }
    }
    addTrace(trace, sizeEstimator) {
      var _a;
      const { fieldExecutionWeight } = trace;
      if (!fieldExecutionWeight) {
        this.queryLatencyStats.requestsWithoutFieldInstrumentation++;
      }
      this.queryLatencyStats.requestCount++;
      if (trace.fullQueryCacheHit) {
        this.queryLatencyStats.cacheLatencyCount.incrementDuration(trace.durationNs);
        this.queryLatencyStats.cacheHits++;
      } else {
        this.queryLatencyStats.latencyCount.incrementDuration(trace.durationNs);
      }
      if (!trace.fullQueryCacheHit && ((_a = trace.cachePolicy) === null || _a === undefined ? undefined : _a.maxAgeNs) != null) {
        switch (trace.cachePolicy.scope) {
          case apollo_reporting_protobuf_1.Trace.CachePolicy.Scope.PRIVATE:
            this.queryLatencyStats.privateCacheTtlCount.incrementDuration(trace.cachePolicy.maxAgeNs);
            break;
          case apollo_reporting_protobuf_1.Trace.CachePolicy.Scope.PUBLIC:
            this.queryLatencyStats.publicCacheTtlCount.incrementDuration(trace.cachePolicy.maxAgeNs);
            break;
        }
      }
      if (trace.persistedQueryHit) {
        this.queryLatencyStats.persistedQueryHits++;
      }
      if (trace.persistedQueryRegister) {
        this.queryLatencyStats.persistedQueryMisses++;
      }
      if (trace.forbiddenOperation) {
        this.queryLatencyStats.forbiddenOperationCount++;
      }
      if (trace.registeredOperation) {
        this.queryLatencyStats.registeredOperationCount++;
      }
      let hasError = false;
      const traceNodeStats = (node, path) => {
        var _a2, _b, _c, _d, _e;
        if ((_a2 = node.error) === null || _a2 === undefined ? undefined : _a2.length) {
          hasError = true;
          let currPathErrorStats = this.queryLatencyStats.rootErrorStats;
          path.toArray().forEach((subPath) => {
            currPathErrorStats = currPathErrorStats.getChild(subPath, sizeEstimator);
          });
          currPathErrorStats.requestsWithErrorsCount += 1;
          currPathErrorStats.errorsCount += node.error.length;
        }
        if (fieldExecutionWeight) {
          const fieldName = node.originalFieldName || node.responseName;
          if (node.parentType && fieldName && node.type && node.endTime != null && node.startTime != null && node.endTime >= node.startTime) {
            const typeStat = this.getTypeStat(node.parentType, sizeEstimator);
            const fieldStat = typeStat.getFieldStat(fieldName, node.type, sizeEstimator);
            fieldStat.errorsCount += (_c = (_b = node.error) === null || _b === undefined ? undefined : _b.length) !== null && _c !== undefined ? _c : 0;
            fieldStat.observedExecutionCount++;
            fieldStat.estimatedExecutionCount += fieldExecutionWeight;
            fieldStat.requestsWithErrorsCount += ((_e = (_d = node.error) === null || _d === undefined ? undefined : _d.length) !== null && _e !== undefined ? _e : 0) > 0 ? 1 : 0;
            fieldStat.latencyCount.incrementDuration(node.endTime - node.startTime, fieldExecutionWeight);
          }
        }
        return false;
      };
      (0, iterateOverTrace_1.iterateOverTrace)(trace, traceNodeStats, true);
      if (hasError) {
        this.queryLatencyStats.requestsWithErrorsCount++;
      }
    }
    getTypeStat(parentType, sizeEstimator) {
      const existing = this.perTypeStat[parentType];
      if (existing) {
        return existing;
      }
      sizeEstimator.bytes += estimatedBytesForString(parentType);
      const typeStat = new OurTypeStat;
      this.perTypeStat[parentType] = typeStat;
      return typeStat;
    }
  }
  exports.OurContextualizedStats = OurContextualizedStats;

  class OurQueryLatencyStats {
    constructor() {
      this.latencyCount = new durationHistogram_1.DurationHistogram;
      this.requestCount = 0;
      this.requestsWithoutFieldInstrumentation = 0;
      this.cacheHits = 0;
      this.persistedQueryHits = 0;
      this.persistedQueryMisses = 0;
      this.cacheLatencyCount = new durationHistogram_1.DurationHistogram;
      this.rootErrorStats = new OurPathErrorStats;
      this.requestsWithErrorsCount = 0;
      this.publicCacheTtlCount = new durationHistogram_1.DurationHistogram;
      this.privateCacheTtlCount = new durationHistogram_1.DurationHistogram;
      this.registeredOperationCount = 0;
      this.forbiddenOperationCount = 0;
    }
  }

  class OurPathErrorStats {
    constructor() {
      this.children = Object.create(null);
      this.errorsCount = 0;
      this.requestsWithErrorsCount = 0;
    }
    getChild(subPath, sizeEstimator) {
      const existing = this.children[subPath];
      if (existing) {
        return existing;
      }
      const child = new OurPathErrorStats;
      this.children[subPath] = child;
      sizeEstimator.bytes += estimatedBytesForString(subPath) + 4;
      return child;
    }
  }

  class OurTypeStat {
    constructor() {
      this.perFieldStat = Object.create(null);
    }
    getFieldStat(fieldName, returnType, sizeEstimator) {
      const existing = this.perFieldStat[fieldName];
      if (existing) {
        return existing;
      }
      sizeEstimator.bytes += estimatedBytesForString(fieldName) + estimatedBytesForString(returnType) + 10;
      const fieldStat = new OurFieldStat(returnType);
      this.perFieldStat[fieldName] = fieldStat;
      return fieldStat;
    }
    ensureCountsAreIntegers() {
      for (const fieldStat of Object.values(this.perFieldStat)) {
        fieldStat.ensureCountsAreIntegers();
      }
    }
  }

  class OurFieldStat {
    constructor(returnType) {
      this.returnType = returnType;
      this.errorsCount = 0;
      this.observedExecutionCount = 0;
      this.estimatedExecutionCount = 0;
      this.requestsWithErrorsCount = 0;
      this.latencyCount = new durationHistogram_1.DurationHistogram;
    }
    ensureCountsAreIntegers() {
      this.estimatedExecutionCount = Math.floor(this.estimatedExecutionCount);
    }
  }
  function estimatedBytesForString(s) {
    return 2 + Buffer.byteLength(s);
  }
});

// node_modules/apollo-server-core/dist/plugin/usageReporting/defaultSendOperationsAsTrace.js
var require_defaultSendOperationsAsTrace = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defaultSendOperationsAsTrace = undefined;
  var lru_cache_1 = __importDefault(require_lru_cache2());
  var iterateOverTrace_1 = require_iterateOverTrace();
  var durationHistogram_1 = require_durationHistogram();
  function defaultSendOperationsAsTrace() {
    const cache = new lru_cache_1.default({
      max: Math.pow(2, 20),
      length: (_val, key) => {
        return key && Buffer.byteLength(key) || 0;
      }
    });
    return (trace, statsReportKey) => {
      var _a;
      const endTimeSeconds = (_a = trace.endTime) === null || _a === undefined ? undefined : _a.seconds;
      if (endTimeSeconds == null) {
        throw Error("programming error: endTime not set on trace");
      }
      const hasErrors = traceHasErrors(trace);
      const cacheKey = JSON.stringify([
        statsReportKey,
        durationHistogram_1.DurationHistogram.durationToBucket(trace.durationNs),
        Math.floor(endTimeSeconds / 60),
        hasErrors ? Math.floor(endTimeSeconds / 5) : ""
      ]);
      if (cache.get(cacheKey)) {
        return false;
      }
      cache.set(cacheKey, true);
      return true;
    };
  }
  exports.defaultSendOperationsAsTrace = defaultSendOperationsAsTrace;
  function traceHasErrors(trace) {
    let hasErrors = false;
    function traceNodeStats(node) {
      var _a, _b;
      if (((_b = (_a = node.error) === null || _a === undefined ? undefined : _a.length) !== null && _b !== undefined ? _b : 0) > 0) {
        hasErrors = true;
      }
      return hasErrors;
    }
    (0, iterateOverTrace_1.iterateOverTrace)(trace, traceNodeStats, false);
    return hasErrors;
  }
});

// node_modules/apollo-server-core/dist/plugin/usageReporting/plugin.js
var require_plugin = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ApolloServerPluginUsageReportingDisabled = exports.makeHTTPRequestHeaders = exports.ApolloServerPluginUsageReporting = undefined;
  var os_1 = __importDefault(__require("os"));
  var util_1 = __require("util");
  var zlib_1 = __require("zlib");
  var async_retry_1 = __importDefault(require_lib7());
  var apollo_reporting_protobuf_1 = require_generated();
  var apollo_server_env_1 = require_dist();
  var node_abort_controller_1 = require_node_abort_controller();
  var apollo_server_types_1 = require_dist3();
  var operationDerivedDataCache_1 = require_operationDerivedDataCache();
  var utils_usagereporting_1 = require_dist10();
  var traceTreeBuilder_1 = require_traceTreeBuilder();
  var traceDetails_1 = require_traceDetails();
  var graphql_1 = require_graphql2();
  var schemaReporting_1 = require_schemaReporting();
  var stats_1 = require_stats();
  var defaultSendOperationsAsTrace_1 = require_defaultSendOperationsAsTrace();
  var utils_usagereporting_2 = require_dist10();
  var gzipPromise = (0, util_1.promisify)(zlib_1.gzip);
  var reportHeaderDefaults = {
    hostname: os_1.default.hostname(),
    agentVersion: `apollo-server-core@${require_package().version}`,
    runtimeVersion: `node ${process.version}`,
    uname: `${os_1.default.platform()}, ${os_1.default.type()}, ${os_1.default.release()}, ${os_1.default.arch()})`
  };
  function ApolloServerPluginUsageReporting(options = Object.create(null)) {
    const fieldLevelInstrumentationOption = options.fieldLevelInstrumentation;
    const fieldLevelInstrumentation = typeof fieldLevelInstrumentationOption === "number" ? async () => Math.random() < fieldLevelInstrumentationOption ? 1 / fieldLevelInstrumentationOption : 0 : fieldLevelInstrumentationOption ? fieldLevelInstrumentationOption : async () => true;
    let requestDidStartHandler;
    return {
      __internal_plugin_id__() {
        return "UsageReporting";
      },
      async requestDidStart(requestContext) {
        if (!requestDidStartHandler) {
          throw Error("The usage reporting plugin has been asked to handle a request before the " + "server has started. See https://github.com/apollographql/apollo-server/issues/4588 " + "for more details.");
        }
        return requestDidStartHandler(requestContext);
      },
      async serverWillStart({ logger: serverLogger, apollo, serverlessFramework }) {
        var _a, _b, _c, _d;
        const logger = (_a = options.logger) !== null && _a !== undefined ? _a : serverLogger;
        const { key, graphRef } = apollo;
        if (!(key && graphRef)) {
          throw new Error("You've enabled usage reporting via ApolloServerPluginUsageReporting, " + "but you also need to provide your Apollo API key and graph ref, via " + "the APOLLO_KEY/APOLLO_GRAPH_REF environment " + "variables or via `new ApolloServer({apollo: {key, graphRef})`.");
        }
        logger.info("Apollo usage reporting starting! See your graph at " + `https://studio.apollographql.com/graph/${encodeURI(graphRef)}/`);
        const sendReportsImmediately = (_b = options.sendReportsImmediately) !== null && _b !== undefined ? _b : serverlessFramework;
        let operationDerivedDataCache = null;
        const reportByExecutableSchemaId = new Map;
        const getReportWhichMustBeUsedImmediately = (executableSchemaId) => {
          const existing = reportByExecutableSchemaId.get(executableSchemaId);
          if (existing) {
            return existing;
          }
          const report = new stats_1.OurReport(new apollo_reporting_protobuf_1.ReportHeader({
            ...reportHeaderDefaults,
            executableSchemaId,
            graphRef
          }));
          reportByExecutableSchemaId.set(executableSchemaId, report);
          return report;
        };
        const getAndDeleteReport = (executableSchemaId) => {
          const report = reportByExecutableSchemaId.get(executableSchemaId);
          if (report) {
            reportByExecutableSchemaId.delete(executableSchemaId);
            return report;
          }
          return null;
        };
        const overriddenExecutableSchemaId = options.overrideReportedSchema ? (0, schemaReporting_1.computeCoreSchemaHash)(options.overrideReportedSchema) : undefined;
        let lastSeenExecutableSchemaToId;
        let reportTimer;
        if (!sendReportsImmediately) {
          reportTimer = setInterval(() => sendAllReportsAndReportErrors(), options.reportIntervalMs || 10 * 1000);
        }
        let graphMightSupportTraces = true;
        const sendOperationAsTrace = (_c = options.experimental_sendOperationAsTrace) !== null && _c !== undefined ? _c : (0, defaultSendOperationsAsTrace_1.defaultSendOperationsAsTrace)();
        const includeTracesContributingToStats = (_d = options.internal_includeTracesContributingToStats) !== null && _d !== undefined ? _d : false;
        let stopped = false;
        function executableSchemaIdForSchema(schema) {
          if ((lastSeenExecutableSchemaToId === null || lastSeenExecutableSchemaToId === undefined ? undefined : lastSeenExecutableSchemaToId.executableSchema) === schema) {
            return lastSeenExecutableSchemaToId.executableSchemaId;
          }
          const id = (0, schemaReporting_1.computeCoreSchemaHash)((0, graphql_1.printSchema)(schema));
          lastSeenExecutableSchemaToId = {
            executableSchema: schema,
            executableSchemaId: id
          };
          return id;
        }
        async function sendAllReportsAndReportErrors() {
          await Promise.all([...reportByExecutableSchemaId.keys()].map((executableSchemaId) => sendReportAndReportErrors(executableSchemaId)));
        }
        async function sendReportAndReportErrors(executableSchemaId) {
          return sendReport(executableSchemaId).catch((err) => {
            if (options.reportErrorFunction) {
              options.reportErrorFunction(err);
            } else {
              logger.error(err.message);
            }
          });
        }
        const sendReport = async (executableSchemaId) => {
          var _a2, _b2;
          let report = getAndDeleteReport(executableSchemaId);
          if (!report || Object.keys(report.tracesPerQuery).length === 0 && report.operationCount === 0) {
            return;
          }
          report.endTime = (0, traceTreeBuilder_1.dateToProtoTimestamp)(new Date);
          report.ensureCountsAreIntegers();
          const protobufError = apollo_reporting_protobuf_1.Report.verify(report);
          if (protobufError) {
            throw new Error(`Error verifying report: ${protobufError}`);
          }
          let message2 = apollo_reporting_protobuf_1.Report.encode(report).finish();
          report = null;
          if (options.debugPrintReports) {
            const decodedReport = apollo_reporting_protobuf_1.Report.decode(message2);
            logger.warn(`Apollo usage report: ${JSON.stringify(decodedReport.toJSON())}`);
          }
          const compressed = await gzipPromise(message2);
          message2 = null;
          const fetcher = (_a2 = options.fetcher) !== null && _a2 !== undefined ? _a2 : apollo_server_env_1.fetch;
          const response = await (0, async_retry_1.default)(async () => {
            var _a3;
            const controller = new node_abort_controller_1.AbortController;
            const abortTimeout = setTimeout(() => {
              controller.abort();
            }, (_a3 = options.requestTimeoutMs) !== null && _a3 !== undefined ? _a3 : 30000);
            let curResponse;
            try {
              const requestInit = {
                method: "POST",
                headers: {
                  "user-agent": "ApolloServerPluginUsageReporting",
                  "x-api-key": key,
                  "content-encoding": "gzip",
                  accept: "application/json"
                },
                body: compressed,
                agent: options.requestAgent
              };
              requestInit.signal = controller.signal;
              curResponse = await fetcher((options.endpointUrl || "https://usage-reporting.api.apollographql.com") + "/api/ingress/traces", requestInit);
            } finally {
              clearTimeout(abortTimeout);
            }
            if (curResponse.status >= 500 && curResponse.status < 600) {
              throw new Error(`HTTP status ${curResponse.status}, ${await curResponse.text() || "(no body)"}`);
            } else {
              return curResponse;
            }
          }, {
            retries: (options.maxAttempts || 5) - 1,
            minTimeout: options.minimumRetryDelayMs || 100,
            factor: 2
          }).catch((err) => {
            throw new Error(`Error sending report to Apollo servers: ${err.message}`);
          });
          if (response.status < 200 || response.status >= 300) {
            throw new Error(`Error sending report to Apollo servers: HTTP status ${response.status}, ${await response.text() || "(no body)"}`);
          }
          if (graphMightSupportTraces && response.status === 200 && ((_b2 = response.headers.get("content-type")) === null || _b2 === undefined ? undefined : _b2.match(/^\s*application\/json\s*(?:;|$)/i))) {
            const body = await response.text();
            let parsedBody;
            try {
              parsedBody = JSON.parse(body);
            } catch (e) {
              throw new Error(`Error parsing response from Apollo servers: ${e}`);
            }
            if (parsedBody.tracesIgnored === true) {
              logger.debug("This graph's organization does not have access to traces; sending all " + "subsequent operations as traces.");
              graphMightSupportTraces = false;
            }
          }
          if (options.debugPrintReports) {
            logger.warn(`Apollo usage report: status ${response.status}`);
          }
        };
        requestDidStartHandler = ({ logger: requestLogger, metrics, schema, request: { http, variables } }) => {
          var _a2;
          const logger2 = (_a2 = requestLogger !== null && requestLogger !== undefined ? requestLogger : options.logger) !== null && _a2 !== undefined ? _a2 : serverLogger;
          const treeBuilder = new traceTreeBuilder_1.TraceTreeBuilder({
            rewriteError: options.rewriteError,
            logger: logger2
          });
          treeBuilder.startTiming();
          metrics.startHrTime = treeBuilder.startHrTime;
          let graphqlValidationFailure = false;
          let graphqlUnknownOperationName = false;
          let includeOperationInUsageReporting = null;
          if (http) {
            treeBuilder.trace.http = new apollo_reporting_protobuf_1.Trace.HTTP({
              method: apollo_reporting_protobuf_1.Trace.HTTP.Method[http.method] || apollo_reporting_protobuf_1.Trace.HTTP.Method.UNKNOWN
            });
            if (options.sendHeaders) {
              makeHTTPRequestHeaders(treeBuilder.trace.http, http.headers, options.sendHeaders);
            }
          }
          async function maybeCallIncludeRequestHook(requestContext) {
            if (includeOperationInUsageReporting !== null)
              return;
            if (typeof options.includeRequest !== "function") {
              includeOperationInUsageReporting = true;
              return;
            }
            includeOperationInUsageReporting = await options.includeRequest(requestContext);
            if (typeof includeOperationInUsageReporting !== "boolean") {
              logger2.warn("The 'includeRequest' async predicate function must return a boolean value.");
              includeOperationInUsageReporting = true;
            }
          }
          let didResolveSource = false;
          return {
            async didResolveSource(requestContext) {
              didResolveSource = true;
              if (metrics.persistedQueryHit) {
                treeBuilder.trace.persistedQueryHit = true;
              }
              if (metrics.persistedQueryRegister) {
                treeBuilder.trace.persistedQueryRegister = true;
              }
              if (variables) {
                treeBuilder.trace.details = (0, traceDetails_1.makeTraceDetails)(variables, options.sendVariableValues, requestContext.source);
              }
              const clientInfo = (options.generateClientInfo || defaultGenerateClientInfo)(requestContext);
              if (clientInfo) {
                const { clientName, clientVersion } = clientInfo;
                treeBuilder.trace.clientVersion = clientVersion || "";
                treeBuilder.trace.clientName = clientName || "";
              }
            },
            async validationDidStart() {
              return async (validationErrors) => {
                graphqlValidationFailure = validationErrors ? validationErrors.length !== 0 : false;
              };
            },
            async didResolveOperation(requestContext) {
              graphqlUnknownOperationName = requestContext.operation === undefined;
              await maybeCallIncludeRequestHook(requestContext);
              if (includeOperationInUsageReporting && !graphqlUnknownOperationName) {
                if (metrics.captureTraces === undefined) {
                  const rawWeight = await fieldLevelInstrumentation(requestContext);
                  treeBuilder.trace.fieldExecutionWeight = typeof rawWeight === "number" ? rawWeight : rawWeight ? 1 : 0;
                  metrics.captureTraces = !!treeBuilder.trace.fieldExecutionWeight;
                }
              }
            },
            async executionDidStart() {
              if (!metrics.captureTraces)
                return;
              return {
                willResolveField({ info }) {
                  return treeBuilder.willResolveField(info);
                }
              };
            },
            async willSendResponse(requestContext) {
              if (!didResolveSource)
                return;
              if (requestContext.errors) {
                treeBuilder.didEncounterErrors(requestContext.errors);
              }
              const resolvedOperation = !!requestContext.operation;
              await maybeCallIncludeRequestHook(requestContext);
              treeBuilder.stopTiming();
              const executableSchemaId = overriddenExecutableSchemaId !== null && overriddenExecutableSchemaId !== undefined ? overriddenExecutableSchemaId : executableSchemaIdForSchema(schema);
              if (includeOperationInUsageReporting === false) {
                if (resolvedOperation)
                  getReportWhichMustBeUsedImmediately(executableSchemaId).operationCount++;
                return;
              }
              treeBuilder.trace.fullQueryCacheHit = !!metrics.responseCacheHit;
              treeBuilder.trace.forbiddenOperation = !!metrics.forbiddenOperation;
              treeBuilder.trace.registeredOperation = !!metrics.registeredOperation;
              const policyIfCacheable = requestContext.overallCachePolicy.policyIfCacheable();
              if (policyIfCacheable) {
                treeBuilder.trace.cachePolicy = new apollo_reporting_protobuf_1.Trace.CachePolicy({
                  scope: policyIfCacheable.scope === apollo_server_types_1.CacheScope.Private ? apollo_reporting_protobuf_1.Trace.CachePolicy.Scope.PRIVATE : policyIfCacheable.scope === apollo_server_types_1.CacheScope.Public ? apollo_reporting_protobuf_1.Trace.CachePolicy.Scope.PUBLIC : apollo_reporting_protobuf_1.Trace.CachePolicy.Scope.UNKNOWN,
                  maxAgeNs: policyIfCacheable.maxAge * 1e9
                });
              }
              if (metrics.queryPlanTrace) {
                treeBuilder.trace.queryPlan = metrics.queryPlanTrace;
              }
              addTrace().catch(logger2.error);
              async function addTrace() {
                if (stopped) {
                  return;
                }
                await new Promise((res) => setImmediate(res));
                const executableSchemaId2 = overriddenExecutableSchemaId !== null && overriddenExecutableSchemaId !== undefined ? overriddenExecutableSchemaId : executableSchemaIdForSchema(schema);
                const { trace } = treeBuilder;
                let statsReportKey = undefined;
                let referencedFieldsByType;
                if (!requestContext.document) {
                  statsReportKey = `## GraphQLParseFailure
`;
                } else if (graphqlValidationFailure) {
                  statsReportKey = `## GraphQLValidationFailure
`;
                } else if (graphqlUnknownOperationName) {
                  statsReportKey = `## GraphQLUnknownOperationName
`;
                }
                const isExecutable = statsReportKey === undefined;
                if (statsReportKey) {
                  if (options.sendUnexecutableOperationDocuments) {
                    trace.unexecutedOperationBody = requestContext.source;
                    trace.unexecutedOperationName = requestContext.request.operationName || "";
                  }
                  referencedFieldsByType = Object.create(null);
                } else {
                  const operationDerivedData = getOperationDerivedData();
                  statsReportKey = `# ${requestContext.operationName || "-"}
${operationDerivedData.signature}`;
                  referencedFieldsByType = operationDerivedData.referencedFieldsByType;
                }
                const protobufError = apollo_reporting_protobuf_1.Trace.verify(trace);
                if (protobufError) {
                  throw new Error(`Error encoding trace: ${protobufError}`);
                }
                if (resolvedOperation) {
                  getReportWhichMustBeUsedImmediately(executableSchemaId2).operationCount++;
                }
                getReportWhichMustBeUsedImmediately(executableSchemaId2).addTrace({
                  statsReportKey,
                  trace,
                  asTrace: graphMightSupportTraces && (!isExecutable || !!metrics.captureTraces) && sendOperationAsTrace(trace, statsReportKey),
                  includeTracesContributingToStats,
                  referencedFieldsByType
                });
                if (sendReportsImmediately || getReportWhichMustBeUsedImmediately(executableSchemaId2).sizeEstimator.bytes >= (options.maxUncompressedReportSize || 4 * 1024 * 1024)) {
                  await sendReportAndReportErrors(executableSchemaId2);
                }
              }
              function getOperationDerivedData() {
                var _a3;
                if (!requestContext.document) {
                  throw new Error("No document?");
                }
                const cacheKey = (0, operationDerivedDataCache_1.operationDerivedDataCacheKey)(requestContext.queryHash, requestContext.operationName || "");
                if (!operationDerivedDataCache || operationDerivedDataCache.forSchema !== schema) {
                  operationDerivedDataCache = {
                    forSchema: schema,
                    cache: (0, operationDerivedDataCache_1.createOperationDerivedDataCache)({ logger: logger2 })
                  };
                }
                const cachedOperationDerivedData = operationDerivedDataCache.cache.get(cacheKey);
                if (cachedOperationDerivedData) {
                  return cachedOperationDerivedData;
                }
                const generatedSignature = (options.calculateSignature || utils_usagereporting_1.usageReportingSignature)(requestContext.document, requestContext.operationName || "");
                const generatedOperationDerivedData = {
                  signature: generatedSignature,
                  referencedFieldsByType: (0, utils_usagereporting_2.calculateReferencedFieldsByType)({
                    document: requestContext.document,
                    schema,
                    resolvedOperationName: (_a3 = requestContext.operationName) !== null && _a3 !== undefined ? _a3 : null
                  })
                };
                operationDerivedDataCache.cache.set(cacheKey, generatedOperationDerivedData);
                return generatedOperationDerivedData;
              }
            }
          };
        };
        return {
          async serverWillStop() {
            if (reportTimer) {
              clearInterval(reportTimer);
              reportTimer = undefined;
            }
            stopped = true;
            await sendAllReportsAndReportErrors();
          }
        };
      }
    };
  }
  exports.ApolloServerPluginUsageReporting = ApolloServerPluginUsageReporting;
  function makeHTTPRequestHeaders(http, headers, sendHeaders) {
    if (!sendHeaders || "none" in sendHeaders && sendHeaders.none || "all" in sendHeaders && !sendHeaders.all) {
      return;
    }
    for (const [key, value] of headers) {
      const lowerCaseKey = key.toLowerCase();
      if ("exceptNames" in sendHeaders && sendHeaders.exceptNames.some((exceptHeader) => {
        return exceptHeader.toLowerCase() === lowerCaseKey;
      }) || "onlyNames" in sendHeaders && !sendHeaders.onlyNames.some((header) => {
        return header.toLowerCase() === lowerCaseKey;
      })) {
        continue;
      }
      switch (key) {
        case "authorization":
        case "cookie":
        case "set-cookie":
          break;
        default:
          http.requestHeaders[key] = new apollo_reporting_protobuf_1.Trace.HTTP.Values({
            value: [value]
          });
      }
    }
  }
  exports.makeHTTPRequestHeaders = makeHTTPRequestHeaders;
  function defaultGenerateClientInfo({ request }) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    const clientNameHeaderKey = "apollographql-client-name";
    const clientVersionHeaderKey = "apollographql-client-version";
    if (((_b = (_a = request.http) === null || _a === undefined ? undefined : _a.headers) === null || _b === undefined ? undefined : _b.get(clientNameHeaderKey)) || ((_d = (_c = request.http) === null || _c === undefined ? undefined : _c.headers) === null || _d === undefined ? undefined : _d.get(clientVersionHeaderKey))) {
      return {
        clientName: (_f = (_e = request.http) === null || _e === undefined ? undefined : _e.headers) === null || _f === undefined ? undefined : _f.get(clientNameHeaderKey),
        clientVersion: (_h = (_g = request.http) === null || _g === undefined ? undefined : _g.headers) === null || _h === undefined ? undefined : _h.get(clientVersionHeaderKey)
      };
    } else if ((_j = request.extensions) === null || _j === undefined ? undefined : _j.clientInfo) {
      return request.extensions.clientInfo;
    } else {
      return {};
    }
  }
  function ApolloServerPluginUsageReportingDisabled() {
    return {
      __internal_plugin_id__() {
        return "UsageReporting";
      }
    };
  }
  exports.ApolloServerPluginUsageReportingDisabled = ApolloServerPluginUsageReportingDisabled;
});

// node_modules/apollo-server-core/dist/plugin/usageReporting/options.js
var require_options = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/apollo-server-core/dist/plugin/usageReporting/index.js
var require_usageReporting = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ApolloServerPluginUsageReportingDisabled = exports.ApolloServerPluginUsageReporting = undefined;
  var plugin_1 = require_plugin();
  Object.defineProperty(exports, "ApolloServerPluginUsageReporting", { enumerable: true, get: function() {
    return plugin_1.ApolloServerPluginUsageReporting;
  } });
  Object.defineProperty(exports, "ApolloServerPluginUsageReportingDisabled", { enumerable: true, get: function() {
    return plugin_1.ApolloServerPluginUsageReportingDisabled;
  } });
  var options_1 = require_options();
});

// node_modules/apollo-server-core/dist/plugin/inlineTrace/index.js
var require_inlineTrace = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ApolloServerPluginInlineTraceDisabled = exports.ApolloServerPluginInlineTrace = undefined;
  var apollo_reporting_protobuf_1 = require_generated();
  var traceTreeBuilder_1 = require_traceTreeBuilder();
  var schemaIsFederated_1 = require_schemaIsFederated();
  function ApolloServerPluginInlineTrace(options = Object.create(null)) {
    let enabled = options.__onlyIfSchemaIsFederated ? null : true;
    return {
      __internal_plugin_id__() {
        return "InlineTrace";
      },
      async serverWillStart({ schema, logger }) {
        if (enabled === null) {
          enabled = (0, schemaIsFederated_1.schemaIsFederated)(schema);
          if (enabled) {
            logger.info("Enabling inline tracing for this federated service. To disable, use " + "ApolloServerPluginInlineTraceDisabled.");
          }
        }
      },
      async requestDidStart({ request: { http }, metrics }) {
        if (!enabled) {
          return;
        }
        const treeBuilder = new traceTreeBuilder_1.TraceTreeBuilder({
          rewriteError: options.rewriteError
        });
        if ((http === null || http === undefined ? undefined : http.headers.get("apollo-federation-include-trace")) !== "ftv1") {
          return;
        }
        if (metrics.captureTraces === false) {
          return;
        }
        metrics.captureTraces = true;
        treeBuilder.startTiming();
        return {
          async executionDidStart() {
            return {
              willResolveField({ info }) {
                return treeBuilder.willResolveField(info);
              }
            };
          },
          async didEncounterErrors({ errors }) {
            treeBuilder.didEncounterErrors(errors);
          },
          async willSendResponse({ response }) {
            treeBuilder.stopTiming();
            if (metrics.queryPlanTrace) {
              treeBuilder.trace.queryPlan = metrics.queryPlanTrace;
            }
            const encodedUint8Array = apollo_reporting_protobuf_1.Trace.encode(treeBuilder.trace).finish();
            const encodedBuffer = Buffer.from(encodedUint8Array, encodedUint8Array.byteOffset, encodedUint8Array.byteLength);
            const extensions = response.extensions || (response.extensions = Object.create(null));
            if (typeof extensions.ftv1 !== "undefined") {
              throw new Error("The `ftv1` extension was already present.");
            }
            extensions.ftv1 = encodedBuffer.toString("base64");
          }
        };
      }
    };
  }
  exports.ApolloServerPluginInlineTrace = ApolloServerPluginInlineTrace;
  function ApolloServerPluginInlineTraceDisabled() {
    return {
      __internal_plugin_id__() {
        return "InlineTrace";
      }
    };
  }
  exports.ApolloServerPluginInlineTraceDisabled = ApolloServerPluginInlineTraceDisabled;
});

// node_modules/apollo-server-core/dist/plugin/cacheControl/index.js
var require_cacheControl = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ApolloServerPluginCacheControlDisabled = exports.ApolloServerPluginCacheControl = undefined;
  var graphql_1 = require_graphql2();
  var cachePolicy_1 = require_cachePolicy();
  var lru_cache_1 = __importDefault(require_lru_cache2());
  function ApolloServerPluginCacheControl(options = Object.create(null)) {
    const typeAnnotationCache = new lru_cache_1.default;
    const fieldAnnotationCache = new lru_cache_1.default;
    function memoizedCacheAnnotationFromType(t) {
      const existing = typeAnnotationCache.get(t);
      if (existing) {
        return existing;
      }
      const annotation = cacheAnnotationFromType(t);
      typeAnnotationCache.set(t, annotation);
      return annotation;
    }
    function memoizedCacheAnnotationFromField(field) {
      const existing = fieldAnnotationCache.get(field);
      if (existing) {
        return existing;
      }
      const annotation = cacheAnnotationFromField(field);
      fieldAnnotationCache.set(field, annotation);
      return annotation;
    }
    return {
      __internal_plugin_id__() {
        return "CacheControl";
      },
      async serverWillStart({ schema }) {
        typeAnnotationCache.max = Object.values(schema.getTypeMap()).filter(graphql_1.isCompositeType).length;
        fieldAnnotationCache.max = Object.values(schema.getTypeMap()).filter(graphql_1.isObjectType).flatMap((t) => Object.values(t.getFields())).length + Object.values(schema.getTypeMap()).filter(graphql_1.isInterfaceType).flatMap((t) => Object.values(t.getFields())).length;
        return;
      },
      async requestDidStart(requestContext) {
        var _a, _b;
        const defaultMaxAge = (_a = options.defaultMaxAge) !== null && _a !== undefined ? _a : 0;
        const calculateHttpHeaders = (_b = options.calculateHttpHeaders) !== null && _b !== undefined ? _b : true;
        const { __testing__cacheHints } = options;
        return {
          async executionDidStart() {
            if (isRestricted(requestContext.overallCachePolicy)) {
              const fakeFieldPolicy = (0, cachePolicy_1.newCachePolicy)();
              return {
                willResolveField({ info }) {
                  info.cacheControl = {
                    setCacheHint: (dynamicHint) => {
                      fakeFieldPolicy.replace(dynamicHint);
                    },
                    cacheHint: fakeFieldPolicy,
                    cacheHintFromType: memoizedCacheAnnotationFromType
                  };
                }
              };
            }
            return {
              willResolveField({ info }) {
                const fieldPolicy = (0, cachePolicy_1.newCachePolicy)();
                let inheritMaxAge = false;
                const targetType = (0, graphql_1.getNamedType)(info.returnType);
                if ((0, graphql_1.isCompositeType)(targetType)) {
                  const typeAnnotation = memoizedCacheAnnotationFromType(targetType);
                  fieldPolicy.replace(typeAnnotation);
                  inheritMaxAge = !!typeAnnotation.inheritMaxAge;
                }
                const fieldAnnotation = memoizedCacheAnnotationFromField(info.parentType.getFields()[info.fieldName]);
                if (fieldAnnotation.inheritMaxAge && fieldPolicy.maxAge === undefined) {
                  inheritMaxAge = true;
                  if (fieldAnnotation.scope) {
                    fieldPolicy.replace({ scope: fieldAnnotation.scope });
                  }
                } else {
                  fieldPolicy.replace(fieldAnnotation);
                }
                info.cacheControl = {
                  setCacheHint: (dynamicHint) => {
                    fieldPolicy.replace(dynamicHint);
                  },
                  cacheHint: fieldPolicy,
                  cacheHintFromType: memoizedCacheAnnotationFromType
                };
                return () => {
                  if (fieldPolicy.maxAge === undefined && ((0, graphql_1.isCompositeType)(targetType) && !inheritMaxAge || !info.path.prev)) {
                    fieldPolicy.restrict({ maxAge: defaultMaxAge });
                  }
                  if (__testing__cacheHints && isRestricted(fieldPolicy)) {
                    const path = (0, graphql_1.responsePathAsArray)(info.path).join(".");
                    if (__testing__cacheHints.has(path)) {
                      throw Error("shouldn't happen: addHint should only be called once per path");
                    }
                    __testing__cacheHints.set(path, {
                      maxAge: fieldPolicy.maxAge,
                      scope: fieldPolicy.scope
                    });
                  }
                  requestContext.overallCachePolicy.restrict(fieldPolicy);
                };
              }
            };
          },
          async willSendResponse(requestContext2) {
            const { response, overallCachePolicy, requestIsBatched } = requestContext2;
            const policyIfCacheable = overallCachePolicy.policyIfCacheable();
            if (calculateHttpHeaders && policyIfCacheable && !response.errors && response.http && !requestIsBatched) {
              response.http.headers.set("Cache-Control", `max-age=${policyIfCacheable.maxAge}, ${policyIfCacheable.scope.toLowerCase()}`);
            }
          }
        };
      }
    };
  }
  exports.ApolloServerPluginCacheControl = ApolloServerPluginCacheControl;
  function cacheAnnotationFromDirectives(directives) {
    var _a, _b, _c;
    if (!directives)
      return;
    const cacheControlDirective = directives.find((directive) => directive.name.value === "cacheControl");
    if (!cacheControlDirective)
      return;
    if (!cacheControlDirective.arguments)
      return;
    const maxAgeArgument = cacheControlDirective.arguments.find((argument) => argument.name.value === "maxAge");
    const scopeArgument = cacheControlDirective.arguments.find((argument) => argument.name.value === "scope");
    const inheritMaxAgeArgument = cacheControlDirective.arguments.find((argument) => argument.name.value === "inheritMaxAge");
    const scope = ((_a = scopeArgument === null || scopeArgument === undefined ? undefined : scopeArgument.value) === null || _a === undefined ? undefined : _a.kind) === "EnumValue" ? scopeArgument.value.value : undefined;
    if (((_b = inheritMaxAgeArgument === null || inheritMaxAgeArgument === undefined ? undefined : inheritMaxAgeArgument.value) === null || _b === undefined ? undefined : _b.kind) === "BooleanValue" && inheritMaxAgeArgument.value.value) {
      return { inheritMaxAge: true, scope };
    }
    return {
      maxAge: ((_c = maxAgeArgument === null || maxAgeArgument === undefined ? undefined : maxAgeArgument.value) === null || _c === undefined ? undefined : _c.kind) === "IntValue" ? parseInt(maxAgeArgument.value.value) : undefined,
      scope
    };
  }
  function cacheAnnotationFromType(t) {
    if (t.astNode) {
      const hint = cacheAnnotationFromDirectives(t.astNode.directives);
      if (hint) {
        return hint;
      }
    }
    if (t.extensionASTNodes) {
      for (const node of t.extensionASTNodes) {
        const hint = cacheAnnotationFromDirectives(node.directives);
        if (hint) {
          return hint;
        }
      }
    }
    return {};
  }
  function cacheAnnotationFromField(field) {
    if (field.astNode) {
      const hint = cacheAnnotationFromDirectives(field.astNode.directives);
      if (hint) {
        return hint;
      }
    }
    return {};
  }
  function isRestricted(hint) {
    return hint.maxAge !== undefined || hint.scope !== undefined;
  }
  function ApolloServerPluginCacheControlDisabled() {
    return {
      __internal_plugin_id__() {
        return "CacheControl";
      }
    };
  }
  exports.ApolloServerPluginCacheControlDisabled = ApolloServerPluginCacheControlDisabled;
});

// node_modules/apollo-server-core/dist/plugin/drainHttpServer/stoppable.js
var require_stoppable = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Stopper = undefined;
  var https_1 = __importDefault(__require("https"));

  class Stopper {
    constructor(server) {
      this.server = server;
      this.requestCountPerSocket = new Map;
      this.stopped = false;
      server.on(server instanceof https_1.default.Server ? "secureConnection" : "connection", (socket) => {
        this.requestCountPerSocket.set(socket, 0);
        socket.once("close", () => this.requestCountPerSocket.delete(socket));
      });
      server.on("request", (req, res) => {
        var _a;
        this.requestCountPerSocket.set(req.socket, ((_a = this.requestCountPerSocket.get(req.socket)) !== null && _a !== undefined ? _a : 0) + 1);
        res.once("finish", () => {
          var _a2;
          const pending = ((_a2 = this.requestCountPerSocket.get(req.socket)) !== null && _a2 !== undefined ? _a2 : 0) - 1;
          this.requestCountPerSocket.set(req.socket, pending);
          if (this.stopped && pending === 0) {
            req.socket.end();
          }
        });
      });
    }
    async stop(stopGracePeriodMillis = Infinity) {
      let gracefully = true;
      await new Promise((resolve) => setImmediate(resolve));
      this.stopped = true;
      let timeout = null;
      if (stopGracePeriodMillis < Infinity) {
        timeout = setTimeout(() => {
          gracefully = false;
          this.requestCountPerSocket.forEach((_, socket) => socket.end());
          setImmediate(() => {
            this.requestCountPerSocket.forEach((_, socket) => socket.destroy());
          });
        }, stopGracePeriodMillis);
      }
      const closePromise = new Promise((resolve) => this.server.close(() => {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        resolve();
      }));
      this.requestCountPerSocket.forEach((requests, socket) => {
        if (requests === 0)
          socket.end();
      });
      await closePromise;
      return gracefully;
    }
  }
  exports.Stopper = Stopper;
});

// node_modules/apollo-server-core/dist/plugin/drainHttpServer/index.js
var require_drainHttpServer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ApolloServerPluginDrainHttpServer = undefined;
  var stoppable_1 = require_stoppable();
  function ApolloServerPluginDrainHttpServer(options) {
    const stopper = new stoppable_1.Stopper(options.httpServer);
    return {
      async serverWillStart() {
        return {
          async drainServer() {
            var _a;
            await stopper.stop((_a = options.stopGracePeriodMillis) !== null && _a !== undefined ? _a : 1e4);
          }
        };
      }
    };
  }
  exports.ApolloServerPluginDrainHttpServer = ApolloServerPluginDrainHttpServer;
});

// node_modules/apollo-server-core/dist/plugin/landingPage/default/index.js
var require_default = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getEmbeddedSandboxHTML = exports.getEmbeddedExplorerHTML = exports.ApolloServerPluginLandingPageProductionDefault = exports.ApolloServerPluginLandingPageLocalDefault = undefined;
  function ApolloServerPluginLandingPageLocalDefault(options = {}) {
    const { version, __internal_apolloStudioEnv__, ...rest } = options;
    return ApolloServerPluginLandingPageDefault(version, {
      isProd: false,
      apolloStudioEnv: __internal_apolloStudioEnv__,
      ...rest
    });
  }
  exports.ApolloServerPluginLandingPageLocalDefault = ApolloServerPluginLandingPageLocalDefault;
  function ApolloServerPluginLandingPageProductionDefault(options = {}) {
    const { version, __internal_apolloStudioEnv__, ...rest } = options;
    return ApolloServerPluginLandingPageDefault(version, {
      isProd: true,
      apolloStudioEnv: __internal_apolloStudioEnv__,
      ...rest
    });
  }
  exports.ApolloServerPluginLandingPageProductionDefault = ApolloServerPluginLandingPageProductionDefault;
  function encodeConfig(config) {
    return JSON.stringify(encodeURIComponent(JSON.stringify(config)));
  }
  function getConfigStringForHtml(config) {
    return JSON.stringify(config).replace("<", "\\u003c").replace(">", "\\u003e").replace("&", "\\u0026").replace("'", "\\u0027");
  }
  var getEmbeddedExplorerHTML = (version, config) => {
    const productionLandingPageConfigOrDefault = {
      displayOptions: {},
      persistExplorerState: false,
      ...typeof config.embed === "boolean" ? {} : config.embed
    };
    const embeddedExplorerParams = {
      ...config,
      target: "#embeddableExplorer",
      initialState: {
        ...config,
        displayOptions: {
          ...productionLandingPageConfigOrDefault.displayOptions
        }
      },
      persistExplorerState: productionLandingPageConfigOrDefault.persistExplorerState
    };
    return `
<div class="fallback">
  <h1>Welcome to Apollo Server</h1>
  <p>Apollo Explorer cannot be loaded; it appears that you might be offline.</p>
</div>
<style>
  iframe {
    background-color: white;
  }
</style>
<div
style="width: 100vw; height: 100vh; position: absolute; top: 0;"
id="embeddableExplorer"
></div>
<script src="https://embeddable-explorer.cdn.apollographql.com/${version}/embeddable-explorer.umd.production.min.js"></script>
<script>
  var endpointUrl = window.location.href;
  var embeddedExplorerConfig = ${getConfigStringForHtml(embeddedExplorerParams)};
  new window.EmbeddedExplorer({
    ...embeddedExplorerConfig,
    endpointUrl,
  });
</script>
`;
  };
  exports.getEmbeddedExplorerHTML = getEmbeddedExplorerHTML;
  var getEmbeddedSandboxHTML = (version, config) => {
    var _a, _b, _c, _d;
    return `
<div class="fallback">
  <h1>Welcome to Apollo Server</h1>
  <p>Apollo Sandbox cannot be loaded; it appears that you might be offline.</p>
</div>
<style>
  iframe {
    background-color: white;
  }
</style>
<div
style="width: 100vw; height: 100vh; position: absolute; top: 0;"
id="embeddableSandbox"
></div>
<script src="https://embeddable-sandbox.cdn.apollographql.com/${version}/embeddable-sandbox.umd.production.min.js"></script>
<script>
  var initialEndpoint = window.location.href;
  new window.EmbeddedSandbox({
    target: '#embeddableSandbox',
    initialEndpoint,
    includeCookies: ${(_a = config.includeCookies) !== null && _a !== undefined ? _a : "false"},
    initialState: ${getConfigStringForHtml({
      document: (_b = config.document) !== null && _b !== undefined ? _b : undefined,
      variables: (_c = config.variables) !== null && _c !== undefined ? _c : undefined,
      headers: (_d = config.headers) !== null && _d !== undefined ? _d : undefined
    })},
  });
</script>
`;
  };
  exports.getEmbeddedSandboxHTML = getEmbeddedSandboxHTML;
  var getNonEmbeddedLandingPageHTML = (version, config) => {
    const encodedConfig = encodeConfig(config);
    return `
 <div class="fallback">
  <h1>Welcome to Apollo Server</h1>
  <p>The full landing page cannot be loaded; it appears that you might be offline.</p>
</div>
<script>window.landingPage = ${encodedConfig};</script>
<script src="https://apollo-server-landing-page.cdn.apollographql.com/${version}/static/js/main.js"></script>`;
  };
  function ApolloServerPluginLandingPageDefault(maybeVersion, config) {
    const version = maybeVersion !== null && maybeVersion !== undefined ? maybeVersion : "_latest";
    return {
      __internal_installed_implicitly__: false,
      async serverWillStart() {
        return {
          async renderLandingPage() {
            const html = `
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link
      rel="icon"
      href="https://apollo-server-landing-page.cdn.apollographql.com/${version}/assets/favicon.png"
    />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <link rel="preconnect" href="https://fonts.gstatic.com" />
    <link
      href="https://fonts.googleapis.com/css2?family=Source+Sans+Pro&display=swap"
      rel="stylesheet"
    />
    <meta name="theme-color" content="#000000" />
    <meta name="description" content="Apollo server landing page" />
    <link
      rel="apple-touch-icon"
      href="https://apollo-server-landing-page.cdn.apollographql.com/${version}/assets/favicon.png"
    />
    <link
      rel="manifest"
      href="https://apollo-server-landing-page.cdn.apollographql.com/${version}/manifest.json"
    />
    <title>Apollo Server</title>
  </head>
  <body style="margin: 0; overflow-x: hidden; overflow-y: hidden">
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="react-root">
      <style>
        .fallback {
          opacity: 0;
          animation: fadeIn 1s 1s;
          animation-iteration-count: 1;
          animation-fill-mode: forwards;
          padding: 1em;
        }
        @keyframes fadeIn {
          0% {opacity:0;}
          100% {opacity:1; }
        }
      </style>
    ${config.embed ? "graphRef" in config && config.graphRef ? (0, exports.getEmbeddedExplorerHTML)(version, config) : (0, exports.getEmbeddedSandboxHTML)(version, config) : getNonEmbeddedLandingPageHTML(version, config)}
    </div>
  </body>
</html>
          `;
            return { html };
          }
        };
      }
    };
  }
});

// node_modules/cssfilter/lib/default.js
var require_default2 = __commonJS((exports) => {
  function getDefaultWhiteList() {
    var whiteList = {};
    whiteList["align-content"] = false;
    whiteList["align-items"] = false;
    whiteList["align-self"] = false;
    whiteList["alignment-adjust"] = false;
    whiteList["alignment-baseline"] = false;
    whiteList["all"] = false;
    whiteList["anchor-point"] = false;
    whiteList["animation"] = false;
    whiteList["animation-delay"] = false;
    whiteList["animation-direction"] = false;
    whiteList["animation-duration"] = false;
    whiteList["animation-fill-mode"] = false;
    whiteList["animation-iteration-count"] = false;
    whiteList["animation-name"] = false;
    whiteList["animation-play-state"] = false;
    whiteList["animation-timing-function"] = false;
    whiteList["azimuth"] = false;
    whiteList["backface-visibility"] = false;
    whiteList["background"] = true;
    whiteList["background-attachment"] = true;
    whiteList["background-clip"] = true;
    whiteList["background-color"] = true;
    whiteList["background-image"] = true;
    whiteList["background-origin"] = true;
    whiteList["background-position"] = true;
    whiteList["background-repeat"] = true;
    whiteList["background-size"] = true;
    whiteList["baseline-shift"] = false;
    whiteList["binding"] = false;
    whiteList["bleed"] = false;
    whiteList["bookmark-label"] = false;
    whiteList["bookmark-level"] = false;
    whiteList["bookmark-state"] = false;
    whiteList["border"] = true;
    whiteList["border-bottom"] = true;
    whiteList["border-bottom-color"] = true;
    whiteList["border-bottom-left-radius"] = true;
    whiteList["border-bottom-right-radius"] = true;
    whiteList["border-bottom-style"] = true;
    whiteList["border-bottom-width"] = true;
    whiteList["border-collapse"] = true;
    whiteList["border-color"] = true;
    whiteList["border-image"] = true;
    whiteList["border-image-outset"] = true;
    whiteList["border-image-repeat"] = true;
    whiteList["border-image-slice"] = true;
    whiteList["border-image-source"] = true;
    whiteList["border-image-width"] = true;
    whiteList["border-left"] = true;
    whiteList["border-left-color"] = true;
    whiteList["border-left-style"] = true;
    whiteList["border-left-width"] = true;
    whiteList["border-radius"] = true;
    whiteList["border-right"] = true;
    whiteList["border-right-color"] = true;
    whiteList["border-right-style"] = true;
    whiteList["border-right-width"] = true;
    whiteList["border-spacing"] = true;
    whiteList["border-style"] = true;
    whiteList["border-top"] = true;
    whiteList["border-top-color"] = true;
    whiteList["border-top-left-radius"] = true;
    whiteList["border-top-right-radius"] = true;
    whiteList["border-top-style"] = true;
    whiteList["border-top-width"] = true;
    whiteList["border-width"] = true;
    whiteList["bottom"] = false;
    whiteList["box-decoration-break"] = true;
    whiteList["box-shadow"] = true;
    whiteList["box-sizing"] = true;
    whiteList["box-snap"] = true;
    whiteList["box-suppress"] = true;
    whiteList["break-after"] = true;
    whiteList["break-before"] = true;
    whiteList["break-inside"] = true;
    whiteList["caption-side"] = false;
    whiteList["chains"] = false;
    whiteList["clear"] = true;
    whiteList["clip"] = false;
    whiteList["clip-path"] = false;
    whiteList["clip-rule"] = false;
    whiteList["color"] = true;
    whiteList["color-interpolation-filters"] = true;
    whiteList["column-count"] = false;
    whiteList["column-fill"] = false;
    whiteList["column-gap"] = false;
    whiteList["column-rule"] = false;
    whiteList["column-rule-color"] = false;
    whiteList["column-rule-style"] = false;
    whiteList["column-rule-width"] = false;
    whiteList["column-span"] = false;
    whiteList["column-width"] = false;
    whiteList["columns"] = false;
    whiteList["contain"] = false;
    whiteList["content"] = false;
    whiteList["counter-increment"] = false;
    whiteList["counter-reset"] = false;
    whiteList["counter-set"] = false;
    whiteList["crop"] = false;
    whiteList["cue"] = false;
    whiteList["cue-after"] = false;
    whiteList["cue-before"] = false;
    whiteList["cursor"] = false;
    whiteList["direction"] = false;
    whiteList["display"] = true;
    whiteList["display-inside"] = true;
    whiteList["display-list"] = true;
    whiteList["display-outside"] = true;
    whiteList["dominant-baseline"] = false;
    whiteList["elevation"] = false;
    whiteList["empty-cells"] = false;
    whiteList["filter"] = false;
    whiteList["flex"] = false;
    whiteList["flex-basis"] = false;
    whiteList["flex-direction"] = false;
    whiteList["flex-flow"] = false;
    whiteList["flex-grow"] = false;
    whiteList["flex-shrink"] = false;
    whiteList["flex-wrap"] = false;
    whiteList["float"] = false;
    whiteList["float-offset"] = false;
    whiteList["flood-color"] = false;
    whiteList["flood-opacity"] = false;
    whiteList["flow-from"] = false;
    whiteList["flow-into"] = false;
    whiteList["font"] = true;
    whiteList["font-family"] = true;
    whiteList["font-feature-settings"] = true;
    whiteList["font-kerning"] = true;
    whiteList["font-language-override"] = true;
    whiteList["font-size"] = true;
    whiteList["font-size-adjust"] = true;
    whiteList["font-stretch"] = true;
    whiteList["font-style"] = true;
    whiteList["font-synthesis"] = true;
    whiteList["font-variant"] = true;
    whiteList["font-variant-alternates"] = true;
    whiteList["font-variant-caps"] = true;
    whiteList["font-variant-east-asian"] = true;
    whiteList["font-variant-ligatures"] = true;
    whiteList["font-variant-numeric"] = true;
    whiteList["font-variant-position"] = true;
    whiteList["font-weight"] = true;
    whiteList["grid"] = false;
    whiteList["grid-area"] = false;
    whiteList["grid-auto-columns"] = false;
    whiteList["grid-auto-flow"] = false;
    whiteList["grid-auto-rows"] = false;
    whiteList["grid-column"] = false;
    whiteList["grid-column-end"] = false;
    whiteList["grid-column-start"] = false;
    whiteList["grid-row"] = false;
    whiteList["grid-row-end"] = false;
    whiteList["grid-row-start"] = false;
    whiteList["grid-template"] = false;
    whiteList["grid-template-areas"] = false;
    whiteList["grid-template-columns"] = false;
    whiteList["grid-template-rows"] = false;
    whiteList["hanging-punctuation"] = false;
    whiteList["height"] = true;
    whiteList["hyphens"] = false;
    whiteList["icon"] = false;
    whiteList["image-orientation"] = false;
    whiteList["image-resolution"] = false;
    whiteList["ime-mode"] = false;
    whiteList["initial-letters"] = false;
    whiteList["inline-box-align"] = false;
    whiteList["justify-content"] = false;
    whiteList["justify-items"] = false;
    whiteList["justify-self"] = false;
    whiteList["left"] = false;
    whiteList["letter-spacing"] = true;
    whiteList["lighting-color"] = true;
    whiteList["line-box-contain"] = false;
    whiteList["line-break"] = false;
    whiteList["line-grid"] = false;
    whiteList["line-height"] = false;
    whiteList["line-snap"] = false;
    whiteList["line-stacking"] = false;
    whiteList["line-stacking-ruby"] = false;
    whiteList["line-stacking-shift"] = false;
    whiteList["line-stacking-strategy"] = false;
    whiteList["list-style"] = true;
    whiteList["list-style-image"] = true;
    whiteList["list-style-position"] = true;
    whiteList["list-style-type"] = true;
    whiteList["margin"] = true;
    whiteList["margin-bottom"] = true;
    whiteList["margin-left"] = true;
    whiteList["margin-right"] = true;
    whiteList["margin-top"] = true;
    whiteList["marker-offset"] = false;
    whiteList["marker-side"] = false;
    whiteList["marks"] = false;
    whiteList["mask"] = false;
    whiteList["mask-box"] = false;
    whiteList["mask-box-outset"] = false;
    whiteList["mask-box-repeat"] = false;
    whiteList["mask-box-slice"] = false;
    whiteList["mask-box-source"] = false;
    whiteList["mask-box-width"] = false;
    whiteList["mask-clip"] = false;
    whiteList["mask-image"] = false;
    whiteList["mask-origin"] = false;
    whiteList["mask-position"] = false;
    whiteList["mask-repeat"] = false;
    whiteList["mask-size"] = false;
    whiteList["mask-source-type"] = false;
    whiteList["mask-type"] = false;
    whiteList["max-height"] = true;
    whiteList["max-lines"] = false;
    whiteList["max-width"] = true;
    whiteList["min-height"] = true;
    whiteList["min-width"] = true;
    whiteList["move-to"] = false;
    whiteList["nav-down"] = false;
    whiteList["nav-index"] = false;
    whiteList["nav-left"] = false;
    whiteList["nav-right"] = false;
    whiteList["nav-up"] = false;
    whiteList["object-fit"] = false;
    whiteList["object-position"] = false;
    whiteList["opacity"] = false;
    whiteList["order"] = false;
    whiteList["orphans"] = false;
    whiteList["outline"] = false;
    whiteList["outline-color"] = false;
    whiteList["outline-offset"] = false;
    whiteList["outline-style"] = false;
    whiteList["outline-width"] = false;
    whiteList["overflow"] = false;
    whiteList["overflow-wrap"] = false;
    whiteList["overflow-x"] = false;
    whiteList["overflow-y"] = false;
    whiteList["padding"] = true;
    whiteList["padding-bottom"] = true;
    whiteList["padding-left"] = true;
    whiteList["padding-right"] = true;
    whiteList["padding-top"] = true;
    whiteList["page"] = false;
    whiteList["page-break-after"] = false;
    whiteList["page-break-before"] = false;
    whiteList["page-break-inside"] = false;
    whiteList["page-policy"] = false;
    whiteList["pause"] = false;
    whiteList["pause-after"] = false;
    whiteList["pause-before"] = false;
    whiteList["perspective"] = false;
    whiteList["perspective-origin"] = false;
    whiteList["pitch"] = false;
    whiteList["pitch-range"] = false;
    whiteList["play-during"] = false;
    whiteList["position"] = false;
    whiteList["presentation-level"] = false;
    whiteList["quotes"] = false;
    whiteList["region-fragment"] = false;
    whiteList["resize"] = false;
    whiteList["rest"] = false;
    whiteList["rest-after"] = false;
    whiteList["rest-before"] = false;
    whiteList["richness"] = false;
    whiteList["right"] = false;
    whiteList["rotation"] = false;
    whiteList["rotation-point"] = false;
    whiteList["ruby-align"] = false;
    whiteList["ruby-merge"] = false;
    whiteList["ruby-position"] = false;
    whiteList["shape-image-threshold"] = false;
    whiteList["shape-outside"] = false;
    whiteList["shape-margin"] = false;
    whiteList["size"] = false;
    whiteList["speak"] = false;
    whiteList["speak-as"] = false;
    whiteList["speak-header"] = false;
    whiteList["speak-numeral"] = false;
    whiteList["speak-punctuation"] = false;
    whiteList["speech-rate"] = false;
    whiteList["stress"] = false;
    whiteList["string-set"] = false;
    whiteList["tab-size"] = false;
    whiteList["table-layout"] = false;
    whiteList["text-align"] = true;
    whiteList["text-align-last"] = true;
    whiteList["text-combine-upright"] = true;
    whiteList["text-decoration"] = true;
    whiteList["text-decoration-color"] = true;
    whiteList["text-decoration-line"] = true;
    whiteList["text-decoration-skip"] = true;
    whiteList["text-decoration-style"] = true;
    whiteList["text-emphasis"] = true;
    whiteList["text-emphasis-color"] = true;
    whiteList["text-emphasis-position"] = true;
    whiteList["text-emphasis-style"] = true;
    whiteList["text-height"] = true;
    whiteList["text-indent"] = true;
    whiteList["text-justify"] = true;
    whiteList["text-orientation"] = true;
    whiteList["text-overflow"] = true;
    whiteList["text-shadow"] = true;
    whiteList["text-space-collapse"] = true;
    whiteList["text-transform"] = true;
    whiteList["text-underline-position"] = true;
    whiteList["text-wrap"] = true;
    whiteList["top"] = false;
    whiteList["transform"] = false;
    whiteList["transform-origin"] = false;
    whiteList["transform-style"] = false;
    whiteList["transition"] = false;
    whiteList["transition-delay"] = false;
    whiteList["transition-duration"] = false;
    whiteList["transition-property"] = false;
    whiteList["transition-timing-function"] = false;
    whiteList["unicode-bidi"] = false;
    whiteList["vertical-align"] = false;
    whiteList["visibility"] = false;
    whiteList["voice-balance"] = false;
    whiteList["voice-duration"] = false;
    whiteList["voice-family"] = false;
    whiteList["voice-pitch"] = false;
    whiteList["voice-range"] = false;
    whiteList["voice-rate"] = false;
    whiteList["voice-stress"] = false;
    whiteList["voice-volume"] = false;
    whiteList["volume"] = false;
    whiteList["white-space"] = false;
    whiteList["widows"] = false;
    whiteList["width"] = true;
    whiteList["will-change"] = false;
    whiteList["word-break"] = true;
    whiteList["word-spacing"] = true;
    whiteList["word-wrap"] = true;
    whiteList["wrap-flow"] = false;
    whiteList["wrap-through"] = false;
    whiteList["writing-mode"] = false;
    whiteList["z-index"] = false;
    return whiteList;
  }
  function onAttr(name, value, options) {}
  function onIgnoreAttr(name, value, options) {}
  var REGEXP_URL_JAVASCRIPT = /javascript\s*\:/img;
  function safeAttrValue(name, value) {
    if (REGEXP_URL_JAVASCRIPT.test(value))
      return "";
    return value;
  }
  exports.whiteList = getDefaultWhiteList();
  exports.getDefaultWhiteList = getDefaultWhiteList;
  exports.onAttr = onAttr;
  exports.onIgnoreAttr = onIgnoreAttr;
  exports.safeAttrValue = safeAttrValue;
});

// node_modules/cssfilter/lib/util.js
var require_util = __commonJS((exports, module) => {
  module.exports = {
    indexOf: function(arr, item) {
      var i, j;
      if (Array.prototype.indexOf) {
        return arr.indexOf(item);
      }
      for (i = 0, j = arr.length;i < j; i++) {
        if (arr[i] === item) {
          return i;
        }
      }
      return -1;
    },
    forEach: function(arr, fn2, scope) {
      var i, j;
      if (Array.prototype.forEach) {
        return arr.forEach(fn2, scope);
      }
      for (i = 0, j = arr.length;i < j; i++) {
        fn2.call(scope, arr[i], i, arr);
      }
    },
    trim: function(str) {
      if (String.prototype.trim) {
        return str.trim();
      }
      return str.replace(/(^\s*)|(\s*$)/g, "");
    },
    trimRight: function(str) {
      if (String.prototype.trimRight) {
        return str.trimRight();
      }
      return str.replace(/(\s*$)/g, "");
    }
  };
});

// node_modules/cssfilter/lib/parser.js
var require_parser3 = __commonJS((exports, module) => {
  var _ = require_util();
  function parseStyle(css, onAttr) {
    css = _.trimRight(css);
    if (css[css.length - 1] !== ";")
      css += ";";
    var cssLength = css.length;
    var isParenthesisOpen = false;
    var lastPos = 0;
    var i = 0;
    var retCSS = "";
    function addNewAttr() {
      if (!isParenthesisOpen) {
        var source = _.trim(css.slice(lastPos, i));
        var j2 = source.indexOf(":");
        if (j2 !== -1) {
          var name = _.trim(source.slice(0, j2));
          var value = _.trim(source.slice(j2 + 1));
          if (name) {
            var ret = onAttr(lastPos, retCSS.length, name, value, source);
            if (ret)
              retCSS += ret + "; ";
          }
        }
      }
      lastPos = i + 1;
    }
    for (;i < cssLength; i++) {
      var c = css[i];
      if (c === "/" && css[i + 1] === "*") {
        var j = css.indexOf("*/", i + 2);
        if (j === -1)
          break;
        i = j + 1;
        lastPos = i + 1;
        isParenthesisOpen = false;
      } else if (c === "(") {
        isParenthesisOpen = true;
      } else if (c === ")") {
        isParenthesisOpen = false;
      } else if (c === ";") {
        if (isParenthesisOpen) {} else {
          addNewAttr();
        }
      } else if (c === `
`) {
        addNewAttr();
      }
    }
    return _.trim(retCSS);
  }
  module.exports = parseStyle;
});

// node_modules/cssfilter/lib/css.js
var require_css = __commonJS((exports, module) => {
  var DEFAULT = require_default2();
  var parseStyle = require_parser3();
  var _ = require_util();
  function isNull(obj) {
    return obj === undefined || obj === null;
  }
  function shallowCopyObject(obj) {
    var ret = {};
    for (var i in obj) {
      ret[i] = obj[i];
    }
    return ret;
  }
  function FilterCSS(options) {
    options = shallowCopyObject(options || {});
    options.whiteList = options.whiteList || DEFAULT.whiteList;
    options.onAttr = options.onAttr || DEFAULT.onAttr;
    options.onIgnoreAttr = options.onIgnoreAttr || DEFAULT.onIgnoreAttr;
    options.safeAttrValue = options.safeAttrValue || DEFAULT.safeAttrValue;
    this.options = options;
  }
  FilterCSS.prototype.process = function(css) {
    css = css || "";
    css = css.toString();
    if (!css)
      return "";
    var me = this;
    var options = me.options;
    var whiteList = options.whiteList;
    var onAttr = options.onAttr;
    var onIgnoreAttr = options.onIgnoreAttr;
    var safeAttrValue = options.safeAttrValue;
    var retCSS = parseStyle(css, function(sourcePosition, position, name, value, source) {
      var check = whiteList[name];
      var isWhite = false;
      if (check === true)
        isWhite = check;
      else if (typeof check === "function")
        isWhite = check(value);
      else if (check instanceof RegExp)
        isWhite = check.test(value);
      if (isWhite !== true)
        isWhite = false;
      value = safeAttrValue(name, value);
      if (!value)
        return;
      var opts = {
        position,
        sourcePosition,
        source,
        isWhite
      };
      if (isWhite) {
        var ret = onAttr(name, value, opts);
        if (isNull(ret)) {
          return name + ":" + value;
        } else {
          return ret;
        }
      } else {
        var ret = onIgnoreAttr(name, value, opts);
        if (!isNull(ret)) {
          return ret;
        }
      }
    });
    return retCSS;
  };
  module.exports = FilterCSS;
});

// node_modules/cssfilter/lib/index.js
var require_lib8 = __commonJS((exports, module) => {
  var DEFAULT = require_default2();
  var FilterCSS = require_css();
  function filterCSS(html, options) {
    var xss = new FilterCSS(options);
    return xss.process(html);
  }
  exports = module.exports = filterCSS;
  exports.FilterCSS = FilterCSS;
  for (i in DEFAULT)
    exports[i] = DEFAULT[i];
  var i;
  if (typeof window !== "undefined") {
    window.filterCSS = module.exports;
  }
});

// node_modules/xss/lib/util.js
var require_util2 = __commonJS((exports, module) => {
  module.exports = {
    indexOf: function(arr, item) {
      var i, j;
      if (Array.prototype.indexOf) {
        return arr.indexOf(item);
      }
      for (i = 0, j = arr.length;i < j; i++) {
        if (arr[i] === item) {
          return i;
        }
      }
      return -1;
    },
    forEach: function(arr, fn2, scope) {
      var i, j;
      if (Array.prototype.forEach) {
        return arr.forEach(fn2, scope);
      }
      for (i = 0, j = arr.length;i < j; i++) {
        fn2.call(scope, arr[i], i, arr);
      }
    },
    trim: function(str) {
      if (String.prototype.trim) {
        return str.trim();
      }
      return str.replace(/(^\s*)|(\s*$)/g, "");
    },
    spaceIndex: function(str) {
      var reg = /\s|\n|\t/;
      var match = reg.exec(str);
      return match ? match.index : -1;
    }
  };
});

// node_modules/xss/lib/default.js
var require_default3 = __commonJS((exports) => {
  var FilterCSS = require_lib8().FilterCSS;
  var getDefaultCSSWhiteList = require_lib8().getDefaultWhiteList;
  var _ = require_util2();
  function getDefaultWhiteList() {
    return {
      a: ["target", "href", "title"],
      abbr: ["title"],
      address: [],
      area: ["shape", "coords", "href", "alt"],
      article: [],
      aside: [],
      audio: [
        "autoplay",
        "controls",
        "crossorigin",
        "loop",
        "muted",
        "preload",
        "src"
      ],
      b: [],
      bdi: ["dir"],
      bdo: ["dir"],
      big: [],
      blockquote: ["cite"],
      br: [],
      caption: [],
      center: [],
      cite: [],
      code: [],
      col: ["align", "valign", "span", "width"],
      colgroup: ["align", "valign", "span", "width"],
      dd: [],
      del: ["datetime"],
      details: ["open"],
      div: [],
      dl: [],
      dt: [],
      em: [],
      figcaption: [],
      figure: [],
      font: ["color", "size", "face"],
      footer: [],
      h1: [],
      h2: [],
      h3: [],
      h4: [],
      h5: [],
      h6: [],
      header: [],
      hr: [],
      i: [],
      img: ["src", "alt", "title", "width", "height"],
      ins: ["datetime"],
      li: [],
      mark: [],
      nav: [],
      ol: [],
      p: [],
      pre: [],
      s: [],
      section: [],
      small: [],
      span: [],
      sub: [],
      summary: [],
      sup: [],
      strong: [],
      strike: [],
      table: ["width", "border", "align", "valign"],
      tbody: ["align", "valign"],
      td: ["width", "rowspan", "colspan", "align", "valign"],
      tfoot: ["align", "valign"],
      th: ["width", "rowspan", "colspan", "align", "valign"],
      thead: ["align", "valign"],
      tr: ["rowspan", "align", "valign"],
      tt: [],
      u: [],
      ul: [],
      video: [
        "autoplay",
        "controls",
        "crossorigin",
        "loop",
        "muted",
        "playsinline",
        "poster",
        "preload",
        "src",
        "height",
        "width"
      ]
    };
  }
  var defaultCSSFilter = new FilterCSS;
  function onTag(tag, html, options) {}
  function onIgnoreTag(tag, html, options) {}
  function onTagAttr(tag, name, value) {}
  function onIgnoreTagAttr(tag, name, value) {}
  function escapeHtml(html) {
    return html.replace(REGEXP_LT, "&lt;").replace(REGEXP_GT, "&gt;");
  }
  function safeAttrValue(tag, name, value, cssFilter) {
    value = friendlyAttrValue(value);
    if (name === "href" || name === "src") {
      value = _.trim(value);
      if (value === "#")
        return "#";
      if (!(value.substr(0, 7) === "http://" || value.substr(0, 8) === "https://" || value.substr(0, 7) === "mailto:" || value.substr(0, 4) === "tel:" || value.substr(0, 11) === "data:image/" || value.substr(0, 6) === "ftp://" || value.substr(0, 2) === "./" || value.substr(0, 3) === "../" || value[0] === "#" || value[0] === "/")) {
        return "";
      }
    } else if (name === "background") {
      REGEXP_DEFAULT_ON_TAG_ATTR_4.lastIndex = 0;
      if (REGEXP_DEFAULT_ON_TAG_ATTR_4.test(value)) {
        return "";
      }
    } else if (name === "style") {
      REGEXP_DEFAULT_ON_TAG_ATTR_7.lastIndex = 0;
      if (REGEXP_DEFAULT_ON_TAG_ATTR_7.test(value)) {
        return "";
      }
      REGEXP_DEFAULT_ON_TAG_ATTR_8.lastIndex = 0;
      if (REGEXP_DEFAULT_ON_TAG_ATTR_8.test(value)) {
        REGEXP_DEFAULT_ON_TAG_ATTR_4.lastIndex = 0;
        if (REGEXP_DEFAULT_ON_TAG_ATTR_4.test(value)) {
          return "";
        }
      }
      if (cssFilter !== false) {
        cssFilter = cssFilter || defaultCSSFilter;
        value = cssFilter.process(value);
      }
    }
    value = escapeAttrValue(value);
    return value;
  }
  var REGEXP_LT = /</g;
  var REGEXP_GT = />/g;
  var REGEXP_QUOTE = /"/g;
  var REGEXP_QUOTE_2 = /&quot;/g;
  var REGEXP_ATTR_VALUE_1 = /&#([a-zA-Z0-9]*);?/gim;
  var REGEXP_ATTR_VALUE_COLON = /&colon;?/gim;
  var REGEXP_ATTR_VALUE_NEWLINE = /&newline;?/gim;
  var REGEXP_DEFAULT_ON_TAG_ATTR_4 = /((j\s*a\s*v\s*a|v\s*b|l\s*i\s*v\s*e)\s*s\s*c\s*r\s*i\s*p\s*t\s*|m\s*o\s*c\s*h\s*a)\:/gi;
  var REGEXP_DEFAULT_ON_TAG_ATTR_7 = /e\s*x\s*p\s*r\s*e\s*s\s*s\s*i\s*o\s*n\s*\(.*/gi;
  var REGEXP_DEFAULT_ON_TAG_ATTR_8 = /u\s*r\s*l\s*\(.*/gi;
  function escapeQuote(str) {
    return str.replace(REGEXP_QUOTE, "&quot;");
  }
  function unescapeQuote(str) {
    return str.replace(REGEXP_QUOTE_2, '"');
  }
  function escapeHtmlEntities(str) {
    return str.replace(REGEXP_ATTR_VALUE_1, function replaceUnicode(str2, code) {
      return code[0] === "x" || code[0] === "X" ? String.fromCharCode(parseInt(code.substr(1), 16)) : String.fromCharCode(parseInt(code, 10));
    });
  }
  function escapeDangerHtml5Entities(str) {
    return str.replace(REGEXP_ATTR_VALUE_COLON, ":").replace(REGEXP_ATTR_VALUE_NEWLINE, " ");
  }
  function clearNonPrintableCharacter(str) {
    var str2 = "";
    for (var i = 0, len = str.length;i < len; i++) {
      str2 += str.charCodeAt(i) < 32 ? " " : str.charAt(i);
    }
    return _.trim(str2);
  }
  function friendlyAttrValue(str) {
    str = unescapeQuote(str);
    str = escapeHtmlEntities(str);
    str = escapeDangerHtml5Entities(str);
    str = clearNonPrintableCharacter(str);
    return str;
  }
  function escapeAttrValue(str) {
    str = escapeQuote(str);
    str = escapeHtml(str);
    return str;
  }
  function onIgnoreTagStripAll() {
    return "";
  }
  function StripTagBody(tags, next) {
    if (typeof next !== "function") {
      next = function() {};
    }
    var isRemoveAllTag = !Array.isArray(tags);
    function isRemoveTag(tag) {
      if (isRemoveAllTag)
        return true;
      return _.indexOf(tags, tag) !== -1;
    }
    var removeList = [];
    var posStart = false;
    return {
      onIgnoreTag: function(tag, html, options) {
        if (isRemoveTag(tag)) {
          if (options.isClosing) {
            var ret = "[/removed]";
            var end = options.position + ret.length;
            removeList.push([
              posStart !== false ? posStart : options.position,
              end
            ]);
            posStart = false;
            return ret;
          } else {
            if (!posStart) {
              posStart = options.position;
            }
            return "[removed]";
          }
        } else {
          return next(tag, html, options);
        }
      },
      remove: function(html) {
        var rethtml = "";
        var lastPos = 0;
        _.forEach(removeList, function(pos) {
          rethtml += html.slice(lastPos, pos[0]);
          lastPos = pos[1];
        });
        rethtml += html.slice(lastPos);
        return rethtml;
      }
    };
  }
  function stripCommentTag(html) {
    return html.replace(STRIP_COMMENT_TAG_REGEXP, "");
  }
  var STRIP_COMMENT_TAG_REGEXP = /<!--[\s\S]*?-->/g;
  function stripBlankChar(html) {
    var chars = html.split("");
    chars = chars.filter(function(char) {
      var c = char.charCodeAt(0);
      if (c === 127)
        return false;
      if (c <= 31) {
        if (c === 10 || c === 13)
          return true;
        return false;
      }
      return true;
    });
    return chars.join("");
  }
  exports.whiteList = getDefaultWhiteList();
  exports.getDefaultWhiteList = getDefaultWhiteList;
  exports.onTag = onTag;
  exports.onIgnoreTag = onIgnoreTag;
  exports.onTagAttr = onTagAttr;
  exports.onIgnoreTagAttr = onIgnoreTagAttr;
  exports.safeAttrValue = safeAttrValue;
  exports.escapeHtml = escapeHtml;
  exports.escapeQuote = escapeQuote;
  exports.unescapeQuote = unescapeQuote;
  exports.escapeHtmlEntities = escapeHtmlEntities;
  exports.escapeDangerHtml5Entities = escapeDangerHtml5Entities;
  exports.clearNonPrintableCharacter = clearNonPrintableCharacter;
  exports.friendlyAttrValue = friendlyAttrValue;
  exports.escapeAttrValue = escapeAttrValue;
  exports.onIgnoreTagStripAll = onIgnoreTagStripAll;
  exports.StripTagBody = StripTagBody;
  exports.stripCommentTag = stripCommentTag;
  exports.stripBlankChar = stripBlankChar;
  exports.cssFilter = defaultCSSFilter;
  exports.getDefaultCSSWhiteList = getDefaultCSSWhiteList;
});

// node_modules/xss/lib/parser.js
var require_parser4 = __commonJS((exports) => {
  var _ = require_util2();
  function getTagName(html) {
    var i = _.spaceIndex(html);
    if (i === -1) {
      var tagName = html.slice(1, -1);
    } else {
      var tagName = html.slice(1, i + 1);
    }
    tagName = _.trim(tagName).toLowerCase();
    if (tagName.slice(0, 1) === "/")
      tagName = tagName.slice(1);
    if (tagName.slice(-1) === "/")
      tagName = tagName.slice(0, -1);
    return tagName;
  }
  function isClosing(html) {
    return html.slice(0, 2) === "</";
  }
  function parseTag(html, onTag, escapeHtml) {
    var rethtml = "";
    var lastPos = 0;
    var tagStart = false;
    var quoteStart = false;
    var currentPos = 0;
    var len = html.length;
    var currentTagName = "";
    var currentHtml = "";
    chariterator:
      for (currentPos = 0;currentPos < len; currentPos++) {
        var c = html.charAt(currentPos);
        if (tagStart === false) {
          if (c === "<") {
            tagStart = currentPos;
            continue;
          }
        } else {
          if (quoteStart === false) {
            if (c === "<") {
              rethtml += escapeHtml(html.slice(lastPos, currentPos));
              tagStart = currentPos;
              lastPos = currentPos;
              continue;
            }
            if (c === ">") {
              rethtml += escapeHtml(html.slice(lastPos, tagStart));
              currentHtml = html.slice(tagStart, currentPos + 1);
              currentTagName = getTagName(currentHtml);
              rethtml += onTag(tagStart, rethtml.length, currentTagName, currentHtml, isClosing(currentHtml));
              lastPos = currentPos + 1;
              tagStart = false;
              continue;
            }
            if (c === '"' || c === "'") {
              var i = 1;
              var ic = html.charAt(currentPos - i);
              while (ic.trim() === "" || ic === "=") {
                if (ic === "=") {
                  quoteStart = c;
                  continue chariterator;
                }
                ic = html.charAt(currentPos - ++i);
              }
            }
          } else {
            if (c === quoteStart) {
              quoteStart = false;
              continue;
            }
          }
        }
      }
    if (lastPos < html.length) {
      rethtml += escapeHtml(html.substr(lastPos));
    }
    return rethtml;
  }
  var REGEXP_ILLEGAL_ATTR_NAME = /[^a-zA-Z0-9_:\.\-]/gim;
  function parseAttr(html, onAttr) {
    var lastPos = 0;
    var retAttrs = [];
    var tmpName = false;
    var len = html.length;
    function addAttr(name, value) {
      name = _.trim(name);
      name = name.replace(REGEXP_ILLEGAL_ATTR_NAME, "").toLowerCase();
      if (name.length < 1)
        return;
      var ret = onAttr(name, value || "");
      if (ret)
        retAttrs.push(ret);
    }
    for (var i = 0;i < len; i++) {
      var c = html.charAt(i);
      var v, j;
      if (tmpName === false && c === "=") {
        tmpName = html.slice(lastPos, i);
        lastPos = i + 1;
        continue;
      }
      if (tmpName !== false) {
        if (i === lastPos && (c === '"' || c === "'") && html.charAt(i - 1) === "=") {
          j = html.indexOf(c, i + 1);
          if (j === -1) {
            break;
          } else {
            v = _.trim(html.slice(lastPos + 1, j));
            addAttr(tmpName, v);
            tmpName = false;
            i = j;
            lastPos = i + 1;
            continue;
          }
        }
      }
      if (/\s|\n|\t/.test(c)) {
        html = html.replace(/\s|\n|\t/g, " ");
        if (tmpName === false) {
          j = findNextEqual(html, i);
          if (j === -1) {
            v = _.trim(html.slice(lastPos, i));
            addAttr(v);
            tmpName = false;
            lastPos = i + 1;
            continue;
          } else {
            i = j - 1;
            continue;
          }
        } else {
          j = findBeforeEqual(html, i - 1);
          if (j === -1) {
            v = _.trim(html.slice(lastPos, i));
            v = stripQuoteWrap(v);
            addAttr(tmpName, v);
            tmpName = false;
            lastPos = i + 1;
            continue;
          } else {
            continue;
          }
        }
      }
    }
    if (lastPos < html.length) {
      if (tmpName === false) {
        addAttr(html.slice(lastPos));
      } else {
        addAttr(tmpName, stripQuoteWrap(_.trim(html.slice(lastPos))));
      }
    }
    return _.trim(retAttrs.join(" "));
  }
  function findNextEqual(str, i) {
    for (;i < str.length; i++) {
      var c = str[i];
      if (c === " ")
        continue;
      if (c === "=")
        return i;
      return -1;
    }
  }
  function findBeforeEqual(str, i) {
    for (;i > 0; i--) {
      var c = str[i];
      if (c === " ")
        continue;
      if (c === "=")
        return i;
      return -1;
    }
  }
  function isQuoteWrapString(text) {
    if (text[0] === '"' && text[text.length - 1] === '"' || text[0] === "'" && text[text.length - 1] === "'") {
      return true;
    } else {
      return false;
    }
  }
  function stripQuoteWrap(text) {
    if (isQuoteWrapString(text)) {
      return text.substr(1, text.length - 2);
    } else {
      return text;
    }
  }
  exports.parseTag = parseTag;
  exports.parseAttr = parseAttr;
});

// node_modules/xss/lib/xss.js
var require_xss = __commonJS((exports, module) => {
  var FilterCSS = require_lib8().FilterCSS;
  var DEFAULT = require_default3();
  var parser = require_parser4();
  var parseTag = parser.parseTag;
  var parseAttr = parser.parseAttr;
  var _ = require_util2();
  function isNull(obj) {
    return obj === undefined || obj === null;
  }
  function getAttrs(html) {
    var i = _.spaceIndex(html);
    if (i === -1) {
      return {
        html: "",
        closing: html[html.length - 2] === "/"
      };
    }
    html = _.trim(html.slice(i + 1, -1));
    var isClosing = html[html.length - 1] === "/";
    if (isClosing)
      html = _.trim(html.slice(0, -1));
    return {
      html,
      closing: isClosing
    };
  }
  function shallowCopyObject(obj) {
    var ret = {};
    for (var i in obj) {
      ret[i] = obj[i];
    }
    return ret;
  }
  function FilterXSS(options) {
    options = shallowCopyObject(options || {});
    if (options.stripIgnoreTag) {
      if (options.onIgnoreTag) {
        console.error('Notes: cannot use these two options "stripIgnoreTag" and "onIgnoreTag" at the same time');
      }
      options.onIgnoreTag = DEFAULT.onIgnoreTagStripAll;
    }
    options.whiteList = options.whiteList || DEFAULT.whiteList;
    options.onTag = options.onTag || DEFAULT.onTag;
    options.onTagAttr = options.onTagAttr || DEFAULT.onTagAttr;
    options.onIgnoreTag = options.onIgnoreTag || DEFAULT.onIgnoreTag;
    options.onIgnoreTagAttr = options.onIgnoreTagAttr || DEFAULT.onIgnoreTagAttr;
    options.safeAttrValue = options.safeAttrValue || DEFAULT.safeAttrValue;
    options.escapeHtml = options.escapeHtml || DEFAULT.escapeHtml;
    this.options = options;
    if (options.css === false) {
      this.cssFilter = false;
    } else {
      options.css = options.css || {};
      this.cssFilter = new FilterCSS(options.css);
    }
  }
  FilterXSS.prototype.process = function(html) {
    html = html || "";
    html = html.toString();
    if (!html)
      return "";
    var me = this;
    var options = me.options;
    var whiteList = options.whiteList;
    var onTag = options.onTag;
    var onIgnoreTag = options.onIgnoreTag;
    var onTagAttr = options.onTagAttr;
    var onIgnoreTagAttr = options.onIgnoreTagAttr;
    var safeAttrValue = options.safeAttrValue;
    var escapeHtml = options.escapeHtml;
    var cssFilter = me.cssFilter;
    if (options.stripBlankChar) {
      html = DEFAULT.stripBlankChar(html);
    }
    if (!options.allowCommentTag) {
      html = DEFAULT.stripCommentTag(html);
    }
    var stripIgnoreTagBody = false;
    if (options.stripIgnoreTagBody) {
      var stripIgnoreTagBody = DEFAULT.StripTagBody(options.stripIgnoreTagBody, onIgnoreTag);
      onIgnoreTag = stripIgnoreTagBody.onIgnoreTag;
    }
    var retHtml = parseTag(html, function(sourcePosition, position, tag, html2, isClosing) {
      var info = {
        sourcePosition,
        position,
        isClosing,
        isWhite: whiteList.hasOwnProperty(tag)
      };
      var ret = onTag(tag, html2, info);
      if (!isNull(ret))
        return ret;
      if (info.isWhite) {
        if (info.isClosing) {
          return "</" + tag + ">";
        }
        var attrs = getAttrs(html2);
        var whiteAttrList = whiteList[tag];
        var attrsHtml = parseAttr(attrs.html, function(name, value) {
          var isWhiteAttr = _.indexOf(whiteAttrList, name) !== -1;
          var ret2 = onTagAttr(tag, name, value, isWhiteAttr);
          if (!isNull(ret2))
            return ret2;
          if (isWhiteAttr) {
            value = safeAttrValue(tag, name, value, cssFilter);
            if (value) {
              return name + '="' + value + '"';
            } else {
              return name;
            }
          } else {
            var ret2 = onIgnoreTagAttr(tag, name, value, isWhiteAttr);
            if (!isNull(ret2))
              return ret2;
            return;
          }
        });
        var html2 = "<" + tag;
        if (attrsHtml)
          html2 += " " + attrsHtml;
        if (attrs.closing)
          html2 += " /";
        html2 += ">";
        return html2;
      } else {
        var ret = onIgnoreTag(tag, html2, info);
        if (!isNull(ret))
          return ret;
        return escapeHtml(html2);
      }
    }, escapeHtml);
    if (stripIgnoreTagBody) {
      retHtml = stripIgnoreTagBody.remove(retHtml);
    }
    return retHtml;
  };
  module.exports = FilterXSS;
});

// node_modules/xss/lib/index.js
var require_lib9 = __commonJS((exports, module) => {
  var DEFAULT = require_default3();
  var parser = require_parser4();
  var FilterXSS = require_xss();
  function filterXSS(html, options) {
    var xss = new FilterXSS(options);
    return xss.process(html);
  }
  exports = module.exports = filterXSS;
  exports.filterXSS = filterXSS;
  exports.FilterXSS = FilterXSS;
  for (i in DEFAULT)
    exports[i] = DEFAULT[i];
  var i;
  for (i in parser)
    exports[i] = parser[i];
  var i;
  if (typeof window !== "undefined") {
    window.filterXSS = module.exports;
  }
  function isWorkerEnv() {
    return typeof self !== "undefined" && typeof DedicatedWorkerGlobalScope !== "undefined" && self instanceof DedicatedWorkerGlobalScope;
  }
  if (isWorkerEnv()) {
    self.filterXSS = module.exports;
  }
});

// node_modules/@apollographql/graphql-playground-html/dist/get-loading-markup.js
var require_get_loading_markup = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var getLoadingMarkup = function() {
    return {
      script: `
    const loadingWrapper = document.getElementById('loading-wrapper');
    if (loadingWrapper) {
      loadingWrapper.classList.add('fadeOut');
    }
    `,
      container: `
<style type="text/css">
.fadeOut {
  -webkit-animation: fadeOut 0.5s ease-out forwards;
  animation: fadeOut 0.5s ease-out forwards;
}

@-webkit-keyframes fadeIn {
  from {
    opacity: 0;
    -webkit-transform: translateY(-10px);
    -ms-transform: translateY(-10px);
    transform: translateY(-10px);
  }
  to {
    opacity: 1;
    -webkit-transform: translateY(0);
    -ms-transform: translateY(0);
    transform: translateY(0);
  }
}

@keyframes fadeIn {
  from {
    opacity: 0;
    -webkit-transform: translateY(-10px);
    -ms-transform: translateY(-10px);
    transform: translateY(-10px);
  }
  to {
    opacity: 1;
    -webkit-transform: translateY(0);
    -ms-transform: translateY(0);
    transform: translateY(0);
  }
}

@-webkit-keyframes fadeOut {
  from {
    opacity: 1;
    -webkit-transform: translateY(0);
    -ms-transform: translateY(0);
    transform: translateY(0);
  }
  to {
    opacity: 0;
    -webkit-transform: translateY(-10px);
    -ms-transform: translateY(-10px);
    transform: translateY(-10px);
  }
}

@keyframes fadeOut {
  from {
    opacity: 1;
    -webkit-transform: translateY(0);
    -ms-transform: translateY(0);
    transform: translateY(0);
  }
  to {
    opacity: 0;
    -webkit-transform: translateY(-10px);
    -ms-transform: translateY(-10px);
    transform: translateY(-10px);
  }
}

@-webkit-keyframes appearIn {
  from {
    opacity: 0;
    -webkit-transform: translateY(0px);
    -ms-transform: translateY(0px);
    transform: translateY(0px);
  }
  to {
    opacity: 1;
    -webkit-transform: translateY(0);
    -ms-transform: translateY(0);
    transform: translateY(0);
  }
}

@keyframes appearIn {
  from {
    opacity: 0;
    -webkit-transform: translateY(0px);
    -ms-transform: translateY(0px);
    transform: translateY(0px);
  }
  to {
    opacity: 1;
    -webkit-transform: translateY(0);
    -ms-transform: translateY(0);
    transform: translateY(0);
  }
}

@-webkit-keyframes scaleIn {
  from {
    -webkit-transform: scale(0);
    -ms-transform: scale(0);
    transform: scale(0);
  }
  to {
    -webkit-transform: scale(1);
    -ms-transform: scale(1);
    transform: scale(1);
  }
}

@keyframes scaleIn {
  from {
    -webkit-transform: scale(0);
    -ms-transform: scale(0);
    transform: scale(0);
  }
  to {
    -webkit-transform: scale(1);
    -ms-transform: scale(1);
    transform: scale(1);
  }
}

@-webkit-keyframes innerDrawIn {
  0% {
    stroke-dashoffset: 70;
  }
  50% {
    stroke-dashoffset: 140;
  }
  100% {
    stroke-dashoffset: 210;
  }
}

@keyframes innerDrawIn {
  0% {
    stroke-dashoffset: 70;
  }
  50% {
    stroke-dashoffset: 140;
  }
  100% {
    stroke-dashoffset: 210;
  }
}

@-webkit-keyframes outerDrawIn {
  0% {
    stroke-dashoffset: 76;
  }
  100% {
    stroke-dashoffset: 152;
  }
}

@keyframes outerDrawIn {
  0% {
    stroke-dashoffset: 76;
  }
  100% {
    stroke-dashoffset: 152;
  }
}

.hHWjkv {
  -webkit-transform-origin: 0px 0px;
  -ms-transform-origin: 0px 0px;
  transform-origin: 0px 0px;
  -webkit-transform: scale(0);
  -ms-transform: scale(0);
  transform: scale(0);
  -webkit-animation: scaleIn 0.25s linear forwards 0.2222222222222222s;
  animation: scaleIn 0.25s linear forwards 0.2222222222222222s;
}

.gCDOzd {
  -webkit-transform-origin: 0px 0px;
  -ms-transform-origin: 0px 0px;
  transform-origin: 0px 0px;
  -webkit-transform: scale(0);
  -ms-transform: scale(0);
  transform: scale(0);
  -webkit-animation: scaleIn 0.25s linear forwards 0.4222222222222222s;
  animation: scaleIn 0.25s linear forwards 0.4222222222222222s;
}

.hmCcxi {
  -webkit-transform-origin: 0px 0px;
  -ms-transform-origin: 0px 0px;
  transform-origin: 0px 0px;
  -webkit-transform: scale(0);
  -ms-transform: scale(0);
  transform: scale(0);
  -webkit-animation: scaleIn 0.25s linear forwards 0.6222222222222222s;
  animation: scaleIn 0.25s linear forwards 0.6222222222222222s;
}

.eHamQi {
  -webkit-transform-origin: 0px 0px;
  -ms-transform-origin: 0px 0px;
  transform-origin: 0px 0px;
  -webkit-transform: scale(0);
  -ms-transform: scale(0);
  transform: scale(0);
  -webkit-animation: scaleIn 0.25s linear forwards 0.8222222222222223s;
  animation: scaleIn 0.25s linear forwards 0.8222222222222223s;
}

.byhgGu {
  -webkit-transform-origin: 0px 0px;
  -ms-transform-origin: 0px 0px;
  transform-origin: 0px 0px;
  -webkit-transform: scale(0);
  -ms-transform: scale(0);
  transform: scale(0);
  -webkit-animation: scaleIn 0.25s linear forwards 1.0222222222222221s;
  animation: scaleIn 0.25s linear forwards 1.0222222222222221s;
}

.llAKP {
  -webkit-transform-origin: 0px 0px;
  -ms-transform-origin: 0px 0px;
  transform-origin: 0px 0px;
  -webkit-transform: scale(0);
  -ms-transform: scale(0);
  transform: scale(0);
  -webkit-animation: scaleIn 0.25s linear forwards 1.2222222222222223s;
  animation: scaleIn 0.25s linear forwards 1.2222222222222223s;
}

.bglIGM {
  -webkit-transform-origin: 64px 28px;
  -ms-transform-origin: 64px 28px;
  transform-origin: 64px 28px;
  -webkit-transform: scale(0);
  -ms-transform: scale(0);
  transform: scale(0);
  -webkit-animation: scaleIn 0.25s linear forwards 0.2222222222222222s;
  animation: scaleIn 0.25s linear forwards 0.2222222222222222s;
}

.ksxRII {
  -webkit-transform-origin: 95.98500061035156px 46.510000228881836px;
  -ms-transform-origin: 95.98500061035156px 46.510000228881836px;
  transform-origin: 95.98500061035156px 46.510000228881836px;
  -webkit-transform: scale(0);
  -ms-transform: scale(0);
  transform: scale(0);
  -webkit-animation: scaleIn 0.25s linear forwards 0.4222222222222222s;
  animation: scaleIn 0.25s linear forwards 0.4222222222222222s;
}

.cWrBmb {
  -webkit-transform-origin: 95.97162628173828px 83.4900016784668px;
  -ms-transform-origin: 95.97162628173828px 83.4900016784668px;
  transform-origin: 95.97162628173828px 83.4900016784668px;
  -webkit-transform: scale(0);
  -ms-transform: scale(0);
  transform: scale(0);
  -webkit-animation: scaleIn 0.25s linear forwards 0.6222222222222222s;
  animation: scaleIn 0.25s linear forwards 0.6222222222222222s;
}

.Wnusb {
  -webkit-transform-origin: 64px 101.97999572753906px;
  -ms-transform-origin: 64px 101.97999572753906px;
  transform-origin: 64px 101.97999572753906px;
  -webkit-transform: scale(0);
  -ms-transform: scale(0);
  transform: scale(0);
  -webkit-animation: scaleIn 0.25s linear forwards 0.8222222222222223s;
  animation: scaleIn 0.25s linear forwards 0.8222222222222223s;
}

.bfPqf {
  -webkit-transform-origin: 32.03982162475586px 83.4900016784668px;
  -ms-transform-origin: 32.03982162475586px 83.4900016784668px;
  transform-origin: 32.03982162475586px 83.4900016784668px;
  -webkit-transform: scale(0);
  -ms-transform: scale(0);
  transform: scale(0);
  -webkit-animation: scaleIn 0.25s linear forwards 1.0222222222222221s;
  animation: scaleIn 0.25s linear forwards 1.0222222222222221s;
}

.edRCTN {
  -webkit-transform-origin: 32.033552169799805px 46.510000228881836px;
  -ms-transform-origin: 32.033552169799805px 46.510000228881836px;
  transform-origin: 32.033552169799805px 46.510000228881836px;
  -webkit-transform: scale(0);
  -ms-transform: scale(0);
  transform: scale(0);
  -webkit-animation: scaleIn 0.25s linear forwards 1.2222222222222223s;
  animation: scaleIn 0.25s linear forwards 1.2222222222222223s;
}

.iEGVWn {
  opacity: 0;
  stroke-dasharray: 76;
  -webkit-animation: outerDrawIn 0.5s ease-out forwards 0.3333333333333333s, appearIn 0.1s ease-out forwards 0.3333333333333333s;
  animation: outerDrawIn 0.5s ease-out forwards 0.3333333333333333s, appearIn 0.1s ease-out forwards 0.3333333333333333s;
  -webkit-animation-iteration-count: 1, 1;
  animation-iteration-count: 1, 1;
}

.bsocdx {
  opacity: 0;
  stroke-dasharray: 76;
  -webkit-animation: outerDrawIn 0.5s ease-out forwards 0.5333333333333333s, appearIn 0.1s ease-out forwards 0.5333333333333333s;
  animation: outerDrawIn 0.5s ease-out forwards 0.5333333333333333s, appearIn 0.1s ease-out forwards 0.5333333333333333s;
  -webkit-animation-iteration-count: 1, 1;
  animation-iteration-count: 1, 1;
}

.jAZXmP {
  opacity: 0;
  stroke-dasharray: 76;
  -webkit-animation: outerDrawIn 0.5s ease-out forwards 0.7333333333333334s, appearIn 0.1s ease-out forwards 0.7333333333333334s;
  animation: outerDrawIn 0.5s ease-out forwards 0.7333333333333334s, appearIn 0.1s ease-out forwards 0.7333333333333334s;
  -webkit-animation-iteration-count: 1, 1;
  animation-iteration-count: 1, 1;
}

.hSeArx {
  opacity: 0;
  stroke-dasharray: 76;
  -webkit-animation: outerDrawIn 0.5s ease-out forwards 0.9333333333333333s, appearIn 0.1s ease-out forwards 0.9333333333333333s;
  animation: outerDrawIn 0.5s ease-out forwards 0.9333333333333333s, appearIn 0.1s ease-out forwards 0.9333333333333333s;
  -webkit-animation-iteration-count: 1, 1;
  animation-iteration-count: 1, 1;
}

.bVgqGk {
  opacity: 0;
  stroke-dasharray: 76;
  -webkit-animation: outerDrawIn 0.5s ease-out forwards 1.1333333333333333s, appearIn 0.1s ease-out forwards 1.1333333333333333s;
  animation: outerDrawIn 0.5s ease-out forwards 1.1333333333333333s, appearIn 0.1s ease-out forwards 1.1333333333333333s;
  -webkit-animation-iteration-count: 1, 1;
  animation-iteration-count: 1, 1;
}

.hEFqBt {
  opacity: 0;
  stroke-dasharray: 76;
  -webkit-animation: outerDrawIn 0.5s ease-out forwards 1.3333333333333333s, appearIn 0.1s ease-out forwards 1.3333333333333333s;
  animation: outerDrawIn 0.5s ease-out forwards 1.3333333333333333s, appearIn 0.1s ease-out forwards 1.3333333333333333s;
  -webkit-animation-iteration-count: 1, 1;
  animation-iteration-count: 1, 1;
}

.dzEKCM {
  opacity: 0;
  stroke-dasharray: 70;
  -webkit-animation: innerDrawIn 1s ease-in-out forwards 1.3666666666666667s, appearIn 0.1s linear forwards 1.3666666666666667s;
  animation: innerDrawIn 1s ease-in-out forwards 1.3666666666666667s, appearIn 0.1s linear forwards 1.3666666666666667s;
  -webkit-animation-iteration-count: infinite, 1;
  animation-iteration-count: infinite, 1;
}

.DYnPx {
  opacity: 0;
  stroke-dasharray: 70;
  -webkit-animation: innerDrawIn 1s ease-in-out forwards 1.5333333333333332s, appearIn 0.1s linear forwards 1.5333333333333332s;
  animation: innerDrawIn 1s ease-in-out forwards 1.5333333333333332s, appearIn 0.1s linear forwards 1.5333333333333332s;
  -webkit-animation-iteration-count: infinite, 1;
  animation-iteration-count: infinite, 1;
}

.hjPEAQ {
  opacity: 0;
  stroke-dasharray: 70;
  -webkit-animation: innerDrawIn 1s ease-in-out forwards 1.7000000000000002s, appearIn 0.1s linear forwards 1.7000000000000002s;
  animation: innerDrawIn 1s ease-in-out forwards 1.7000000000000002s, appearIn 0.1s linear forwards 1.7000000000000002s;
  -webkit-animation-iteration-count: infinite, 1;
  animation-iteration-count: infinite, 1;
}

#loading-wrapper {
  position: absolute;
  width: 100vw;
  height: 100vh;
  display: -webkit-box;
  display: -webkit-flex;
  display: -ms-flexbox;
  display: flex;
  -webkit-align-items: center;
  -webkit-box-align: center;
  -ms-flex-align: center;
  align-items: center;
  -webkit-box-pack: center;
  -webkit-justify-content: center;
  -ms-flex-pack: center;
  justify-content: center;
  -webkit-flex-direction: column;
  -ms-flex-direction: column;
  flex-direction: column;
}

.logo {
  width: 75px;
  height: 75px;
  margin-bottom: 20px;
  opacity: 0;
  -webkit-animation: fadeIn 0.5s ease-out forwards;
  animation: fadeIn 0.5s ease-out forwards;
}

.text {
  font-size: 32px;
  font-weight: 200;
  text-align: center;
  color: rgba(255, 255, 255, 0.6);
  opacity: 0;
  -webkit-animation: fadeIn 0.5s ease-out forwards;
  animation: fadeIn 0.5s ease-out forwards;
}

.dGfHfc {
  font-weight: 400;
}
</style>
<div id="loading-wrapper">
<svg class="logo" viewBox="0 0 128 128" xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>GraphQL Playground Logo</title>
  <defs>
    <linearGradient id="linearGradient-1" x1="4.86%" x2="96.21%" y1="0%" y2="99.66%">
      <stop stop-color="#E00082" stop-opacity=".8" offset="0%"></stop>
      <stop stop-color="#E00082" offset="100%"></stop>
    </linearGradient>
  </defs>
  <g>
    <rect id="Gradient" width="127.96" height="127.96" y="1" fill="url(#linearGradient-1)" rx="4"></rect>
    <path id="Border" fill="#E00082" fill-rule="nonzero" d="M4.7 2.84c-1.58 0-2.86 1.28-2.86 2.85v116.57c0 1.57 1.28 2.84 2.85 2.84h116.57c1.57 0 2.84-1.26 2.84-2.83V5.67c0-1.55-1.26-2.83-2.83-2.83H4.67zM4.7 0h116.58c3.14 0 5.68 2.55 5.68 5.7v116.58c0 3.14-2.54 5.68-5.68 5.68H4.68c-3.13 0-5.68-2.54-5.68-5.68V5.68C-1 2.56 1.55 0 4.7 0z"></path>
    <path class="bglIGM" x="64" y="28" fill="#fff" d="M64 36c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8" style="transform: translate(100px, 100px);"></path>
    <path class="ksxRII" x="95.98500061035156" y="46.510000228881836" fill="#fff" d="M89.04 50.52c-2.2-3.84-.9-8.73 2.94-10.96 3.83-2.2 8.72-.9 10.95 2.94 2.2 3.84.9 8.73-2.94 10.96-3.85 2.2-8.76.9-10.97-2.94"
      style="transform: translate(100px, 100px);"></path>
    <path class="cWrBmb" x="95.97162628173828" y="83.4900016784668" fill="#fff" d="M102.9 87.5c-2.2 3.84-7.1 5.15-10.94 2.94-3.84-2.2-5.14-7.12-2.94-10.96 2.2-3.84 7.12-5.15 10.95-2.94 3.86 2.23 5.16 7.12 2.94 10.96"
      style="transform: translate(100px, 100px);"></path>
    <path class="Wnusb" x="64" y="101.97999572753906" fill="#fff" d="M64 110c-4.43 0-8-3.6-8-8.02 0-4.44 3.57-8.02 8-8.02s8 3.58 8 8.02c0 4.4-3.57 8.02-8 8.02"
      style="transform: translate(100px, 100px);"></path>
    <path class="bfPqf" x="32.03982162475586" y="83.4900016784668" fill="#fff" d="M25.1 87.5c-2.2-3.84-.9-8.73 2.93-10.96 3.83-2.2 8.72-.9 10.95 2.94 2.2 3.84.9 8.73-2.94 10.96-3.85 2.2-8.74.9-10.95-2.94"
      style="transform: translate(100px, 100px);"></path>
    <path class="edRCTN" x="32.033552169799805" y="46.510000228881836" fill="#fff" d="M38.96 50.52c-2.2 3.84-7.12 5.15-10.95 2.94-3.82-2.2-5.12-7.12-2.92-10.96 2.2-3.84 7.12-5.15 10.95-2.94 3.83 2.23 5.14 7.12 2.94 10.96"
      style="transform: translate(100px, 100px);"></path>
    <path class="iEGVWn" stroke="#fff" stroke-width="4" stroke-linecap="round" stroke-linejoin="round" d="M63.55 27.5l32.9 19-32.9-19z"></path>
    <path class="bsocdx" stroke="#fff" stroke-width="4" stroke-linecap="round" stroke-linejoin="round" d="M96 46v38-38z"></path>
    <path class="jAZXmP" stroke="#fff" stroke-width="4" stroke-linecap="round" stroke-linejoin="round" d="M96.45 84.5l-32.9 19 32.9-19z"></path>
    <path class="hSeArx" stroke="#fff" stroke-width="4" stroke-linecap="round" stroke-linejoin="round" d="M64.45 103.5l-32.9-19 32.9 19z"></path>
    <path class="bVgqGk" stroke="#fff" stroke-width="4" stroke-linecap="round" stroke-linejoin="round" d="M32 84V46v38z"></path>
    <path class="hEFqBt" stroke="#fff" stroke-width="4" stroke-linecap="round" stroke-linejoin="round" d="M31.55 46.5l32.9-19-32.9 19z"></path>
    <path class="dzEKCM" id="Triangle-Bottom" stroke="#fff" stroke-width="4" d="M30 84h70" stroke-linecap="round"></path>
    <path class="DYnPx" id="Triangle-Left" stroke="#fff" stroke-width="4" d="M65 26L30 87" stroke-linecap="round"></path>
    <path class="hjPEAQ" id="Triangle-Right" stroke="#fff" stroke-width="4" d="M98 87L63 26" stroke-linecap="round"></path>
  </g>
</svg>
<div class="text">Loading
  <span class="dGfHfc">GraphQL Playground</span>
</div>
</div>
`
    };
  };
  exports.default = getLoadingMarkup;
});

// node_modules/@apollographql/graphql-playground-html/dist/render-playground-page.js
var require_render_playground_page = __commonJS((exports) => {
  var __assign = exports && exports.__assign || function() {
    __assign = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length;i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    return __assign.apply(this, arguments);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.renderPlaygroundPage = undefined;
  var xss_1 = require_lib9();
  var get_loading_markup_1 = require_get_loading_markup();
  var filter = function(val) {
    return xss_1.filterXSS(val, {
      whiteList: [],
      stripIgnoreTag: true,
      stripIgnoreTagBody: ["script"]
    });
  };
  var loading = get_loading_markup_1.default();
  var reactPackageName = "@apollographql/graphql-playground-react";
  var getCdnMarkup = function(_a) {
    var { version, cdnUrl: _b } = _a, cdnUrl = _b === undefined ? "//cdn.jsdelivr.net/npm" : _b, faviconUrl = _a.faviconUrl;
    var buildCDNUrl = function(packageName, suffix) {
      return filter(cdnUrl + "/" + packageName + (version ? "@" + version : "") + "/" + suffix || "");
    };
    return `
    <link
      rel="stylesheet"
      href="` + buildCDNUrl(reactPackageName, "build/static/css/index.css") + `"
    />
    ` + (typeof faviconUrl === "string" ? '<link rel="shortcut icon" href="' + filter(faviconUrl || "") + '" />' : "") + `
    ` + (faviconUrl === undefined ? '<link rel="shortcut icon" href="' + buildCDNUrl(reactPackageName, "build/favicon.png") + '" />' : "") + `
    <script
      src="` + buildCDNUrl(reactPackageName, "build/static/js/middleware.js") + `"
    ></script>
`;
  };
  var renderConfig = function(config) {
    return '<div id="playground-config" style="display: none;">' + xss_1.filterXSS(JSON.stringify(config), {
      whiteList: []
    }) + "</div>";
  };
  function renderPlaygroundPage(options) {
    var extendedOptions = __assign(__assign({}, options), { canSaveConfig: false });
    if (options.subscriptionsEndpoint) {
      extendedOptions.subscriptionEndpoint = filter(options.subscriptionsEndpoint || "");
    }
    if (options.config) {
      extendedOptions.configString = JSON.stringify(options.config, null, 2);
    }
    if (extendedOptions.endpoint) {
      extendedOptions.endpoint = filter(extendedOptions.endpoint || "");
    }
    return `
  <!DOCTYPE html>
  <html>
  <head>
    <meta charset=utf-8 />
    <meta name="viewport" content="user-scalable=no, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, minimal-ui">
    <link href="https://fonts.googleapis.com/css?family=Open+Sans:300,400,600,700|Source+Code+Pro:400,700" rel="stylesheet">
    <title>` + (filter(extendedOptions.title) || "GraphQL Playground") + `</title>
    ` + (extendedOptions.env === "react" || extendedOptions.env === "electron" ? "" : getCdnMarkup(extendedOptions)) + `
  </head>
  <body>
    <style type="text/css">
      html {
        font-family: "Open Sans", sans-serif;
        overflow: hidden;
      }
  
      body {
        margin: 0;
        background: #172a3a;
      }
  
      .playgroundIn {
        -webkit-animation: playgroundIn 0.5s ease-out forwards;
        animation: playgroundIn 0.5s ease-out forwards;
      }
  
      @-webkit-keyframes playgroundIn {
        from {
          opacity: 0;
          -webkit-transform: translateY(10px);
          -ms-transform: translateY(10px);
          transform: translateY(10px);
        }
        to {
          opacity: 1;
          -webkit-transform: translateY(0);
          -ms-transform: translateY(0);
          transform: translateY(0);
        }
      }
  
      @keyframes playgroundIn {
        from {
          opacity: 0;
          -webkit-transform: translateY(10px);
          -ms-transform: translateY(10px);
          transform: translateY(10px);
        }
        to {
          opacity: 1;
          -webkit-transform: translateY(0);
          -ms-transform: translateY(0);
          transform: translateY(0);
        }
      }
    </style>
    ` + loading.container + `
    ` + renderConfig(extendedOptions) + `
    <div id="root" />
    <script type="text/javascript">
      window.addEventListener('load', function (event) {
        ` + loading.script + `
  
        const root = document.getElementById('root');
        root.classList.add('playgroundIn');
        const configText = document.getElementById('playground-config').innerText
        if(configText && configText.length) {
          try {
            GraphQLPlayground.init(root, JSON.parse(configText))
          }
          catch(err) {
            console.error("could not find config")
          }
        }
      })
    </script>
  </body>
  </html>
`;
  }
  exports.renderPlaygroundPage = renderPlaygroundPage;
});

// node_modules/@apollographql/graphql-playground-html/dist/index.js
var require_dist12 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var render_playground_page_1 = require_render_playground_page();
  Object.defineProperty(exports, "renderPlaygroundPage", { enumerable: true, get: function() {
    return render_playground_page_1.renderPlaygroundPage;
  } });
});

// node_modules/apollo-server-core/dist/plugin/landingPage/graphqlPlayground/index.js
var require_graphqlPlayground = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ApolloServerPluginLandingPageGraphQLPlayground = undefined;
  var graphql_playground_html_1 = require_dist12();
  var defaultPlaygroundVersion = "1.7.42";
  function ApolloServerPluginLandingPageGraphQLPlayground(options = Object.create(null)) {
    return {
      async serverWillStart() {
        return {
          async renderLandingPage() {
            return {
              html: (0, graphql_playground_html_1.renderPlaygroundPage)({
                version: defaultPlaygroundVersion,
                ...options
              })
            };
          }
        };
      }
    };
  }
  exports.ApolloServerPluginLandingPageGraphQLPlayground = ApolloServerPluginLandingPageGraphQLPlayground;
});

// node_modules/apollo-server-core/dist/plugin/index.js
var require_plugin2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ApolloServerPluginLandingPageGraphQLPlayground = exports.ApolloServerPluginLandingPageProductionDefault = exports.ApolloServerPluginLandingPageLocalDefault = exports.ApolloServerPluginLandingPageDisabled = exports.ApolloServerPluginDrainHttpServer = exports.ApolloServerPluginCacheControlDisabled = exports.ApolloServerPluginCacheControl = exports.ApolloServerPluginInlineTraceDisabled = exports.ApolloServerPluginInlineTrace = exports.ApolloServerPluginSchemaReporting = exports.ApolloServerPluginUsageReportingDisabled = exports.ApolloServerPluginUsageReporting = undefined;
  function ApolloServerPluginUsageReporting(options = Object.create(null)) {
    return require_usageReporting().ApolloServerPluginUsageReporting(options);
  }
  exports.ApolloServerPluginUsageReporting = ApolloServerPluginUsageReporting;
  function ApolloServerPluginUsageReportingDisabled() {
    return require_usageReporting().ApolloServerPluginUsageReportingDisabled();
  }
  exports.ApolloServerPluginUsageReportingDisabled = ApolloServerPluginUsageReportingDisabled;
  function ApolloServerPluginSchemaReporting(options = Object.create(null)) {
    return require_schemaReporting().ApolloServerPluginSchemaReporting(options);
  }
  exports.ApolloServerPluginSchemaReporting = ApolloServerPluginSchemaReporting;
  function ApolloServerPluginInlineTrace(options = Object.create(null)) {
    return require_inlineTrace().ApolloServerPluginInlineTrace(options);
  }
  exports.ApolloServerPluginInlineTrace = ApolloServerPluginInlineTrace;
  function ApolloServerPluginInlineTraceDisabled() {
    return require_inlineTrace().ApolloServerPluginInlineTraceDisabled();
  }
  exports.ApolloServerPluginInlineTraceDisabled = ApolloServerPluginInlineTraceDisabled;
  function ApolloServerPluginCacheControl(options = Object.create(null)) {
    return require_cacheControl().ApolloServerPluginCacheControl(options);
  }
  exports.ApolloServerPluginCacheControl = ApolloServerPluginCacheControl;
  function ApolloServerPluginCacheControlDisabled() {
    return require_cacheControl().ApolloServerPluginCacheControlDisabled();
  }
  exports.ApolloServerPluginCacheControlDisabled = ApolloServerPluginCacheControlDisabled;
  function ApolloServerPluginDrainHttpServer(options) {
    return require_drainHttpServer().ApolloServerPluginDrainHttpServer(options);
  }
  exports.ApolloServerPluginDrainHttpServer = ApolloServerPluginDrainHttpServer;
  function ApolloServerPluginLandingPageDisabled() {
    const plugin = {
      __internal_plugin_id__() {
        return "LandingPageDisabled";
      }
    };
    return plugin;
  }
  exports.ApolloServerPluginLandingPageDisabled = ApolloServerPluginLandingPageDisabled;
  function ApolloServerPluginLandingPageLocalDefault(options) {
    return require_default().ApolloServerPluginLandingPageLocalDefault(options);
  }
  exports.ApolloServerPluginLandingPageLocalDefault = ApolloServerPluginLandingPageLocalDefault;
  function ApolloServerPluginLandingPageProductionDefault(options) {
    return require_default().ApolloServerPluginLandingPageProductionDefault(options);
  }
  exports.ApolloServerPluginLandingPageProductionDefault = ApolloServerPluginLandingPageProductionDefault;
  function ApolloServerPluginLandingPageGraphQLPlayground(options = Object.create(null)) {
    return require_graphqlPlayground().ApolloServerPluginLandingPageGraphQLPlayground(options);
  }
  exports.ApolloServerPluginLandingPageGraphQLPlayground = ApolloServerPluginLandingPageGraphQLPlayground;
});

// node_modules/apollo-server-core/dist/internalPlugin.js
var require_internalPlugin = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.pluginIsInternal = undefined;
  function pluginIsInternal(plugin) {
    return "__internal_plugin_id__" in plugin;
  }
  exports.pluginIsInternal = pluginIsInternal;
});

// node_modules/apollo-server-core/dist/utils/schemaManager.js
var require_schemaManager = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GatewayIsTooOldError = exports.SchemaManager = undefined;

  class SchemaManager {
    constructor(options) {
      this.onSchemaLoadOrUpdateListeners = new Set;
      this.isStopped = false;
      this.logger = options.logger;
      this.schemaDerivedDataProvider = options.schemaDerivedDataProvider;
      if ("gateway" in options) {
        this.modeSpecificState = {
          mode: "gateway",
          gateway: options.gateway,
          apolloConfig: options.apolloConfig
        };
      } else {
        this.modeSpecificState = {
          mode: "schema",
          apiSchema: options.apiSchema,
          schemaDerivedData: options.schemaDerivedDataProvider(options.apiSchema)
        };
      }
    }
    async start() {
      if (this.modeSpecificState.mode === "gateway") {
        const gateway = this.modeSpecificState.gateway;
        if (gateway.onSchemaLoadOrUpdate) {
          this.modeSpecificState.unsubscribeFromGateway = gateway.onSchemaLoadOrUpdate((schemaContext) => {
            this.processSchemaLoadOrUpdateEvent(schemaContext);
          });
        } else if (gateway.onSchemaChange) {
          this.modeSpecificState.unsubscribeFromGateway = gateway.onSchemaChange((apiSchema) => {
            this.processSchemaLoadOrUpdateEvent({ apiSchema });
          });
        } else {
          throw new Error("Unexpectedly couldn't find onSchemaChange or onSchemaLoadOrUpdate on gateway");
        }
        const config = await this.modeSpecificState.gateway.load({
          apollo: this.modeSpecificState.apolloConfig
        });
        if (!this.schemaDerivedData) {
          this.processSchemaLoadOrUpdateEvent({ apiSchema: config.schema });
        }
        return config.executor;
      } else {
        this.processSchemaLoadOrUpdateEvent({
          apiSchema: this.modeSpecificState.apiSchema
        }, this.modeSpecificState.schemaDerivedData);
        return null;
      }
    }
    onSchemaLoadOrUpdate(callback) {
      if (this.modeSpecificState.mode === "gateway" && !this.modeSpecificState.gateway.onSchemaLoadOrUpdate) {
        throw new GatewayIsTooOldError([
          `Your gateway is too old to register a 'onSchemaLoadOrUpdate' listener.`,
          `Please update your version of @apollo/gateway to at least 0.35.0.`
        ].join(" "));
      } else {
        if (!this.schemaContext) {
          throw new Error("You must call start() before onSchemaLoadOrUpdate()");
        }
        if (!this.isStopped) {
          try {
            callback(this.schemaContext);
          } catch (e) {
            throw new Error(`An error was thrown from an 'onSchemaLoadOrUpdate' listener: ${e.message}`);
          }
        }
        this.onSchemaLoadOrUpdateListeners.add(callback);
      }
      return () => {
        this.onSchemaLoadOrUpdateListeners.delete(callback);
      };
    }
    getSchemaDerivedData() {
      if (!this.schemaDerivedData) {
        throw new Error("You must call start() before getSchemaDerivedData()");
      }
      return this.schemaDerivedData;
    }
    async stop() {
      var _a, _b, _c, _d;
      this.isStopped = true;
      if (this.modeSpecificState.mode === "gateway") {
        (_b = (_a = this.modeSpecificState).unsubscribeFromGateway) === null || _b === undefined || _b.call(_a);
        await ((_d = (_c = this.modeSpecificState.gateway).stop) === null || _d === undefined ? undefined : _d.call(_c));
      }
    }
    processSchemaLoadOrUpdateEvent(schemaContext, schemaDerivedData) {
      if (!this.isStopped) {
        this.schemaDerivedData = schemaDerivedData !== null && schemaDerivedData !== undefined ? schemaDerivedData : this.schemaDerivedDataProvider(schemaContext.apiSchema);
        this.schemaContext = schemaContext;
        this.onSchemaLoadOrUpdateListeners.forEach((listener) => {
          try {
            listener(schemaContext);
          } catch (e) {
            this.logger.error("An error was thrown from an 'onSchemaLoadOrUpdate' listener");
            this.logger.error(e);
          }
        });
      }
    }
  }
  exports.SchemaManager = SchemaManager;

  class GatewayIsTooOldError extends Error {
    constructor(message2) {
      super(message2);
    }
  }
  exports.GatewayIsTooOldError = GatewayIsTooOldError;
});

// node_modules/apollo-server-core/dist/utils/UnboundedCache.js
var require_UnboundedCache = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UnboundedCache = undefined;

  class UnboundedCache {
    constructor(cache = new Map) {
      this.cache = cache;
    }
    async get(key) {
      const entry = this.cache.get(key);
      if (!entry)
        return;
      if (entry.deadline && entry.deadline <= Date.now()) {
        await this.delete(key);
        return;
      }
      return entry.value;
    }
    async set(key, value, { ttl } = { ttl: null }) {
      this.cache.set(key, {
        value,
        deadline: ttl ? Date.now() + ttl * 1000 : null
      });
    }
    async delete(key) {
      this.cache.delete(key);
    }
  }
  exports.UnboundedCache = UnboundedCache;
});

// node_modules/apollo-server-core/dist/ApolloServer.js
var require_ApolloServer = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod2) {
    if (mod2 && mod2.__esModule)
      return mod2;
    var result = {};
    if (mod2 != null) {
      for (var k in mod2)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
          __createBinding(result, mod2, k);
    }
    __setModuleDefault(result, mod2);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isImplicitlyInstallablePlugin = exports.ApolloServerBase = undefined;
  var mock_1 = require_mock();
  var schema_1 = require_schema3();
  var loglevel_1 = __importDefault(require_loglevel());
  var graphql_1 = require_graphql2();
  var resolvable_1 = __importDefault(require_resolvable());
  var utils_keyvaluecache_1 = require_dist4();
  var schemaHash_1 = require_schemaHash();
  var requestPipeline_1 = require_requestPipeline();
  var apollo_server_env_1 = require_dist();
  var apollo_tools_1 = require_lib6();
  var runHttpQuery_1 = require_runHttpQuery();
  var isNodeLike_1 = __importDefault(require_isNodeLike());
  var determineApolloConfig_1 = require_determineApolloConfig();
  var plugin_1 = require_plugin2();
  var internalPlugin_1 = require_internalPlugin();
  var cachePolicy_1 = require_cachePolicy();
  var schemaManager_1 = require_schemaManager();
  var uuid = __importStar(require_dist11());
  var UnboundedCache_1 = require_UnboundedCache();
  var NoIntrospection = (context) => ({
    Field(node) {
      if (node.name.value === "__schema" || node.name.value === "__type") {
        context.reportError(new graphql_1.GraphQLError("GraphQL introspection is not allowed by Apollo Server, but the query contained __schema or __type. To enable introspection, pass introspection: true to ApolloServer in production", [node]));
      }
    }
  });

  class UnreachableCaseError extends Error {
    constructor(val) {
      super(`Unreachable case: ${val}`);
    }
  }
  var recommendedCsrfPreventionRequestHeaders = [
    "x-apollo-operation-name",
    "apollo-require-preflight"
  ];

  class ApolloServerBase {
    constructor(config) {
      var _a, _b;
      this.graphqlPath = "/graphql";
      this.requestOptions = Object.create(null);
      this.plugins = [];
      this.toDispose = new Set;
      this.toDisposeLast = new Set;
      this.drainServers = null;
      this.landingPage = null;
      if (!config)
        throw new Error("ApolloServer requires options.");
      this.config = {
        ...config,
        nodeEnv: (_a = config.nodeEnv) !== null && _a !== undefined ? _a : "development"
      };
      const { context, resolvers, schema, modules, typeDefs, parseOptions = {}, introspection, plugins, gateway, apollo, stopOnTerminationSignals, mocks, mockEntireSchema, documentStore, csrfPrevention, ...requestOptions } = this.config;
      if (config.logger) {
        this.logger = config.logger;
      } else {
        const loglevelLogger = loglevel_1.default.getLogger("apollo-server");
        if (this.config.debug === true) {
          loglevelLogger.setLevel(loglevel_1.default.levels.DEBUG);
        } else {
          loglevelLogger.setLevel(loglevel_1.default.levels.INFO);
        }
        this.logger = loglevelLogger;
      }
      this.apolloConfig = (0, determineApolloConfig_1.determineApolloConfig)(apollo, this.logger);
      if (gateway && (modules || schema || typeDefs || resolvers)) {
        throw new Error("Cannot define both `gateway` and any of: `modules`, `schema`, `typeDefs`, or `resolvers`");
      }
      this.parseOptions = parseOptions;
      this.context = context;
      this.csrfPreventionRequestHeaders = csrfPrevention === true ? recommendedCsrfPreventionRequestHeaders : csrfPrevention === false ? null : csrfPrevention === undefined ? null : (_b = csrfPrevention.requestHeaders) !== null && _b !== undefined ? _b : recommendedCsrfPreventionRequestHeaders;
      const isDev = this.config.nodeEnv !== "production";
      this.stopOnTerminationSignals = typeof stopOnTerminationSignals === "boolean" ? stopOnTerminationSignals : isNodeLike_1.default && this.config.nodeEnv !== "test" && !this.serverlessFramework();
      if (typeof introspection === "boolean" && !introspection || introspection === undefined && !isDev) {
        const noIntro = [NoIntrospection];
        requestOptions.validationRules = requestOptions.validationRules ? requestOptions.validationRules.concat(noIntro) : noIntro;
      }
      if (requestOptions.cache === "bounded") {
        requestOptions.cache = new utils_keyvaluecache_1.InMemoryLRUCache;
      }
      if (!requestOptions.cache) {
        requestOptions.cache = new UnboundedCache_1.UnboundedCache;
        if (!isDev && (requestOptions.persistedQueries === undefined || requestOptions.persistedQueries && !requestOptions.persistedQueries.cache)) {
          this.logger.warn("Persisted queries are enabled and are using an unbounded cache. Your server" + " is vulnerable to denial of service attacks via memory exhaustion. " + 'Set `cache: "bounded"` or `persistedQueries: false` in your ApolloServer ' + "constructor, or see https://go.apollo.dev/s/cache-backends for other alternatives.");
        }
      }
      if (requestOptions.persistedQueries !== false) {
        const { cache: apqCache = requestOptions.cache, ...apqOtherOptions } = requestOptions.persistedQueries || Object.create(null);
        requestOptions.persistedQueries = {
          cache: new utils_keyvaluecache_1.PrefixingKeyValueCache(apqCache, requestPipeline_1.APQ_CACHE_PREFIX),
          ...apqOtherOptions
        };
      } else {
        delete requestOptions.persistedQueries;
      }
      this.requestOptions = requestOptions;
      this.ensurePluginInstantiation(plugins, isDev);
      if (gateway) {
        this.state = {
          phase: "initialized",
          schemaManager: new schemaManager_1.SchemaManager({
            gateway,
            apolloConfig: this.apolloConfig,
            schemaDerivedDataProvider: (schema2) => this.generateSchemaDerivedData(schema2),
            logger: this.logger
          })
        };
      } else {
        this.state = {
          phase: "initialized",
          schemaManager: new schemaManager_1.SchemaManager({
            apiSchema: this.maybeAddMocksToConstructedSchema(this.constructSchema()),
            schemaDerivedDataProvider: (schema2) => this.generateSchemaDerivedData(schema2),
            logger: this.logger
          })
        };
      }
      if (this.serverlessFramework()) {
        this._start().catch((e) => this.logStartupError(e));
      }
    }
    async start() {
      if (this.serverlessFramework()) {
        throw new Error("When using an ApolloServer subclass from a serverless framework " + "package, you don't need to call start(); just call createHandler().");
      }
      return await this._start();
    }
    async _start() {
      var _a;
      if (this.state.phase !== "initialized") {
        throw new Error(`called start() with surprising state ${this.state.phase}`);
      }
      const schemaManager = this.state.schemaManager;
      const barrier = (0, resolvable_1.default)();
      this.state = {
        phase: "starting",
        barrier,
        schemaManager
      };
      try {
        const executor = await schemaManager.start();
        this.toDispose.add(async () => {
          await schemaManager.stop();
        });
        if (executor) {
          this.requestOptions.executor = executor;
        }
        const schemaDerivedData = schemaManager.getSchemaDerivedData();
        const service = {
          logger: this.logger,
          schema: schemaDerivedData.schema,
          schemaHash: schemaDerivedData.schemaHash,
          apollo: this.apolloConfig,
          serverlessFramework: this.serverlessFramework()
        };
        if ((_a = this.requestOptions.persistedQueries) === null || _a === undefined ? undefined : _a.cache) {
          service.persistedQueries = {
            cache: this.requestOptions.persistedQueries.cache
          };
        }
        const taggedServerListeners = (await Promise.all(this.plugins.map(async (plugin) => ({
          serverListener: plugin.serverWillStart && await plugin.serverWillStart(service),
          installedImplicitly: isImplicitlyInstallablePlugin(plugin) && plugin.__internal_installed_implicitly__
        })))).filter((maybeTaggedServerListener) => typeof maybeTaggedServerListener.serverListener === "object");
        taggedServerListeners.forEach(({ serverListener: { schemaDidLoadOrUpdate } }) => {
          if (schemaDidLoadOrUpdate) {
            try {
              schemaManager.onSchemaLoadOrUpdate(schemaDidLoadOrUpdate);
            } catch (e) {
              if (e instanceof schemaManager_1.GatewayIsTooOldError) {
                throw new Error([
                  `One of your plugins uses the 'schemaDidLoadOrUpdate' hook,`,
                  `but your gateway version is too old to support this hook.`,
                  `Please update your version of @apollo/gateway to at least 0.35.0.`
                ].join(" "));
              }
              throw e;
            }
          }
        });
        const serverWillStops = taggedServerListeners.flatMap((l) => l.serverListener.serverWillStop ? [l.serverListener.serverWillStop] : []);
        if (serverWillStops.length) {
          this.toDispose.add(async () => {
            await Promise.all(serverWillStops.map((serverWillStop) => serverWillStop()));
          });
        }
        const drainServerCallbacks = taggedServerListeners.flatMap((l) => l.serverListener.drainServer ? [l.serverListener.drainServer] : []);
        if (drainServerCallbacks.length) {
          this.drainServers = async () => {
            await Promise.all(drainServerCallbacks.map((drainServer) => drainServer()));
          };
        }
        let taggedServerListenersWithRenderLandingPage = taggedServerListeners.filter((l) => l.serverListener.renderLandingPage);
        if (taggedServerListenersWithRenderLandingPage.length > 1) {
          taggedServerListenersWithRenderLandingPage = taggedServerListenersWithRenderLandingPage.filter((l) => !l.installedImplicitly);
        }
        if (taggedServerListenersWithRenderLandingPage.length > 1) {
          throw Error("Only one plugin can implement renderLandingPage.");
        } else if (taggedServerListenersWithRenderLandingPage.length) {
          this.landingPage = await taggedServerListenersWithRenderLandingPage[0].serverListener.renderLandingPage();
        } else {
          this.landingPage = null;
        }
        this.state = {
          phase: "started",
          schemaManager
        };
        this.maybeRegisterTerminationSignalHandlers(["SIGINT", "SIGTERM"]);
      } catch (error) {
        this.state = { phase: "failed to start", error };
        throw error;
      } finally {
        barrier.resolve();
      }
    }
    maybeRegisterTerminationSignalHandlers(signals) {
      if (!this.stopOnTerminationSignals) {
        return;
      }
      let receivedSignal = false;
      const signalHandler = async (signal) => {
        if (receivedSignal) {
          return;
        }
        receivedSignal = true;
        try {
          await this.stop();
        } catch (e) {
          this.logger.error(`stop() threw during ${signal} shutdown`);
          this.logger.error(e);
          process.exit(1);
        }
        process.kill(process.pid, signal);
      };
      signals.forEach((signal) => {
        process.on(signal, signalHandler);
        this.toDisposeLast.add(async () => {
          process.removeListener(signal, signalHandler);
        });
      });
    }
    async _ensureStarted() {
      while (true) {
        switch (this.state.phase) {
          case "initialized":
            throw new Error("You need to call `server.start()` before using your Apollo Server.");
          case "starting":
            await this.state.barrier;
            break;
          case "failed to start":
            this.logStartupError(this.state.error);
            throw new Error("This data graph is missing a valid configuration. More details may be available in the server logs.");
          case "started":
          case "draining":
            return this.state.schemaManager.getSchemaDerivedData();
          case "stopping":
            throw new Error("Cannot execute GraphQL operations while the server is stopping.");
          case "stopped":
            throw new Error("Cannot execute GraphQL operations after the server has stopped.");
          default:
            throw new UnreachableCaseError(this.state);
        }
      }
    }
    async ensureStarted() {
      await this._ensureStarted();
    }
    assertStarted(methodName) {
      if (this.state.phase !== "started" && this.state.phase !== "draining") {
        throw new Error("You must `await server.start()` before calling `server." + methodName + "()`");
      }
    }
    logStartupError(err) {
      this.logger.error("An error occurred during Apollo Server startup. All GraphQL requests " + "will now fail. The startup error was: " + ((err === null || err === undefined ? undefined : err.message) || err));
    }
    constructSchema() {
      const { schema, modules, typeDefs, resolvers, parseOptions } = this.config;
      if (schema) {
        return schema;
      }
      if (modules) {
        const { schema: schema2, errors } = (0, apollo_tools_1.buildServiceDefinition)(modules);
        if (errors && errors.length > 0) {
          throw new Error(errors.map((error) => error.message).join(`

`));
        }
        return schema2;
      }
      if (!typeDefs) {
        throw Error("Apollo Server requires either an existing schema, modules or typeDefs");
      }
      const augmentedTypeDefs = Array.isArray(typeDefs) ? typeDefs : [typeDefs];
      return (0, schema_1.makeExecutableSchema)({
        typeDefs: augmentedTypeDefs,
        resolvers,
        parseOptions
      });
    }
    maybeAddMocksToConstructedSchema(schema) {
      const { mocks, mockEntireSchema } = this.config;
      if (mocks === false) {
        return schema;
      }
      if (!mocks && typeof mockEntireSchema === "undefined") {
        return schema;
      }
      return (0, mock_1.addMocksToSchema)({
        schema,
        mocks: mocks === true || typeof mocks === "undefined" ? {} : mocks,
        preserveResolvers: typeof mockEntireSchema === "undefined" ? false : !mockEntireSchema
      });
    }
    generateSchemaDerivedData(schema) {
      const schemaHash = (0, schemaHash_1.generateSchemaHash)(schema);
      return {
        schema,
        schemaHash,
        documentStore: this.config.documentStore === undefined ? new utils_keyvaluecache_1.InMemoryLRUCache : this.config.documentStore === null ? null : new utils_keyvaluecache_1.PrefixingKeyValueCache(this.config.documentStore, `${uuid.v4()}:`)
      };
    }
    async stop() {
      var _a;
      switch (this.state.phase) {
        case "initialized":
        case "starting":
        case "failed to start":
          throw Error("apolloServer.stop() should only be called after `await apolloServer.start()` has succeeded");
        case "stopped":
          if (this.state.stopError) {
            throw this.state.stopError;
          }
          return;
        case "stopping":
        case "draining": {
          await this.state.barrier;
          const state = this.state;
          if (state.phase !== "stopped") {
            throw Error(`Surprising post-stopping state ${state.phase}`);
          }
          if (state.stopError) {
            throw state.stopError;
          }
          return;
        }
        case "started":
          break;
        default:
          throw new UnreachableCaseError(this.state);
      }
      const barrier = (0, resolvable_1.default)();
      this.state = {
        phase: "draining",
        schemaManager: this.state.schemaManager,
        barrier
      };
      try {
        await ((_a = this.drainServers) === null || _a === undefined ? undefined : _a.call(this));
        this.state = { phase: "stopping", barrier };
        await Promise.all([...this.toDispose].map((dispose) => dispose()));
        await Promise.all([...this.toDisposeLast].map((dispose) => dispose()));
      } catch (stopError) {
        this.state = { phase: "stopped", stopError };
        barrier.resolve();
        throw stopError;
      }
      this.state = { phase: "stopped", stopError: null };
    }
    serverlessFramework() {
      return false;
    }
    ensurePluginInstantiation(userPlugins = [], isDev) {
      this.plugins = userPlugins.map((plugin) => {
        if (typeof plugin === "function") {
          return plugin();
        }
        return plugin;
      });
      const alreadyHavePluginWithInternalId = (id) => this.plugins.some((p) => (0, internalPlugin_1.pluginIsInternal)(p) && p.__internal_plugin_id__() === id);
      {
        if (!alreadyHavePluginWithInternalId("CacheControl")) {
          this.plugins.push((0, plugin_1.ApolloServerPluginCacheControl)());
        }
      }
      {
        const alreadyHavePlugin2 = alreadyHavePluginWithInternalId("UsageReporting");
        if (!alreadyHavePlugin2 && this.apolloConfig.key) {
          if (this.apolloConfig.graphRef) {
            this.plugins.unshift((0, plugin_1.ApolloServerPluginUsageReporting)());
          } else {
            this.logger.warn("You have specified an Apollo key but have not specified a graph ref; usage " + "reporting is disabled. To enable usage reporting, set the `APOLLO_GRAPH_REF` " + "environment variable to `your-graph-id@your-graph-variant`. To disable this " + "warning, install `ApolloServerPluginUsageReportingDisabled`.");
          }
        }
      }
      {
        const alreadyHavePlugin2 = alreadyHavePluginWithInternalId("SchemaReporting");
        const enabledViaEnvVar = process.env.APOLLO_SCHEMA_REPORTING === "true";
        if (!alreadyHavePlugin2 && enabledViaEnvVar) {
          if (this.apolloConfig.key) {
            const options = {};
            this.plugins.push((0, plugin_1.ApolloServerPluginSchemaReporting)(options));
          } else {
            throw new Error("You've enabled schema reporting by setting the APOLLO_SCHEMA_REPORTING " + "environment variable to true, but you also need to provide your " + "Apollo API key, via the APOLLO_KEY environment " + "variable or via `new ApolloServer({apollo: {key})");
          }
        }
      }
      {
        const alreadyHavePlugin2 = alreadyHavePluginWithInternalId("InlineTrace");
        if (!alreadyHavePlugin2) {
          this.plugins.push((0, plugin_1.ApolloServerPluginInlineTrace)({ __onlyIfSchemaIsFederated: true }));
        }
      }
      const alreadyHavePlugin = alreadyHavePluginWithInternalId("LandingPageDisabled");
      if (!alreadyHavePlugin) {
        const plugin = isDev ? (0, plugin_1.ApolloServerPluginLandingPageLocalDefault)() : (0, plugin_1.ApolloServerPluginLandingPageProductionDefault)();
        if (!isImplicitlyInstallablePlugin(plugin)) {
          throw Error("default landing page plugin should be implicitly installable?");
        }
        plugin.__internal_installed_implicitly__ = true;
        this.plugins.push(plugin);
      }
    }
    async graphQLServerOptions(integrationContextArgument) {
      const { schema, schemaHash, documentStore } = await this._ensureStarted();
      let context = this.context ? this.context : {};
      try {
        context = typeof this.context === "function" ? await this.context(integrationContextArgument || {}) : context;
      } catch (error) {
        context = () => {
          throw error;
        };
      }
      return {
        schema,
        schemaHash,
        logger: this.logger,
        plugins: this.plugins,
        documentStore,
        dangerouslyDisableValidation: this.config.dangerouslyDisableValidation,
        context,
        parseOptions: this.parseOptions,
        ...this.requestOptions
      };
    }
    async executeOperation(request, integrationContextArgument) {
      if (this.state.phase === "initialized") {
        await this._start();
      }
      const options = await this.graphQLServerOptions(integrationContextArgument);
      if (typeof options.context === "function") {
        options.context = options.context();
      } else if (typeof options.context === "object") {
        options.context = (0, runHttpQuery_1.cloneObject)(options.context);
      }
      const requestCtx = {
        logger: this.logger,
        schema: options.schema,
        schemaHash: options.schemaHash,
        request: {
          ...request,
          query: request.query && typeof request.query !== "string" ? (0, graphql_1.print)(request.query) : request.query
        },
        context: options.context || Object.create(null),
        cache: options.cache,
        metrics: {},
        response: {
          http: {
            headers: new apollo_server_env_1.Headers
          }
        },
        debug: options.debug,
        overallCachePolicy: (0, cachePolicy_1.newCachePolicy)(),
        requestIsBatched: false
      };
      return (0, requestPipeline_1.processGraphQLRequest)(options, requestCtx);
    }
    getLandingPage() {
      this.assertStarted("getLandingPage");
      return this.landingPage;
    }
  }
  exports.ApolloServerBase = ApolloServerBase;
  function isImplicitlyInstallablePlugin(p) {
    return "__internal_installed_implicitly__" in p;
  }
  exports.isImplicitlyInstallablePlugin = isImplicitlyInstallablePlugin;
});

// node_modules/apollo-server-core/dist/types.js
var require_types2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/apollo-server-core/dist/index.js
var require_dist13 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ApolloServerBase = exports.convertNodeHttpToRequest = exports.formatApolloErrors = exports.UserInputError = exports.ForbiddenError = exports.AuthenticationError = exports.ValidationError = exports.SyntaxError = exports.toApolloError = exports.ApolloError = exports.resolveGraphqlOptions = exports.isHttpQueryError = exports.HttpQueryError = exports.runHttpQuery = undefined;
  var runHttpQuery_1 = require_runHttpQuery();
  Object.defineProperty(exports, "runHttpQuery", { enumerable: true, get: function() {
    return runHttpQuery_1.runHttpQuery;
  } });
  Object.defineProperty(exports, "HttpQueryError", { enumerable: true, get: function() {
    return runHttpQuery_1.HttpQueryError;
  } });
  Object.defineProperty(exports, "isHttpQueryError", { enumerable: true, get: function() {
    return runHttpQuery_1.isHttpQueryError;
  } });
  var graphqlOptions_1 = require_graphqlOptions();
  Object.defineProperty(exports, "resolveGraphqlOptions", { enumerable: true, get: function() {
    return graphqlOptions_1.resolveGraphqlOptions;
  } });
  var apollo_server_errors_1 = require_dist2();
  Object.defineProperty(exports, "ApolloError", { enumerable: true, get: function() {
    return apollo_server_errors_1.ApolloError;
  } });
  Object.defineProperty(exports, "toApolloError", { enumerable: true, get: function() {
    return apollo_server_errors_1.toApolloError;
  } });
  Object.defineProperty(exports, "SyntaxError", { enumerable: true, get: function() {
    return apollo_server_errors_1.SyntaxError;
  } });
  Object.defineProperty(exports, "ValidationError", { enumerable: true, get: function() {
    return apollo_server_errors_1.ValidationError;
  } });
  Object.defineProperty(exports, "AuthenticationError", { enumerable: true, get: function() {
    return apollo_server_errors_1.AuthenticationError;
  } });
  Object.defineProperty(exports, "ForbiddenError", { enumerable: true, get: function() {
    return apollo_server_errors_1.ForbiddenError;
  } });
  Object.defineProperty(exports, "UserInputError", { enumerable: true, get: function() {
    return apollo_server_errors_1.UserInputError;
  } });
  Object.defineProperty(exports, "formatApolloErrors", { enumerable: true, get: function() {
    return apollo_server_errors_1.formatApolloErrors;
  } });
  var nodeHttpToRequest_1 = require_nodeHttpToRequest();
  Object.defineProperty(exports, "convertNodeHttpToRequest", { enumerable: true, get: function() {
    return nodeHttpToRequest_1.convertNodeHttpToRequest;
  } });
  var ApolloServer_1 = require_ApolloServer();
  Object.defineProperty(exports, "ApolloServerBase", { enumerable: true, get: function() {
    return ApolloServer_1.ApolloServerBase;
  } });
  __exportStar(require_types2(), exports);
  var apollo_server_types_1 = require_dist3();
  __exportStar(require_gql(), exports);
  __exportStar(require_plugin2(), exports);
});

// node_modules/object-assign/index.js
var require_object_assign = __commonJS((exports, module) => {
  var getOwnPropertySymbols = Object.getOwnPropertySymbols;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var propIsEnumerable = Object.prototype.propertyIsEnumerable;
  function toObject(val) {
    if (val === null || val === undefined) {
      throw new TypeError("Object.assign cannot be called with null or undefined");
    }
    return Object(val);
  }
  function shouldUseNative() {
    try {
      if (!Object.assign) {
        return false;
      }
      var test1 = new String("abc");
      test1[5] = "de";
      if (Object.getOwnPropertyNames(test1)[0] === "5") {
        return false;
      }
      var test2 = {};
      for (var i = 0;i < 10; i++) {
        test2["_" + String.fromCharCode(i)] = i;
      }
      var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
        return test2[n];
      });
      if (order2.join("") !== "0123456789") {
        return false;
      }
      var test3 = {};
      "abcdefghijklmnopqrst".split("").forEach(function(letter) {
        test3[letter] = letter;
      });
      if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
        return false;
      }
      return true;
    } catch (err) {
      return false;
    }
  }
  module.exports = shouldUseNative() ? Object.assign : function(target, source) {
    var from;
    var to = toObject(target);
    var symbols;
    for (var s = 1;s < arguments.length; s++) {
      from = Object(arguments[s]);
      for (var key in from) {
        if (hasOwnProperty.call(from, key)) {
          to[key] = from[key];
        }
      }
      if (getOwnPropertySymbols) {
        symbols = getOwnPropertySymbols(from);
        for (var i = 0;i < symbols.length; i++) {
          if (propIsEnumerable.call(from, symbols[i])) {
            to[symbols[i]] = from[symbols[i]];
          }
        }
      }
    }
    return to;
  };
});

// node_modules/cors/lib/index.js
var require_lib10 = __commonJS((exports, module) => {
  (function() {
    var assign = require_object_assign();
    var vary = require_vary();
    var defaults = {
      origin: "*",
      methods: "GET,HEAD,PUT,PATCH,POST,DELETE",
      preflightContinue: false,
      optionsSuccessStatus: 204
    };
    function isString(s) {
      return typeof s === "string" || s instanceof String;
    }
    function isOriginAllowed(origin, allowedOrigin) {
      if (Array.isArray(allowedOrigin)) {
        for (var i = 0;i < allowedOrigin.length; ++i) {
          if (isOriginAllowed(origin, allowedOrigin[i])) {
            return true;
          }
        }
        return false;
      } else if (isString(allowedOrigin)) {
        return origin === allowedOrigin;
      } else if (allowedOrigin instanceof RegExp) {
        return allowedOrigin.test(origin);
      } else {
        return !!allowedOrigin;
      }
    }
    function configureOrigin(options, req) {
      var requestOrigin = req.headers.origin, headers = [], isAllowed;
      if (!options.origin || options.origin === "*") {
        headers.push([{
          key: "Access-Control-Allow-Origin",
          value: "*"
        }]);
      } else if (isString(options.origin)) {
        headers.push([{
          key: "Access-Control-Allow-Origin",
          value: options.origin
        }]);
        headers.push([{
          key: "Vary",
          value: "Origin"
        }]);
      } else {
        isAllowed = isOriginAllowed(requestOrigin, options.origin);
        headers.push([{
          key: "Access-Control-Allow-Origin",
          value: isAllowed ? requestOrigin : false
        }]);
        headers.push([{
          key: "Vary",
          value: "Origin"
        }]);
      }
      return headers;
    }
    function configureMethods(options) {
      var methods = options.methods;
      if (methods.join) {
        methods = options.methods.join(",");
      }
      return {
        key: "Access-Control-Allow-Methods",
        value: methods
      };
    }
    function configureCredentials(options) {
      if (options.credentials === true) {
        return {
          key: "Access-Control-Allow-Credentials",
          value: "true"
        };
      }
      return null;
    }
    function configureAllowedHeaders(options, req) {
      var allowedHeaders = options.allowedHeaders || options.headers;
      var headers = [];
      if (!allowedHeaders) {
        allowedHeaders = req.headers["access-control-request-headers"];
        headers.push([{
          key: "Vary",
          value: "Access-Control-Request-Headers"
        }]);
      } else if (allowedHeaders.join) {
        allowedHeaders = allowedHeaders.join(",");
      }
      if (allowedHeaders && allowedHeaders.length) {
        headers.push([{
          key: "Access-Control-Allow-Headers",
          value: allowedHeaders
        }]);
      }
      return headers;
    }
    function configureExposedHeaders(options) {
      var headers = options.exposedHeaders;
      if (!headers) {
        return null;
      } else if (headers.join) {
        headers = headers.join(",");
      }
      if (headers && headers.length) {
        return {
          key: "Access-Control-Expose-Headers",
          value: headers
        };
      }
      return null;
    }
    function configureMaxAge(options) {
      var maxAge = (typeof options.maxAge === "number" || options.maxAge) && options.maxAge.toString();
      if (maxAge && maxAge.length) {
        return {
          key: "Access-Control-Max-Age",
          value: maxAge
        };
      }
      return null;
    }
    function applyHeaders(headers, res) {
      for (var i = 0, n = headers.length;i < n; i++) {
        var header = headers[i];
        if (header) {
          if (Array.isArray(header)) {
            applyHeaders(header, res);
          } else if (header.key === "Vary" && header.value) {
            vary(res, header.value);
          } else if (header.value) {
            res.setHeader(header.key, header.value);
          }
        }
      }
    }
    function cors(options, req, res, next) {
      var headers = [], method = req.method && req.method.toUpperCase && req.method.toUpperCase();
      if (method === "OPTIONS") {
        headers.push(configureOrigin(options, req));
        headers.push(configureCredentials(options, req));
        headers.push(configureMethods(options, req));
        headers.push(configureAllowedHeaders(options, req));
        headers.push(configureMaxAge(options, req));
        headers.push(configureExposedHeaders(options, req));
        applyHeaders(headers, res);
        if (options.preflightContinue) {
          next();
        } else {
          res.statusCode = options.optionsSuccessStatus;
          res.setHeader("Content-Length", "0");
          res.end();
        }
      } else {
        headers.push(configureOrigin(options, req));
        headers.push(configureCredentials(options, req));
        headers.push(configureExposedHeaders(options, req));
        applyHeaders(headers, res);
        next();
      }
    }
    function middlewareWrapper(o) {
      var optionsCallback = null;
      if (typeof o === "function") {
        optionsCallback = o;
      } else {
        optionsCallback = function(req, cb) {
          cb(null, o);
        };
      }
      return function corsMiddleware(req, res, next) {
        optionsCallback(req, function(err, options) {
          if (err) {
            next(err);
          } else {
            var corsOptions = assign({}, defaults, options);
            var originCallback = null;
            if (corsOptions.origin && typeof corsOptions.origin === "function") {
              originCallback = corsOptions.origin;
            } else if (corsOptions.origin) {
              originCallback = function(origin, cb) {
                cb(null, corsOptions.origin);
              };
            }
            if (originCallback) {
              originCallback(req.headers.origin, function(err2, origin) {
                if (err2 || !origin) {
                  next(err2);
                } else {
                  corsOptions.origin = origin;
                  cors(corsOptions, req, res, next);
                }
              });
            } else {
              next();
            }
          }
        });
      };
    }
    module.exports = middlewareWrapper;
  })();
});

// node_modules/apollo-server-express/dist/ApolloServer.js
var require_ApolloServer2 = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ApolloServer = undefined;
  var express_1 = __importDefault(require_express2());
  var cors_1 = __importDefault(require_lib10());
  var body_parser_1 = require_body_parser();
  var apollo_server_core_1 = require_dist13();
  var accepts_1 = __importDefault(require_accepts());
  var apollo_server_core_2 = require_dist13();

  class ApolloServer extends apollo_server_core_1.ApolloServerBase {
    async createGraphQLServerOptions(req, res) {
      const contextParams = { req, res };
      return super.graphQLServerOptions(contextParams);
    }
    applyMiddleware({ app, ...rest }) {
      this.assertStarted("applyMiddleware");
      app.use(this.getMiddleware(rest));
    }
    getMiddleware({ path, cors, bodyParserConfig, disableHealthCheck, onHealthCheck, __internal_healthCheckPath } = {}) {
      if (!path)
        path = "/graphql";
      this.assertStarted("getMiddleware");
      const router = express_1.default.Router();
      if (!disableHealthCheck && __internal_healthCheckPath !== null) {
        router.use(__internal_healthCheckPath !== null && __internal_healthCheckPath !== undefined ? __internal_healthCheckPath : "/.well-known/apollo/server-health", (req, res) => {
          res.type("application/health+json");
          if (onHealthCheck) {
            onHealthCheck(req).then(() => {
              res.json({ status: "pass" });
            }).catch(() => {
              res.status(503).json({ status: "fail" });
            });
          } else {
            res.json({ status: "pass" });
          }
        });
      }
      this.graphqlPath = path;
      if (cors === true) {
        router.use(path, (0, cors_1.default)());
      } else if (cors !== false) {
        router.use(path, (0, cors_1.default)(cors));
      }
      if (bodyParserConfig === true) {
        router.use(path, (0, body_parser_1.json)());
      } else if (bodyParserConfig !== false) {
        router.use(path, (0, body_parser_1.json)(bodyParserConfig));
      }
      const landingPage = this.getLandingPage();
      router.use(path, (req, res, next) => {
        if (landingPage && prefersHtml(req)) {
          res.setHeader("Content-Type", "text/html");
          res.write(landingPage.html);
          res.end();
          return;
        }
        if (!req.body) {
          res.status(500);
          if (bodyParserConfig === false) {
            res.send("`res.body` is not set; you passed `bodyParserConfig: false`, " + "but you still need to use `body-parser` middleware yourself.");
          } else {
            res.send("`res.body` is not set even though Apollo Server installed " + "`body-parser` middleware; this shouldn't happen!");
          }
          return;
        }
        (0, apollo_server_core_1.runHttpQuery)([], {
          method: req.method,
          options: () => this.createGraphQLServerOptions(req, res),
          query: req.method === "POST" ? req.body : req.query,
          request: (0, apollo_server_core_1.convertNodeHttpToRequest)(req)
        }, this.csrfPreventionRequestHeaders).then(({ graphqlResponse, responseInit }) => {
          if (responseInit.headers) {
            for (const [name, value] of Object.entries(responseInit.headers)) {
              res.setHeader(name, value);
            }
          }
          res.statusCode = responseInit.status || 200;
          if (typeof res.send === "function") {
            res.send(graphqlResponse);
          } else {
            res.end(graphqlResponse);
          }
        }, (error) => {
          if (!(0, apollo_server_core_1.isHttpQueryError)(error)) {
            return next(error);
          }
          if (error.headers) {
            for (const [name, value] of Object.entries(error.headers)) {
              res.setHeader(name, value);
            }
          }
          res.statusCode = error.statusCode;
          if (typeof res.send === "function") {
            res.send(error.message);
          } else {
            res.end(error.message);
          }
        });
      });
      return router;
    }
  }
  exports.ApolloServer = ApolloServer;
  function prefersHtml(req) {
    if (req.method !== "GET") {
      return false;
    }
    const accept = (0, accepts_1.default)(req);
    const types = accept.types();
    return types.find((x) => x === "text/html" || x === "application/json") === "text/html";
  }
});

// node_modules/apollo-server-express/dist/index.js
var require_dist14 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ApolloServer = exports.UserInputError = exports.ForbiddenError = exports.AuthenticationError = exports.ValidationError = exports.SyntaxError = exports.toApolloError = exports.ApolloError = exports.gql = undefined;
  var apollo_server_core_1 = require_dist13();
  Object.defineProperty(exports, "gql", { enumerable: true, get: function() {
    return apollo_server_core_1.gql;
  } });
  Object.defineProperty(exports, "ApolloError", { enumerable: true, get: function() {
    return apollo_server_core_1.ApolloError;
  } });
  Object.defineProperty(exports, "toApolloError", { enumerable: true, get: function() {
    return apollo_server_core_1.toApolloError;
  } });
  Object.defineProperty(exports, "SyntaxError", { enumerable: true, get: function() {
    return apollo_server_core_1.SyntaxError;
  } });
  Object.defineProperty(exports, "ValidationError", { enumerable: true, get: function() {
    return apollo_server_core_1.ValidationError;
  } });
  Object.defineProperty(exports, "AuthenticationError", { enumerable: true, get: function() {
    return apollo_server_core_1.AuthenticationError;
  } });
  Object.defineProperty(exports, "ForbiddenError", { enumerable: true, get: function() {
    return apollo_server_core_1.ForbiddenError;
  } });
  Object.defineProperty(exports, "UserInputError", { enumerable: true, get: function() {
    return apollo_server_core_1.UserInputError;
  } });
  var ApolloServer_1 = require_ApolloServer2();
  Object.defineProperty(exports, "ApolloServer", { enumerable: true, get: function() {
    return ApolloServer_1.ApolloServer;
  } });
  var cors_1 = require_lib10();
  var body_parser_1 = require_body_parser();
});

// node_modules/apollo-server/dist/exports.js
var require_exports = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UserInputError = exports.ForbiddenError = exports.AuthenticationError = exports.ValidationError = exports.SyntaxError = exports.toApolloError = exports.ApolloError = exports.gql = undefined;
  var apollo_server_core_1 = require_dist13();
  Object.defineProperty(exports, "gql", { enumerable: true, get: function() {
    return apollo_server_core_1.gql;
  } });
  Object.defineProperty(exports, "ApolloError", { enumerable: true, get: function() {
    return apollo_server_core_1.ApolloError;
  } });
  Object.defineProperty(exports, "toApolloError", { enumerable: true, get: function() {
    return apollo_server_core_1.toApolloError;
  } });
  Object.defineProperty(exports, "SyntaxError", { enumerable: true, get: function() {
    return apollo_server_core_1.SyntaxError;
  } });
  Object.defineProperty(exports, "ValidationError", { enumerable: true, get: function() {
    return apollo_server_core_1.ValidationError;
  } });
  Object.defineProperty(exports, "AuthenticationError", { enumerable: true, get: function() {
    return apollo_server_core_1.AuthenticationError;
  } });
  Object.defineProperty(exports, "ForbiddenError", { enumerable: true, get: function() {
    return apollo_server_core_1.ForbiddenError;
  } });
  Object.defineProperty(exports, "UserInputError", { enumerable: true, get: function() {
    return apollo_server_core_1.UserInputError;
  } });
  var apollo_server_express_1 = require_dist14();
});

// node_modules/apollo-server/dist/index.js
var require_dist15 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  var __importDefault = exports && exports.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ApolloServer = undefined;
  var express_1 = __importDefault(require_express2());
  var http_1 = __importDefault(__require("http"));
  var apollo_server_express_1 = require_dist14();
  var url_1 = __require("url");
  var apollo_server_core_1 = require_dist13();
  __exportStar(require_exports(), exports);

  class ApolloServer extends apollo_server_express_1.ApolloServer {
    constructor(config) {
      var _a;
      const httpServer = http_1.default.createServer();
      super({
        ...config,
        plugins: [
          ...(_a = config.plugins) !== null && _a !== undefined ? _a : [],
          (0, apollo_server_core_1.ApolloServerPluginDrainHttpServer)({
            httpServer,
            stopGracePeriodMillis: config.stopGracePeriodMillis
          })
        ]
      });
      this.httpServer = httpServer;
      this.cors = config.cors;
      this.onHealthCheck = config.onHealthCheck;
      this.healthCheckPath = config === null || config === undefined ? undefined : config.healthCheckPath;
    }
    createServerInfo() {
      const addressInfo = this.httpServer.address();
      let hostForUrl = addressInfo.address;
      if (hostForUrl === "" || hostForUrl === "::") {
        hostForUrl = "localhost";
      }
      const url = (0, url_1.format)({
        protocol: "http",
        hostname: hostForUrl,
        port: addressInfo.port,
        pathname: this.graphqlPath
      });
      return {
        ...addressInfo,
        server: this.httpServer,
        url
      };
    }
    applyMiddleware() {
      throw new Error("To use Apollo Server with an existing express application, please use apollo-server-express");
    }
    async start() {
      throw new Error("When using the `apollo-server` package, you don't need to call start(); just call listen().");
    }
    async listen(...opts) {
      await this._start();
      const app = (0, express_1.default)();
      this.httpServer.on("request", app);
      app.disable("x-powered-by");
      super.applyMiddleware({
        app,
        path: "/",
        bodyParserConfig: { limit: "50mb" },
        onHealthCheck: this.onHealthCheck,
        cors: typeof this.cors !== "undefined" ? this.cors : {
          origin: "*"
        },
        __internal_healthCheckPath: this.healthCheckPath
      });
      await new Promise((resolve) => {
        this.httpServer.once("listening", resolve);
        this.httpServer.listen(...opts.length ? opts : [{ port: 4000 }]);
      });
      return this.createServerInfo();
    }
  }
  exports.ApolloServer = ApolloServer;
});

// node_modules/file-uri-to-path/index.js
var require_file_uri_to_path = __commonJS((exports, module) => {
  var sep = __require("path").sep || "/";
  module.exports = fileUriToPath;
  function fileUriToPath(uri) {
    if (typeof uri != "string" || uri.length <= 7 || uri.substring(0, 7) != "file://") {
      throw new TypeError("must pass in a file:// URI to convert to a file path");
    }
    var rest = decodeURI(uri.substring(7));
    var firstSlash = rest.indexOf("/");
    var host = rest.substring(0, firstSlash);
    var path = rest.substring(firstSlash + 1);
    if (host == "localhost")
      host = "";
    if (host) {
      host = sep + sep + host;
    }
    path = path.replace(/^(.+)\|/, "$1:");
    if (sep == "\\") {
      path = path.replace(/\//g, "\\");
    }
    if (/^.+\:/.test(path)) {} else {
      path = sep + path;
    }
    return host + path;
  }
});

// node_modules/bindings/bindings.js
var require_bindings = __commonJS((exports, module) => {
  var __filename = "/Users/chris/imessagegraphqlserver/node_modules/bindings/bindings.js";
  var fs = __require("fs");
  var path = __require("path");
  var fileURLToPath = require_file_uri_to_path();
  var join = path.join;
  var dirname = path.dirname;
  var exists = fs.accessSync && function(path2) {
    try {
      fs.accessSync(path2);
    } catch (e) {
      return false;
    }
    return true;
  } || fs.existsSync || path.existsSync;
  var defaults = {
    arrow: process.env.NODE_BINDINGS_ARROW || "  ",
    compiled: process.env.NODE_BINDINGS_COMPILED_DIR || "compiled",
    platform: process.platform,
    arch: process.arch,
    nodePreGyp: "node-v" + process.versions.modules + "-" + process.platform + "-" + process.arch,
    version: process.versions.node,
    bindings: "bindings.node",
    try: [
      ["module_root", "build", "bindings"],
      ["module_root", "build", "Debug", "bindings"],
      ["module_root", "build", "Release", "bindings"],
      ["module_root", "out", "Debug", "bindings"],
      ["module_root", "Debug", "bindings"],
      ["module_root", "out", "Release", "bindings"],
      ["module_root", "Release", "bindings"],
      ["module_root", "build", "default", "bindings"],
      ["module_root", "compiled", "version", "platform", "arch", "bindings"],
      ["module_root", "addon-build", "release", "install-root", "bindings"],
      ["module_root", "addon-build", "debug", "install-root", "bindings"],
      ["module_root", "addon-build", "default", "install-root", "bindings"],
      ["module_root", "lib", "binding", "nodePreGyp", "bindings"]
    ]
  };
  function bindings(opts) {
    if (typeof opts == "string") {
      opts = { bindings: opts };
    } else if (!opts) {
      opts = {};
    }
    Object.keys(defaults).map(function(i2) {
      if (!(i2 in opts))
        opts[i2] = defaults[i2];
    });
    if (!opts.module_root) {
      opts.module_root = exports.getRoot(exports.getFileName());
    }
    if (path.extname(opts.bindings) != ".node") {
      opts.bindings += ".node";
    }
    var requireFunc = typeof __webpack_require__ === "function" ? __non_webpack_require__ : __require;
    var tries = [], i = 0, l = opts.try.length, n, b, err;
    for (;i < l; i++) {
      n = join.apply(null, opts.try[i].map(function(p) {
        return opts[p] || p;
      }));
      tries.push(n);
      try {
        b = opts.path ? requireFunc.resolve(n) : requireFunc(n);
        if (!opts.path) {
          b.path = n;
        }
        return b;
      } catch (e) {
        if (e.code !== "MODULE_NOT_FOUND" && e.code !== "QUALIFIED_PATH_RESOLUTION_FAILED" && !/not find/i.test(e.message)) {
          throw e;
        }
      }
    }
    err = new Error(`Could not locate the bindings file. Tried:
` + tries.map(function(a) {
      return opts.arrow + a;
    }).join(`
`));
    err.tries = tries;
    throw err;
  }
  module.exports = exports = bindings;
  exports.getFileName = function getFileName(calling_file) {
    var { prepareStackTrace: origPST, stackTraceLimit: origSTL } = Error, dummy = {}, fileName;
    Error.stackTraceLimit = 10;
    Error.prepareStackTrace = function(e, st) {
      for (var i = 0, l = st.length;i < l; i++) {
        fileName = st[i].getFileName();
        if (fileName !== __filename) {
          if (calling_file) {
            if (fileName !== calling_file) {
              return;
            }
          } else {
            return;
          }
        }
      }
    };
    Error.captureStackTrace(dummy);
    dummy.stack;
    Error.prepareStackTrace = origPST;
    Error.stackTraceLimit = origSTL;
    var fileSchema = "file://";
    if (fileName.indexOf(fileSchema) === 0) {
      fileName = fileURLToPath(fileName);
    }
    return fileName;
  };
  exports.getRoot = function getRoot(file) {
    var dir = dirname(file), prev;
    while (true) {
      if (dir === ".") {
        dir = process.cwd();
      }
      if (exists(join(dir, "package.json")) || exists(join(dir, "node_modules"))) {
        return dir;
      }
      if (prev === dir) {
        throw new Error('Could not find module root given file: "' + file + '". Do you have a `package.json` file? ');
      }
      prev = dir;
      dir = join(dir, "..");
    }
  };
});

// node_modules/sqlite3/lib/sqlite3-binding.js
var require_sqlite3_binding = __commonJS((exports, module) => {
  module.exports = require_bindings()("node_sqlite3.node");
});

// node_modules/sqlite3/lib/trace.js
var require_trace = __commonJS((exports) => {
  var __filename = "/Users/chris/imessagegraphqlserver/node_modules/sqlite3/lib/trace.js";
  var util = __require("util");
  function extendTrace(object, property, pos) {
    const old = object[property];
    object[property] = function() {
      const error = new Error;
      const name = object.constructor.name + "#" + property + "(" + Array.prototype.slice.call(arguments).map(function(el) {
        return util.inspect(el, false, 0);
      }).join(", ") + ")";
      if (typeof pos === "undefined")
        pos = -1;
      if (pos < 0)
        pos += arguments.length;
      const cb = arguments[pos];
      if (typeof arguments[pos] === "function") {
        arguments[pos] = function replacement() {
          const err = arguments[0];
          if (err && err.stack && !err.__augmented) {
            err.stack = filter(err).join(`
`);
            err.stack += `
--> in ` + name;
            err.stack += `
` + filter(error).slice(1).join(`
`);
            err.__augmented = true;
          }
          return cb.apply(this, arguments);
        };
      }
      return old.apply(this, arguments);
    };
  }
  exports.extendTrace = extendTrace;
  function filter(error) {
    return error.stack.split(`
`).filter(function(line) {
      return line.indexOf(__filename) < 0;
    });
  }
});

// node_modules/sqlite3/lib/sqlite3.js
var require_sqlite3 = __commonJS((exports, module) => {
  var path = __require("path");
  var sqlite3 = require_sqlite3_binding();
  var EventEmitter = __require("events").EventEmitter;
  module.exports = exports = sqlite3;
  function normalizeMethod(fn2) {
    return function(sql) {
      let errBack;
      const args2 = Array.prototype.slice.call(arguments, 1);
      if (typeof args2[args2.length - 1] === "function") {
        const callback = args2[args2.length - 1];
        errBack = function(err) {
          if (err) {
            callback(err);
          }
        };
      }
      const statement = new Statement(this, sql, errBack);
      return fn2.call(this, statement, args2);
    };
  }
  function inherits(target, source) {
    for (const k in source.prototype)
      target.prototype[k] = source.prototype[k];
  }
  sqlite3.cached = {
    Database: function(file, a, b) {
      if (file === "" || file === ":memory:") {
        return new Database(file, a, b);
      }
      let db;
      file = path.resolve(file);
      if (!sqlite3.cached.objects[file]) {
        db = sqlite3.cached.objects[file] = new Database(file, a, b);
      } else {
        db = sqlite3.cached.objects[file];
        const callback = typeof a === "number" ? b : a;
        if (typeof callback === "function") {
          let cb2 = function() {
            callback.call(db, null);
          };
          var cb = cb2;
          if (db.open)
            process.nextTick(cb2);
          else
            db.once("open", cb2);
        }
      }
      return db;
    },
    objects: {}
  };
  var Database = sqlite3.Database;
  var Statement = sqlite3.Statement;
  var Backup = sqlite3.Backup;
  inherits(Database, EventEmitter);
  inherits(Statement, EventEmitter);
  inherits(Backup, EventEmitter);
  Database.prototype.prepare = normalizeMethod(function(statement, params) {
    return params.length ? statement.bind.apply(statement, params) : statement;
  });
  Database.prototype.run = normalizeMethod(function(statement, params) {
    statement.run.apply(statement, params).finalize();
    return this;
  });
  Database.prototype.get = normalizeMethod(function(statement, params) {
    statement.get.apply(statement, params).finalize();
    return this;
  });
  Database.prototype.all = normalizeMethod(function(statement, params) {
    statement.all.apply(statement, params).finalize();
    return this;
  });
  Database.prototype.each = normalizeMethod(function(statement, params) {
    statement.each.apply(statement, params).finalize();
    return this;
  });
  Database.prototype.map = normalizeMethod(function(statement, params) {
    statement.map.apply(statement, params).finalize();
    return this;
  });
  Database.prototype.backup = function() {
    let backup;
    if (arguments.length <= 2) {
      backup = new Backup(this, arguments[0], "main", "main", true, arguments[1]);
    } else {
      backup = new Backup(this, arguments[0], arguments[1], arguments[2], arguments[3], arguments[4]);
    }
    backup.retryErrors = [sqlite3.BUSY, sqlite3.LOCKED];
    return backup;
  };
  Statement.prototype.map = function() {
    const params = Array.prototype.slice.call(arguments);
    const callback = params.pop();
    params.push(function(err, rows) {
      if (err)
        return callback(err);
      const result = {};
      if (rows.length) {
        const keys = Object.keys(rows[0]);
        const key = keys[0];
        if (keys.length > 2) {
          for (let i = 0;i < rows.length; i++) {
            result[rows[i][key]] = rows[i];
          }
        } else {
          const value = keys[1];
          for (let i = 0;i < rows.length; i++) {
            result[rows[i][key]] = rows[i][value];
          }
        }
      }
      callback(err, result);
    });
    return this.all.apply(this, params);
  };
  var isVerbose = false;
  var supportedEvents = ["trace", "profile", "change"];
  Database.prototype.addListener = Database.prototype.on = function(type) {
    const val = EventEmitter.prototype.addListener.apply(this, arguments);
    if (supportedEvents.indexOf(type) >= 0) {
      this.configure(type, true);
    }
    return val;
  };
  Database.prototype.removeListener = function(type) {
    const val = EventEmitter.prototype.removeListener.apply(this, arguments);
    if (supportedEvents.indexOf(type) >= 0 && !this._events[type]) {
      this.configure(type, false);
    }
    return val;
  };
  Database.prototype.removeAllListeners = function(type) {
    const val = EventEmitter.prototype.removeAllListeners.apply(this, arguments);
    if (supportedEvents.indexOf(type) >= 0) {
      this.configure(type, false);
    }
    return val;
  };
  sqlite3.verbose = function() {
    if (!isVerbose) {
      const trace = require_trace();
      [
        "prepare",
        "get",
        "run",
        "all",
        "each",
        "map",
        "close",
        "exec"
      ].forEach(function(name) {
        trace.extendTrace(Database.prototype, name);
      });
      [
        "bind",
        "get",
        "run",
        "all",
        "each",
        "map",
        "reset",
        "finalize"
      ].forEach(function(name) {
        trace.extendTrace(Statement.prototype, name);
      });
      isVerbose = true;
    }
    return sqlite3;
  };
});

// node_modules/blessed/lib/alias.js
var require_alias = __commonJS((exports) => {
  var alias = exports;
  alias.bools = {
    auto_left_margin: ["bw", "bw"],
    auto_right_margin: ["am", "am"],
    back_color_erase: ["bce", "ut"],
    can_change: ["ccc", "cc"],
    ceol_standout_glitch: ["xhp", "xs"],
    col_addr_glitch: ["xhpa", "YA"],
    cpi_changes_res: ["cpix", "YF"],
    cr_cancels_micro_mode: ["crxm", "YB"],
    dest_tabs_magic_smso: ["xt", "xt"],
    eat_newline_glitch: ["xenl", "xn"],
    erase_overstrike: ["eo", "eo"],
    generic_type: ["gn", "gn"],
    hard_copy: ["hc", "hc"],
    hard_cursor: ["chts", "HC"],
    has_meta_key: ["km", "km"],
    has_print_wheel: ["daisy", "YC"],
    has_status_line: ["hs", "hs"],
    hue_lightness_saturation: ["hls", "hl"],
    insert_null_glitch: ["in", "in"],
    lpi_changes_res: ["lpix", "YG"],
    memory_above: ["da", "da"],
    memory_below: ["db", "db"],
    move_insert_mode: ["mir", "mi"],
    move_standout_mode: ["msgr", "ms"],
    needs_xon_xoff: ["nxon", "nx"],
    no_esc_ctlc: ["xsb", "xb"],
    no_pad_char: ["npc", "NP"],
    non_dest_scroll_region: ["ndscr", "ND"],
    non_rev_rmcup: ["nrrmc", "NR"],
    over_strike: ["os", "os"],
    prtr_silent: ["mc5i", "5i"],
    row_addr_glitch: ["xvpa", "YD"],
    semi_auto_right_margin: ["sam", "YE"],
    status_line_esc_ok: ["eslok", "es"],
    tilde_glitch: ["hz", "hz"],
    transparent_underline: ["ul", "ul"],
    xon_xoff: ["xon", "xo"]
  };
  alias.numbers = {
    columns: ["cols", "co"],
    init_tabs: ["it", "it"],
    label_height: ["lh", "lh"],
    label_width: ["lw", "lw"],
    lines: ["lines", "li"],
    lines_of_memory: ["lm", "lm"],
    magic_cookie_glitch: ["xmc", "sg"],
    max_attributes: ["ma", "ma"],
    max_colors: ["colors", "Co"],
    max_pairs: ["pairs", "pa"],
    maximum_windows: ["wnum", "MW"],
    no_color_video: ["ncv", "NC"],
    num_labels: ["nlab", "Nl"],
    padding_baud_rate: ["pb", "pb"],
    virtual_terminal: ["vt", "vt"],
    width_status_line: ["wsl", "ws"],
    bit_image_entwining: ["bitwin", "Yo"],
    bit_image_type: ["bitype", "Yp"],
    buffer_capacity: ["bufsz", "Ya"],
    buttons: ["btns", "BT"],
    dot_horz_spacing: ["spinh", "Yc"],
    dot_vert_spacing: ["spinv", "Yb"],
    max_micro_address: ["maddr", "Yd"],
    max_micro_jump: ["mjump", "Ye"],
    micro_col_size: ["mcs", "Yf"],
    micro_line_size: ["mls", "Yg"],
    number_of_pins: ["npins", "Yh"],
    output_res_char: ["orc", "Yi"],
    output_res_horz_inch: ["orhi", "Yk"],
    output_res_line: ["orl", "Yj"],
    output_res_vert_inch: ["orvi", "Yl"],
    print_rate: ["cps", "Ym"],
    wide_char_size: ["widcs", "Yn"]
  };
  alias.strings = {
    acs_chars: ["acsc", "ac"],
    back_tab: ["cbt", "bt"],
    bell: ["bel", "bl"],
    carriage_return: ["cr", "cr"],
    change_char_pitch: ["cpi", "ZA"],
    change_line_pitch: ["lpi", "ZB"],
    change_res_horz: ["chr", "ZC"],
    change_res_vert: ["cvr", "ZD"],
    change_scroll_region: ["csr", "cs"],
    char_padding: ["rmp", "rP"],
    clear_all_tabs: ["tbc", "ct"],
    clear_margins: ["mgc", "MC"],
    clear_screen: ["clear", "cl"],
    clr_bol: ["el1", "cb"],
    clr_eol: ["el", "ce"],
    clr_eos: ["ed", "cd"],
    column_address: ["hpa", "ch"],
    command_character: ["cmdch", "CC"],
    create_window: ["cwin", "CW"],
    cursor_address: ["cup", "cm"],
    cursor_down: ["cud1", "do"],
    cursor_home: ["home", "ho"],
    cursor_invisible: ["civis", "vi"],
    cursor_left: ["cub1", "le"],
    cursor_mem_address: ["mrcup", "CM"],
    cursor_normal: ["cnorm", "ve"],
    cursor_right: ["cuf1", "nd"],
    cursor_to_ll: ["ll", "ll"],
    cursor_up: ["cuu1", "up"],
    cursor_visible: ["cvvis", "vs"],
    define_char: ["defc", "ZE"],
    delete_character: ["dch1", "dc"],
    delete_line: ["dl1", "dl"],
    dial_phone: ["dial", "DI"],
    dis_status_line: ["dsl", "ds"],
    display_clock: ["dclk", "DK"],
    down_half_line: ["hd", "hd"],
    ena_acs: ["enacs", "eA"],
    enter_alt_charset_mode: ["smacs", "as"],
    enter_am_mode: ["smam", "SA"],
    enter_blink_mode: ["blink", "mb"],
    enter_bold_mode: ["bold", "md"],
    enter_ca_mode: ["smcup", "ti"],
    enter_delete_mode: ["smdc", "dm"],
    enter_dim_mode: ["dim", "mh"],
    enter_doublewide_mode: ["swidm", "ZF"],
    enter_draft_quality: ["sdrfq", "ZG"],
    enter_insert_mode: ["smir", "im"],
    enter_italics_mode: ["sitm", "ZH"],
    enter_leftward_mode: ["slm", "ZI"],
    enter_micro_mode: ["smicm", "ZJ"],
    enter_near_letter_quality: ["snlq", "ZK"],
    enter_normal_quality: ["snrmq", "ZL"],
    enter_protected_mode: ["prot", "mp"],
    enter_reverse_mode: ["rev", "mr"],
    enter_secure_mode: ["invis", "mk"],
    enter_shadow_mode: ["sshm", "ZM"],
    enter_standout_mode: ["smso", "so"],
    enter_subscript_mode: ["ssubm", "ZN"],
    enter_superscript_mode: ["ssupm", "ZO"],
    enter_underline_mode: ["smul", "us"],
    enter_upward_mode: ["sum", "ZP"],
    enter_xon_mode: ["smxon", "SX"],
    erase_chars: ["ech", "ec"],
    exit_alt_charset_mode: ["rmacs", "ae"],
    exit_am_mode: ["rmam", "RA"],
    exit_attribute_mode: ["sgr0", "me"],
    exit_ca_mode: ["rmcup", "te"],
    exit_delete_mode: ["rmdc", "ed"],
    exit_doublewide_mode: ["rwidm", "ZQ"],
    exit_insert_mode: ["rmir", "ei"],
    exit_italics_mode: ["ritm", "ZR"],
    exit_leftward_mode: ["rlm", "ZS"],
    exit_micro_mode: ["rmicm", "ZT"],
    exit_shadow_mode: ["rshm", "ZU"],
    exit_standout_mode: ["rmso", "se"],
    exit_subscript_mode: ["rsubm", "ZV"],
    exit_superscript_mode: ["rsupm", "ZW"],
    exit_underline_mode: ["rmul", "ue"],
    exit_upward_mode: ["rum", "ZX"],
    exit_xon_mode: ["rmxon", "RX"],
    fixed_pause: ["pause", "PA"],
    flash_hook: ["hook", "fh"],
    flash_screen: ["flash", "vb"],
    form_feed: ["ff", "ff"],
    from_status_line: ["fsl", "fs"],
    goto_window: ["wingo", "WG"],
    hangup: ["hup", "HU"],
    init_1string: ["is1", "i1"],
    init_2string: ["is2", "is"],
    init_3string: ["is3", "i3"],
    init_file: ["if", "if"],
    init_prog: ["iprog", "iP"],
    initialize_color: ["initc", "Ic"],
    initialize_pair: ["initp", "Ip"],
    insert_character: ["ich1", "ic"],
    insert_line: ["il1", "al"],
    insert_padding: ["ip", "ip"],
    key_a1: ["ka1", "K1"],
    key_a3: ["ka3", "K3"],
    key_b2: ["kb2", "K2"],
    key_backspace: ["kbs", "kb"],
    key_beg: ["kbeg", "@1"],
    key_btab: ["kcbt", "kB"],
    key_c1: ["kc1", "K4"],
    key_c3: ["kc3", "K5"],
    key_cancel: ["kcan", "@2"],
    key_catab: ["ktbc", "ka"],
    key_clear: ["kclr", "kC"],
    key_close: ["kclo", "@3"],
    key_command: ["kcmd", "@4"],
    key_copy: ["kcpy", "@5"],
    key_create: ["kcrt", "@6"],
    key_ctab: ["kctab", "kt"],
    key_dc: ["kdch1", "kD"],
    key_dl: ["kdl1", "kL"],
    key_down: ["kcud1", "kd"],
    key_eic: ["krmir", "kM"],
    key_end: ["kend", "@7"],
    key_enter: ["kent", "@8"],
    key_eol: ["kel", "kE"],
    key_eos: ["ked", "kS"],
    key_exit: ["kext", "@9"],
    key_f0: ["kf0", "k0"],
    key_f1: ["kf1", "k1"],
    key_f10: ["kf10", "k;"],
    key_f11: ["kf11", "F1"],
    key_f12: ["kf12", "F2"],
    key_f13: ["kf13", "F3"],
    key_f14: ["kf14", "F4"],
    key_f15: ["kf15", "F5"],
    key_f16: ["kf16", "F6"],
    key_f17: ["kf17", "F7"],
    key_f18: ["kf18", "F8"],
    key_f19: ["kf19", "F9"],
    key_f2: ["kf2", "k2"],
    key_f20: ["kf20", "FA"],
    key_f21: ["kf21", "FB"],
    key_f22: ["kf22", "FC"],
    key_f23: ["kf23", "FD"],
    key_f24: ["kf24", "FE"],
    key_f25: ["kf25", "FF"],
    key_f26: ["kf26", "FG"],
    key_f27: ["kf27", "FH"],
    key_f28: ["kf28", "FI"],
    key_f29: ["kf29", "FJ"],
    key_f3: ["kf3", "k3"],
    key_f30: ["kf30", "FK"],
    key_f31: ["kf31", "FL"],
    key_f32: ["kf32", "FM"],
    key_f33: ["kf33", "FN"],
    key_f34: ["kf34", "FO"],
    key_f35: ["kf35", "FP"],
    key_f36: ["kf36", "FQ"],
    key_f37: ["kf37", "FR"],
    key_f38: ["kf38", "FS"],
    key_f39: ["kf39", "FT"],
    key_f4: ["kf4", "k4"],
    key_f40: ["kf40", "FU"],
    key_f41: ["kf41", "FV"],
    key_f42: ["kf42", "FW"],
    key_f43: ["kf43", "FX"],
    key_f44: ["kf44", "FY"],
    key_f45: ["kf45", "FZ"],
    key_f46: ["kf46", "Fa"],
    key_f47: ["kf47", "Fb"],
    key_f48: ["kf48", "Fc"],
    key_f49: ["kf49", "Fd"],
    key_f5: ["kf5", "k5"],
    key_f50: ["kf50", "Fe"],
    key_f51: ["kf51", "Ff"],
    key_f52: ["kf52", "Fg"],
    key_f53: ["kf53", "Fh"],
    key_f54: ["kf54", "Fi"],
    key_f55: ["kf55", "Fj"],
    key_f56: ["kf56", "Fk"],
    key_f57: ["kf57", "Fl"],
    key_f58: ["kf58", "Fm"],
    key_f59: ["kf59", "Fn"],
    key_f6: ["kf6", "k6"],
    key_f60: ["kf60", "Fo"],
    key_f61: ["kf61", "Fp"],
    key_f62: ["kf62", "Fq"],
    key_f63: ["kf63", "Fr"],
    key_f7: ["kf7", "k7"],
    key_f8: ["kf8", "k8"],
    key_f9: ["kf9", "k9"],
    key_find: ["kfnd", "@0"],
    key_help: ["khlp", "%1"],
    key_home: ["khome", "kh"],
    key_ic: ["kich1", "kI"],
    key_il: ["kil1", "kA"],
    key_left: ["kcub1", "kl"],
    key_ll: ["kll", "kH"],
    key_mark: ["kmrk", "%2"],
    key_message: ["kmsg", "%3"],
    key_move: ["kmov", "%4"],
    key_next: ["knxt", "%5"],
    key_npage: ["knp", "kN"],
    key_open: ["kopn", "%6"],
    key_options: ["kopt", "%7"],
    key_ppage: ["kpp", "kP"],
    key_previous: ["kprv", "%8"],
    key_print: ["kprt", "%9"],
    key_redo: ["krdo", "%0"],
    key_reference: ["kref", "&1"],
    key_refresh: ["krfr", "&2"],
    key_replace: ["krpl", "&3"],
    key_restart: ["krst", "&4"],
    key_resume: ["kres", "&5"],
    key_right: ["kcuf1", "kr"],
    key_save: ["ksav", "&6"],
    key_sbeg: ["kBEG", "&9"],
    key_scancel: ["kCAN", "&0"],
    key_scommand: ["kCMD", "*1"],
    key_scopy: ["kCPY", "*2"],
    key_screate: ["kCRT", "*3"],
    key_sdc: ["kDC", "*4"],
    key_sdl: ["kDL", "*5"],
    key_select: ["kslt", "*6"],
    key_send: ["kEND", "*7"],
    key_seol: ["kEOL", "*8"],
    key_sexit: ["kEXT", "*9"],
    key_sf: ["kind", "kF"],
    key_sfind: ["kFND", "*0"],
    key_shelp: ["kHLP", "#1"],
    key_shome: ["kHOM", "#2"],
    key_sic: ["kIC", "#3"],
    key_sleft: ["kLFT", "#4"],
    key_smessage: ["kMSG", "%a"],
    key_smove: ["kMOV", "%b"],
    key_snext: ["kNXT", "%c"],
    key_soptions: ["kOPT", "%d"],
    key_sprevious: ["kPRV", "%e"],
    key_sprint: ["kPRT", "%f"],
    key_sr: ["kri", "kR"],
    key_sredo: ["kRDO", "%g"],
    key_sreplace: ["kRPL", "%h"],
    key_sright: ["kRIT", "%i"],
    key_srsume: ["kRES", "%j"],
    key_ssave: ["kSAV", "!1"],
    key_ssuspend: ["kSPD", "!2"],
    key_stab: ["khts", "kT"],
    key_sundo: ["kUND", "!3"],
    key_suspend: ["kspd", "&7"],
    key_undo: ["kund", "&8"],
    key_up: ["kcuu1", "ku"],
    keypad_local: ["rmkx", "ke"],
    keypad_xmit: ["smkx", "ks"],
    lab_f0: ["lf0", "l0"],
    lab_f1: ["lf1", "l1"],
    lab_f10: ["lf10", "la"],
    lab_f2: ["lf2", "l2"],
    lab_f3: ["lf3", "l3"],
    lab_f4: ["lf4", "l4"],
    lab_f5: ["lf5", "l5"],
    lab_f6: ["lf6", "l6"],
    lab_f7: ["lf7", "l7"],
    lab_f8: ["lf8", "l8"],
    lab_f9: ["lf9", "l9"],
    label_format: ["fln", "Lf"],
    label_off: ["rmln", "LF"],
    label_on: ["smln", "LO"],
    meta_off: ["rmm", "mo"],
    meta_on: ["smm", "mm"],
    micro_column_address: ["mhpa", "ZY"],
    micro_down: ["mcud1", "ZZ"],
    micro_left: ["mcub1", "Za"],
    micro_right: ["mcuf1", "Zb"],
    micro_row_address: ["mvpa", "Zc"],
    micro_up: ["mcuu1", "Zd"],
    newline: ["nel", "nw"],
    order_of_pins: ["porder", "Ze"],
    orig_colors: ["oc", "oc"],
    orig_pair: ["op", "op"],
    pad_char: ["pad", "pc"],
    parm_dch: ["dch", "DC"],
    parm_delete_line: ["dl", "DL"],
    parm_down_cursor: ["cud", "DO"],
    parm_down_micro: ["mcud", "Zf"],
    parm_ich: ["ich", "IC"],
    parm_index: ["indn", "SF"],
    parm_insert_line: ["il", "AL"],
    parm_left_cursor: ["cub", "LE"],
    parm_left_micro: ["mcub", "Zg"],
    parm_right_cursor: ["cuf", "RI"],
    parm_right_micro: ["mcuf", "Zh"],
    parm_rindex: ["rin", "SR"],
    parm_up_cursor: ["cuu", "UP"],
    parm_up_micro: ["mcuu", "Zi"],
    pkey_key: ["pfkey", "pk"],
    pkey_local: ["pfloc", "pl"],
    pkey_xmit: ["pfx", "px"],
    plab_norm: ["pln", "pn"],
    print_screen: ["mc0", "ps"],
    prtr_non: ["mc5p", "pO"],
    prtr_off: ["mc4", "pf"],
    prtr_on: ["mc5", "po"],
    pulse: ["pulse", "PU"],
    quick_dial: ["qdial", "QD"],
    remove_clock: ["rmclk", "RC"],
    repeat_char: ["rep", "rp"],
    req_for_input: ["rfi", "RF"],
    reset_1string: ["rs1", "r1"],
    reset_2string: ["rs2", "r2"],
    reset_3string: ["rs3", "r3"],
    reset_file: ["rf", "rf"],
    restore_cursor: ["rc", "rc"],
    row_address: ["vpa", "cv"],
    save_cursor: ["sc", "sc"],
    scroll_forward: ["ind", "sf"],
    scroll_reverse: ["ri", "sr"],
    select_char_set: ["scs", "Zj"],
    set_attributes: ["sgr", "sa"],
    set_background: ["setb", "Sb"],
    set_bottom_margin: ["smgb", "Zk"],
    set_bottom_margin_parm: ["smgbp", "Zl"],
    set_clock: ["sclk", "SC"],
    set_color_pair: ["scp", "sp"],
    set_foreground: ["setf", "Sf"],
    set_left_margin: ["smgl", "ML"],
    set_left_margin_parm: ["smglp", "Zm"],
    set_right_margin: ["smgr", "MR"],
    set_right_margin_parm: ["smgrp", "Zn"],
    set_tab: ["hts", "st"],
    set_top_margin: ["smgt", "Zo"],
    set_top_margin_parm: ["smgtp", "Zp"],
    set_window: ["wind", "wi"],
    start_bit_image: ["sbim", "Zq"],
    start_char_set_def: ["scsd", "Zr"],
    stop_bit_image: ["rbim", "Zs"],
    stop_char_set_def: ["rcsd", "Zt"],
    subscript_characters: ["subcs", "Zu"],
    superscript_characters: ["supcs", "Zv"],
    tab: ["ht", "ta"],
    these_cause_cr: ["docr", "Zw"],
    to_status_line: ["tsl", "ts"],
    tone: ["tone", "TO"],
    underline_char: ["uc", "uc"],
    up_half_line: ["hu", "hu"],
    user0: ["u0", "u0"],
    user1: ["u1", "u1"],
    user2: ["u2", "u2"],
    user3: ["u3", "u3"],
    user4: ["u4", "u4"],
    user5: ["u5", "u5"],
    user6: ["u6", "u6"],
    user7: ["u7", "u7"],
    user8: ["u8", "u8"],
    user9: ["u9", "u9"],
    wait_tone: ["wait", "WA"],
    xoff_character: ["xoffc", "XF"],
    xon_character: ["xonc", "XN"],
    zero_motion: ["zerom", "Zx"],
    alt_scancode_esc: ["scesa", "S8"],
    bit_image_carriage_return: ["bicr", "Yv"],
    bit_image_newline: ["binel", "Zz"],
    bit_image_repeat: ["birep", "Xy"],
    char_set_names: ["csnm", "Zy"],
    code_set_init: ["csin", "ci"],
    color_names: ["colornm", "Yw"],
    define_bit_image_region: ["defbi", "Yx"],
    device_type: ["devt", "dv"],
    display_pc_char: ["dispc", "S1"],
    end_bit_image_region: ["endbi", "Yy"],
    enter_pc_charset_mode: ["smpch", "S2"],
    enter_scancode_mode: ["smsc", "S4"],
    exit_pc_charset_mode: ["rmpch", "S3"],
    exit_scancode_mode: ["rmsc", "S5"],
    get_mouse: ["getm", "Gm"],
    key_mouse: ["kmous", "Km"],
    mouse_info: ["minfo", "Mi"],
    pc_term_options: ["pctrm", "S6"],
    pkey_plab: ["pfxl", "xl"],
    req_mouse_pos: ["reqmp", "RQ"],
    scancode_escape: ["scesc", "S7"],
    set0_des_seq: ["s0ds", "s0"],
    set1_des_seq: ["s1ds", "s1"],
    set2_des_seq: ["s2ds", "s2"],
    set3_des_seq: ["s3ds", "s3"],
    set_a_background: ["setab", "AB"],
    set_a_foreground: ["setaf", "AF"],
    set_color_band: ["setcolor", "Yz"],
    set_lr_margin: ["smglr", "ML"],
    set_page_length: ["slines", "YZ"],
    set_tb_margin: ["smgtb", "MT"],
    enter_horizontal_hl_mode: ["ehhlm", "Xh"],
    enter_left_hl_mode: ["elhlm", "Xl"],
    enter_low_hl_mode: ["elohlm", "Xo"],
    enter_right_hl_mode: ["erhlm", "Xr"],
    enter_top_hl_mode: ["ethlm", "Xt"],
    enter_vertical_hl_mode: ["evhlm", "Xv"],
    set_a_attributes: ["sgr1", "sA"],
    set_pglen_inch: ["slength", "sL"]
  };
});

// node_modules/blessed/lib/tput.js
var require_tput = __commonJS((exports, module) => {
  var __dirname = "/Users/chris/imessagegraphqlserver/node_modules/blessed/lib";
  var assert = __require("assert");
  var path = __require("path");
  var fs = __require("fs");
  var cp = __require("child_process");
  function Tput(options) {
    if (!(this instanceof Tput)) {
      return new Tput(options);
    }
    options = options || {};
    if (typeof options === "string") {
      options = { terminal: options };
    }
    this.options = options;
    this.terminal = options.terminal || options.term || process.env.TERM || (process.platform === "win32" ? "windows-ansi" : "xterm");
    this.terminal = this.terminal.toLowerCase();
    this.debug = options.debug;
    this.padding = options.padding;
    this.extended = options.extended;
    this.printf = options.printf;
    this.termcap = options.termcap;
    this.error = null;
    this.terminfoPrefix = options.terminfoPrefix;
    this.terminfoFile = options.terminfoFile;
    this.termcapFile = options.termcapFile;
    if (options.terminal || options.term) {
      this.setup();
    }
  }
  Tput.prototype.setup = function() {
    this.error = null;
    try {
      if (this.termcap) {
        try {
          this.injectTermcap();
        } catch (e) {
          if (this.debug)
            throw e;
          this.error = new Error("Termcap parse error.");
          this._useInternalCap(this.terminal);
        }
      } else {
        try {
          this.injectTerminfo();
        } catch (e) {
          if (this.debug)
            throw e;
          this.error = new Error("Terminfo parse error.");
          this._useInternalInfo(this.terminal);
        }
      }
    } catch (e) {
      if (this.debug)
        throw e;
      this.error = new Error("Terminfo not found.");
      this._useXtermInfo();
    }
  };
  Tput.prototype.term = function(is) {
    return this.terminal.indexOf(is) === 0;
  };
  Tput.prototype._debug = function() {
    if (!this.debug)
      return;
    return console.log.apply(console, arguments);
  };
  Tput.prototype._useVt102Cap = function() {
    return this.injectTermcap("vt102");
  };
  Tput.prototype._useXtermCap = function() {
    return this.injectTermcap(__dirname + "/../usr/xterm.termcap");
  };
  Tput.prototype._useXtermInfo = function() {
    return this.injectTerminfo(__dirname + "/../usr/xterm");
  };
  Tput.prototype._useInternalInfo = function(name) {
    name = path.basename(name);
    return this.injectTerminfo(__dirname + "/../usr/" + name);
  };
  Tput.prototype._useInternalCap = function(name) {
    name = path.basename(name);
    return this.injectTermcap(__dirname + "/../usr/" + name + ".termcap");
  };
  Tput.ipaths = [
    process.env.TERMINFO || "",
    (process.env.TERMINFO_DIRS || "").split(":"),
    (process.env.HOME || "") + "/.terminfo",
    "/usr/share/terminfo",
    "/usr/share/lib/terminfo",
    "/usr/lib/terminfo",
    "/usr/local/share/terminfo",
    "/usr/local/share/lib/terminfo",
    "/usr/local/lib/terminfo",
    "/usr/local/ncurses/lib/terminfo",
    "/lib/terminfo"
  ];
  Tput.prototype.readTerminfo = function(term) {
    var data, file, info;
    term = term || this.terminal;
    file = path.normalize(this._prefix(term));
    data = fs.readFileSync(file);
    info = this.parseTerminfo(data, file);
    if (this.debug) {
      this._terminfo = info;
    }
    return info;
  };
  Tput._prefix = Tput.prototype._prefix = function(term) {
    if (term) {
      if (~term.indexOf(path.sep)) {
        return term;
      }
      if (this.terminfoFile) {
        return this.terminfoFile;
      }
    }
    var paths = Tput.ipaths.slice(), file;
    if (this.terminfoPrefix) {
      paths.unshift(this.terminfoPrefix);
    }
    file = this._tprefix(paths, term);
    if (file)
      return file;
    file = this._tprefix(paths, term, true);
    if (file)
      return file;
    throw new Error("Terminfo directory not found.");
  };
  Tput._tprefix = Tput.prototype._tprefix = function(prefix, term, soft) {
    if (!prefix)
      return;
    var file, dir, i, sdiff, sfile, list;
    if (Array.isArray(prefix)) {
      for (i = 0;i < prefix.length; i++) {
        file = this._tprefix(prefix[i], term, soft);
        if (file)
          return file;
      }
      return;
    }
    var find = function(word) {
      var file2, ch;
      file2 = path.resolve(prefix, word[0]);
      try {
        fs.statSync(file2);
        return file2;
      } catch (e) {}
      ch = word[0].charCodeAt(0).toString(16);
      if (ch.length < 2)
        ch = "0" + ch;
      file2 = path.resolve(prefix, ch);
      try {
        fs.statSync(file2);
        return file2;
      } catch (e) {}
    };
    if (!term) {
      try {
        dir = fs.readdirSync(prefix).filter(function(file2) {
          return file2.length !== 1 && !/^[0-9a-fA-F]{2}$/.test(file2);
        });
        if (!dir.length) {
          return prefix;
        }
      } catch (e) {}
      return;
    }
    term = path.basename(term);
    dir = find(term);
    if (!dir)
      return;
    if (soft) {
      try {
        list = fs.readdirSync(dir);
      } catch (e) {
        return;
      }
      list.forEach(function(file2) {
        if (file2.indexOf(term) === 0) {
          var diff = file2.length - term.length;
          if (!sfile || diff < sdiff) {
            sdiff = diff;
            sfile = file2;
          }
        }
      });
      return sfile && (soft || sdiff === 0) ? path.resolve(dir, sfile) : null;
    }
    file = path.resolve(dir, term);
    try {
      fs.statSync(file);
      return file;
    } catch (e) {}
  };
  Tput.prototype.parseTerminfo = function(data, file) {
    var info = {}, extended, l = data.length, i = 0, v, o;
    var h = info.header = {
      dataSize: data.length,
      headerSize: 12,
      magicNumber: data[1] << 8 | data[0],
      namesSize: data[3] << 8 | data[2],
      boolCount: data[5] << 8 | data[4],
      numCount: data[7] << 8 | data[6],
      strCount: data[9] << 8 | data[8],
      strTableSize: data[11] << 8 | data[10]
    };
    h.total = h.headerSize + h.namesSize + h.boolCount + h.numCount * 2 + h.strCount * 2 + h.strTableSize;
    i += h.headerSize;
    var names = data.toString("ascii", i, i + h.namesSize - 1), parts = names.split("|"), name = parts[0], desc = parts.pop();
    info.name = name;
    info.names = parts;
    info.desc = desc;
    info.dir = path.resolve(file, "..", "..");
    info.file = file;
    i += h.namesSize - 1;
    assert.equal(data[i], 0);
    i++;
    info.bools = {};
    l = i + h.boolCount;
    o = 0;
    for (;i < l; i++) {
      v = Tput.bools[o++];
      info.bools[v] = data[i] === 1;
    }
    if (i % 2) {
      assert.equal(data[i], 0);
      i++;
    }
    info.numbers = {};
    l = i + h.numCount * 2;
    o = 0;
    for (;i < l; i += 2) {
      v = Tput.numbers[o++];
      if (data[i + 1] === 255 && data[i] === 255) {
        info.numbers[v] = -1;
      } else {
        info.numbers[v] = data[i + 1] << 8 | data[i];
      }
    }
    info.strings = {};
    l = i + h.strCount * 2;
    o = 0;
    for (;i < l; i += 2) {
      v = Tput.strings[o++];
      if (data[i + 1] === 255 && data[i] === 255) {
        info.strings[v] = -1;
      } else {
        info.strings[v] = data[i + 1] << 8 | data[i];
      }
    }
    Object.keys(info.strings).forEach(function(key) {
      if (info.strings[key] === -1) {
        delete info.strings[key];
        return;
      }
      if (info.strings[key] === 65534) {
        delete info.strings[key];
        return;
      }
      var s = i + info.strings[key], j = s;
      while (data[j])
        j++;
      assert(j < data.length);
      info.strings[key] = data.toString("ascii", s, j);
    });
    if (this.extended !== false) {
      i--;
      i += h.strTableSize;
      if (i % 2) {
        assert.equal(data[i], 0);
        i++;
      }
      l = data.length;
      if (i < l - 1) {
        try {
          extended = this.parseExtended(data.slice(i));
        } catch (e) {
          if (this.debug) {
            throw e;
          }
          return info;
        }
        info.header.extended = extended.header;
        ["bools", "numbers", "strings"].forEach(function(key) {
          merge(info[key], extended[key]);
        });
      }
    }
    return info;
  };
  Tput.prototype.parseExtended = function(data) {
    var info = {}, l = data.length, i = 0;
    var h = info.header = {
      dataSize: data.length,
      headerSize: 10,
      boolCount: data[i + 1] << 8 | data[i + 0],
      numCount: data[i + 3] << 8 | data[i + 2],
      strCount: data[i + 5] << 8 | data[i + 4],
      strTableSize: data[i + 7] << 8 | data[i + 6],
      lastStrTableOffset: data[i + 9] << 8 | data[i + 8]
    };
    h.total = h.headerSize + h.boolCount + h.numCount * 2 + h.strCount * 2 + h.strTableSize;
    i += h.headerSize;
    var _bools = [];
    l = i + h.boolCount;
    for (;i < l; i++) {
      _bools.push(data[i] === 1);
    }
    if (i % 2) {
      assert.equal(data[i], 0);
      i++;
    }
    var _numbers = [];
    l = i + h.numCount * 2;
    for (;i < l; i += 2) {
      if (data[i + 1] === 255 && data[i] === 255) {
        _numbers.push(-1);
      } else {
        _numbers.push(data[i + 1] << 8 | data[i]);
      }
    }
    var _strings = [];
    l = i + h.strCount * 2;
    for (;i < l; i += 2) {
      if (data[i + 1] === 255 && data[i] === 255) {
        _strings.push(-1);
      } else {
        _strings.push(data[i + 1] << 8 | data[i]);
      }
    }
    i = data.length - h.lastStrTableOffset;
    var high = 0;
    _strings.forEach(function(offset, k) {
      if (offset === -1) {
        _strings[k] = "";
        return;
      }
      var s = i + offset, j2 = s;
      while (data[j2])
        j2++;
      assert(j2 < data.length);
      if (high < j2 - i) {
        high = j2 - i;
      }
      _strings[k] = data.toString("ascii", s, j2);
    });
    i += high + 1;
    l = data.length;
    var sym = [], j;
    for (;i < l; i++) {
      j = i;
      while (data[j])
        j++;
      sym.push(data.toString("ascii", i, j));
      i = j;
    }
    j = 0;
    info.bools = {};
    _bools.forEach(function(bool) {
      info.bools[sym[j++]] = bool;
    });
    info.numbers = {};
    _numbers.forEach(function(number) {
      info.numbers[sym[j++]] = number;
    });
    info.strings = {};
    _strings.forEach(function(string) {
      info.strings[sym[j++]] = string;
    });
    assert.equal(i, data.length);
    return info;
  };
  Tput.prototype.compileTerminfo = function(term) {
    return this.compile(this.readTerminfo(term));
  };
  Tput.prototype.injectTerminfo = function(term) {
    return this.inject(this.compileTerminfo(term));
  };
  Tput.prototype.compile = function(info) {
    var self2 = this;
    if (!info) {
      throw new Error("Terminal not found.");
    }
    this.detectFeatures(info);
    this._debug(info);
    info.all = {};
    info.methods = {};
    ["bools", "numbers", "strings"].forEach(function(type) {
      Object.keys(info[type]).forEach(function(key) {
        info.all[key] = info[type][key];
        info.methods[key] = self2._compile(info, key, info.all[key]);
      });
    });
    Tput.bools.forEach(function(key) {
      if (info.methods[key] == null)
        info.methods[key] = false;
    });
    Tput.numbers.forEach(function(key) {
      if (info.methods[key] == null)
        info.methods[key] = -1;
    });
    Tput.strings.forEach(function(key) {
      if (!info.methods[key])
        info.methods[key] = noop;
    });
    Object.keys(info.methods).forEach(function(key) {
      if (!Tput.alias[key])
        return;
      Tput.alias[key].forEach(function(alias) {
        info.methods[alias] = info.methods[key];
      });
    });
    return info;
  };
  Tput.prototype.inject = function(info) {
    var self2 = this, methods = info.methods || info;
    Object.keys(methods).forEach(function(key) {
      if (typeof methods[key] !== "function") {
        self2[key] = methods[key];
        return;
      }
      self2[key] = function() {
        var args2 = Array.prototype.slice.call(arguments);
        return methods[key].call(self2, args2);
      };
    });
    this.info = info;
    this.all = info.all;
    this.methods = info.methods;
    this.bools = info.bools;
    this.numbers = info.numbers;
    this.strings = info.strings;
    if (!~info.names.indexOf(this.terminal)) {
      this.terminal = info.name;
    }
    this.features = info.features;
    Object.keys(info.features).forEach(function(key) {
      if (key === "padding") {
        if (!info.features.padding && self2.options.padding !== true) {
          self2.padding = false;
        }
        return;
      }
      self2[key] = info.features[key];
    });
  };
  Tput.prototype._compile = function(info, key, str) {
    var v;
    this._debug("Compiling %s: %s", key, JSON.stringify(str));
    switch (typeof str) {
      case "boolean":
        return str;
      case "number":
        return str;
      case "string":
        break;
      default:
        return noop;
    }
    if (!str) {
      return noop;
    }
    if (key === "init_file" || key === "reset_file") {
      try {
        str = fs.readFileSync(str, "utf8");
        if (this.debug) {
          v = ("return " + JSON.stringify(str) + ";").replace(/\x1b/g, "\\x1b").replace(/\r/g, "\\r").replace(/\n/g, "\\n");
          process.stdout.write(v + `
`);
        }
        return function() {
          return str;
        };
      } catch (e) {
        return noop;
      }
    }
    var tkey = info.name + "." + key, header = "var v, dyn = {}, stat = {}, stack = [], out = [];", footer = ';return out.join("");', code = header, val = str, buff = "", cap, ch, fi, then, els, end;
    function read(regex, no) {
      cap = regex.exec(val);
      if (!cap)
        return;
      val = val.substring(cap[0].length);
      ch = cap[1];
      if (!no)
        clear();
      return cap;
    }
    function stmt(c) {
      if (code[code.length - 1] === ",") {
        code = code.slice(0, -1);
      }
      code += c;
    }
    function expr(c) {
      code += c + ",";
    }
    function echo(c) {
      if (c === '""')
        return;
      expr("out.push(" + c + ")");
    }
    function print(c) {
      buff += c;
    }
    function clear() {
      if (buff) {
        echo(JSON.stringify(buff).replace(/\\u00([0-9a-fA-F]{2})/g, "\\x$1"));
        buff = "";
      }
    }
    while (val) {
      if (read(/^\n /, true)) {
        continue;
      }
      if (read(/^\^(.)/i, true)) {
        if (!(ch >= " " && ch <= "~")) {
          this._debug("%s: bad caret char.", tkey);
          print(cap[0]);
          continue;
        }
        if (ch === "?") {
          ch = "";
        } else {
          ch = ch.charCodeAt(0) & 31;
          if (ch === 0)
            ch = 128;
          ch = String.fromCharCode(ch);
        }
        print(ch);
        continue;
      }
      if (read(/^\\([0-7]{3})/, true)) {
        print(String.fromCharCode(parseInt(ch, 8)));
        continue;
      }
      if (read(/^\\([eEnlrtbfs\^\\,:0]|.)/, true)) {
        switch (ch) {
          case "e":
          case "E":
            ch = "\x1B";
            break;
          case "n":
            ch = `
`;
            break;
          case "l":
            ch = "";
            break;
          case "r":
            ch = "\r";
            break;
          case "t":
            ch = "\t";
            break;
          case "b":
            ch = "\b";
            break;
          case "f":
            ch = "\f";
            break;
          case "s":
            ch = " ";
            break;
          case "^":
            ch = "^";
            break;
          case "\\":
            ch = "\\";
            break;
          case ",":
            ch = ",";
            break;
          case ":":
            ch = ":";
            break;
          case "0":
            ch = "";
            break;
          case "a":
            ch = "\x07";
            break;
          default:
            this._debug("%s: bad backslash char.", tkey);
            ch = cap[0];
            break;
        }
        print(ch);
        continue;
      }
      if (read(/^\$<(\d+)([*\/]{0,2})>/, true)) {
        if (this.padding)
          print(cap[0]);
        continue;
      }
      if (read(/^%%/, true)) {
        print("%");
        continue;
      }
      if (read(/^%((?::-|[+# ]){1,4})?(\d+(?:\.\d+)?)?([doxXsc])/)) {
        if (this.printf || cap[1] || cap[2] || ~"oxX".indexOf(cap[3])) {
          echo('sprintf("' + cap[0].replace(":-", "-") + '", stack.pop())');
        } else if (cap[3] === "c") {
          echo("(v = stack.pop(), isFinite(v) " + '? String.fromCharCode(v || 0200) : "")');
        } else {
          echo("stack.pop()");
        }
        continue;
      }
      if (read(/^%p([1-9])/)) {
        expr("(stack.push(v = params[" + (ch - 1) + "]), v)");
        continue;
      }
      if (read(/^%P([a-z])/)) {
        expr("dyn." + ch + " = stack.pop()");
        continue;
      }
      if (read(/^%g([a-z])/)) {
        expr("(stack.push(dyn." + ch + "), dyn." + ch + ")");
        continue;
      }
      if (read(/^%P([A-Z])/)) {
        expr("stat." + ch + " = stack.pop()");
        continue;
      }
      if (read(/^%g([A-Z])/)) {
        expr("(stack.push(v = stat." + ch + "), v)");
        continue;
      }
      if (read(/^%'(.)'/)) {
        expr("(stack.push(v = " + ch.charCodeAt(0) + "), v)");
        continue;
      }
      if (read(/^%\{(\d+)\}/)) {
        expr("(stack.push(v = " + ch + "), v)");
        continue;
      }
      if (read(/^%l/)) {
        expr('(stack.push(v = (stack.pop() || "").length || 0), v)');
        continue;
      }
      if (read(/^%([+\-*\/m&|\^=><])/)) {
        if (ch === "=")
          ch = "===";
        else if (ch === "m")
          ch = "%";
        expr("(v = stack.pop()," + " stack.push(v = (stack.pop() " + ch + " v) || 0)," + " v)");
        continue;
      }
      if (read(/^%([AO])/)) {
        expr("(stack.push(v = (stack.pop() " + (ch === "A" ? "&&" : "||") + " stack.pop())), v)");
        continue;
      }
      if (read(/^%([!~])/)) {
        expr("(stack.push(v = " + ch + "stack.pop()), v)");
        continue;
      }
      if (read(/^%i/)) {
        expr("(params[0]++, params[1]++)");
        continue;
      }
      if (read(/^%\?/)) {
        end = -1;
        stmt(";if (");
        continue;
      }
      if (read(/^%t/)) {
        end = -1;
        stmt(") {");
        continue;
      }
      if (read(/^%e/)) {
        fi = val.indexOf("%?");
        then = val.indexOf("%t");
        els = val.indexOf("%e");
        end = val.indexOf("%;");
        if (end === -1)
          end = Infinity;
        if (then !== -1 && then < end && (fi === -1 || then < fi) && (els === -1 || then < els)) {
          stmt("} else if (");
        } else {
          stmt("} else {");
        }
        continue;
      }
      if (read(/^%;/)) {
        end = null;
        stmt("}");
        continue;
      }
      buff += val[0];
      val = val.substring(1);
    }
    clear();
    if (end != null) {
      stmt("}");
    }
    stmt(footer);
    v = code.slice(header.length, -footer.length);
    if (!v.length) {
      code = 'return "";';
    } else if (v = /^out\.push\(("(?:[^"]|\\")+")\)$/.exec(v)) {
      code = "return " + v[1] + ";";
    } else {
      code = code.replace(/\(stack\.push\(v = params\[(\d+)\]\), v\),out\.push\(stack\.pop\(\)\)/g, "out.push(params[$1])");
      v = code.slice(header.length, -footer.length);
      if (!~v.indexOf("v = "))
        code = code.replace("v, ", "");
      if (!~v.indexOf("dyn"))
        code = code.replace("dyn = {}, ", "");
      if (!~v.indexOf("stat"))
        code = code.replace("stat = {}, ", "");
      if (!~v.indexOf("stack"))
        code = code.replace("stack = [], ", "");
      code = code.replace(/out = \[\];out\.push\(("(?:[^"]|\\")+")\),/, "out = [$1];");
    }
    if (str === "\x1B%?") {
      code = 'return "\\x1b";';
    }
    if (this.debug) {
      v = code.replace(/\x1b/g, "\\x1b").replace(/\r/g, "\\r").replace(/\n/g, "\\n");
      process.stdout.write(v + `
`);
    }
    try {
      if (this.options.stringify && code.indexOf("return ") === 0) {
        return new Function("", code)();
      }
      return this.printf || ~code.indexOf("sprintf(") ? new Function("sprintf, params", code).bind(null, sprintf) : new Function("params", code);
    } catch (e) {
      console.error("");
      console.error("Error on %s:", tkey);
      console.error(JSON.stringify(str));
      console.error("");
      console.error(code.replace(/(,|;)/g, `$1
`));
      e.stack = e.stack.replace(/\x1b/g, "\\x1b");
      throw e;
    }
  };
  Tput.prototype._print = function(code, print, done) {
    var xon = !this.bools.needs_xon_xoff || this.bools.xon_xoff;
    print = print || write;
    done = done || noop;
    if (!this.padding) {
      print(code);
      return done();
    }
    var parts = code.split(/(?=\$<[\d.]+[*\/]{0,2}>)/), i = 0;
    (function next() {
      if (i === parts.length) {
        return done();
      }
      var part = parts[i++], padding = /^\$<([\d.]+)([*\/]{0,2})>/.exec(part), amount, suffix;
      if (!padding) {
        print(part);
        return next();
      }
      part = part.substring(padding[0].length);
      amount = +padding[1];
      suffix = padding[2];
      if (xon && !~suffix.indexOf("/")) {
        print(part);
        return next();
      }
      if (~suffix.indexOf("*")) {
        amount = amount;
      }
      return setTimeout(function() {
        print(part);
        return next();
      }, amount);
    })();
  };
  Tput.print = function() {
    var fake = {
      padding: true,
      bools: { needs_xon_xoff: true, xon_xoff: false }
    };
    return Tput.prototype._print.apply(fake, arguments);
  };
  Tput.cpaths = [
    process.env.TERMCAP || "",
    (process.env.TERMPATH || "").split(/[: ]/),
    (process.env.HOME || "") + "/.termcap",
    "/usr/share/misc/termcap",
    "/etc/termcap"
  ];
  Tput.prototype.readTermcap = function(term) {
    var self2 = this, terms, term_, root, paths;
    term = term || this.terminal;
    if (~term.indexOf(path.sep) && (terms = this._tryCap(path.resolve(term)))) {
      term_ = path.basename(term).split(".")[0];
      if (terms[process.env.TERM]) {
        term = process.env.TERM;
      } else if (terms[term_]) {
        term = term_;
      } else {
        term = Object.keys(terms)[0];
      }
    } else {
      paths = Tput.cpaths.slice();
      if (this.termcapFile) {
        paths.unshift(this.termcapFile);
      }
      paths.push(Tput.termcap);
      terms = this._tryCap(paths, term);
    }
    if (!terms) {
      throw new Error("Cannot find termcap for: " + term);
    }
    root = terms[term];
    if (this.debug) {
      this._termcap = terms;
    }
    (function tc(term2) {
      if (term2 && term2.strings.tc) {
        root.inherits = root.inherits || [];
        root.inherits.push(term2.strings.tc);
        var names = terms[term2.strings.tc] ? terms[term2.strings.tc].names : [term2.strings.tc];
        self2._debug("%s inherits from %s.", term2.names.join("/"), names.join("/"));
        var inherit = tc(terms[term2.strings.tc]);
        if (inherit) {
          ["bools", "numbers", "strings"].forEach(function(type) {
            merge(term2[type], inherit[type]);
          });
        }
      }
      return term2;
    })(root);
    root = this.translateTermcap(root);
    return root;
  };
  Tput.prototype._tryCap = function(file, term) {
    if (!file)
      return;
    var terms, data, i;
    if (Array.isArray(file)) {
      for (i = 0;i < file.length; i++) {
        data = this._tryCap(file[i], term);
        if (data)
          return data;
      }
      return;
    }
    data = file[0] === "/" ? tryRead(file) : file;
    if (!data)
      return;
    terms = this.parseTermcap(data, file);
    if (term && !terms[term]) {
      return;
    }
    return terms;
  };
  Tput.prototype.parseTermcap = function(data, file) {
    var terms = {}, parts, term, entries, fields, field, names, i, j, k;
    data = data.replace(/\\\n[ \t]*/g, "");
    data = data.replace(/^#[^\n]+/gm, "");
    entries = data.trim().split(/\n+/);
    for (i = 0;i < entries.length; i++) {
      fields = entries[i].split(/:+/);
      for (j = 0;j < fields.length; j++) {
        field = fields[j].trim();
        if (!field)
          continue;
        if (j === 0) {
          names = field.split("|");
          term = {
            name: names[0],
            names,
            desc: names.pop(),
            file: ~file.indexOf(path.sep) ? path.resolve(file) : file,
            termcap: true
          };
          for (k = 0;k < names.length; k++) {
            terms[names[k]] = term;
          }
          term.bools = {};
          term.numbers = {};
          term.strings = {};
          continue;
        }
        if (~field.indexOf("=")) {
          parts = field.split("=");
          term.strings[parts[0]] = parts.slice(1).join("=");
        } else if (~field.indexOf("#")) {
          parts = field.split("#");
          term.numbers[parts[0]] = +parts.slice(1).join("#");
        } else {
          term.bools[field] = true;
        }
      }
    }
    return terms;
  };
  Tput.prototype.translateTermcap = function(info) {
    var self2 = this, out = {};
    if (!info)
      return;
    this._debug(info);
    ["name", "names", "desc", "file", "termcap"].forEach(function(key) {
      out[key] = info[key];
    });
    var map = function() {
      var out2 = {};
      Object.keys(Tput.alias).forEach(function(key) {
        var aliases = Tput.alias[key];
        out2[aliases.termcap] = key;
      });
      return out2;
    }();
    ["bools", "numbers", "strings"].forEach(function(key) {
      out[key] = {};
      Object.keys(info[key]).forEach(function(cap) {
        if (key === "strings") {
          info.strings[cap] = self2._captoinfo(cap, info.strings[cap], 1);
        }
        if (map[cap]) {
          out[key][map[cap]] = info[key][cap];
        } else {
          out[key][cap] = info[key][cap];
        }
      });
    });
    return out;
  };
  Tput.prototype.compileTermcap = function(term) {
    return this.compile(this.readTermcap(term));
  };
  Tput.prototype.injectTermcap = function(term) {
    return this.inject(this.compileTermcap(term));
  };
  Tput.prototype._captoinfo = function(cap, s, parameterized) {
    var self2 = this;
    var capstart;
    if (parameterized == null) {
      parameterized = 0;
    }
    var MAX_PUSHED = 16, stack2 = [];
    var stackptr = 0, onstack = 0, seenm = 0, seenn = 0, seenr = 0, param = 1, i = 0, out = "";
    function warn() {
      var args2 = Array.prototype.slice.call(arguments);
      args2[0] = "captoinfo: " + (args2[0] || "");
      return self2._debug.apply(self2, args2);
    }
    function isdigit(ch) {
      return ch >= "0" && ch <= "9";
    }
    function isgraph(ch) {
      return ch > " " && ch <= "~";
    }
    function cvtchar(sp) {
      var c = "\x00", len;
      var j = i;
      switch (sp[j]) {
        case "\\":
          switch (sp[++j]) {
            case "'":
            case "$":
            case "\\":
            case "%":
              c = sp[j];
              len = 2;
              break;
            case "\x00":
              c = "\\";
              len = 1;
              break;
            case "0":
            case "1":
            case "2":
            case "3":
              len = 1;
              while (isdigit(sp[j])) {
                c = String.fromCharCode(8 * c.charCodeAt(0) + (sp[j++].charCodeAt(0) - 48));
                len++;
              }
              break;
            default:
              c = sp[j];
              len = 2;
              break;
          }
          break;
        case "^":
          c = String.fromCharCode(sp[++j].charCodeAt(0) & 31);
          len = 2;
          break;
        default:
          c = sp[j];
          len = 1;
      }
      if (isgraph(c) && c !== "," && c !== "'" && c !== "\\" && c !== ":") {
        out += "%'";
        out += c;
        out += "'";
      } else {
        out += "%{";
        if (c.charCodeAt(0) > 99) {
          out += String.fromCharCode((c.charCodeAt(0) / 100 | 0) + 48);
        }
        if (c.charCodeAt(0) > 9) {
          out += String.fromCharCode((c.charCodeAt(0) / 10 | 0) % 10 + 48);
        }
        out += String.fromCharCode(c.charCodeAt(0) % 10 + 48);
        out += "}";
      }
      return len;
    }
    function getparm(parm, n) {
      if (seenr) {
        if (parm === 1) {
          parm = 2;
        } else if (parm === 2) {
          parm = 1;
        }
      }
      if (onstack === parm) {
        if (n > 1) {
          warn("string may not be optimal");
          out += "%Pa";
          while (n--) {
            out += "%ga";
          }
        }
        return;
      }
      if (onstack !== 0) {
        push();
      }
      onstack = parm;
      while (n--) {
        out += "%p";
        out += String.fromCharCode(48 + parm);
      }
      if (seenn && parm < 3) {
        out += "%{96}%^";
      }
      if (seenm && parm < 3) {
        out += "%{127}%^";
      }
    }
    function push() {
      if (stackptr >= MAX_PUSHED) {
        warn("string too complex to convert");
      } else {
        stack2[stackptr++] = onstack;
      }
    }
    function pop() {
      if (stackptr === 0) {
        if (onstack === 0) {
          warn("I'm confused");
        } else {
          onstack = 0;
        }
      } else {
        onstack = stack2[--stackptr];
      }
      param++;
    }
    function see03() {
      getparm(param, 1);
      out += "%3d";
      pop();
    }
    function invalid() {
      out += "%";
      i--;
      warn("unknown %% code %s (%#x) in %s", JSON.stringify(s[i]), s[i].charCodeAt(0), cap);
    }
    capstart = null;
    if (s == null)
      s = "";
    if (parameterized >= 0 && isdigit(s[i])) {
      for (capstart = i;; i++) {
        if (!(isdigit(s[i]) || s[i] === "*" || s[i] === ".")) {
          break;
        }
      }
    }
    while (s[i]) {
      switch (s[i]) {
        case "%":
          i++;
          if (parameterized < 1) {
            out += "%";
            break;
          }
          switch (s[i++]) {
            case "%":
              out += "%";
              break;
            case "r":
              if (seenr++ === 1) {
                warn("saw %%r twice in %s", cap);
              }
              break;
            case "m":
              if (seenm++ === 1) {
                warn("saw %%m twice in %s", cap);
              }
              break;
            case "n":
              if (seenn++ === 1) {
                warn("saw %%n twice in %s", cap);
              }
              break;
            case "i":
              out += "%i";
              break;
            case "6":
            case "B":
              getparm(param, 1);
              out += "%{10}%/%{16}%*";
              getparm(param, 1);
              out += "%{10}%m%+";
              break;
            case "8":
            case "D":
              getparm(param, 2);
              out += "%{2}%*%-";
              break;
            case ">":
              getparm(param, 2);
              out += "%?";
              i += cvtchar(s);
              out += "%>%t";
              i += cvtchar(s);
              out += "%+%;";
              break;
            case "a":
              if ((s[i] === "=" || s[i] === "+" || s[i] === "-" || s[i] === "*" || s[i] === "/") && (s[i + 1] === "p" || s[i + 1] === "c") && s[i + 2] !== "\x00" && s[i + 2]) {
                var l;
                l = 2;
                if (s[i] !== "=") {
                  getparm(param, 1);
                }
                if (s[i + 1] === "p") {
                  getparm(param + s[i + 2].charCodeAt(0) - 64, 1);
                  if (param !== onstack) {
                    pop();
                    param--;
                  }
                  l++;
                } else {
                  i += 2, l += cvtchar(s), i -= 2;
                }
                switch (s[i]) {
                  case "+":
                    out += "%+";
                    break;
                  case "-":
                    out += "%-";
                    break;
                  case "*":
                    out += "%*";
                    break;
                  case "/":
                    out += "%/";
                    break;
                  case "=":
                    if (seenr) {
                      if (param === 1) {
                        onstack = 2;
                      } else if (param === 2) {
                        onstack = 1;
                      } else {
                        onstack = param;
                      }
                    } else {
                      onstack = param;
                    }
                    break;
                }
                i += l;
                break;
              }
              getparm(param, 1);
              i += cvtchar(s);
              out += "%+";
              break;
            case "+":
              getparm(param, 1);
              i += cvtchar(s);
              out += "%+%c";
              pop();
              break;
            case "s":
              getparm(param, 1);
              out += "%s";
              pop();
              break;
            case "-":
              i += cvtchar(s);
              getparm(param, 1);
              out += "%-%c";
              pop();
              break;
            case ".":
              getparm(param, 1);
              out += "%c";
              pop();
              break;
            case "0":
              if (s[i] === "3") {
                see03();
                break;
              } else if (s[i] !== "2") {
                invalid();
                break;
              }
            case "2":
              getparm(param, 1);
              out += "%2d";
              pop();
              break;
            case "3":
              see03();
              break;
            case "d":
              getparm(param, 1);
              out += "%d";
              pop();
              break;
            case "f":
              param++;
              break;
            case "b":
              param--;
              break;
            case "\\":
              out += "%\\";
              break;
            default:
              invalid();
              break;
          }
          break;
        default:
          out += s[i++];
          break;
      }
    }
    if (capstart != null) {
      out += "$<";
      for (i = capstart;; i++) {
        if (isdigit(s[i]) || s[i] === "*" || s[i] === ".") {
          out += s[i];
        } else {
          break;
        }
      }
      out += "/>";
    }
    if (s !== out) {
      warn("Translating %s from %s to %s.", cap, JSON.stringify(s), JSON.stringify(out));
    }
    return out;
  };
  Tput.prototype.getAll = function() {
    var dir = this._prefix(), list = asort(fs.readdirSync(dir)), infos = [];
    list.forEach(function(letter) {
      var terms = asort(fs.readdirSync(path.resolve(dir, letter)));
      infos.push.apply(infos, terms);
    });
    function asort(obj) {
      return obj.sort(function(a, b) {
        a = a.toLowerCase().charCodeAt(0);
        b = b.toLowerCase().charCodeAt(0);
        return a - b;
      });
    }
    return infos;
  };
  Tput.prototype.compileAll = function(start) {
    var self2 = this, all = {};
    this.getAll().forEach(function(name) {
      if (start && name !== start) {
        return;
      } else {
        start = null;
      }
      all[name] = self2.compileTerminfo(name);
    });
    return all;
  };
  Tput.prototype.detectFeatures = function(info) {
    var data = this.parseACS(info);
    info.features = {
      unicode: this.detectUnicode(info),
      brokenACS: this.detectBrokenACS(info),
      PCRomSet: this.detectPCRomSet(info),
      magicCookie: this.detectMagicCookie(info),
      padding: this.detectPadding(info),
      setbuf: this.detectSetbuf(info),
      acsc: data.acsc,
      acscr: data.acscr
    };
    return info.features;
  };
  Tput.prototype.detectUnicode = function() {
    if (this.options.forceUnicode != null) {
      return this.options.forceUnicode;
    }
    var LANG = process.env.LANG + ":" + process.env.LANGUAGE + ":" + process.env.LC_ALL + ":" + process.env.LC_CTYPE;
    return /utf-?8/i.test(LANG) || this.GetConsoleCP() === 65001;
  };
  Tput.prototype.detectBrokenACS = function(info) {
    if (process.env.NCURSES_NO_UTF8_ACS != null) {
      return !!+process.env.NCURSES_NO_UTF8_ACS;
    }
    if (info.numbers.U8 >= 0) {
      return !!info.numbers.U8;
    }
    if (info.name === "linux") {
      return true;
    }
    if (this.detectPCRomSet(info)) {
      return true;
    }
    if (this.termcap && info.name.indexOf("screen") === 0 && process.env.TERMCAP && ~process.env.TERMCAP.indexOf("screen") && ~process.env.TERMCAP.indexOf("hhII00")) {
      if (~info.strings.enter_alt_charset_mode.indexOf("\x0E") || ~info.strings.enter_alt_charset_mode.indexOf("\x0F") || ~info.strings.set_attributes.indexOf("\x0E") || ~info.strings.set_attributes.indexOf("\x0F")) {
        return true;
      }
    }
    return false;
  };
  Tput.prototype.detectPCRomSet = function(info) {
    var s = info.strings;
    if (s.enter_pc_charset_mode && s.enter_alt_charset_mode && s.enter_pc_charset_mode === s.enter_alt_charset_mode && s.exit_pc_charset_mode === s.exit_alt_charset_mode) {
      return true;
    }
    return false;
  };
  Tput.prototype.detectMagicCookie = function() {
    return process.env.NCURSES_NO_MAGIC_COOKIE == null;
  };
  Tput.prototype.detectPadding = function() {
    return process.env.NCURSES_NO_PADDING == null;
  };
  Tput.prototype.detectSetbuf = function() {
    return process.env.NCURSES_NO_SETBUF == null;
  };
  Tput.prototype.parseACS = function(info) {
    var data = {};
    data.acsc = {};
    data.acscr = {};
    if (this.detectPCRomSet(info)) {
      return data;
    }
    Object.keys(Tput.acsc).forEach(function(ch) {
      var acs_chars = info.strings.acs_chars || "", i = acs_chars.indexOf(ch), next = acs_chars[i + 1];
      if (!next || i === -1 || !Tput.acsc[next]) {
        return;
      }
      data.acsc[ch] = Tput.acsc[next];
      data.acscr[Tput.acsc[next]] = ch;
    });
    return data;
  };
  Tput.prototype.GetConsoleCP = function() {
    var ccp;
    if (process.platform !== "win32") {
      return -1;
    }
    if (+process.env.NCURSES_UNICODE !== 0) {
      return 65001;
    }
    try {
      ccp = cp.execFileSync(process.env.WINDIR + "\\system32\\chcp.com", [], {
        stdio: ["ignore", "pipe", "ignore"],
        encoding: "ascii",
        timeout: 1500
      });
    } catch (e) {}
    ccp = /\d+/.exec(ccp);
    if (!ccp) {
      return -1;
    }
    ccp = +ccp[0];
    return ccp;
  };
  function noop() {
    return "";
  }
  noop.unsupported = true;
  function merge(a, b) {
    Object.keys(b).forEach(function(key) {
      a[key] = b[key];
    });
    return a;
  }
  function write(data) {
    return process.stdout.write(data);
  }
  function tryRead(file) {
    if (Array.isArray(file)) {
      for (var i = 0;i < file.length; i++) {
        var data = tryRead(file[i]);
        if (data)
          return data;
      }
      return "";
    }
    if (!file)
      return "";
    file = path.resolve.apply(path, arguments);
    try {
      return fs.readFileSync(file, "utf8");
    } catch (e) {
      return "";
    }
  }
  function sprintf(src) {
    var params = Array.prototype.slice.call(arguments, 1), rule = /%([\-+# ]{1,4})?(\d+(?:\.\d+)?)?([doxXsc])/g, i = 0;
    return src.replace(rule, function(_, flag, width, type) {
      var flags = (flag || "").split(""), param = params[i] != null ? params[i] : "", initial = param, opt = {}, pre = "";
      i++;
      switch (type) {
        case "d":
          param = (+param).toString(10);
          break;
        case "o":
          param = (+param).toString(8);
          break;
        case "x":
          param = (+param).toString(16);
          break;
        case "X":
          param = (+param).toString(16).toUppercase();
          break;
        case "s":
          break;
        case "c":
          param = isFinite(param) ? String.fromCharCode(param || 128) : "";
          break;
      }
      flags.forEach(function(flag2) {
        switch (flag2) {
          case "-":
            opt.left = true;
            break;
          case "+":
            opt.signs = true;
            break;
          case "#":
            opt.hexpoint = true;
            break;
          case " ":
            opt.space = true;
            break;
        }
      });
      width = +width.split(".")[0];
      if (width && !opt.left) {
        param = param + "";
        while (param.length < width) {
          param = "0" + param;
        }
      }
      if (opt.signs) {
        if (+initial >= 0) {
          pre += "+";
        }
      }
      if (opt.space) {
        if (!opt.signs && +initial >= 0) {
          pre += " ";
        }
      }
      if (opt.hexpoint) {
        switch (type) {
          case "o":
            pre += "0";
            break;
          case "x":
            pre += "0x";
            break;
          case "X":
            pre += "0X";
            break;
        }
      }
      if (opt.left) {
        if (width > pre.length + param.length) {
          width -= pre.length + param.length;
          pre = Array(width + 1).join(" ") + pre;
        }
      }
      return pre + param;
    });
  }
  Tput._alias = require_alias();
  Tput.alias = {};
  ["bools", "numbers", "strings"].forEach(function(type) {
    Object.keys(Tput._alias[type]).forEach(function(key) {
      var aliases = Tput._alias[type][key];
      Tput.alias[key] = [aliases[0]];
      Tput.alias[key].terminfo = aliases[0];
      Tput.alias[key].termcap = aliases[1];
    });
  });
  Tput.alias.no_esc_ctlc.push("beehive_glitch");
  Tput.alias.dest_tabs_magic_smso.push("teleray_glitch");
  Tput.alias.micro_col_size.push("micro_char_size");
  Tput.aliasMap = {};
  Object.keys(Tput.alias).forEach(function(key) {
    Tput.aliasMap[key] = key;
    Tput.alias[key].forEach(function(k) {
      Tput.aliasMap[k] = key;
    });
  });
  Tput.prototype.has = function(name) {
    name = Tput.aliasMap[name];
    var val = this.all[name];
    if (!name)
      return false;
    if (typeof val === "number") {
      return val !== -1;
    }
    return !!val;
  };
  Tput.termcap = "" + "vt102|dec vt102:" + ":do=^J:co#80:li#24:cl=50\\E[;H\\E[2J:" + ":le=^H:bs:cm=5\\E[%i%d;%dH:nd=2\\E[C:up=2\\E[A:" + ":ce=3\\E[K:cd=50\\E[J:so=2\\E[7m:se=2\\E[m:us=2\\E[4m:ue=2\\E[m:" + ":md=2\\E[1m:mr=2\\E[7m:mb=2\\E[5m:me=2\\E[m:is=\\E[1;24r\\E[24;1H:" + ":rs=\\E>\\E[?3l\\E[?4l\\E[?5l\\E[?7h\\E[?8h:ks=\\E[?1h\\E=:ke=\\E[?1l\\E>:" + ":ku=\\EOA:kd=\\EOB:kr=\\EOC:kl=\\EOD:kb=^H:\\\n" + ":ho=\\E[H:k1=\\EOP:k2=\\EOQ:k3=\\EOR:k4=\\EOS:pt:sr=5\\EM:vt#3:" + ":sc=\\E7:rc=\\E8:cs=\\E[%i%d;%dr:vs=\\E[?7l:ve=\\E[?7h:" + ":mi:al=\\E[L:dc=\\E[P:dl=\\E[M:ei=\\E[4l:im=\\E[4h:";
  Tput.bools = [
    "auto_left_margin",
    "auto_right_margin",
    "no_esc_ctlc",
    "ceol_standout_glitch",
    "eat_newline_glitch",
    "erase_overstrike",
    "generic_type",
    "hard_copy",
    "has_meta_key",
    "has_status_line",
    "insert_null_glitch",
    "memory_above",
    "memory_below",
    "move_insert_mode",
    "move_standout_mode",
    "over_strike",
    "status_line_esc_ok",
    "dest_tabs_magic_smso",
    "tilde_glitch",
    "transparent_underline",
    "xon_xoff",
    "needs_xon_xoff",
    "prtr_silent",
    "hard_cursor",
    "non_rev_rmcup",
    "no_pad_char",
    "non_dest_scroll_region",
    "can_change",
    "back_color_erase",
    "hue_lightness_saturation",
    "col_addr_glitch",
    "cr_cancels_micro_mode",
    "has_print_wheel",
    "row_addr_glitch",
    "semi_auto_right_margin",
    "cpi_changes_res",
    "lpi_changes_res",
    "backspaces_with_bs",
    "crt_no_scrolling",
    "no_correctly_working_cr",
    "gnu_has_meta_key",
    "linefeed_is_newline",
    "has_hardware_tabs",
    "return_does_clr_eol"
  ];
  Tput.numbers = [
    "columns",
    "init_tabs",
    "lines",
    "lines_of_memory",
    "magic_cookie_glitch",
    "padding_baud_rate",
    "virtual_terminal",
    "width_status_line",
    "num_labels",
    "label_height",
    "label_width",
    "max_attributes",
    "maximum_windows",
    "max_colors",
    "max_pairs",
    "no_color_video",
    "buffer_capacity",
    "dot_vert_spacing",
    "dot_horz_spacing",
    "max_micro_address",
    "max_micro_jump",
    "micro_col_size",
    "micro_line_size",
    "number_of_pins",
    "output_res_char",
    "output_res_line",
    "output_res_horz_inch",
    "output_res_vert_inch",
    "print_rate",
    "wide_char_size",
    "buttons",
    "bit_image_entwining",
    "bit_image_type",
    "magic_cookie_glitch_ul",
    "carriage_return_delay",
    "new_line_delay",
    "backspace_delay",
    "horizontal_tab_delay",
    "number_of_function_keys"
  ];
  Tput.strings = [
    "back_tab",
    "bell",
    "carriage_return",
    "change_scroll_region",
    "clear_all_tabs",
    "clear_screen",
    "clr_eol",
    "clr_eos",
    "column_address",
    "command_character",
    "cursor_address",
    "cursor_down",
    "cursor_home",
    "cursor_invisible",
    "cursor_left",
    "cursor_mem_address",
    "cursor_normal",
    "cursor_right",
    "cursor_to_ll",
    "cursor_up",
    "cursor_visible",
    "delete_character",
    "delete_line",
    "dis_status_line",
    "down_half_line",
    "enter_alt_charset_mode",
    "enter_blink_mode",
    "enter_bold_mode",
    "enter_ca_mode",
    "enter_delete_mode",
    "enter_dim_mode",
    "enter_insert_mode",
    "enter_secure_mode",
    "enter_protected_mode",
    "enter_reverse_mode",
    "enter_standout_mode",
    "enter_underline_mode",
    "erase_chars",
    "exit_alt_charset_mode",
    "exit_attribute_mode",
    "exit_ca_mode",
    "exit_delete_mode",
    "exit_insert_mode",
    "exit_standout_mode",
    "exit_underline_mode",
    "flash_screen",
    "form_feed",
    "from_status_line",
    "init_1string",
    "init_2string",
    "init_3string",
    "init_file",
    "insert_character",
    "insert_line",
    "insert_padding",
    "key_backspace",
    "key_catab",
    "key_clear",
    "key_ctab",
    "key_dc",
    "key_dl",
    "key_down",
    "key_eic",
    "key_eol",
    "key_eos",
    "key_f0",
    "key_f1",
    "key_f10",
    "key_f2",
    "key_f3",
    "key_f4",
    "key_f5",
    "key_f6",
    "key_f7",
    "key_f8",
    "key_f9",
    "key_home",
    "key_ic",
    "key_il",
    "key_left",
    "key_ll",
    "key_npage",
    "key_ppage",
    "key_right",
    "key_sf",
    "key_sr",
    "key_stab",
    "key_up",
    "keypad_local",
    "keypad_xmit",
    "lab_f0",
    "lab_f1",
    "lab_f10",
    "lab_f2",
    "lab_f3",
    "lab_f4",
    "lab_f5",
    "lab_f6",
    "lab_f7",
    "lab_f8",
    "lab_f9",
    "meta_off",
    "meta_on",
    "newline",
    "pad_char",
    "parm_dch",
    "parm_delete_line",
    "parm_down_cursor",
    "parm_ich",
    "parm_index",
    "parm_insert_line",
    "parm_left_cursor",
    "parm_right_cursor",
    "parm_rindex",
    "parm_up_cursor",
    "pkey_key",
    "pkey_local",
    "pkey_xmit",
    "print_screen",
    "prtr_off",
    "prtr_on",
    "repeat_char",
    "reset_1string",
    "reset_2string",
    "reset_3string",
    "reset_file",
    "restore_cursor",
    "row_address",
    "save_cursor",
    "scroll_forward",
    "scroll_reverse",
    "set_attributes",
    "set_tab",
    "set_window",
    "tab",
    "to_status_line",
    "underline_char",
    "up_half_line",
    "init_prog",
    "key_a1",
    "key_a3",
    "key_b2",
    "key_c1",
    "key_c3",
    "prtr_non",
    "char_padding",
    "acs_chars",
    "plab_norm",
    "key_btab",
    "enter_xon_mode",
    "exit_xon_mode",
    "enter_am_mode",
    "exit_am_mode",
    "xon_character",
    "xoff_character",
    "ena_acs",
    "label_on",
    "label_off",
    "key_beg",
    "key_cancel",
    "key_close",
    "key_command",
    "key_copy",
    "key_create",
    "key_end",
    "key_enter",
    "key_exit",
    "key_find",
    "key_help",
    "key_mark",
    "key_message",
    "key_move",
    "key_next",
    "key_open",
    "key_options",
    "key_previous",
    "key_print",
    "key_redo",
    "key_reference",
    "key_refresh",
    "key_replace",
    "key_restart",
    "key_resume",
    "key_save",
    "key_suspend",
    "key_undo",
    "key_sbeg",
    "key_scancel",
    "key_scommand",
    "key_scopy",
    "key_screate",
    "key_sdc",
    "key_sdl",
    "key_select",
    "key_send",
    "key_seol",
    "key_sexit",
    "key_sfind",
    "key_shelp",
    "key_shome",
    "key_sic",
    "key_sleft",
    "key_smessage",
    "key_smove",
    "key_snext",
    "key_soptions",
    "key_sprevious",
    "key_sprint",
    "key_sredo",
    "key_sreplace",
    "key_sright",
    "key_srsume",
    "key_ssave",
    "key_ssuspend",
    "key_sundo",
    "req_for_input",
    "key_f11",
    "key_f12",
    "key_f13",
    "key_f14",
    "key_f15",
    "key_f16",
    "key_f17",
    "key_f18",
    "key_f19",
    "key_f20",
    "key_f21",
    "key_f22",
    "key_f23",
    "key_f24",
    "key_f25",
    "key_f26",
    "key_f27",
    "key_f28",
    "key_f29",
    "key_f30",
    "key_f31",
    "key_f32",
    "key_f33",
    "key_f34",
    "key_f35",
    "key_f36",
    "key_f37",
    "key_f38",
    "key_f39",
    "key_f40",
    "key_f41",
    "key_f42",
    "key_f43",
    "key_f44",
    "key_f45",
    "key_f46",
    "key_f47",
    "key_f48",
    "key_f49",
    "key_f50",
    "key_f51",
    "key_f52",
    "key_f53",
    "key_f54",
    "key_f55",
    "key_f56",
    "key_f57",
    "key_f58",
    "key_f59",
    "key_f60",
    "key_f61",
    "key_f62",
    "key_f63",
    "clr_bol",
    "clear_margins",
    "set_left_margin",
    "set_right_margin",
    "label_format",
    "set_clock",
    "display_clock",
    "remove_clock",
    "create_window",
    "goto_window",
    "hangup",
    "dial_phone",
    "quick_dial",
    "tone",
    "pulse",
    "flash_hook",
    "fixed_pause",
    "wait_tone",
    "user0",
    "user1",
    "user2",
    "user3",
    "user4",
    "user5",
    "user6",
    "user7",
    "user8",
    "user9",
    "orig_pair",
    "orig_colors",
    "initialize_color",
    "initialize_pair",
    "set_color_pair",
    "set_foreground",
    "set_background",
    "change_char_pitch",
    "change_line_pitch",
    "change_res_horz",
    "change_res_vert",
    "define_char",
    "enter_doublewide_mode",
    "enter_draft_quality",
    "enter_italics_mode",
    "enter_leftward_mode",
    "enter_micro_mode",
    "enter_near_letter_quality",
    "enter_normal_quality",
    "enter_shadow_mode",
    "enter_subscript_mode",
    "enter_superscript_mode",
    "enter_upward_mode",
    "exit_doublewide_mode",
    "exit_italics_mode",
    "exit_leftward_mode",
    "exit_micro_mode",
    "exit_shadow_mode",
    "exit_subscript_mode",
    "exit_superscript_mode",
    "exit_upward_mode",
    "micro_column_address",
    "micro_down",
    "micro_left",
    "micro_right",
    "micro_row_address",
    "micro_up",
    "order_of_pins",
    "parm_down_micro",
    "parm_left_micro",
    "parm_right_micro",
    "parm_up_micro",
    "select_char_set",
    "set_bottom_margin",
    "set_bottom_margin_parm",
    "set_left_margin_parm",
    "set_right_margin_parm",
    "set_top_margin",
    "set_top_margin_parm",
    "start_bit_image",
    "start_char_set_def",
    "stop_bit_image",
    "stop_char_set_def",
    "subscript_characters",
    "superscript_characters",
    "these_cause_cr",
    "zero_motion",
    "char_set_names",
    "key_mouse",
    "mouse_info",
    "req_mouse_pos",
    "get_mouse",
    "set_a_foreground",
    "set_a_background",
    "pkey_plab",
    "device_type",
    "code_set_init",
    "set0_des_seq",
    "set1_des_seq",
    "set2_des_seq",
    "set3_des_seq",
    "set_lr_margin",
    "set_tb_margin",
    "bit_image_repeat",
    "bit_image_newline",
    "bit_image_carriage_return",
    "color_names",
    "define_bit_image_region",
    "end_bit_image_region",
    "set_color_band",
    "set_page_length",
    "display_pc_char",
    "enter_pc_charset_mode",
    "exit_pc_charset_mode",
    "enter_scancode_mode",
    "exit_scancode_mode",
    "pc_term_options",
    "scancode_escape",
    "alt_scancode_esc",
    "enter_horizontal_hl_mode",
    "enter_left_hl_mode",
    "enter_low_hl_mode",
    "enter_right_hl_mode",
    "enter_top_hl_mode",
    "enter_vertical_hl_mode",
    "set_a_attributes",
    "set_pglen_inch",
    "termcap_init2",
    "termcap_reset",
    "linefeed_if_not_lf",
    "backspace_if_not_bs",
    "other_non_function_keys",
    "arrow_key_map",
    "acs_ulcorner",
    "acs_llcorner",
    "acs_urcorner",
    "acs_lrcorner",
    "acs_ltee",
    "acs_rtee",
    "acs_btee",
    "acs_ttee",
    "acs_hline",
    "acs_vline",
    "acs_plus",
    "memory_lock",
    "memory_unlock",
    "box_chars_1"
  ];
  Tput.acsc = {
    "`": "",
    a: "",
    b: "\t",
    c: "\f",
    d: "\r",
    e: `
`,
    f: "",
    g: "",
    h: "",
    i: "\v",
    j: "",
    k: "",
    l: "",
    m: "",
    n: "",
    o: "",
    p: "",
    q: "",
    r: "",
    s: "",
    t: "",
    u: "",
    v: "",
    w: "",
    x: "",
    y: "",
    z: "",
    "{": "",
    "|": "",
    "}": "",
    "~": ""
  };
  Tput.utoa = Tput.prototype.utoa = {
    "": "*",
    "": " ",
    "": "*",
    "": "+",
    "": `
`,
    "": "+",
    "": "+",
    "": "+",
    "": "+",
    "": "+",
    "": "-",
    "": "-",
    "": "-",
    "": "-",
    "": "_",
    "": "+",
    "": "+",
    "": "+",
    "": "+",
    "": "|",
    "": "<",
    "": ">",
    "": "?",
    "": "=",
    "": "?",
    "": "*"
  };
  exports = Tput;
  exports.sprintf = sprintf;
  exports.tryRead = tryRead;
  module.exports = exports;
});

// node_modules/blessed/lib/colors.js
var require_colors = __commonJS((exports) => {
  exports.match = function(r1, g1, b1) {
    if (typeof r1 === "string") {
      var hex = r1;
      if (hex[0] !== "#") {
        return -1;
      }
      hex = exports.hexToRGB(hex);
      r1 = hex[0], g1 = hex[1], b1 = hex[2];
    } else if (Array.isArray(r1)) {
      b1 = r1[2], g1 = r1[1], r1 = r1[0];
    }
    var hash = r1 << 16 | g1 << 8 | b1;
    if (exports._cache[hash] != null) {
      return exports._cache[hash];
    }
    var ldiff = Infinity, li = -1, i = 0, c, r2, g2, b2, diff;
    for (;i < exports.vcolors.length; i++) {
      c = exports.vcolors[i];
      r2 = c[0];
      g2 = c[1];
      b2 = c[2];
      diff = colorDistance(r1, g1, b1, r2, g2, b2);
      if (diff === 0) {
        li = i;
        break;
      }
      if (diff < ldiff) {
        ldiff = diff;
        li = i;
      }
    }
    return exports._cache[hash] = li;
  };
  exports.RGBToHex = function(r, g, b) {
    if (Array.isArray(r)) {
      b = r[2], g = r[1], r = r[0];
    }
    function hex(n) {
      n = n.toString(16);
      if (n.length < 2)
        n = "0" + n;
      return n;
    }
    return "#" + hex(r) + hex(g) + hex(b);
  };
  exports.hexToRGB = function(hex) {
    if (hex.length === 4) {
      hex = hex[0] + hex[1] + hex[1] + hex[2] + hex[2] + hex[3] + hex[3];
    }
    var col = parseInt(hex.substring(1), 16), r = col >> 16 & 255, g = col >> 8 & 255, b = col & 255;
    return [r, g, b];
  };
  function colorDistance(r1, g1, b1, r2, g2, b2) {
    return Math.pow(30 * (r1 - r2), 2) + Math.pow(59 * (g1 - g2), 2) + Math.pow(11 * (b1 - b2), 2);
  }
  exports.mixColors = function(c1, c2, alpha) {
    if (c1 === 511)
      c1 = 0;
    if (c2 === 511)
      c2 = 0;
    if (alpha == null)
      alpha = 0.5;
    c1 = exports.vcolors[c1];
    var r1 = c1[0];
    var g1 = c1[1];
    var b1 = c1[2];
    c2 = exports.vcolors[c2];
    var r2 = c2[0];
    var g2 = c2[1];
    var b2 = c2[2];
    r1 += (r2 - r1) * alpha | 0;
    g1 += (g2 - g1) * alpha | 0;
    b1 += (b2 - b1) * alpha | 0;
    return exports.match([r1, g1, b1]);
  };
  exports.blend = function blend(attr, attr2, alpha) {
    var name, i, c, nc;
    var bg = attr & 511;
    if (attr2 != null) {
      var bg2 = attr2 & 511;
      if (bg === 511)
        bg = 0;
      if (bg2 === 511)
        bg2 = 0;
      bg = exports.mixColors(bg, bg2, alpha);
    } else {
      if (blend._cache[bg] != null) {
        bg = blend._cache[bg];
      } else if (bg >= 8 && bg <= 15) {
        bg -= 8;
      } else {
        name = exports.ncolors[bg];
        if (name) {
          for (i = 0;i < exports.ncolors.length; i++) {
            if (name === exports.ncolors[i] && i !== bg) {
              c = exports.vcolors[bg];
              nc = exports.vcolors[i];
              if (nc[0] + nc[1] + nc[2] < c[0] + c[1] + c[2]) {
                blend._cache[bg] = i;
                bg = i;
                break;
              }
            }
          }
        }
      }
    }
    attr &= ~511;
    attr |= bg;
    var fg = attr >> 9 & 511;
    if (attr2 != null) {
      var fg2 = attr2 >> 9 & 511;
      if (fg === 511) {
        fg = 248;
      } else {
        if (fg === 511)
          fg = 7;
        if (fg2 === 511)
          fg2 = 7;
        fg = exports.mixColors(fg, fg2, alpha);
      }
    } else {
      if (blend._cache[fg] != null) {
        fg = blend._cache[fg];
      } else if (fg >= 8 && fg <= 15) {
        fg -= 8;
      } else {
        name = exports.ncolors[fg];
        if (name) {
          for (i = 0;i < exports.ncolors.length; i++) {
            if (name === exports.ncolors[i] && i !== fg) {
              c = exports.vcolors[fg];
              nc = exports.vcolors[i];
              if (nc[0] + nc[1] + nc[2] < c[0] + c[1] + c[2]) {
                blend._cache[fg] = i;
                fg = i;
                break;
              }
            }
          }
        }
      }
    }
    attr &= ~(511 << 9);
    attr |= fg << 9;
    return attr;
  };
  exports.blend._cache = {};
  exports._cache = {};
  exports.reduce = function(color, total) {
    if (color >= 16 && total <= 16) {
      color = exports.ccolors[color];
    } else if (color >= 8 && total <= 8) {
      color -= 8;
    } else if (color >= 2 && total <= 2) {
      color %= 2;
    }
    return color;
  };
  exports.xterm = [
    "#000000",
    "#cd0000",
    "#00cd00",
    "#cdcd00",
    "#0000ee",
    "#cd00cd",
    "#00cdcd",
    "#e5e5e5",
    "#7f7f7f",
    "#ff0000",
    "#00ff00",
    "#ffff00",
    "#5c5cff",
    "#ff00ff",
    "#00ffff",
    "#ffffff"
  ];
  exports.colors = function() {
    var cols = exports.colors = [], _cols = exports.vcolors = [], r, g, b, i, l;
    function hex(n) {
      n = n.toString(16);
      if (n.length < 2)
        n = "0" + n;
      return n;
    }
    function push(i2, r2, g2, b2) {
      cols[i2] = "#" + hex(r2) + hex(g2) + hex(b2);
      _cols[i2] = [r2, g2, b2];
    }
    exports.xterm.forEach(function(c, i2) {
      c = parseInt(c.substring(1), 16);
      push(i2, c >> 16 & 255, c >> 8 & 255, c & 255);
    });
    for (r = 0;r < 6; r++) {
      for (g = 0;g < 6; g++) {
        for (b = 0;b < 6; b++) {
          i = 16 + r * 36 + g * 6 + b;
          push(i, r ? r * 40 + 55 : 0, g ? g * 40 + 55 : 0, b ? b * 40 + 55 : 0);
        }
      }
    }
    for (g = 0;g < 24; g++) {
      l = g * 10 + 8;
      i = 232 + g;
      push(i, l, l, l);
    }
    return cols;
  }();
  exports.ccolors = function() {
    var _cols = exports.vcolors.slice(), cols = exports.colors.slice(), out;
    exports.vcolors = exports.vcolors.slice(0, 8);
    exports.colors = exports.colors.slice(0, 8);
    out = cols.map(exports.match);
    exports.colors = cols;
    exports.vcolors = _cols;
    exports.ccolors = out;
    return out;
  }();
  var colorNames = exports.colorNames = {
    default: -1,
    normal: -1,
    bg: -1,
    fg: -1,
    black: 0,
    red: 1,
    green: 2,
    yellow: 3,
    blue: 4,
    magenta: 5,
    cyan: 6,
    white: 7,
    lightblack: 8,
    lightred: 9,
    lightgreen: 10,
    lightyellow: 11,
    lightblue: 12,
    lightmagenta: 13,
    lightcyan: 14,
    lightwhite: 15,
    brightblack: 8,
    brightred: 9,
    brightgreen: 10,
    brightyellow: 11,
    brightblue: 12,
    brightmagenta: 13,
    brightcyan: 14,
    brightwhite: 15,
    grey: 8,
    gray: 8,
    lightgrey: 7,
    lightgray: 7,
    brightgrey: 7,
    brightgray: 7
  };
  exports.convert = function(color) {
    if (typeof color === "number") {} else if (typeof color === "string") {
      color = color.replace(/[\- ]/g, "");
      if (colorNames[color] != null) {
        color = colorNames[color];
      } else {
        color = exports.match(color);
      }
    } else if (Array.isArray(color)) {
      color = exports.match(color);
    } else {
      color = -1;
    }
    return color !== -1 ? color : 511;
  };
  exports.ccolors = {
    blue: [
      4,
      12,
      [17, 21],
      [24, 27],
      [31, 33],
      [38, 39],
      45,
      [54, 57],
      [60, 63],
      [67, 69],
      [74, 75],
      81,
      [91, 93],
      [97, 99],
      [103, 105],
      [110, 111],
      117,
      [128, 129],
      [134, 135],
      [140, 141],
      [146, 147],
      153,
      165,
      171,
      177,
      183,
      189
    ],
    green: [
      2,
      10,
      22,
      [28, 29],
      [34, 36],
      [40, 43],
      [46, 50],
      [64, 65],
      [70, 72],
      [76, 79],
      [82, 86],
      [106, 108],
      [112, 115],
      [118, 122],
      [148, 151],
      [154, 158],
      [190, 194]
    ],
    cyan: [
      6,
      14,
      23,
      30,
      37,
      44,
      51,
      66,
      73,
      80,
      87,
      109,
      116,
      123,
      152,
      159,
      195
    ],
    red: [
      1,
      9,
      52,
      [88, 89],
      [94, 95],
      [124, 126],
      [130, 132],
      [136, 138],
      [160, 163],
      [166, 169],
      [172, 175],
      [178, 181],
      [196, 200],
      [202, 206],
      [208, 212],
      [214, 218],
      [220, 224]
    ],
    magenta: [
      5,
      13,
      53,
      90,
      96,
      127,
      133,
      139,
      164,
      170,
      176,
      182,
      201,
      207,
      213,
      219,
      225
    ],
    yellow: [
      3,
      11,
      58,
      [100, 101],
      [142, 144],
      [184, 187],
      [226, 230]
    ],
    black: [
      0,
      8,
      16,
      59,
      102,
      [232, 243]
    ],
    white: [
      7,
      15,
      145,
      188,
      231,
      [244, 255]
    ]
  };
  exports.ncolors = [];
  Object.keys(exports.ccolors).forEach(function(name) {
    exports.ccolors[name].forEach(function(offset) {
      if (typeof offset === "number") {
        exports.ncolors[offset] = name;
        exports.ccolors[offset] = exports.colorNames[name];
        return;
      }
      for (var i = offset[0], l = offset[1];i <= l; i++) {
        exports.ncolors[i] = name;
        exports.ccolors[i] = exports.colorNames[name];
      }
    });
    delete exports.ccolors[name];
  });
});

// node_modules/blessed/lib/keys.js
var require_keys = __commonJS((exports) => {
  var EventEmitter = __require("events").EventEmitter;
  function listenerCount(stream, event) {
    return EventEmitter.listenerCount ? EventEmitter.listenerCount(stream, event) : stream.listeners(event).length;
  }
  function emitKeypressEvents(stream) {
    if (stream._keypressDecoder)
      return;
    var StringDecoder = __require("string_decoder").StringDecoder;
    stream._keypressDecoder = new StringDecoder("utf8");
    function onData(b) {
      if (listenerCount(stream, "keypress") > 0) {
        var r = stream._keypressDecoder.write(b);
        if (r)
          emitKeys(stream, r);
      } else {
        stream.removeListener("data", onData);
        stream.on("newListener", onNewListener);
      }
    }
    function onNewListener(event) {
      if (event === "keypress") {
        stream.on("data", onData);
        stream.removeListener("newListener", onNewListener);
      }
    }
    if (listenerCount(stream, "keypress") > 0) {
      stream.on("data", onData);
    } else {
      stream.on("newListener", onNewListener);
    }
  }
  exports.emitKeypressEvents = emitKeypressEvents;
  var metaKeyCodeReAnywhere = /(?:\x1b)([a-zA-Z0-9])/;
  var metaKeyCodeRe = new RegExp("^" + metaKeyCodeReAnywhere.source + "$");
  var functionKeyCodeReAnywhere = new RegExp("(?:\x1B+)(O|N|\\[|\\[\\[)(?:" + [
    "(\\d+)(?:;(\\d+))?([~^$])",
    "(?:M([@ #!a`])(.)(.))",
    "(?:1;)?(\\d+)?([a-zA-Z])"
  ].join("|") + ")");
  var functionKeyCodeRe = new RegExp("^" + functionKeyCodeReAnywhere.source);
  var escapeCodeReAnywhere = new RegExp([
    functionKeyCodeReAnywhere.source,
    metaKeyCodeReAnywhere.source,
    /\x1b./.source
  ].join("|"));
  function emitKeys(stream, s) {
    if (Buffer.isBuffer(s)) {
      if (s[0] > 127 && s[1] === undefined) {
        s[0] -= 128;
        s = "\x1B" + s.toString(stream.encoding || "utf-8");
      } else {
        s = s.toString(stream.encoding || "utf-8");
      }
    }
    if (isMouse(s))
      return;
    var buffer = [];
    var match;
    while (match = escapeCodeReAnywhere.exec(s)) {
      buffer = buffer.concat(s.slice(0, match.index).split(""));
      buffer.push(match[0]);
      s = s.slice(match.index + match[0].length);
    }
    buffer = buffer.concat(s.split(""));
    buffer.forEach(function(s2) {
      var ch, key = {
        sequence: s2,
        name: undefined,
        ctrl: false,
        meta: false,
        shift: false
      }, parts;
      if (s2 === "\r") {
        key.name = "return";
      } else if (s2 === `
`) {
        key.name = "enter";
      } else if (s2 === "\t") {
        key.name = "tab";
      } else if (s2 === "\b" || s2 === "" || s2 === "\x1B" || s2 === "\x1B\b") {
        key.name = "backspace";
        key.meta = s2.charAt(0) === "\x1B";
      } else if (s2 === "\x1B" || s2 === "\x1B\x1B") {
        key.name = "escape";
        key.meta = s2.length === 2;
      } else if (s2 === " " || s2 === "\x1B ") {
        key.name = "space";
        key.meta = s2.length === 2;
      } else if (s2.length === 1 && s2 <= "\x1A") {
        key.name = String.fromCharCode(s2.charCodeAt(0) + 97 - 1);
        key.ctrl = true;
      } else if (s2.length === 1 && s2 >= "a" && s2 <= "z") {
        key.name = s2;
      } else if (s2.length === 1 && s2 >= "A" && s2 <= "Z") {
        key.name = s2.toLowerCase();
        key.shift = true;
      } else if (parts = metaKeyCodeRe.exec(s2)) {
        key.name = parts[1].toLowerCase();
        key.meta = true;
        key.shift = /^[A-Z]$/.test(parts[1]);
      } else if (parts = functionKeyCodeRe.exec(s2)) {
        var code = (parts[1] || "") + (parts[2] || "") + (parts[4] || "") + (parts[9] || ""), modifier = (parts[3] || parts[8] || 1) - 1;
        key.ctrl = !!(modifier & 4);
        key.meta = !!(modifier & 10);
        key.shift = !!(modifier & 1);
        key.code = code;
        switch (code) {
          case "OP":
            key.name = "f1";
            break;
          case "OQ":
            key.name = "f2";
            break;
          case "OR":
            key.name = "f3";
            break;
          case "OS":
            key.name = "f4";
            break;
          case "[11~":
            key.name = "f1";
            break;
          case "[12~":
            key.name = "f2";
            break;
          case "[13~":
            key.name = "f3";
            break;
          case "[14~":
            key.name = "f4";
            break;
          case "[[A":
            key.name = "f1";
            break;
          case "[[B":
            key.name = "f2";
            break;
          case "[[C":
            key.name = "f3";
            break;
          case "[[D":
            key.name = "f4";
            break;
          case "[[E":
            key.name = "f5";
            break;
          case "[15~":
            key.name = "f5";
            break;
          case "[17~":
            key.name = "f6";
            break;
          case "[18~":
            key.name = "f7";
            break;
          case "[19~":
            key.name = "f8";
            break;
          case "[20~":
            key.name = "f9";
            break;
          case "[21~":
            key.name = "f10";
            break;
          case "[23~":
            key.name = "f11";
            break;
          case "[24~":
            key.name = "f12";
            break;
          case "[A":
            key.name = "up";
            break;
          case "[B":
            key.name = "down";
            break;
          case "[C":
            key.name = "right";
            break;
          case "[D":
            key.name = "left";
            break;
          case "[E":
            key.name = "clear";
            break;
          case "[F":
            key.name = "end";
            break;
          case "[H":
            key.name = "home";
            break;
          case "OA":
            key.name = "up";
            break;
          case "OB":
            key.name = "down";
            break;
          case "OC":
            key.name = "right";
            break;
          case "OD":
            key.name = "left";
            break;
          case "OE":
            key.name = "clear";
            break;
          case "OF":
            key.name = "end";
            break;
          case "OH":
            key.name = "home";
            break;
          case "[1~":
            key.name = "home";
            break;
          case "[2~":
            key.name = "insert";
            break;
          case "[3~":
            key.name = "delete";
            break;
          case "[4~":
            key.name = "end";
            break;
          case "[5~":
            key.name = "pageup";
            break;
          case "[6~":
            key.name = "pagedown";
            break;
          case "[[5~":
            key.name = "pageup";
            break;
          case "[[6~":
            key.name = "pagedown";
            break;
          case "[7~":
            key.name = "home";
            break;
          case "[8~":
            key.name = "end";
            break;
          case "[a":
            key.name = "up";
            key.shift = true;
            break;
          case "[b":
            key.name = "down";
            key.shift = true;
            break;
          case "[c":
            key.name = "right";
            key.shift = true;
            break;
          case "[d":
            key.name = "left";
            key.shift = true;
            break;
          case "[e":
            key.name = "clear";
            key.shift = true;
            break;
          case "[2$":
            key.name = "insert";
            key.shift = true;
            break;
          case "[3$":
            key.name = "delete";
            key.shift = true;
            break;
          case "[5$":
            key.name = "pageup";
            key.shift = true;
            break;
          case "[6$":
            key.name = "pagedown";
            key.shift = true;
            break;
          case "[7$":
            key.name = "home";
            key.shift = true;
            break;
          case "[8$":
            key.name = "end";
            key.shift = true;
            break;
          case "Oa":
            key.name = "up";
            key.ctrl = true;
            break;
          case "Ob":
            key.name = "down";
            key.ctrl = true;
            break;
          case "Oc":
            key.name = "right";
            key.ctrl = true;
            break;
          case "Od":
            key.name = "left";
            key.ctrl = true;
            break;
          case "Oe":
            key.name = "clear";
            key.ctrl = true;
            break;
          case "[2^":
            key.name = "insert";
            key.ctrl = true;
            break;
          case "[3^":
            key.name = "delete";
            key.ctrl = true;
            break;
          case "[5^":
            key.name = "pageup";
            key.ctrl = true;
            break;
          case "[6^":
            key.name = "pagedown";
            key.ctrl = true;
            break;
          case "[7^":
            key.name = "home";
            key.ctrl = true;
            break;
          case "[8^":
            key.name = "end";
            key.ctrl = true;
            break;
          case "[Z":
            key.name = "tab";
            key.shift = true;
            break;
          default:
            key.name = "undefined";
            break;
        }
      }
      if (key.name === undefined) {
        key = undefined;
      }
      if (s2.length === 1) {
        ch = s2;
      }
      if (key || ch) {
        stream.emit("keypress", ch, key);
      }
    });
  }
  function isMouse(s) {
    return /\x1b\[M/.test(s) || /\x1b\[M([\x00\u0020-\uffff]{3})/.test(s) || /\x1b\[(\d+;\d+;\d+)M/.test(s) || /\x1b\[<(\d+;\d+;\d+)([mM])/.test(s) || /\x1b\[<(\d+;\d+;\d+;\d+)&w/.test(s) || /\x1b\[24([0135])~\[(\d+),(\d+)\]\r/.test(s) || /\x1b\[(O|I)/.test(s);
  }
});

// node_modules/blessed/lib/gpmclient.js
var require_gpmclient = __commonJS((exports, module) => {
  var net = __require("net");
  var fs = __require("fs");
  var EventEmitter = __require("events").EventEmitter;
  var GPM_USE_MAGIC = false;
  var GPM_MOVE = 1;
  var GPM_DRAG = 2;
  var GPM_DOWN = 4;
  var GPM_UP = 8;
  var GPM_DOUBLE = 32;
  var GPM_MFLAG = 128;
  var GPM_REQ_NOPASTE = 3;
  var GPM_HARD = 256;
  var GPM_MAGIC = 1198550348;
  var GPM_SOCKET = "/dev/gpmctl";
  function send_config(socket, Gpm_Connect, callback) {
    var buffer;
    if (GPM_USE_MAGIC) {
      buffer = new Buffer(20);
      buffer.writeUInt32LE(GPM_MAGIC, 0);
      buffer.writeUInt16LE(Gpm_Connect.eventMask, 4);
      buffer.writeUInt16LE(Gpm_Connect.defaultMask, 6);
      buffer.writeUInt16LE(Gpm_Connect.minMod, 8);
      buffer.writeUInt16LE(Gpm_Connect.maxMod, 10);
      buffer.writeInt16LE(process.pid, 12);
      buffer.writeInt16LE(Gpm_Connect.vc, 16);
    } else {
      buffer = new Buffer(16);
      buffer.writeUInt16LE(Gpm_Connect.eventMask, 0);
      buffer.writeUInt16LE(Gpm_Connect.defaultMask, 2);
      buffer.writeUInt16LE(Gpm_Connect.minMod, 4);
      buffer.writeUInt16LE(Gpm_Connect.maxMod, 6);
      buffer.writeInt16LE(Gpm_Connect.pid, 8);
      buffer.writeInt16LE(Gpm_Connect.vc, 12);
    }
    socket.write(buffer, function() {
      if (callback)
        callback();
    });
  }
  function parseEvent(raw) {
    var evnt = {};
    evnt.buttons = raw[0];
    evnt.modifiers = raw[1];
    evnt.vc = raw.readUInt16LE(2);
    evnt.dx = raw.readInt16LE(4);
    evnt.dy = raw.readInt16LE(6);
    evnt.x = raw.readInt16LE(8);
    evnt.y = raw.readInt16LE(10);
    evnt.type = raw.readInt16LE(12);
    evnt.clicks = raw.readInt32LE(16);
    evnt.margin = raw.readInt32LE(20);
    evnt.wdx = raw.readInt16LE(24);
    evnt.wdy = raw.readInt16LE(26);
    return evnt;
  }
  function GpmClient(options) {
    if (!(this instanceof GpmClient)) {
      return new GpmClient(options);
    }
    EventEmitter.call(this);
    var pid = process.pid;
    var path;
    try {
      path = fs.readlinkSync("/proc/" + pid + "/fd/0");
    } catch (e) {}
    var tty = /tty[0-9]+$/.exec(path);
    if (tty === null) {}
    var vc;
    if (tty) {
      tty = tty[0];
      vc = +/[0-9]+$/.exec(tty)[0];
    }
    var self2 = this;
    if (tty) {
      fs.stat(GPM_SOCKET, function(err, stat) {
        if (err || !stat.isSocket()) {
          return;
        }
        var conf = {
          eventMask: 65535,
          defaultMask: GPM_MOVE | GPM_HARD,
          minMod: 0,
          maxMod: 65535,
          pid,
          vc
        };
        var gpm = net.createConnection(GPM_SOCKET);
        this.gpm = gpm;
        gpm.on("connect", function() {
          send_config(gpm, conf, function() {
            conf.pid = 0;
            conf.vc = GPM_REQ_NOPASTE;
          });
        });
        gpm.on("data", function(packet) {
          var evnt = parseEvent(packet);
          switch (evnt.type & 15) {
            case GPM_MOVE:
              if (evnt.dx || evnt.dy) {
                self2.emit("move", evnt.buttons, evnt.modifiers, evnt.x, evnt.y);
              }
              if (evnt.wdx || evnt.wdy) {
                self2.emit("mousewheel", evnt.buttons, evnt.modifiers, evnt.x, evnt.y, evnt.wdx, evnt.wdy);
              }
              break;
            case GPM_DRAG:
              if (evnt.dx || evnt.dy) {
                self2.emit("drag", evnt.buttons, evnt.modifiers, evnt.x, evnt.y);
              }
              if (evnt.wdx || evnt.wdy) {
                self2.emit("mousewheel", evnt.buttons, evnt.modifiers, evnt.x, evnt.y, evnt.wdx, evnt.wdy);
              }
              break;
            case GPM_DOWN:
              self2.emit("btndown", evnt.buttons, evnt.modifiers, evnt.x, evnt.y);
              if (evnt.type & GPM_DOUBLE) {
                self2.emit("dblclick", evnt.buttons, evnt.modifiers, evnt.x, evnt.y);
              }
              break;
            case GPM_UP:
              self2.emit("btnup", evnt.buttons, evnt.modifiers, evnt.x, evnt.y);
              if (!(evnt.type & GPM_MFLAG)) {
                self2.emit("click", evnt.buttons, evnt.modifiers, evnt.x, evnt.y);
              }
              break;
          }
        });
        gpm.on("error", function() {
          self2.stop();
        });
      });
    }
  }
  GpmClient.prototype.__proto__ = EventEmitter.prototype;
  GpmClient.prototype.stop = function() {
    if (this.gpm) {
      this.gpm.end();
    }
    delete this.gpm;
  };
  GpmClient.prototype.ButtonName = function(btn) {
    if (btn & 4)
      return "left";
    if (btn & 2)
      return "middle";
    if (btn & 1)
      return "right";
    return "";
  };
  GpmClient.prototype.hasShiftKey = function(mod2) {
    return mod2 & 1 ? true : false;
  };
  GpmClient.prototype.hasCtrlKey = function(mod2) {
    return mod2 & 4 ? true : false;
  };
  GpmClient.prototype.hasMetaKey = function(mod2) {
    return mod2 & 8 ? true : false;
  };
  module.exports = GpmClient;
});

// node_modules/blessed/lib/program.js
var require_program = __commonJS((exports, module) => {
  var EventEmitter = __require("events").EventEmitter;
  var StringDecoder = __require("string_decoder").StringDecoder;
  var cp = __require("child_process");
  var util = __require("util");
  var fs = __require("fs");
  var Tput = require_tput();
  var colors = require_colors();
  var slice = Array.prototype.slice;
  var nextTick = global.setImmediate || process.nextTick.bind(process);
  function Program(options) {
    var self2 = this;
    if (!(this instanceof Program)) {
      return new Program(options);
    }
    Program.bind(this);
    EventEmitter.call(this);
    if (!options || options.__proto__ !== Object.prototype) {
      options = {
        input: arguments[0],
        output: arguments[1]
      };
    }
    this.options = options;
    this.input = options.input || process.stdin;
    this.output = options.output || process.stdout;
    options.log = options.log || options.dump;
    if (options.log) {
      this._logger = fs.createWriteStream(options.log);
      if (options.dump)
        this.setupDump();
    }
    this.zero = options.zero !== false;
    this.useBuffer = options.buffer;
    this.x = 0;
    this.y = 0;
    this.savedX = 0;
    this.savedY = 0;
    this.cols = this.output.columns || 1;
    this.rows = this.output.rows || 1;
    this.scrollTop = 0;
    this.scrollBottom = this.rows - 1;
    this._terminal = options.terminal || options.term || process.env.TERM || (process.platform === "win32" ? "windows-ansi" : "xterm");
    this._terminal = this._terminal.toLowerCase();
    this.isOSXTerm = process.env.TERM_PROGRAM === "Apple_Terminal";
    this.isiTerm2 = process.env.TERM_PROGRAM === "iTerm.app" || !!process.env.ITERM_SESSION_ID;
    this.isXFCE = /xfce/i.test(process.env.COLORTERM);
    this.isTerminator = !!process.env.TERMINATOR_UUID;
    this.isLXDE = false;
    this.isVTE = !!process.env.VTE_VERSION || this.isXFCE || this.isTerminator || this.isLXDE;
    this.isRxvt = /rxvt/i.test(process.env.COLORTERM);
    this.isXterm = false;
    this.tmux = !!process.env.TMUX;
    this.tmuxVersion = function() {
      if (!self2.tmux)
        return 2;
      try {
        var version = cp.execFileSync("tmux", ["-V"], { encoding: "utf8" });
        return +/^tmux ([\d.]+)/i.exec(version.trim().split(`
`)[0])[1];
      } catch (e) {
        return 2;
      }
    }();
    this._buf = "";
    this._flush = this.flush.bind(this);
    if (options.tput !== false) {
      this.setupTput();
    }
    this.listen();
  }
  Program.global = null;
  Program.total = 0;
  Program.instances = [];
  Program.bind = function(program) {
    if (!Program.global) {
      Program.global = program;
    }
    if (!~Program.instances.indexOf(program)) {
      Program.instances.push(program);
      program.index = Program.total;
      Program.total++;
    }
    if (Program._bound)
      return;
    Program._bound = true;
    unshiftEvent(process, "exit", Program._exitHandler = function() {
      Program.instances.forEach(function(program2) {
        program2.flush();
        program2._exiting = true;
      });
    });
  };
  Program.prototype.__proto__ = EventEmitter.prototype;
  Program.prototype.type = "program";
  Program.prototype.log = function() {
    return this._log("LOG", util.format.apply(util, arguments));
  };
  Program.prototype.debug = function() {
    if (!this.options.debug)
      return;
    return this._log("DEBUG", util.format.apply(util, arguments));
  };
  Program.prototype._log = function(pre, msg) {
    if (!this._logger)
      return;
    return this._logger.write(pre + ": " + msg + `
-
`);
  };
  Program.prototype.setupDump = function() {
    var self2 = this, write = this.output.write, decoder = new StringDecoder("utf8");
    function stringify(data) {
      return caret(data.replace(/\r/g, "\\r").replace(/\n/g, "\\n").replace(/\t/g, "\\t")).replace(/[^ -~]/g, function(ch) {
        if (ch.charCodeAt(0) > 255)
          return ch;
        ch = ch.charCodeAt(0).toString(16);
        if (ch.length > 2) {
          if (ch.length < 4)
            ch = "0" + ch;
          return "\\u" + ch;
        }
        if (ch.length < 2)
          ch = "0" + ch;
        return "\\x" + ch;
      });
    }
    function caret(data) {
      return data.replace(/[\0\x80\x1b-\x1f\x7f\x01-\x1a]/g, function(ch) {
        switch (ch) {
          case "\x00":
          case "":
            ch = "@";
            break;
          case "\x1B":
            ch = "[";
            break;
          case "\x1C":
            ch = "\\";
            break;
          case "\x1D":
            ch = "]";
            break;
          case "\x1E":
            ch = "^";
            break;
          case "\x1F":
            ch = "_";
            break;
          case "":
            ch = "?";
            break;
          default:
            ch = ch.charCodeAt(0);
            if (ch >= 1 && ch <= 26) {
              ch = String.fromCharCode(ch + 64);
            } else {
              return String.fromCharCode(ch);
            }
            break;
        }
        return "^" + ch;
      });
    }
    this.input.on("data", function(data) {
      self2._log("IN", stringify(decoder.write(data)));
    });
    this.output.write = function(data) {
      self2._log("OUT", stringify(data));
      return write.apply(this, arguments);
    };
  };
  Program.prototype.setupTput = function() {
    if (this._tputSetup)
      return;
    this._tputSetup = true;
    var self2 = this, options = this.options, write = this._write.bind(this);
    var tput = this.tput = new Tput({
      terminal: this.terminal,
      padding: options.padding,
      extended: options.extended,
      printf: options.printf,
      termcap: options.termcap,
      forceUnicode: options.forceUnicode
    });
    if (tput.error) {
      nextTick(function() {
        self2.emit("warning", tput.error.message);
      });
    }
    if (tput.padding) {
      nextTick(function() {
        self2.emit("warning", "Terminfo padding has been enabled.");
      });
    }
    this.put = function() {
      var args2 = slice.call(arguments), cap = args2.shift();
      if (tput[cap]) {
        return this._write(tput[cap].apply(tput, args2));
      }
    };
    Object.keys(tput).forEach(function(key) {
      if (self2[key] == null) {
        self2[key] = tput[key];
      }
      if (typeof tput[key] !== "function") {
        self2.put[key] = tput[key];
        return;
      }
      if (tput.padding) {
        self2.put[key] = function() {
          return tput._print(tput[key].apply(tput, arguments), write);
        };
      } else {
        self2.put[key] = function() {
          return self2._write(tput[key].apply(tput, arguments));
        };
      }
    });
  };
  Program.prototype.__defineGetter__("terminal", function() {
    return this._terminal;
  });
  Program.prototype.__defineSetter__("terminal", function(terminal) {
    this.setTerminal(terminal);
    return this.terminal;
  });
  Program.prototype.setTerminal = function(terminal) {
    this._terminal = terminal.toLowerCase();
    delete this._tputSetup;
    this.setupTput();
  };
  Program.prototype.has = function(name) {
    return this.tput ? this.tput.has(name) : false;
  };
  Program.prototype.term = function(is) {
    return this.terminal.indexOf(is) === 0;
  };
  Program.prototype.listen = function() {
    var self2 = this;
    if (!this.input._blessedInput) {
      this.input._blessedInput = 1;
      this._listenInput();
    } else {
      this.input._blessedInput++;
    }
    this.on("newListener", this._newHandler = function fn(type) {
      if (type === "keypress" || type === "mouse") {
        self2.removeListener("newListener", fn);
        if (self2.input.setRawMode && !self2.input.isRaw) {
          self2.input.setRawMode(true);
          self2.input.resume();
        }
      }
    });
    this.on("newListener", function fn(type) {
      if (type === "mouse") {
        self2.removeListener("newListener", fn);
        self2.bindMouse();
      }
    });
    if (!this.output._blessedOutput) {
      this.output._blessedOutput = 1;
      this._listenOutput();
    } else {
      this.output._blessedOutput++;
    }
  };
  Program.prototype._listenInput = function() {
    var keys = require_keys(), self2 = this;
    this.input.on("keypress", this.input._keypressHandler = function(ch, key) {
      key = key || { ch };
      if (key.name === "undefined" && (key.code === "[M" || key.code === "[I" || key.code === "[O")) {
        return;
      }
      if (key.name === "undefined") {
        return;
      }
      if (key.name === "enter" && key.sequence === `
`) {
        key.name = "linefeed";
      }
      if (key.name === "return" && key.sequence === "\r") {
        self2.input.emit("keypress", ch, merge({}, key, { name: "enter" }));
      }
      var name = (key.ctrl ? "C-" : "") + (key.meta ? "M-" : "") + (key.shift && key.name ? "S-" : "") + (key.name || ch);
      key.full = name;
      Program.instances.forEach(function(program) {
        if (program.input !== self2.input)
          return;
        program.emit("keypress", ch, key);
        program.emit("key " + name, ch, key);
      });
    });
    this.input.on("data", this.input._dataHandler = function(data) {
      Program.instances.forEach(function(program) {
        if (program.input !== self2.input)
          return;
        program.emit("data", data);
      });
    });
    keys.emitKeypressEvents(this.input);
  };
  Program.prototype._listenOutput = function() {
    var self2 = this;
    if (!this.output.isTTY) {
      nextTick(function() {
        self2.emit("warning", "Output is not a TTY");
      });
    }
    function resize() {
      Program.instances.forEach(function(program) {
        if (program.output !== self2.output)
          return;
        program.cols = program.output.columns;
        program.rows = program.output.rows;
        program.emit("resize");
      });
    }
    this.output.on("resize", this.output._resizeHandler = function() {
      Program.instances.forEach(function(program) {
        if (program.output !== self2.output)
          return;
        if (!program.options.resizeTimeout) {
          return resize();
        }
        if (program._resizeTimer) {
          clearTimeout(program._resizeTimer);
          delete program._resizeTimer;
        }
        var time = typeof program.options.resizeTimeout === "number" ? program.options.resizeTimeout : 300;
        program._resizeTimer = setTimeout(resize, time);
      });
    });
  };
  Program.prototype.destroy = function() {
    var index = Program.instances.indexOf(this);
    if (~index) {
      Program.instances.splice(index, 1);
      Program.total--;
      this.flush();
      this._exiting = true;
      Program.global = Program.instances[0];
      if (Program.total === 0) {
        Program.global = null;
        process.removeListener("exit", Program._exitHandler);
        delete Program._exitHandler;
        delete Program._bound;
      }
      this.input._blessedInput--;
      this.output._blessedOutput--;
      if (this.input._blessedInput === 0) {
        this.input.removeListener("keypress", this.input._keypressHandler);
        this.input.removeListener("data", this.input._dataHandler);
        delete this.input._keypressHandler;
        delete this.input._dataHandler;
        if (this.input.setRawMode) {
          if (this.input.isRaw) {
            this.input.setRawMode(false);
          }
          if (!this.input.destroyed) {
            this.input.pause();
          }
        }
      }
      if (this.output._blessedOutput === 0) {
        this.output.removeListener("resize", this.output._resizeHandler);
        delete this.output._resizeHandler;
      }
      this.removeListener("newListener", this._newHandler);
      delete this._newHandler;
      this.destroyed = true;
      this.emit("destroy");
    }
  };
  Program.prototype.key = function(key, listener) {
    if (typeof key === "string")
      key = key.split(/\s*,\s*/);
    key.forEach(function(key2) {
      return this.on("key " + key2, listener);
    }, this);
  };
  Program.prototype.onceKey = function(key, listener) {
    if (typeof key === "string")
      key = key.split(/\s*,\s*/);
    key.forEach(function(key2) {
      return this.once("key " + key2, listener);
    }, this);
  };
  Program.prototype.unkey = Program.prototype.removeKey = function(key, listener) {
    if (typeof key === "string")
      key = key.split(/\s*,\s*/);
    key.forEach(function(key2) {
      return this.removeListener("key " + key2, listener);
    }, this);
  };
  Program.prototype.bindMouse = function() {
    if (this._boundMouse)
      return;
    this._boundMouse = true;
    var decoder = new StringDecoder("utf8"), self2 = this;
    this.on("data", function(data) {
      var text = decoder.write(data);
      if (!text)
        return;
      self2._bindMouse(text, data);
    });
  };
  Program.prototype._bindMouse = function(s, buf) {
    var self2 = this, key, parts, b, x, y, mod2, params, down, page, button;
    key = {
      name: undefined,
      ctrl: false,
      meta: false,
      shift: false
    };
    if (Buffer.isBuffer(s)) {
      if (s[0] > 127 && s[1] === undefined) {
        s[0] -= 128;
        s = "\x1B" + s.toString("utf-8");
      } else {
        s = s.toString("utf-8");
      }
    }
    var bx = s.charCodeAt(4);
    var by = s.charCodeAt(5);
    if (buf[0] === 27 && buf[1] === 91 && buf[2] === 77 && (this.isVTE || bx >= 65533 || by >= 65533 || bx > 0 && bx < 32 || by > 0 && by < 32 || buf[4] > 223 && buf[4] < 248 && buf.length === 6 || buf[5] > 223 && buf[5] < 248 && buf.length === 6)) {
      b = buf[3];
      x = buf[4];
      y = buf[5];
      if (x < 32)
        x += 255;
      if (y < 32)
        y += 255;
      s = "\x1B[M" + String.fromCharCode(b) + String.fromCharCode(x) + String.fromCharCode(y);
    }
    if (parts = /^\x1b\[M([\x00\u0020-\uffff]{3})/.exec(s)) {
      b = parts[1].charCodeAt(0);
      x = parts[1].charCodeAt(1);
      y = parts[1].charCodeAt(2);
      key.name = "mouse";
      key.type = "X10";
      key.raw = [b, x, y, parts[0]];
      key.buf = buf;
      key.x = x - 32;
      key.y = y - 32;
      if (this.zero)
        key.x--, key.y--;
      if (x === 0)
        key.x = 255;
      if (y === 0)
        key.y = 255;
      mod2 = b >> 2;
      key.shift = !!(mod2 & 1);
      key.meta = !!(mod2 >> 1 & 1);
      key.ctrl = !!(mod2 >> 2 & 1);
      b -= 32;
      if (b >> 6 & 1) {
        key.action = b & 1 ? "wheeldown" : "wheelup";
        key.button = "middle";
      } else if (b === 3) {
        key.action = "mouseup";
        key.button = this._lastButton || "unknown";
        delete this._lastButton;
      } else {
        key.action = "mousedown";
        button = b & 3;
        key.button = button === 0 ? "left" : button === 1 ? "middle" : button === 2 ? "right" : "unknown";
        this._lastButton = key.button;
      }
      if (b === 35 || b === 39 || b === 51 || b === 43 || this.isVTE && (b === 32 || b === 36 || b === 48 || b === 40)) {
        delete key.button;
        key.action = "mousemove";
      }
      self2.emit("mouse", key);
      return;
    }
    if (parts = /^\x1b\[(\d+;\d+;\d+)M/.exec(s)) {
      params = parts[1].split(";");
      b = +params[0];
      x = +params[1];
      y = +params[2];
      key.name = "mouse";
      key.type = "urxvt";
      key.raw = [b, x, y, parts[0]];
      key.buf = buf;
      key.x = x;
      key.y = y;
      if (this.zero)
        key.x--, key.y--;
      mod2 = b >> 2;
      key.shift = !!(mod2 & 1);
      key.meta = !!(mod2 >> 1 & 1);
      key.ctrl = !!(mod2 >> 2 & 1);
      if (b === 128 || b === 129) {
        b = 67;
      }
      b -= 32;
      if (b >> 6 & 1) {
        key.action = b & 1 ? "wheeldown" : "wheelup";
        key.button = "middle";
      } else if (b === 3) {
        key.action = "mouseup";
        key.button = this._lastButton || "unknown";
        delete this._lastButton;
      } else {
        key.action = "mousedown";
        button = b & 3;
        key.button = button === 0 ? "left" : button === 1 ? "middle" : button === 2 ? "right" : "unknown";
        this._lastButton = key.button;
      }
      if (b === 35 || b === 39 || b === 51 || b === 43 || this.isVTE && (b === 32 || b === 36 || b === 48 || b === 40)) {
        delete key.button;
        key.action = "mousemove";
      }
      self2.emit("mouse", key);
      return;
    }
    if (parts = /^\x1b\[<(\d+;\d+;\d+)([mM])/.exec(s)) {
      down = parts[2] === "M";
      params = parts[1].split(";");
      b = +params[0];
      x = +params[1];
      y = +params[2];
      key.name = "mouse";
      key.type = "sgr";
      key.raw = [b, x, y, parts[0]];
      key.buf = buf;
      key.x = x;
      key.y = y;
      if (this.zero)
        key.x--, key.y--;
      mod2 = b >> 2;
      key.shift = !!(mod2 & 1);
      key.meta = !!(mod2 >> 1 & 1);
      key.ctrl = !!(mod2 >> 2 & 1);
      if (b >> 6 & 1) {
        key.action = b & 1 ? "wheeldown" : "wheelup";
        key.button = "middle";
      } else {
        key.action = down ? "mousedown" : "mouseup";
        button = b & 3;
        key.button = button === 0 ? "left" : button === 1 ? "middle" : button === 2 ? "right" : "unknown";
      }
      if (b === 35 || b === 39 || b === 51 || b === 43 || this.isVTE && (b === 32 || b === 36 || b === 48 || b === 40)) {
        delete key.button;
        key.action = "mousemove";
      }
      self2.emit("mouse", key);
      return;
    }
    if (parts = /^\x1b\[<(\d+;\d+;\d+;\d+)&w/.exec(s)) {
      params = parts[1].split(";");
      b = +params[0];
      x = +params[1];
      y = +params[2];
      page = +params[3];
      key.name = "mouse";
      key.type = "dec";
      key.raw = [b, x, y, parts[0]];
      key.buf = buf;
      key.x = x;
      key.y = y;
      key.page = page;
      if (this.zero)
        key.x--, key.y--;
      key.action = b === 3 ? "mouseup" : "mousedown";
      key.button = b === 2 ? "left" : b === 4 ? "middle" : b === 6 ? "right" : "unknown";
      self2.emit("mouse", key);
      return;
    }
    if (parts = /^\x1b\[24([0135])~\[(\d+),(\d+)\]\r/.exec(s)) {
      b = +parts[1];
      x = +parts[2];
      y = +parts[3];
      key.name = "mouse";
      key.type = "vt300";
      key.raw = [b, x, y, parts[0]];
      key.buf = buf;
      key.x = x;
      key.y = y;
      if (this.zero)
        key.x--, key.y--;
      key.action = "mousedown";
      key.button = b === 1 ? "left" : b === 2 ? "middle" : b === 5 ? "right" : "unknown";
      self2.emit("mouse", key);
      return;
    }
    if (parts = /^\x1b\[(O|I)/.exec(s)) {
      key.action = parts[1] === "I" ? "focus" : "blur";
      self2.emit("mouse", key);
      self2.emit(key.action);
      return;
    }
  };
  Program.prototype.enableGpm = function() {
    var self2 = this;
    var gpmclient = require_gpmclient();
    if (this.gpm)
      return;
    this.gpm = gpmclient();
    this.gpm.on("btndown", function(btn, modifier, x, y) {
      x--, y--;
      var key = {
        name: "mouse",
        type: "GPM",
        action: "mousedown",
        button: self2.gpm.ButtonName(btn),
        raw: [btn, modifier, x, y],
        x,
        y,
        shift: self2.gpm.hasShiftKey(modifier),
        meta: self2.gpm.hasMetaKey(modifier),
        ctrl: self2.gpm.hasCtrlKey(modifier)
      };
      self2.emit("mouse", key);
    });
    this.gpm.on("btnup", function(btn, modifier, x, y) {
      x--, y--;
      var key = {
        name: "mouse",
        type: "GPM",
        action: "mouseup",
        button: self2.gpm.ButtonName(btn),
        raw: [btn, modifier, x, y],
        x,
        y,
        shift: self2.gpm.hasShiftKey(modifier),
        meta: self2.gpm.hasMetaKey(modifier),
        ctrl: self2.gpm.hasCtrlKey(modifier)
      };
      self2.emit("mouse", key);
    });
    this.gpm.on("move", function(btn, modifier, x, y) {
      x--, y--;
      var key = {
        name: "mouse",
        type: "GPM",
        action: "mousemove",
        button: self2.gpm.ButtonName(btn),
        raw: [btn, modifier, x, y],
        x,
        y,
        shift: self2.gpm.hasShiftKey(modifier),
        meta: self2.gpm.hasMetaKey(modifier),
        ctrl: self2.gpm.hasCtrlKey(modifier)
      };
      self2.emit("mouse", key);
    });
    this.gpm.on("drag", function(btn, modifier, x, y) {
      x--, y--;
      var key = {
        name: "mouse",
        type: "GPM",
        action: "mousemove",
        button: self2.gpm.ButtonName(btn),
        raw: [btn, modifier, x, y],
        x,
        y,
        shift: self2.gpm.hasShiftKey(modifier),
        meta: self2.gpm.hasMetaKey(modifier),
        ctrl: self2.gpm.hasCtrlKey(modifier)
      };
      self2.emit("mouse", key);
    });
    this.gpm.on("mousewheel", function(btn, modifier, x, y, dx, dy) {
      var key = {
        name: "mouse",
        type: "GPM",
        action: dy > 0 ? "wheelup" : "wheeldown",
        button: self2.gpm.ButtonName(btn),
        raw: [btn, modifier, x, y, dx, dy],
        x,
        y,
        shift: self2.gpm.hasShiftKey(modifier),
        meta: self2.gpm.hasMetaKey(modifier),
        ctrl: self2.gpm.hasCtrlKey(modifier)
      };
      self2.emit("mouse", key);
    });
  };
  Program.prototype.disableGpm = function() {
    if (this.gpm) {
      this.gpm.stop();
      delete this.gpm;
    }
  };
  Program.prototype.bindResponse = function() {
    if (this._boundResponse)
      return;
    this._boundResponse = true;
    var decoder = new StringDecoder("utf8"), self2 = this;
    this.on("data", function(data) {
      data = decoder.write(data);
      if (!data)
        return;
      self2._bindResponse(data);
    });
  };
  Program.prototype._bindResponse = function(s) {
    var out = {}, parts;
    if (Buffer.isBuffer(s)) {
      if (s[0] > 127 && s[1] === undefined) {
        s[0] -= 128;
        s = "\x1B" + s.toString("utf-8");
      } else {
        s = s.toString("utf-8");
      }
    }
    if (parts = /^\x1b\[(\?|>)(\d*(?:;\d*)*)c/.exec(s)) {
      parts = parts[2].split(";").map(function(ch) {
        return +ch || 0;
      });
      out.event = "device-attributes";
      out.code = "DA";
      if (parts[1] === "?") {
        out.type = "primary-attribute";
        if (parts[0] === 1 && parts[2] === 2) {
          out.term = "vt100";
          out.advancedVideo = true;
        } else if (parts[0] === 1 && parts[2] === 0) {
          out.term = "vt101";
        } else if (parts[0] === 6) {
          out.term = "vt102";
        } else if (parts[0] === 60 && parts[1] === 1 && parts[2] === 2 && parts[3] === 6 && parts[4] === 8 && parts[5] === 9 && parts[6] === 15) {
          out.term = "vt220";
        } else {
          parts.forEach(function(attr) {
            switch (attr) {
              case 1:
                out.cols132 = true;
                break;
              case 2:
                out.printer = true;
                break;
              case 6:
                out.selectiveErase = true;
                break;
              case 8:
                out.userDefinedKeys = true;
                break;
              case 9:
                out.nationalReplacementCharsets = true;
                break;
              case 15:
                out.technicalCharacters = true;
                break;
              case 18:
                out.userWindows = true;
                break;
              case 21:
                out.horizontalScrolling = true;
                break;
              case 22:
                out.ansiColor = true;
                break;
              case 29:
                out.ansiTextLocator = true;
                break;
            }
          });
        }
      } else {
        out.type = "secondary-attribute";
        switch (parts[0]) {
          case 0:
            out.term = "vt100";
            break;
          case 1:
            out.term = "vt220";
            break;
          case 2:
            out.term = "vt240";
            break;
          case 18:
            out.term = "vt330";
            break;
          case 19:
            out.term = "vt340";
            break;
          case 24:
            out.term = "vt320";
            break;
          case 41:
            out.term = "vt420";
            break;
          case 61:
            out.term = "vt510";
            break;
          case 64:
            out.term = "vt520";
            break;
          case 65:
            out.term = "vt525";
            break;
        }
        out.firmwareVersion = parts[1];
        out.romCartridgeRegistrationNumber = parts[2];
      }
      out.deviceAttributes = out;
      this.emit("response", out);
      this.emit("response " + out.event, out);
      return;
    }
    if (parts = /^\x1b\[(\?)?(\d+)(?:;(\d+);(\d+);(\d+))?n/.exec(s)) {
      out.event = "device-status";
      out.code = "DSR";
      if (!parts[1] && parts[2] === "0" && !parts[3]) {
        out.type = "device-status";
        out.status = "OK";
        out.deviceStatus = out.status;
        this.emit("response", out);
        this.emit("response " + out.event, out);
        return;
      }
      if (parts[1] && (parts[2] === "10" || parts[2] === "11") && !parts[3]) {
        out.type = "printer-status";
        out.status = parts[2] === "10" ? "ready" : "not ready";
        out.printerStatus = out.status;
        this.emit("response", out);
        this.emit("response " + out.event, out);
        return;
      }
      if (parts[1] && (parts[2] === "20" || parts[2] === "21") && !parts[3]) {
        out.type = "udk-status";
        out.status = parts[2] === "20" ? "unlocked" : "locked";
        out.UDKStatus = out.status;
        this.emit("response", out);
        this.emit("response " + out.event, out);
        return;
      }
      if (parts[1] && parts[2] === "27" && parts[3] === "1" && parts[4] === "0" && parts[5] === "0") {
        out.type = "keyboard-status";
        out.status = "OK";
        out.keyboardStatus = out.status;
        this.emit("response", out);
        this.emit("response " + out.event, out);
        return;
      }
      if (parts[1] && (parts[2] === "53" || parts[2] === "50") && !parts[3]) {
        out.type = "locator-status";
        out.status = parts[2] === "53" ? "available" : "unavailable";
        out.locator = out.status;
        this.emit("response", out);
        this.emit("response " + out.event, out);
        return;
      }
      out.type = "error";
      out.text = "Unhandled: " + JSON.stringify(parts);
      out.error = out.text;
      this.emit("response", out);
      this.emit("response " + out.event, out);
      return;
    }
    if (parts = /^\x1b\[(\?)?(\d+);(\d+)R/.exec(s)) {
      out.event = "device-status";
      out.code = "DSR";
      out.type = "cursor-status";
      out.status = {
        x: +parts[3],
        y: +parts[2],
        page: !parts[1] ? undefined : 0
      };
      out.x = out.status.x;
      out.y = out.status.y;
      out.page = out.status.page;
      out.cursor = out.status;
      this.emit("response", out);
      this.emit("response " + out.event, out);
      return;
    }
    if (parts = /^\x1b\[(\d+)(?:;(\d+);(\d+))?t/.exec(s)) {
      out.event = "window-manipulation";
      out.code = "";
      if ((parts[1] === "1" || parts[1] === "2") && !parts[2]) {
        out.type = "window-state";
        out.state = parts[1] === "1" ? "non-iconified" : "iconified";
        out.windowState = out.state;
        this.emit("response", out);
        this.emit("response " + out.event, out);
        return;
      }
      if (parts[1] === "3" && parts[2]) {
        out.type = "window-position";
        out.position = {
          x: +parts[2],
          y: +parts[3]
        };
        out.x = out.position.x;
        out.y = out.position.y;
        out.windowPosition = out.position;
        this.emit("response", out);
        this.emit("response " + out.event, out);
        return;
      }
      if (parts[1] === "4" && parts[2]) {
        out.type = "window-size-pixels";
        out.size = {
          height: +parts[2],
          width: +parts[3]
        };
        out.height = out.size.height;
        out.width = out.size.width;
        out.windowSizePixels = out.size;
        this.emit("response", out);
        this.emit("response " + out.event, out);
        return;
      }
      if (parts[1] === "8" && parts[2]) {
        out.type = "textarea-size";
        out.size = {
          height: +parts[2],
          width: +parts[3]
        };
        out.height = out.size.height;
        out.width = out.size.width;
        out.textAreaSizeCharacters = out.size;
        this.emit("response", out);
        this.emit("response " + out.event, out);
        return;
      }
      if (parts[1] === "9" && parts[2]) {
        out.type = "screen-size";
        out.size = {
          height: +parts[2],
          width: +parts[3]
        };
        out.height = out.size.height;
        out.width = out.size.width;
        out.screenSizeCharacters = out.size;
        this.emit("response", out);
        this.emit("response " + out.event, out);
        return;
      }
      out.type = "error";
      out.text = "Unhandled: " + JSON.stringify(parts);
      out.error = out.text;
      this.emit("response", out);
      this.emit("response " + out.event, out);
      return;
    }
    if (parts = /^\x1b\](l|L)([^\x07\x1b]*)$/.exec(s)) {
      parts[2] = "rxvt";
      s = "\x1B]" + parts[1] + parts[2] + "\x1B\\";
    }
    if (parts = /^\x1b\](l|L)([^\x07\x1b]*)(?:\x07|\x1b\\)/.exec(s)) {
      out.event = "window-manipulation";
      out.code = "";
      if (parts[1] === "L") {
        out.type = "window-icon-label";
        out.text = parts[2];
        out.windowIconLabel = out.text;
        this.emit("response", out);
        this.emit("response " + out.event, out);
        return;
      }
      if (parts[1] === "l") {
        out.type = "window-title";
        out.text = parts[2];
        out.windowTitle = out.text;
        this.emit("response", out);
        this.emit("response " + out.event, out);
        return;
      }
      out.type = "error";
      out.text = "Unhandled: " + JSON.stringify(parts);
      out.error = out.text;
      this.emit("response", out);
      this.emit("response " + out.event, out);
      return;
    }
    if (parts = /^\x1b\[(\d+(?:;\d+){4})&w/.exec(s)) {
      parts = parts[1].split(";").map(function(ch) {
        return +ch;
      });
      out.event = "locator-position";
      out.code = "DECRQLP";
      switch (parts[0]) {
        case 0:
          out.status = "locator-unavailable";
          break;
        case 1:
          out.status = "request";
          break;
        case 2:
          out.status = "left-button-down";
          break;
        case 3:
          out.status = "left-button-up";
          break;
        case 4:
          out.status = "middle-button-down";
          break;
        case 5:
          out.status = "middle-button-up";
          break;
        case 6:
          out.status = "right-button-down";
          break;
        case 7:
          out.status = "right-button-up";
          break;
        case 8:
          out.status = "m4-button-down";
          break;
        case 9:
          out.status = "m4-button-up";
          break;
        case 10:
          out.status = "locator-outside";
          break;
      }
      out.mask = parts[1];
      out.row = parts[2];
      out.col = parts[3];
      out.page = parts[4];
      out.locatorPosition = out;
      this.emit("response", out);
      this.emit("response " + out.event, out);
      return;
    }
    if (parts = /^\x1b\](\d+);([^\x07\x1b]+)(?:\x07|\x1b\\)/.exec(s)) {
      out.event = "text-params";
      out.code = "Set Text Parameters";
      out.ps = +s[1];
      out.pt = s[2];
      this.emit("response", out);
      this.emit("response " + out.event, out);
    }
  };
  Program.prototype.response = function(name, text, callback, noBypass) {
    var self2 = this;
    if (arguments.length === 2) {
      callback = text;
      text = name;
      name = null;
    }
    if (!callback) {
      callback = function() {};
    }
    this.bindResponse();
    name = name ? "response " + name : "response";
    var onresponse;
    this.once(name, onresponse = function(event) {
      if (timeout)
        clearTimeout(timeout);
      if (event.type === "error") {
        return callback(new Error(event.event + ": " + event.text));
      }
      return callback(null, event);
    });
    var timeout = setTimeout(function() {
      self2.removeListener(name, onresponse);
      return callback(new Error("Timeout."));
    }, 2000);
    return noBypass ? this._write(text) : this._twrite(text);
  };
  Program.prototype._owrite = Program.prototype.write = function(text) {
    if (!this.output.writable)
      return;
    return this.output.write(text);
  };
  Program.prototype._buffer = function(text) {
    if (this._exiting) {
      this.flush();
      this._owrite(text);
      return;
    }
    if (this._buf) {
      this._buf += text;
      return;
    }
    this._buf = text;
    nextTick(this._flush);
    return true;
  };
  Program.prototype.flush = function() {
    if (!this._buf)
      return;
    this._owrite(this._buf);
    this._buf = "";
  };
  Program.prototype._write = function(text) {
    if (this.ret)
      return text;
    if (this.useBuffer) {
      return this._buffer(text);
    }
    return this._owrite(text);
  };
  Program.prototype._twrite = function(data) {
    var self2 = this, iterations = 0, timer;
    if (this.tmux) {
      data = data.replace(/\x1b\\/g, "\x07");
      data = "\x1BPtmux;\x1B" + data + "\x1B\\";
      if (this.output.bytesWritten === 0) {
        timer = setInterval(function() {
          if (self2.output.bytesWritten > 0 || ++iterations === 50) {
            clearInterval(timer);
            self2.flush();
            self2._owrite(data);
          }
        }, 100);
        return true;
      }
      this.flush();
      return this._owrite(data);
    }
    return this._write(data);
  };
  Program.prototype.echo = Program.prototype.print = function(text, attr) {
    return attr ? this._write(this.text(text, attr)) : this._write(text);
  };
  Program.prototype._ncoords = function() {
    if (this.x < 0)
      this.x = 0;
    else if (this.x >= this.cols)
      this.x = this.cols - 1;
    if (this.y < 0)
      this.y = 0;
    else if (this.y >= this.rows)
      this.y = this.rows - 1;
  };
  Program.prototype.setx = function(x) {
    return this.cursorCharAbsolute(x);
  };
  Program.prototype.sety = function(y) {
    return this.linePosAbsolute(y);
  };
  Program.prototype.move = function(x, y) {
    return this.cursorPos(y, x);
  };
  Program.prototype.omove = function(x, y) {
    if (!this.zero) {
      x = (x || 1) - 1;
      y = (y || 1) - 1;
    } else {
      x = x || 0;
      y = y || 0;
    }
    if (y === this.y && x === this.x) {
      return;
    }
    if (y === this.y) {
      if (x > this.x) {
        this.cuf(x - this.x);
      } else if (x < this.x) {
        this.cub(this.x - x);
      }
    } else if (x === this.x) {
      if (y > this.y) {
        this.cud(y - this.y);
      } else if (y < this.y) {
        this.cuu(this.y - y);
      }
    } else {
      if (!this.zero)
        x++, y++;
      this.cup(y, x);
    }
  };
  Program.prototype.rsetx = function(x) {
    if (!x)
      return;
    return x > 0 ? this.forward(x) : this.back(-x);
  };
  Program.prototype.rsety = function(y) {
    if (!y)
      return;
    return y > 0 ? this.up(y) : this.down(-y);
  };
  Program.prototype.rmove = function(x, y) {
    this.rsetx(x);
    this.rsety(y);
  };
  Program.prototype.simpleInsert = function(ch, i, attr) {
    return this._write(this.repeat(ch, i), attr);
  };
  Program.prototype.repeat = function(ch, i) {
    if (!i || i < 0)
      i = 0;
    return Array(i + 1).join(ch);
  };
  Program.prototype.__defineGetter__("title", function() {
    return this._title;
  });
  Program.prototype.__defineSetter__("title", function(title) {
    this.setTitle(title);
    return this._title;
  });
  Program.prototype.copyToClipboard = function(text) {
    if (this.isiTerm2) {
      this._twrite("\x1B]50;CopyToCliboard=" + text + "\x07");
      return true;
    }
    return false;
  };
  Program.prototype.cursorShape = function(shape, blink) {
    if (this.isiTerm2) {
      switch (shape) {
        case "block":
          if (!blink) {
            this._twrite("\x1B]50;CursorShape=0;BlinkingCursorEnabled=0\x07");
          } else {
            this._twrite("\x1B]50;CursorShape=0;BlinkingCursorEnabled=1\x07");
          }
          break;
        case "underline":
          if (!blink) {} else {}
          break;
        case "line":
          if (!blink) {
            this._twrite("\x1B]50;CursorShape=1;BlinkingCursorEnabled=0\x07");
          } else {
            this._twrite("\x1B]50;CursorShape=1;BlinkingCursorEnabled=1\x07");
          }
          break;
      }
      return true;
    } else if (this.term("xterm") || this.term("screen")) {
      switch (shape) {
        case "block":
          if (!blink) {
            this._twrite("\x1B[0 q");
          } else {
            this._twrite("\x1B[1 q");
          }
          break;
        case "underline":
          if (!blink) {
            this._twrite("\x1B[2 q");
          } else {
            this._twrite("\x1B[3 q");
          }
          break;
        case "line":
          if (!blink) {
            this._twrite("\x1B[4 q");
          } else {
            this._twrite("\x1B[5 q");
          }
          break;
      }
      return true;
    }
    return false;
  };
  Program.prototype.cursorColor = function(color) {
    if (this.term("xterm") || this.term("rxvt") || this.term("screen")) {
      this._twrite("\x1B]12;" + color + "\x07");
      return true;
    }
    return false;
  };
  Program.prototype.cursorReset = Program.prototype.resetCursor = function() {
    if (this.term("xterm") || this.term("rxvt") || this.term("screen")) {
      this._twrite("\x1B[0 q");
      this._twrite("\x1B]112\x07");
      this._twrite("\x1B]12;white\x07");
      return true;
    }
    return false;
  };
  Program.prototype.getTextParams = function(param, callback) {
    return this.response("text-params", "\x1B]" + param + ";?\x07", function(err, data) {
      if (err)
        return callback(err);
      return callback(null, data.pt);
    });
  };
  Program.prototype.getCursorColor = function(callback) {
    return this.getTextParams(12, callback);
  };
  Program.prototype.nul = function() {
    return this._write("");
  };
  Program.prototype.bel = Program.prototype.bell = function() {
    if (this.has("bel"))
      return this.put.bel();
    return this._write("\x07");
  };
  Program.prototype.vtab = function() {
    this.y++;
    this._ncoords();
    return this._write("\v");
  };
  Program.prototype.ff = Program.prototype.form = function() {
    if (this.has("ff"))
      return this.put.ff();
    return this._write("\f");
  };
  Program.prototype.kbs = Program.prototype.backspace = function() {
    this.x--;
    this._ncoords();
    if (this.has("kbs"))
      return this.put.kbs();
    return this._write("\b");
  };
  Program.prototype.ht = Program.prototype.tab = function() {
    this.x += 8;
    this._ncoords();
    if (this.has("ht"))
      return this.put.ht();
    return this._write("\t");
  };
  Program.prototype.shiftOut = function() {
    return this._write("\x0E");
  };
  Program.prototype.shiftIn = function() {
    return this._write("\x0F");
  };
  Program.prototype.cr = Program.prototype.return = function() {
    this.x = 0;
    if (this.has("cr"))
      return this.put.cr();
    return this._write("\r");
  };
  Program.prototype.nel = Program.prototype.newline = Program.prototype.feed = function() {
    if (this.tput && this.tput.bools.eat_newline_glitch && this.x >= this.cols) {
      return;
    }
    this.x = 0;
    this.y++;
    this._ncoords();
    if (this.has("nel"))
      return this.put.nel();
    return this._write(`
`);
  };
  Program.prototype.ind = Program.prototype.index = function() {
    this.y++;
    this._ncoords();
    if (this.tput)
      return this.put.ind();
    return this._write("\x1BD");
  };
  Program.prototype.ri = Program.prototype.reverse = Program.prototype.reverseIndex = function() {
    this.y--;
    this._ncoords();
    if (this.tput)
      return this.put.ri();
    return this._write("\x1BM");
  };
  Program.prototype.nextLine = function() {
    this.y++;
    this.x = 0;
    this._ncoords();
    if (this.has("nel"))
      return this.put.nel();
    return this._write("\x1BE");
  };
  Program.prototype.reset = function() {
    this.x = this.y = 0;
    if (this.has("rs1") || this.has("ris")) {
      return this.has("rs1") ? this.put.rs1() : this.put.ris();
    }
    return this._write("\x1Bc");
  };
  Program.prototype.tabSet = function() {
    if (this.tput)
      return this.put.hts();
    return this._write("\x1BH");
  };
  Program.prototype.sc = Program.prototype.saveCursor = function(key) {
    if (key)
      return this.lsaveCursor(key);
    this.savedX = this.x || 0;
    this.savedY = this.y || 0;
    if (this.tput)
      return this.put.sc();
    return this._write("\x1B7");
  };
  Program.prototype.rc = Program.prototype.restoreCursor = function(key, hide) {
    if (key)
      return this.lrestoreCursor(key, hide);
    this.x = this.savedX || 0;
    this.y = this.savedY || 0;
    if (this.tput)
      return this.put.rc();
    return this._write("\x1B8");
  };
  Program.prototype.lsaveCursor = function(key) {
    key = key || "local";
    this._saved = this._saved || {};
    this._saved[key] = this._saved[key] || {};
    this._saved[key].x = this.x;
    this._saved[key].y = this.y;
    this._saved[key].hidden = this.cursorHidden;
  };
  Program.prototype.lrestoreCursor = function(key, hide) {
    var pos;
    key = key || "local";
    if (!this._saved || !this._saved[key])
      return;
    pos = this._saved[key];
    this.cup(pos.y, pos.x);
    if (hide && pos.hidden !== this.cursorHidden) {
      if (pos.hidden) {
        this.hideCursor();
      } else {
        this.showCursor();
      }
    }
  };
  Program.prototype.lineHeight = function() {
    return this._write("\x1B#");
  };
  Program.prototype.charset = function(val, level) {
    level = level || 0;
    switch (level) {
      case 0:
        level = "(";
        break;
      case 1:
        level = ")";
        break;
      case 2:
        level = "*";
        break;
      case 3:
        level = "+";
        break;
    }
    var name = typeof val === "string" ? val.toLowerCase() : val;
    switch (name) {
      case "acs":
      case "scld":
        if (this.tput)
          return this.put.smacs();
        val = "0";
        break;
      case "uk":
        val = "A";
        break;
      case "us":
      case "usascii":
      case "ascii":
        if (this.tput)
          return this.put.rmacs();
        val = "B";
        break;
      case "dutch":
        val = "4";
        break;
      case "finnish":
        val = "C";
        val = "5";
        break;
      case "french":
        val = "R";
        break;
      case "frenchcanadian":
        val = "Q";
        break;
      case "german":
        val = "K";
        break;
      case "italian":
        val = "Y";
        break;
      case "norwegiandanish":
        val = "E";
        val = "6";
        break;
      case "spanish":
        val = "Z";
        break;
      case "swedish":
        val = "H";
        val = "7";
        break;
      case "swiss":
        val = "=";
        break;
      case "isolatin":
        val = "/A";
        break;
      default:
        if (this.tput)
          return this.put.rmacs();
        val = "B";
        break;
    }
    return this._write("\x1B(" + val);
  };
  Program.prototype.enter_alt_charset_mode = Program.prototype.as = Program.prototype.smacs = function() {
    return this.charset("acs");
  };
  Program.prototype.exit_alt_charset_mode = Program.prototype.ae = Program.prototype.rmacs = function() {
    return this.charset("ascii");
  };
  Program.prototype.setG = function(val) {
    switch (val) {
      case 1:
        val = "~";
        break;
      case 2:
        val = "n";
        val = "}";
        val = "N";
        break;
      case 3:
        val = "o";
        val = "|";
        val = "O";
        break;
    }
    return this._write("\x1B" + val);
  };
  Program.prototype.setTitle = function(title) {
    this._title = title;
    return this._twrite("\x1B]0;" + title + "\x07");
  };
  Program.prototype.resetColors = function(param) {
    if (this.has("Cr")) {
      return this.put.Cr(param);
    }
    return this._twrite("\x1B]112\x07");
  };
  Program.prototype.dynamicColors = function(param) {
    if (this.has("Cs")) {
      return this.put.Cs(param);
    }
    return this._twrite("\x1B]12;" + param + "\x07");
  };
  Program.prototype.selData = function(a, b) {
    if (this.has("Ms")) {
      return this.put.Ms(a, b);
    }
    return this._twrite("\x1B]52;" + a + ";" + b + "\x07");
  };
  Program.prototype.cuu = Program.prototype.up = Program.prototype.cursorUp = function(param) {
    this.y -= param || 1;
    this._ncoords();
    if (this.tput) {
      if (!this.tput.strings.parm_up_cursor) {
        return this._write(this.repeat(this.tput.cuu1(), param));
      }
      return this.put.cuu(param);
    }
    return this._write("\x1B[" + (param || "") + "A");
  };
  Program.prototype.cud = Program.prototype.down = Program.prototype.cursorDown = function(param) {
    this.y += param || 1;
    this._ncoords();
    if (this.tput) {
      if (!this.tput.strings.parm_down_cursor) {
        return this._write(this.repeat(this.tput.cud1(), param));
      }
      return this.put.cud(param);
    }
    return this._write("\x1B[" + (param || "") + "B");
  };
  Program.prototype.cuf = Program.prototype.right = Program.prototype.forward = Program.prototype.cursorForward = function(param) {
    this.x += param || 1;
    this._ncoords();
    if (this.tput) {
      if (!this.tput.strings.parm_right_cursor) {
        return this._write(this.repeat(this.tput.cuf1(), param));
      }
      return this.put.cuf(param);
    }
    return this._write("\x1B[" + (param || "") + "C");
  };
  Program.prototype.cub = Program.prototype.left = Program.prototype.back = Program.prototype.cursorBackward = function(param) {
    this.x -= param || 1;
    this._ncoords();
    if (this.tput) {
      if (!this.tput.strings.parm_left_cursor) {
        return this._write(this.repeat(this.tput.cub1(), param));
      }
      return this.put.cub(param);
    }
    return this._write("\x1B[" + (param || "") + "D");
  };
  Program.prototype.cup = Program.prototype.pos = Program.prototype.cursorPos = function(row, col) {
    if (!this.zero) {
      row = (row || 1) - 1;
      col = (col || 1) - 1;
    } else {
      row = row || 0;
      col = col || 0;
    }
    this.x = col;
    this.y = row;
    this._ncoords();
    if (this.tput)
      return this.put.cup(row, col);
    return this._write("\x1B[" + (row + 1) + ";" + (col + 1) + "H");
  };
  Program.prototype.ed = Program.prototype.eraseInDisplay = function(param) {
    if (this.tput) {
      switch (param) {
        case "above":
          param = 1;
          break;
        case "all":
          param = 2;
          break;
        case "saved":
          param = 3;
          break;
        case "below":
        default:
          param = 0;
          break;
      }
      return this.put.ed(param);
    }
    switch (param) {
      case "above":
        return this._write("X1b[1J");
      case "all":
        return this._write("\x1B[2J");
      case "saved":
        return this._write("\x1B[3J");
      case "below":
      default:
        return this._write("\x1B[J");
    }
  };
  Program.prototype.clear = function() {
    this.x = 0;
    this.y = 0;
    if (this.tput)
      return this.put.clear();
    return this._write("\x1B[H\x1B[J");
  };
  Program.prototype.el = Program.prototype.eraseInLine = function(param) {
    if (this.tput) {
      switch (param) {
        case "left":
          param = 1;
          break;
        case "all":
          param = 2;
          break;
        case "right":
        default:
          param = 0;
          break;
      }
      return this.put.el(param);
    }
    switch (param) {
      case "left":
        return this._write("\x1B[1K");
      case "all":
        return this._write("\x1B[2K");
      case "right":
      default:
        return this._write("\x1B[K");
    }
  };
  Program.prototype.sgr = Program.prototype.attr = Program.prototype.charAttributes = function(param, val) {
    return this._write(this._attr(param, val));
  };
  Program.prototype.text = function(text, attr) {
    return this._attr(attr, true) + text + this._attr(attr, false);
  };
  Program.prototype._attr = function(param, val) {
    var self2 = this, parts, color, m;
    if (Array.isArray(param)) {
      parts = param;
      param = parts[0] || "normal";
    } else {
      param = param || "normal";
      parts = param.split(/\s*[,;]\s*/);
    }
    if (parts.length > 1) {
      var used = {}, out = [];
      parts.forEach(function(part) {
        part = self2._attr(part, val).slice(2, -1);
        if (part === "")
          return;
        if (used[part])
          return;
        used[part] = true;
        out.push(part);
      });
      return "\x1B[" + out.join(";") + "m";
    }
    if (param.indexOf("no ") === 0) {
      param = param.substring(3);
      val = false;
    } else if (param.indexOf("!") === 0) {
      param = param.substring(1);
      val = false;
    }
    switch (param) {
      case "normal":
      case "default":
        if (val === false)
          return "";
        return "\x1B[m";
      case "bold":
        return val === false ? "\x1B[22m" : "\x1B[1m";
      case "ul":
      case "underline":
      case "underlined":
        return val === false ? "\x1B[24m" : "\x1B[4m";
      case "blink":
        return val === false ? "\x1B[25m" : "\x1B[5m";
      case "inverse":
        return val === false ? "\x1B[27m" : "\x1B[7m";
      case "invisible":
        return val === false ? "\x1B[28m" : "\x1B[8m";
      case "black fg":
        return val === false ? "\x1B[39m" : "\x1B[30m";
      case "red fg":
        return val === false ? "\x1B[39m" : "\x1B[31m";
      case "green fg":
        return val === false ? "\x1B[39m" : "\x1B[32m";
      case "yellow fg":
        return val === false ? "\x1B[39m" : "\x1B[33m";
      case "blue fg":
        return val === false ? "\x1B[39m" : "\x1B[34m";
      case "magenta fg":
        return val === false ? "\x1B[39m" : "\x1B[35m";
      case "cyan fg":
        return val === false ? "\x1B[39m" : "\x1B[36m";
      case "white fg":
      case "light grey fg":
      case "light gray fg":
      case "bright grey fg":
      case "bright gray fg":
        return val === false ? "\x1B[39m" : "\x1B[37m";
      case "default fg":
        if (val === false)
          return "";
        return "\x1B[39m";
      case "black bg":
        return val === false ? "\x1B[49m" : "\x1B[40m";
      case "red bg":
        return val === false ? "\x1B[49m" : "\x1B[41m";
      case "green bg":
        return val === false ? "\x1B[49m" : "\x1B[42m";
      case "yellow bg":
        return val === false ? "\x1B[49m" : "\x1B[43m";
      case "blue bg":
        return val === false ? "\x1B[49m" : "\x1B[44m";
      case "magenta bg":
        return val === false ? "\x1B[49m" : "\x1B[45m";
      case "cyan bg":
        return val === false ? "\x1B[49m" : "\x1B[46m";
      case "white bg":
      case "light grey bg":
      case "light gray bg":
      case "bright grey bg":
      case "bright gray bg":
        return val === false ? "\x1B[49m" : "\x1B[47m";
      case "default bg":
        if (val === false)
          return "";
        return "\x1B[49m";
      case "light black fg":
      case "bright black fg":
      case "grey fg":
      case "gray fg":
        return val === false ? "\x1B[39m" : "\x1B[90m";
      case "light red fg":
      case "bright red fg":
        return val === false ? "\x1B[39m" : "\x1B[91m";
      case "light green fg":
      case "bright green fg":
        return val === false ? "\x1B[39m" : "\x1B[92m";
      case "light yellow fg":
      case "bright yellow fg":
        return val === false ? "\x1B[39m" : "\x1B[93m";
      case "light blue fg":
      case "bright blue fg":
        return val === false ? "\x1B[39m" : "\x1B[94m";
      case "light magenta fg":
      case "bright magenta fg":
        return val === false ? "\x1B[39m" : "\x1B[95m";
      case "light cyan fg":
      case "bright cyan fg":
        return val === false ? "\x1B[39m" : "\x1B[96m";
      case "light white fg":
      case "bright white fg":
        return val === false ? "\x1B[39m" : "\x1B[97m";
      case "light black bg":
      case "bright black bg":
      case "grey bg":
      case "gray bg":
        return val === false ? "\x1B[49m" : "\x1B[100m";
      case "light red bg":
      case "bright red bg":
        return val === false ? "\x1B[49m" : "\x1B[101m";
      case "light green bg":
      case "bright green bg":
        return val === false ? "\x1B[49m" : "\x1B[102m";
      case "light yellow bg":
      case "bright yellow bg":
        return val === false ? "\x1B[49m" : "\x1B[103m";
      case "light blue bg":
      case "bright blue bg":
        return val === false ? "\x1B[49m" : "\x1B[104m";
      case "light magenta bg":
      case "bright magenta bg":
        return val === false ? "\x1B[49m" : "\x1B[105m";
      case "light cyan bg":
      case "bright cyan bg":
        return val === false ? "\x1B[49m" : "\x1B[106m";
      case "light white bg":
      case "bright white bg":
        return val === false ? "\x1B[49m" : "\x1B[107m";
      case "default fg bg":
        if (val === false)
          return "";
        return this.term("rxvt") ? "\x1B[100m" : "\x1B[39;49m";
      default:
        if (param[0] === "#") {
          param = param.replace(/#(?:[0-9a-f]{3}){1,2}/i, colors.match);
        }
        m = /^(-?\d+) (fg|bg)$/.exec(param);
        if (m) {
          color = +m[1];
          if (val === false || color === -1) {
            return this._attr("default " + m[2]);
          }
          color = colors.reduce(color, this.tput.colors);
          if (color < 16 || this.tput && this.tput.colors <= 16) {
            if (m[2] === "fg") {
              if (color < 8) {
                color += 30;
              } else if (color < 16) {
                color -= 8;
                color += 90;
              }
            } else if (m[2] === "bg") {
              if (color < 8) {
                color += 40;
              } else if (color < 16) {
                color -= 8;
                color += 100;
              }
            }
            return "\x1B[" + color + "m";
          }
          if (m[2] === "fg") {
            return "\x1B[38;5;" + color + "m";
          }
          if (m[2] === "bg") {
            return "\x1B[48;5;" + color + "m";
          }
        }
        if (/^[\d;]*$/.test(param)) {
          return "\x1B[" + param + "m";
        }
        return null;
    }
  };
  Program.prototype.fg = Program.prototype.setForeground = function(color, val) {
    color = color.split(/\s*[,;]\s*/).join(" fg, ") + " fg";
    return this.attr(color, val);
  };
  Program.prototype.bg = Program.prototype.setBackground = function(color, val) {
    color = color.split(/\s*[,;]\s*/).join(" bg, ") + " bg";
    return this.attr(color, val);
  };
  Program.prototype.dsr = Program.prototype.deviceStatus = function(param, callback, dec, noBypass) {
    if (dec) {
      return this.response("device-status", "\x1B[?" + (param || "0") + "n", callback, noBypass);
    }
    return this.response("device-status", "\x1B[" + (param || "0") + "n", callback, noBypass);
  };
  Program.prototype.getCursor = function(callback) {
    return this.deviceStatus(6, callback, false, true);
  };
  Program.prototype.saveReportedCursor = function(callback) {
    var self2 = this;
    if (this.tput.strings.user7 === "\x1B[6n" || this.term("screen")) {
      return this.getCursor(function(err, data) {
        if (data) {
          self2._rx = data.status.x;
          self2._ry = data.status.y;
        }
        if (!callback)
          return;
        return callback(err);
      });
    }
    if (!callback)
      return;
    return callback();
  };
  Program.prototype.restoreReportedCursor = function() {
    if (this._rx == null)
      return;
    return this.cup(this._ry, this._rx);
  };
  Program.prototype.ich = Program.prototype.insertChars = function(param) {
    this.x += param || 1;
    this._ncoords();
    if (this.tput)
      return this.put.ich(param);
    return this._write("\x1B[" + (param || 1) + "@");
  };
  Program.prototype.cnl = Program.prototype.cursorNextLine = function(param) {
    this.y += param || 1;
    this._ncoords();
    return this._write("\x1B[" + (param || "") + "E");
  };
  Program.prototype.cpl = Program.prototype.cursorPrecedingLine = function(param) {
    this.y -= param || 1;
    this._ncoords();
    return this._write("\x1B[" + (param || "") + "F");
  };
  Program.prototype.cha = Program.prototype.cursorCharAbsolute = function(param) {
    if (!this.zero) {
      param = (param || 1) - 1;
    } else {
      param = param || 0;
    }
    this.x = param;
    this.y = 0;
    this._ncoords();
    if (this.tput)
      return this.put.hpa(param);
    return this._write("\x1B[" + (param + 1) + "G");
  };
  Program.prototype.il = Program.prototype.insertLines = function(param) {
    if (this.tput)
      return this.put.il(param);
    return this._write("\x1B[" + (param || "") + "L");
  };
  Program.prototype.dl = Program.prototype.deleteLines = function(param) {
    if (this.tput)
      return this.put.dl(param);
    return this._write("\x1B[" + (param || "") + "M");
  };
  Program.prototype.dch = Program.prototype.deleteChars = function(param) {
    if (this.tput)
      return this.put.dch(param);
    return this._write("\x1B[" + (param || "") + "P");
  };
  Program.prototype.ech = Program.prototype.eraseChars = function(param) {
    if (this.tput)
      return this.put.ech(param);
    return this._write("\x1B[" + (param || "") + "X");
  };
  Program.prototype.hpa = Program.prototype.charPosAbsolute = function(param) {
    this.x = param || 0;
    this._ncoords();
    if (this.tput) {
      return this.put.hpa.apply(this.put, arguments);
    }
    param = slice.call(arguments).join(";");
    return this._write("\x1B[" + (param || "") + "`");
  };
  Program.prototype.hpr = Program.prototype.HPositionRelative = function(param) {
    if (this.tput)
      return this.cuf(param);
    this.x += param || 1;
    this._ncoords();
    return this._write("\x1B[" + (param || "") + "a");
  };
  Program.prototype.da = Program.prototype.sendDeviceAttributes = function(param, callback) {
    return this.response("device-attributes", "\x1B[" + (param || "") + "c", callback);
  };
  Program.prototype.vpa = Program.prototype.linePosAbsolute = function(param) {
    this.y = param || 1;
    this._ncoords();
    if (this.tput) {
      return this.put.vpa.apply(this.put, arguments);
    }
    param = slice.call(arguments).join(";");
    return this._write("\x1B[" + (param || "") + "d");
  };
  Program.prototype.vpr = Program.prototype.VPositionRelative = function(param) {
    if (this.tput)
      return this.cud(param);
    this.y += param || 1;
    this._ncoords();
    return this._write("\x1B[" + (param || "") + "e");
  };
  Program.prototype.hvp = Program.prototype.HVPosition = function(row, col) {
    if (!this.zero) {
      row = (row || 1) - 1;
      col = (col || 1) - 1;
    } else {
      row = row || 0;
      col = col || 0;
    }
    this.y = row;
    this.x = col;
    this._ncoords();
    if (this.tput)
      return this.put.cup(row, col);
    return this._write("\x1B[" + (row + 1) + ";" + (col + 1) + "f");
  };
  Program.prototype.sm = Program.prototype.setMode = function() {
    var param = slice.call(arguments).join(";");
    return this._write("\x1B[" + (param || "") + "h");
  };
  Program.prototype.decset = function() {
    var param = slice.call(arguments).join(";");
    return this.setMode("?" + param);
  };
  Program.prototype.dectcem = Program.prototype.cnorm = Program.prototype.cvvis = Program.prototype.showCursor = function() {
    this.cursorHidden = false;
    if (this.tput)
      return this.put.cnorm();
    return this.setMode("?25");
  };
  Program.prototype.alternate = Program.prototype.smcup = Program.prototype.alternateBuffer = function() {
    this.isAlt = true;
    if (this.tput)
      return this.put.smcup();
    if (this.term("vt") || this.term("linux"))
      return;
    this.setMode("?47");
    return this.setMode("?1049");
  };
  Program.prototype.rm = Program.prototype.resetMode = function() {
    var param = slice.call(arguments).join(";");
    return this._write("\x1B[" + (param || "") + "l");
  };
  Program.prototype.decrst = function() {
    var param = slice.call(arguments).join(";");
    return this.resetMode("?" + param);
  };
  Program.prototype.dectcemh = Program.prototype.cursor_invisible = Program.prototype.vi = Program.prototype.civis = Program.prototype.hideCursor = function() {
    this.cursorHidden = true;
    if (this.tput)
      return this.put.civis();
    return this.resetMode("?25");
  };
  Program.prototype.rmcup = Program.prototype.normalBuffer = function() {
    this.isAlt = false;
    if (this.tput)
      return this.put.rmcup();
    this.resetMode("?47");
    return this.resetMode("?1049");
  };
  Program.prototype.enableMouse = function() {
    if (process.env.BLESSED_FORCE_MODES) {
      var modes = process.env.BLESSED_FORCE_MODES.split(",");
      var options = {};
      for (var n = 0;n < modes.length; ++n) {
        var pair = modes[n].split("=");
        var v = pair[1] !== "0";
        switch (pair[0].toUpperCase()) {
          case "SGRMOUSE":
            options.sgrMouse = v;
            break;
          case "UTFMOUSE":
            options.utfMouse = v;
            break;
          case "VT200MOUSE":
            options.vt200Mouse = v;
            break;
          case "URXVTMOUSE":
            options.urxvtMouse = v;
            break;
          case "X10MOUSE":
            options.x10Mouse = v;
            break;
          case "DECMOUSE":
            options.decMouse = v;
            break;
          case "PTERMMOUSE":
            options.ptermMouse = v;
            break;
          case "JSBTERMMOUSE":
            options.jsbtermMouse = v;
            break;
          case "VT200HILITE":
            options.vt200Hilite = v;
            break;
          case "GPMMOUSE":
            options.gpmMouse = v;
            break;
          case "CELLMOTION":
            options.cellMotion = v;
            break;
          case "ALLMOTION":
            options.allMotion = v;
            break;
          case "SENDFOCUS":
            options.sendFocus = v;
            break;
        }
      }
      return this.setMouse(options, true);
    }
    if (this.term("rxvt-unicode")) {
      return this.setMouse({
        urxvtMouse: true,
        cellMotion: true,
        allMotion: true
      }, true);
    }
    if (this.term("rxvt")) {
      return this.setMouse({
        vt200Mouse: true,
        x10Mouse: true,
        cellMotion: true,
        allMotion: true
      }, true);
    }
    if (this.isVTE) {
      return this.setMouse({
        sgrMouse: true,
        cellMotion: true,
        allMotion: true
      }, true);
    }
    if (this.term("linux")) {
      return this.setMouse({
        vt200Mouse: true,
        gpmMouse: true
      }, true);
    }
    if (this.term("xterm") || this.term("screen") || this.tput && this.tput.strings.key_mouse) {
      return this.setMouse({
        vt200Mouse: true,
        utfMouse: true,
        cellMotion: true,
        allMotion: true
      }, true);
    }
  };
  Program.prototype.disableMouse = function() {
    if (!this._currentMouse)
      return;
    var obj = {};
    Object.keys(this._currentMouse).forEach(function(key) {
      obj[key] = false;
    });
    return this.setMouse(obj, false);
  };
  Program.prototype.setMouse = function(opt, enable) {
    if (opt.normalMouse != null) {
      opt.vt200Mouse = opt.normalMouse;
      opt.allMotion = opt.normalMouse;
    }
    if (opt.hiliteTracking != null) {
      opt.vt200Hilite = opt.hiliteTracking;
    }
    if (enable === true) {
      if (this._currentMouse) {
        this.setMouse(opt);
        Object.keys(opt).forEach(function(key) {
          this._currentMouse[key] = opt[key];
        }, this);
        return;
      }
      this._currentMouse = opt;
      this.mouseEnabled = true;
    } else if (enable === false) {
      delete this._currentMouse;
      this.mouseEnabled = false;
    }
    if (opt.x10Mouse != null) {
      if (opt.x10Mouse)
        this.setMode("?9");
      else
        this.resetMode("?9");
    }
    if (opt.vt200Mouse != null) {
      if (opt.vt200Mouse)
        this.setMode("?1000");
      else
        this.resetMode("?1000");
    }
    if (opt.vt200Hilite != null) {
      if (opt.vt200Hilite)
        this.setMode("?1001");
      else
        this.resetMode("?1001");
    }
    if (opt.cellMotion != null) {
      if (opt.cellMotion)
        this.setMode("?1002");
      else
        this.resetMode("?1002");
    }
    if (opt.allMotion != null) {
      if (this.tmux && this.tmuxVersion >= 2) {
        if (opt.allMotion)
          this._twrite("\x1B[?1003h");
        else
          this._twrite("\x1B[?1003l");
      } else {
        if (opt.allMotion)
          this.setMode("?1003");
        else
          this.resetMode("?1003");
      }
    }
    if (opt.sendFocus != null) {
      if (opt.sendFocus)
        this.setMode("?1004");
      else
        this.resetMode("?1004");
    }
    if (opt.utfMouse != null) {
      if (opt.utfMouse)
        this.setMode("?1005");
      else
        this.resetMode("?1005");
    }
    if (opt.sgrMouse != null) {
      if (opt.sgrMouse)
        this.setMode("?1006");
      else
        this.resetMode("?1006");
    }
    if (opt.urxvtMouse != null) {
      if (opt.urxvtMouse)
        this.setMode("?1015");
      else
        this.resetMode("?1015");
    }
    if (opt.decMouse != null) {
      if (opt.decMouse)
        this._write("\x1B[1;2'z\x1B[1;3'{");
      else
        this._write("\x1B['z");
    }
    if (opt.ptermMouse != null) {
      if (opt.ptermMouse)
        this._write("\x1B[>1h\x1B[>6h\x1B[>7h\x1B[>1h\x1B[>9l");
      else
        this._write("\x1B[>1l\x1B[>6l\x1B[>7l\x1B[>1l\x1B[>9h");
    }
    if (opt.jsbtermMouse != null) {
      if (opt.jsbtermMouse)
        this._write("\x1B[0~ZwLMRK+1Q\x1B\\");
      else
        this._write("\x1B[0~ZwQ\x1B\\");
    }
    if (opt.gpmMouse != null) {
      if (opt.gpmMouse)
        this.enableGpm();
      else
        this.disableGpm();
    }
  };
  Program.prototype.decstbm = Program.prototype.csr = Program.prototype.setScrollRegion = function(top, bottom) {
    if (!this.zero) {
      top = (top || 1) - 1;
      bottom = (bottom || this.rows) - 1;
    } else {
      top = top || 0;
      bottom = bottom || this.rows - 1;
    }
    this.scrollTop = top;
    this.scrollBottom = bottom;
    this.x = 0;
    this.y = 0;
    this._ncoords();
    if (this.tput)
      return this.put.csr(top, bottom);
    return this._write("\x1B[" + (top + 1) + ";" + (bottom + 1) + "r");
  };
  Program.prototype.scA = Program.prototype.saveCursorA = function() {
    this.savedX = this.x;
    this.savedY = this.y;
    if (this.tput)
      return this.put.sc();
    return this._write("\x1B[s");
  };
  Program.prototype.rcA = Program.prototype.restoreCursorA = function() {
    this.x = this.savedX || 0;
    this.y = this.savedY || 0;
    if (this.tput)
      return this.put.rc();
    return this._write("\x1B[u");
  };
  Program.prototype.cht = Program.prototype.cursorForwardTab = function(param) {
    this.x += 8;
    this._ncoords();
    if (this.tput)
      return this.put.tab(param);
    return this._write("\x1B[" + (param || 1) + "I");
  };
  Program.prototype.su = Program.prototype.scrollUp = function(param) {
    this.y -= param || 1;
    this._ncoords();
    if (this.tput)
      return this.put.parm_index(param);
    return this._write("\x1B[" + (param || 1) + "S");
  };
  Program.prototype.sd = Program.prototype.scrollDown = function(param) {
    this.y += param || 1;
    this._ncoords();
    if (this.tput)
      return this.put.parm_rindex(param);
    return this._write("\x1B[" + (param || 1) + "T");
  };
  Program.prototype.initMouseTracking = function() {
    return this._write("\x1B[" + slice.call(arguments).join(";") + "T");
  };
  Program.prototype.resetTitleModes = function() {
    return this._write("\x1B[>" + slice.call(arguments).join(";") + "T");
  };
  Program.prototype.cbt = Program.prototype.cursorBackwardTab = function(param) {
    this.x -= 8;
    this._ncoords();
    if (this.tput)
      return this.put.cbt(param);
    return this._write("\x1B[" + (param || 1) + "Z");
  };
  Program.prototype.rep = Program.prototype.repeatPrecedingCharacter = function(param) {
    this.x += param || 1;
    this._ncoords();
    if (this.tput)
      return this.put.rep(param);
    return this._write("\x1B[" + (param || 1) + "b");
  };
  Program.prototype.tbc = Program.prototype.tabClear = function(param) {
    if (this.tput)
      return this.put.tbc(param);
    return this._write("\x1B[" + (param || 0) + "g");
  };
  Program.prototype.mc = Program.prototype.mediaCopy = function() {
    return this._write("\x1B[" + slice.call(arguments).join(";") + "i");
  };
  Program.prototype.print_screen = Program.prototype.ps = Program.prototype.mc0 = function() {
    if (this.tput)
      return this.put.mc0();
    return this.mc("0");
  };
  Program.prototype.prtr_on = Program.prototype.po = Program.prototype.mc5 = function() {
    if (this.tput)
      return this.put.mc5();
    return this.mc("5");
  };
  Program.prototype.prtr_off = Program.prototype.pf = Program.prototype.mc4 = function() {
    if (this.tput)
      return this.put.mc4();
    return this.mc("4");
  };
  Program.prototype.prtr_non = Program.prototype.pO = Program.prototype.mc5p = function() {
    if (this.tput)
      return this.put.mc5p();
    return this.mc("?5");
  };
  Program.prototype.setResources = function() {
    return this._write("\x1B[>" + slice.call(arguments).join(";") + "m");
  };
  Program.prototype.disableModifiers = function(param) {
    return this._write("\x1B[>" + (param || "") + "n");
  };
  Program.prototype.setPointerMode = function(param) {
    return this._write("\x1B[>" + (param || "") + "p");
  };
  Program.prototype.decstr = Program.prototype.rs2 = Program.prototype.softReset = function() {
    if (this.tput)
      return this.put.rs2();
    return this._write("\x1B[!p\x1B[?3;4l\x1B[4l\x1B>");
  };
  Program.prototype.decrqm = Program.prototype.requestAnsiMode = function(param) {
    return this._write("\x1B[" + (param || "") + "$p");
  };
  Program.prototype.decrqmp = Program.prototype.requestPrivateMode = function(param) {
    return this._write("\x1B[?" + (param || "") + "$p");
  };
  Program.prototype.decscl = Program.prototype.setConformanceLevel = function() {
    return this._write("\x1B[" + slice.call(arguments).join(";") + '"p');
  };
  Program.prototype.decll = Program.prototype.loadLEDs = function(param) {
    return this._write("\x1B[" + (param || "") + "q");
  };
  Program.prototype.decscusr = Program.prototype.setCursorStyle = function(param) {
    switch (param) {
      case "blinking block":
        param = 1;
        break;
      case "block":
      case "steady block":
        param = 2;
        break;
      case "blinking underline":
        param = 3;
        break;
      case "underline":
      case "steady underline":
        param = 4;
        break;
      case "blinking bar":
        param = 5;
        break;
      case "bar":
      case "steady bar":
        param = 6;
        break;
    }
    if (param === 2 && this.has("Se")) {
      return this.put.Se();
    }
    if (this.has("Ss")) {
      return this.put.Ss(param);
    }
    return this._write("\x1B[" + (param || 1) + " q");
  };
  Program.prototype.decsca = Program.prototype.setCharProtectionAttr = function(param) {
    return this._write("\x1B[" + (param || 0) + '"q');
  };
  Program.prototype.restorePrivateValues = function() {
    return this._write("\x1B[?" + slice.call(arguments).join(";") + "r");
  };
  Program.prototype.deccara = Program.prototype.setAttrInRectangle = function() {
    return this._write("\x1B[" + slice.call(arguments).join(";") + "$r");
  };
  Program.prototype.savePrivateValues = function() {
    return this._write("\x1B[?" + slice.call(arguments).join(";") + "s");
  };
  Program.prototype.manipulateWindow = function() {
    var args2 = slice.call(arguments);
    var callback = typeof args2[args2.length - 1] === "function" ? args2.pop() : function() {};
    return this.response("window-manipulation", "\x1B[" + args2.join(";") + "t", callback);
  };
  Program.prototype.getWindowSize = function(callback) {
    return this.manipulateWindow(18, callback);
  };
  Program.prototype.decrara = Program.prototype.reverseAttrInRectangle = function() {
    return this._write("\x1B[" + slice.call(arguments).join(";") + "$t");
  };
  Program.prototype.setTitleModeFeature = function() {
    return this._twrite("\x1B[>" + slice.call(arguments).join(";") + "t");
  };
  Program.prototype.decswbv = Program.prototype.setWarningBellVolume = function(param) {
    return this._write("\x1B[" + (param || "") + " t");
  };
  Program.prototype.decsmbv = Program.prototype.setMarginBellVolume = function(param) {
    return this._write("\x1B[" + (param || "") + " u");
  };
  Program.prototype.deccra = Program.prototype.copyRectangle = function() {
    return this._write("\x1B[" + slice.call(arguments).join(";") + "$v");
  };
  Program.prototype.decefr = Program.prototype.enableFilterRectangle = function() {
    return this._write("\x1B[" + slice.call(arguments).join(";") + "'w");
  };
  Program.prototype.decreqtparm = Program.prototype.requestParameters = function(param) {
    return this._write("\x1B[" + (param || 0) + "x");
  };
  Program.prototype.decsace = Program.prototype.selectChangeExtent = function(param) {
    return this._write("\x1B[" + (param || 0) + "x");
  };
  Program.prototype.decfra = Program.prototype.fillRectangle = function() {
    return this._write("\x1B[" + slice.call(arguments).join(";") + "$x");
  };
  Program.prototype.decelr = Program.prototype.enableLocatorReporting = function() {
    return this._write("\x1B[" + slice.call(arguments).join(";") + "'z");
  };
  Program.prototype.decera = Program.prototype.eraseRectangle = function() {
    return this._write("\x1B[" + slice.call(arguments).join(";") + "$z");
  };
  Program.prototype.decsle = Program.prototype.setLocatorEvents = function() {
    return this._write("\x1B[" + slice.call(arguments).join(";") + "'{");
  };
  Program.prototype.decsera = Program.prototype.selectiveEraseRectangle = function() {
    return this._write("\x1B[" + slice.call(arguments).join(";") + "${");
  };
  Program.prototype.decrqlp = Program.prototype.req_mouse_pos = Program.prototype.reqmp = Program.prototype.requestLocatorPosition = function(param, callback) {
    if (this.has("req_mouse_pos")) {
      var code = this.tput.req_mouse_pos(param);
      return this.response("locator-position", code, callback);
    }
    return this.response("locator-position", "\x1B[" + (param || "") + "'|", callback);
  };
  Program.prototype.decic = Program.prototype.insertColumns = function() {
    return this._write("\x1B[" + slice.call(arguments).join(";") + " }");
  };
  Program.prototype.decdc = Program.prototype.deleteColumns = function() {
    return this._write("\x1B[" + slice.call(arguments).join(";") + " ~");
  };
  Program.prototype.out = function(name) {
    var args2 = Array.prototype.slice.call(arguments, 1);
    this.ret = true;
    var out = this[name].apply(this, args2);
    this.ret = false;
    return out;
  };
  Program.prototype.sigtstp = function(callback) {
    var resume = this.pause();
    process.once("SIGCONT", function() {
      resume();
      if (callback)
        callback();
    });
    process.kill(process.pid, "SIGTSTP");
  };
  Program.prototype.pause = function(callback) {
    var self2 = this, isAlt = this.isAlt, mouseEnabled = this.mouseEnabled;
    this.lsaveCursor("pause");
    if (isAlt)
      this.normalBuffer();
    this.showCursor();
    if (mouseEnabled)
      this.disableMouse();
    var write = this.output.write;
    this.output.write = function() {};
    if (this.input.setRawMode) {
      this.input.setRawMode(false);
    }
    this.input.pause();
    return this._resume = function() {
      delete self2._resume;
      if (self2.input.setRawMode) {
        self2.input.setRawMode(true);
      }
      self2.input.resume();
      self2.output.write = write;
      if (isAlt)
        self2.alternateBuffer();
      if (mouseEnabled)
        self2.enableMouse();
      self2.lrestoreCursor("pause", true);
      if (callback)
        callback();
    };
  };
  Program.prototype.resume = function() {
    if (this._resume)
      return this._resume();
  };
  function unshiftEvent(obj, event, listener) {
    var listeners = obj.listeners(event);
    obj.removeAllListeners(event);
    obj.on(event, listener);
    listeners.forEach(function(listener2) {
      obj.on(event, listener2);
    });
  }
  function merge(out) {
    slice.call(arguments, 1).forEach(function(obj) {
      Object.keys(obj).forEach(function(key) {
        out[key] = obj[key];
      });
    });
    return out;
  }
  module.exports = Program;
});

// node_modules/blessed/lib/widget.js
var require_widget = __commonJS((exports) => {
  var widget = exports;
  widget.classes = [
    "Node",
    "Screen",
    "Element",
    "Box",
    "Text",
    "Line",
    "ScrollableBox",
    "ScrollableText",
    "BigText",
    "List",
    "Form",
    "Input",
    "Textarea",
    "Textbox",
    "Button",
    "ProgressBar",
    "FileManager",
    "Checkbox",
    "RadioSet",
    "RadioButton",
    "Prompt",
    "Question",
    "Message",
    "Loading",
    "Listbar",
    "Log",
    "Table",
    "ListTable",
    "Terminal",
    "Image",
    "ANSIImage",
    "OverlayImage",
    "Video",
    "Layout"
  ];
  widget.classes.forEach(function(name) {
    var file = name.toLowerCase();
    widget[name] = widget[file] = __require("./widgets/" + file);
  });
  widget.aliases = {
    ListBar: "Listbar",
    PNG: "ANSIImage"
  };
  Object.keys(widget.aliases).forEach(function(key) {
    var name = widget.aliases[key];
    widget[key] = widget[name];
    widget[key.toLowerCase()] = widget[name];
  });
});

// node_modules/blessed/lib/unicode.js
var require_unicode = __commonJS((exports) => {
  var stringFromCharCode = String.fromCharCode;
  var floor = Math.floor;
  exports.charWidth = function(str, i) {
    var point = typeof str !== "number" ? exports.codePointAt(str, i || 0) : str;
    if (point === 0)
      return 0;
    if (point === 9) {
      if (!exports.blessed) {
        exports.blessed = require_blessed();
      }
      return exports.blessed.screen.global ? exports.blessed.screen.global.tabc.length : 8;
    }
    if (point < 32 || point >= 127 && point < 160) {
      return 0;
    }
    if (exports.combining[point]) {
      return 0;
    }
    if (point === 12288 || 65281 <= point && point <= 65376 || 65504 <= point && point <= 65510) {
      return 2;
    }
    if (4352 <= point && point <= 4447 || 4515 <= point && point <= 4519 || 4602 <= point && point <= 4607 || 9001 <= point && point <= 9002 || 11904 <= point && point <= 11929 || 11931 <= point && point <= 12019 || 12032 <= point && point <= 12245 || 12272 <= point && point <= 12283 || 12289 <= point && point <= 12350 || 12353 <= point && point <= 12438 || 12441 <= point && point <= 12543 || 12549 <= point && point <= 12589 || 12593 <= point && point <= 12686 || 12688 <= point && point <= 12730 || 12736 <= point && point <= 12771 || 12784 <= point && point <= 12830 || 12832 <= point && point <= 12871 || 12880 <= point && point <= 13054 || 13056 <= point && point <= 19903 || 19968 <= point && point <= 42124 || 42128 <= point && point <= 42182 || 43360 <= point && point <= 43388 || 44032 <= point && point <= 55203 || 55216 <= point && point <= 55238 || 55243 <= point && point <= 55291 || 63744 <= point && point <= 64255 || 65040 <= point && point <= 65049 || 65072 <= point && point <= 65106 || 65108 <= point && point <= 65126 || 65128 <= point && point <= 65131 || 110592 <= point && point <= 110593 || 127488 <= point && point <= 127490 || 127504 <= point && point <= 127546 || 127552 <= point && point <= 127560 || 127568 <= point && point <= 127569 || 131072 <= point && point <= 194367 || 177984 <= point && point <= 196605 || 196608 <= point && point <= 262141) {
      return 2;
    }
    if (process.env.NCURSES_CJK_WIDTH) {
      if (point === 161 || point === 164 || 167 <= point && point <= 168 || point === 170 || 173 <= point && point <= 174 || 176 <= point && point <= 180 || 182 <= point && point <= 186 || 188 <= point && point <= 191 || point === 198 || point === 208 || 215 <= point && point <= 216 || 222 <= point && point <= 225 || point === 230 || 232 <= point && point <= 234 || 236 <= point && point <= 237 || point === 240 || 242 <= point && point <= 243 || 247 <= point && point <= 250 || point === 252 || point === 254 || point === 257 || point === 273 || point === 275 || point === 283 || 294 <= point && point <= 295 || point === 299 || 305 <= point && point <= 307 || point === 312 || 319 <= point && point <= 322 || point === 324 || 328 <= point && point <= 331 || point === 333 || 338 <= point && point <= 339 || 358 <= point && point <= 359 || point === 363 || point === 462 || point === 464 || point === 466 || point === 468 || point === 470 || point === 472 || point === 474 || point === 476 || point === 593 || point === 609 || point === 708 || point === 711 || 713 <= point && point <= 715 || point === 717 || point === 720 || 728 <= point && point <= 731 || point === 733 || point === 735 || 768 <= point && point <= 879 || 913 <= point && point <= 929 || 931 <= point && point <= 937 || 945 <= point && point <= 961 || 963 <= point && point <= 969 || point === 1025 || 1040 <= point && point <= 1103 || point === 1105 || point === 8208 || 8211 <= point && point <= 8214 || 8216 <= point && point <= 8217 || 8220 <= point && point <= 8221 || 8224 <= point && point <= 8226 || 8228 <= point && point <= 8231 || point === 8240 || 8242 <= point && point <= 8243 || point === 8245 || point === 8251 || point === 8254 || point === 8308 || point === 8319 || 8321 <= point && point <= 8324 || point === 8364 || point === 8451 || point === 8453 || point === 8457 || point === 8467 || point === 8470 || 8481 <= point && point <= 8482 || point === 8486 || point === 8491 || 8531 <= point && point <= 8532 || 8539 <= point && point <= 8542 || 8544 <= point && point <= 8555 || 8560 <= point && point <= 8569 || point === 8585 || 8592 <= point && point <= 8601 || 8632 <= point && point <= 8633 || point === 8658 || point === 8660 || point === 8679 || point === 8704 || 8706 <= point && point <= 8707 || 8711 <= point && point <= 8712 || point === 8715 || point === 8719 || point === 8721 || point === 8725 || point === 8730 || 8733 <= point && point <= 8736 || point === 8739 || point === 8741 || 8743 <= point && point <= 8748 || point === 8750 || 8756 <= point && point <= 8759 || 8764 <= point && point <= 8765 || point === 8776 || point === 8780 || point === 8786 || 8800 <= point && point <= 8801 || 8804 <= point && point <= 8807 || 8810 <= point && point <= 8811 || 8814 <= point && point <= 8815 || 8834 <= point && point <= 8835 || 8838 <= point && point <= 8839 || point === 8853 || point === 8857 || point === 8869 || point === 8895 || point === 8978 || 9312 <= point && point <= 9449 || 9451 <= point && point <= 9547 || 9552 <= point && point <= 9587 || 9600 <= point && point <= 9615 || 9618 <= point && point <= 9621 || 9632 <= point && point <= 9633 || 9635 <= point && point <= 9641 || 9650 <= point && point <= 9651 || 9654 <= point && point <= 9655 || 9660 <= point && point <= 9661 || 9664 <= point && point <= 9665 || 9670 <= point && point <= 9672 || point === 9675 || 9678 <= point && point <= 9681 || 9698 <= point && point <= 9701 || point === 9711 || 9733 <= point && point <= 9734 || point === 9737 || 9742 <= point && point <= 9743 || 9748 <= point && point <= 9749 || point === 9756 || point === 9758 || point === 9792 || point === 9794 || 9824 <= point && point <= 9825 || 9827 <= point && point <= 9829 || 9831 <= point && point <= 9834 || 9836 <= point && point <= 9837 || point === 9839 || 9886 <= point && point <= 9887 || 9918 <= point && point <= 9919 || 9924 <= point && point <= 9933 || 9935 <= point && point <= 9953 || point === 9955 || 9960 <= point && point <= 9983 || point === 10045 || point === 10071 || 10102 <= point && point <= 10111 || 11093 <= point && point <= 11097 || 12872 <= point && point <= 12879 || 57344 <= point && point <= 63743 || 65024 <= point && point <= 65039 || point === 65533 || 127232 <= point && point <= 127242 || 127248 <= point && point <= 127277 || 127280 <= point && point <= 127337 || 127344 <= point && point <= 127386 || 917760 <= point && point <= 917999 || 983040 <= point && point <= 1048573 || 1048576 <= point && point <= 1114109) {
        return +process.env.NCURSES_CJK_WIDTH || 1;
      }
    }
    return 1;
  };
  exports.strWidth = function(str) {
    var width = 0;
    for (var i = 0;i < str.length; i++) {
      width += exports.charWidth(str, i);
      if (exports.isSurrogate(str, i))
        i++;
    }
    return width;
  };
  exports.isSurrogate = function(str, i) {
    var point = typeof str !== "number" ? exports.codePointAt(str, i || 0) : str;
    return point > 65535;
  };
  exports.combiningTable = [
    [768, 879],
    [1155, 1158],
    [1160, 1161],
    [1425, 1469],
    [1471, 1471],
    [1473, 1474],
    [1476, 1477],
    [1479, 1479],
    [1536, 1539],
    [1552, 1557],
    [1611, 1630],
    [1648, 1648],
    [1750, 1764],
    [1767, 1768],
    [1770, 1773],
    [1807, 1807],
    [1809, 1809],
    [1840, 1866],
    [1958, 1968],
    [2027, 2035],
    [2305, 2306],
    [2364, 2364],
    [2369, 2376],
    [2381, 2381],
    [2385, 2388],
    [2402, 2403],
    [2433, 2433],
    [2492, 2492],
    [2497, 2500],
    [2509, 2509],
    [2530, 2531],
    [2561, 2562],
    [2620, 2620],
    [2625, 2626],
    [2631, 2632],
    [2635, 2637],
    [2672, 2673],
    [2689, 2690],
    [2748, 2748],
    [2753, 2757],
    [2759, 2760],
    [2765, 2765],
    [2786, 2787],
    [2817, 2817],
    [2876, 2876],
    [2879, 2879],
    [2881, 2883],
    [2893, 2893],
    [2902, 2902],
    [2946, 2946],
    [3008, 3008],
    [3021, 3021],
    [3134, 3136],
    [3142, 3144],
    [3146, 3149],
    [3157, 3158],
    [3260, 3260],
    [3263, 3263],
    [3270, 3270],
    [3276, 3277],
    [3298, 3299],
    [3393, 3395],
    [3405, 3405],
    [3530, 3530],
    [3538, 3540],
    [3542, 3542],
    [3633, 3633],
    [3636, 3642],
    [3655, 3662],
    [3761, 3761],
    [3764, 3769],
    [3771, 3772],
    [3784, 3789],
    [3864, 3865],
    [3893, 3893],
    [3895, 3895],
    [3897, 3897],
    [3953, 3966],
    [3968, 3972],
    [3974, 3975],
    [3984, 3991],
    [3993, 4028],
    [4038, 4038],
    [4141, 4144],
    [4146, 4146],
    [4150, 4151],
    [4153, 4153],
    [4184, 4185],
    [4448, 4607],
    [4959, 4959],
    [5906, 5908],
    [5938, 5940],
    [5970, 5971],
    [6002, 6003],
    [6068, 6069],
    [6071, 6077],
    [6086, 6086],
    [6089, 6099],
    [6109, 6109],
    [6155, 6157],
    [6313, 6313],
    [6432, 6434],
    [6439, 6440],
    [6450, 6450],
    [6457, 6459],
    [6679, 6680],
    [6912, 6915],
    [6964, 6964],
    [6966, 6970],
    [6972, 6972],
    [6978, 6978],
    [7019, 7027],
    [7616, 7626],
    [7678, 7679],
    [8203, 8207],
    [8234, 8238],
    [8288, 8291],
    [8298, 8303],
    [8400, 8431],
    [12330, 12335],
    [12441, 12442],
    [43014, 43014],
    [43019, 43019],
    [43045, 43046],
    [64286, 64286],
    [65024, 65039],
    [65056, 65059],
    [65279, 65279],
    [65529, 65531],
    [68097, 68099],
    [68101, 68102],
    [68108, 68111],
    [68152, 68154],
    [68159, 68159],
    [119143, 119145],
    [119155, 119170],
    [119173, 119179],
    [119210, 119213],
    [119362, 119364],
    [917505, 917505],
    [917536, 917631],
    [917760, 917999]
  ];
  exports.combining = exports.combiningTable.reduce(function(out, row) {
    for (var i = row[0];i <= row[1]; i++) {
      out[i] = true;
    }
    return out;
  }, {});
  exports.isCombining = function(str, i) {
    var point = typeof str !== "number" ? exports.codePointAt(str, i || 0) : str;
    return exports.combining[point] === true;
  };
  exports.codePointAt = function(str, position) {
    if (str == null) {
      throw TypeError();
    }
    var string = String(str);
    if (string.codePointAt) {
      return string.codePointAt(position);
    }
    var size = string.length;
    var index = position ? Number(position) : 0;
    if (index !== index) {
      index = 0;
    }
    if (index < 0 || index >= size) {
      return;
    }
    var first = string.charCodeAt(index);
    var second;
    if (first >= 55296 && first <= 56319 && size > index + 1) {
      second = string.charCodeAt(index + 1);
      if (second >= 56320 && second <= 57343) {
        return (first - 55296) * 1024 + second - 56320 + 65536;
      }
    }
    return first;
  };
  exports.fromCodePoint = function() {
    if (String.fromCodePoint) {
      return String.fromCodePoint.apply(String, arguments);
    }
    var MAX_SIZE = 16384;
    var codeUnits = [];
    var highSurrogate;
    var lowSurrogate;
    var index = -1;
    var length = arguments.length;
    if (!length) {
      return "";
    }
    var result = "";
    while (++index < length) {
      var codePoint = Number(arguments[index]);
      if (!isFinite(codePoint) || codePoint < 0 || codePoint > 1114111 || floor(codePoint) !== codePoint) {
        throw RangeError("Invalid code point: " + codePoint);
      }
      if (codePoint <= 65535) {
        codeUnits.push(codePoint);
      } else {
        codePoint -= 65536;
        highSurrogate = (codePoint >> 10) + 55296;
        lowSurrogate = codePoint % 1024 + 56320;
        codeUnits.push(highSurrogate, lowSurrogate);
      }
      if (index + 1 === length || codeUnits.length > MAX_SIZE) {
        result += stringFromCharCode.apply(null, codeUnits);
        codeUnits.length = 0;
      }
    }
    return result;
  };
  exports.chars = {};
  exports.chars.wide = new RegExp("([" + "\\u1100-\\u115f" + "\\u2329\\u232a" + "\\u2e80-\\u303e\\u3040-\\ua4cf" + "\\uac00-\\ud7a3" + "\\uf900-\\ufaff" + "\\ufe10-\\ufe19" + "\\ufe30-\\ufe6f" + "\\uff00-\\uff60" + "\\uffe0-\\uffe6" + "])", "g");
  exports.chars.swide = new RegExp("(" + "[\\ud840-\\ud87f][\\udc00-\\udffd]" + "|" + "[\\ud880-\\ud8bf][\\udc00-\\udffd]" + ")", "g");
  exports.chars.all = new RegExp("(" + exports.chars.swide.source.slice(1, -1) + "|" + exports.chars.wide.source.slice(1, -1) + ")", "g");
  exports.chars.surrogate = /[\ud800-\udbff][\udc00-\udfff]/g;
  exports.chars.combining = exports.combiningTable.reduce(function(out, row) {
    var low, high, range;
    if (row[0] > 65535) {
      low = exports.fromCodePoint(row[0]);
      low = [
        hexify(low.charCodeAt(0)),
        hexify(low.charCodeAt(1))
      ];
      high = exports.fromCodePoint(row[1]);
      high = [
        hexify(high.charCodeAt(0)),
        hexify(high.charCodeAt(1))
      ];
      range = "[\\u" + low[0] + "-" + "\\u" + high[0] + "]" + "[\\u" + low[1] + "-" + "\\u" + high[1] + "]";
      if (!~out.indexOf("|"))
        out += "]";
      out += "|" + range;
    } else {
      low = hexify(row[0]);
      high = hexify(row[1]);
      low = "\\u" + low;
      high = "\\u" + high;
      out += low + "-" + high;
    }
    return out;
  }, "[");
  exports.chars.combining = new RegExp(exports.chars.combining, "g");
  function hexify(n) {
    n = n.toString(16);
    while (n.length < 4)
      n = "0" + n;
    return n;
  }
});

// node_modules/blessed/lib/events.js
var require_events = __commonJS((exports, module) => {
  var slice = Array.prototype.slice;
  function EventEmitter() {
    if (!this._events)
      this._events = {};
  }
  EventEmitter.prototype.setMaxListeners = function(n) {
    this._maxListeners = n;
  };
  EventEmitter.prototype.addListener = function(type, listener) {
    if (!this._events[type]) {
      this._events[type] = listener;
    } else if (typeof this._events[type] === "function") {
      this._events[type] = [this._events[type], listener];
    } else {
      this._events[type].push(listener);
    }
    this._emit("newListener", [type, listener]);
  };
  EventEmitter.prototype.on = EventEmitter.prototype.addListener;
  EventEmitter.prototype.removeListener = function(type, listener) {
    var handler = this._events[type];
    if (!handler)
      return;
    if (typeof handler === "function" || handler.length === 1) {
      delete this._events[type];
      this._emit("removeListener", [type, listener]);
      return;
    }
    for (var i = 0;i < handler.length; i++) {
      if (handler[i] === listener || handler[i].listener === listener) {
        handler.splice(i, 1);
        this._emit("removeListener", [type, listener]);
        return;
      }
    }
  };
  EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
  EventEmitter.prototype.removeAllListeners = function(type) {
    if (type) {
      delete this._events[type];
    } else {
      this._events = {};
    }
  };
  EventEmitter.prototype.once = function(type, listener) {
    function on() {
      this.removeListener(type, on);
      return listener.apply(this, arguments);
    }
    on.listener = listener;
    return this.on(type, on);
  };
  EventEmitter.prototype.listeners = function(type) {
    return typeof this._events[type] === "function" ? [this._events[type]] : this._events[type] || [];
  };
  EventEmitter.prototype._emit = function(type, args2) {
    var handler = this._events[type], ret;
    if (!handler) {
      if (type === "error") {
        throw new args2[0];
      }
      return;
    }
    if (typeof handler === "function") {
      return handler.apply(this, args2);
    }
    for (var i = 0;i < handler.length; i++) {
      if (handler[i].apply(this, args2) === false) {
        ret = false;
      }
    }
    return ret !== false;
  };
  EventEmitter.prototype.emit = function(type) {
    var args2 = slice.call(arguments, 1), params = slice.call(arguments), el = this;
    this._emit("event", params);
    if (this.type === "screen") {
      return this._emit(type, args2);
    }
    if (this._emit(type, args2) === false) {
      return false;
    }
    type = "element " + type;
    args2.unshift(this);
    do {
      if (!el._events[type])
        continue;
      if (el._emit(type, args2) === false) {
        return false;
      }
    } while (el = el.parent);
    return true;
  };
  exports = EventEmitter;
  exports.EventEmitter = EventEmitter;
  module.exports = exports;
});

// node_modules/blessed/lib/widgets/node.js
var require_node5 = __commonJS((exports, module) => {
  var EventEmitter = require_events().EventEmitter;
  function Node(options) {
    var self2 = this;
    var Screen = require_screen();
    if (!(this instanceof Node)) {
      return new Node(options);
    }
    EventEmitter.call(this);
    options = options || {};
    this.options = options;
    this.screen = this.screen || options.screen;
    if (!this.screen) {
      if (this.type === "screen") {
        this.screen = this;
      } else if (Screen.total === 1) {
        this.screen = Screen.global;
      } else if (options.parent) {
        this.screen = options.parent;
        while (this.screen && this.screen.type !== "screen") {
          this.screen = this.screen.parent;
        }
      } else if (Screen.total) {
        this.screen = Screen.instances[Screen.instances.length - 1];
        process.nextTick(function() {
          if (!self2.parent) {
            throw new Error("Element (" + self2.type + ")" + " was not appended synchronously after the" + " screen's creation. Please set a `parent`" + " or `screen` option in the element's constructor" + " if you are going to use multiple screens and" + " append the element later.");
          }
        });
      } else {
        throw new Error("No active screen.");
      }
    }
    this.parent = options.parent || null;
    this.children = [];
    this.$ = this._ = this.data = {};
    this.uid = Node.uid++;
    this.index = this.index != null ? this.index : -1;
    if (this.type !== "screen") {
      this.detached = true;
    }
    if (this.parent) {
      this.parent.append(this);
    }
    (options.children || []).forEach(this.append.bind(this));
  }
  Node.uid = 0;
  Node.prototype.__proto__ = EventEmitter.prototype;
  Node.prototype.type = "node";
  Node.prototype.insert = function(element, i) {
    var self2 = this;
    if (element.screen && element.screen !== this.screen) {
      throw new Error("Cannot switch a node's screen.");
    }
    element.detach();
    element.parent = this;
    element.screen = this.screen;
    if (i === 0) {
      this.children.unshift(element);
    } else if (i === this.children.length) {
      this.children.push(element);
    } else {
      this.children.splice(i, 0, element);
    }
    element.emit("reparent", this);
    this.emit("adopt", element);
    (function emit(el) {
      var n = el.detached !== self2.detached;
      el.detached = self2.detached;
      if (n)
        el.emit("attach");
      el.children.forEach(emit);
    })(element);
    if (!this.screen.focused) {
      this.screen.focused = element;
    }
  };
  Node.prototype.prepend = function(element) {
    this.insert(element, 0);
  };
  Node.prototype.append = function(element) {
    this.insert(element, this.children.length);
  };
  Node.prototype.insertBefore = function(element, other) {
    var i = this.children.indexOf(other);
    if (~i)
      this.insert(element, i);
  };
  Node.prototype.insertAfter = function(element, other) {
    var i = this.children.indexOf(other);
    if (~i)
      this.insert(element, i + 1);
  };
  Node.prototype.remove = function(element) {
    if (element.parent !== this)
      return;
    var i = this.children.indexOf(element);
    if (!~i)
      return;
    element.clearPos();
    element.parent = null;
    this.children.splice(i, 1);
    i = this.screen.clickable.indexOf(element);
    if (~i)
      this.screen.clickable.splice(i, 1);
    i = this.screen.keyable.indexOf(element);
    if (~i)
      this.screen.keyable.splice(i, 1);
    element.emit("reparent", null);
    this.emit("remove", element);
    (function emit(el) {
      var n = el.detached !== true;
      el.detached = true;
      if (n)
        el.emit("detach");
      el.children.forEach(emit);
    })(element);
    if (this.screen.focused === element) {
      this.screen.rewindFocus();
    }
  };
  Node.prototype.detach = function() {
    if (this.parent)
      this.parent.remove(this);
  };
  Node.prototype.free = function() {
    return;
  };
  Node.prototype.destroy = function() {
    this.detach();
    this.forDescendants(function(el) {
      el.free();
      el.destroyed = true;
      el.emit("destroy");
    }, this);
  };
  Node.prototype.forDescendants = function(iter, s) {
    if (s)
      iter(this);
    this.children.forEach(function emit(el) {
      iter(el);
      el.children.forEach(emit);
    });
  };
  Node.prototype.forAncestors = function(iter, s) {
    var el = this;
    if (s)
      iter(this);
    while (el = el.parent) {
      iter(el);
    }
  };
  Node.prototype.collectDescendants = function(s) {
    var out = [];
    this.forDescendants(function(el) {
      out.push(el);
    }, s);
    return out;
  };
  Node.prototype.collectAncestors = function(s) {
    var out = [];
    this.forAncestors(function(el) {
      out.push(el);
    }, s);
    return out;
  };
  Node.prototype.emitDescendants = function() {
    var args2 = Array.prototype.slice(arguments), iter;
    if (typeof args2[args2.length - 1] === "function") {
      iter = args2.pop();
    }
    return this.forDescendants(function(el) {
      if (iter)
        iter(el);
      el.emit.apply(el, args2);
    }, true);
  };
  Node.prototype.emitAncestors = function() {
    var args2 = Array.prototype.slice(arguments), iter;
    if (typeof args2[args2.length - 1] === "function") {
      iter = args2.pop();
    }
    return this.forAncestors(function(el) {
      if (iter)
        iter(el);
      el.emit.apply(el, args2);
    }, true);
  };
  Node.prototype.hasDescendant = function(target) {
    return function find(el) {
      for (var i = 0;i < el.children.length; i++) {
        if (el.children[i] === target) {
          return true;
        }
        if (find(el.children[i]) === true) {
          return true;
        }
      }
      return false;
    }(this);
  };
  Node.prototype.hasAncestor = function(target) {
    var el = this;
    while (el = el.parent) {
      if (el === target)
        return true;
    }
    return false;
  };
  Node.prototype.get = function(name, value) {
    if (this.data.hasOwnProperty(name)) {
      return this.data[name];
    }
    return value;
  };
  Node.prototype.set = function(name, value) {
    return this.data[name] = value;
  };
  module.exports = Node;
});

// node_modules/blessed/lib/widgets/element.js
var require_element = __commonJS((exports, module) => {
  var assert = __require("assert");
  var colors = require_colors();
  var unicode = require_unicode();
  var nextTick = global.setImmediate || process.nextTick.bind(process);
  var helpers = require_helpers();
  var Node = require_node5();
  function Element(options) {
    var self2 = this;
    if (!(this instanceof Node)) {
      return new Element(options);
    }
    options = options || {};
    if (options.scrollable && !this._ignore && this.type !== "scrollable-box") {
      var ScrollableBox = require_scrollablebox();
      Object.getOwnPropertyNames(ScrollableBox.prototype).forEach(function(key) {
        if (key === "type")
          return;
        Object.defineProperty(this, key, Object.getOwnPropertyDescriptor(ScrollableBox.prototype, key));
      }, this);
      this._ignore = true;
      ScrollableBox.call(this, options);
      delete this._ignore;
      return this;
    }
    Node.call(this, options);
    this.name = options.name;
    options.position = options.position || {
      left: options.left,
      right: options.right,
      top: options.top,
      bottom: options.bottom,
      width: options.width,
      height: options.height
    };
    if (options.position.width === "shrink" || options.position.height === "shrink") {
      if (options.position.width === "shrink") {
        delete options.position.width;
      }
      if (options.position.height === "shrink") {
        delete options.position.height;
      }
      options.shrink = true;
    }
    this.position = options.position;
    this.noOverflow = options.noOverflow;
    this.dockBorders = options.dockBorders;
    this.shadow = options.shadow;
    this.style = options.style;
    if (!this.style) {
      this.style = {};
      this.style.fg = options.fg;
      this.style.bg = options.bg;
      this.style.bold = options.bold;
      this.style.underline = options.underline;
      this.style.blink = options.blink;
      this.style.inverse = options.inverse;
      this.style.invisible = options.invisible;
      this.style.transparent = options.transparent;
    }
    this.hidden = options.hidden || false;
    this.fixed = options.fixed || false;
    this.align = options.align || "left";
    this.valign = options.valign || "top";
    this.wrap = options.wrap !== false;
    this.shrink = options.shrink;
    this.fixed = options.fixed;
    this.ch = options.ch || " ";
    if (typeof options.padding === "number" || !options.padding) {
      options.padding = {
        left: options.padding,
        top: options.padding,
        right: options.padding,
        bottom: options.padding
      };
    }
    this.padding = {
      left: options.padding.left || 0,
      top: options.padding.top || 0,
      right: options.padding.right || 0,
      bottom: options.padding.bottom || 0
    };
    this.border = options.border;
    if (this.border) {
      if (typeof this.border === "string") {
        this.border = { type: this.border };
      }
      this.border.type = this.border.type || "bg";
      if (this.border.type === "ascii")
        this.border.type = "line";
      this.border.ch = this.border.ch || " ";
      this.style.border = this.style.border || this.border.style;
      if (!this.style.border) {
        this.style.border = {};
        this.style.border.fg = this.border.fg;
        this.style.border.bg = this.border.bg;
      }
      if (this.border.left == null)
        this.border.left = true;
      if (this.border.top == null)
        this.border.top = true;
      if (this.border.right == null)
        this.border.right = true;
      if (this.border.bottom == null)
        this.border.bottom = true;
    }
    if (options.clickable) {
      this.screen._listenMouse(this);
    }
    if (options.input || options.keyable) {
      this.screen._listenKeys(this);
    }
    this.parseTags = options.parseTags || options.tags;
    this.setContent(options.content || "", true);
    if (options.label) {
      this.setLabel(options.label);
    }
    if (options.hoverText) {
      this.setHover(options.hoverText);
    }
    this.on("newListener", function fn(type) {
      if (type === "mouse" || type === "click" || type === "mouseover" || type === "mouseout" || type === "mousedown" || type === "mouseup" || type === "mousewheel" || type === "wheeldown" || type === "wheelup" || type === "mousemove") {
        self2.screen._listenMouse(self2);
      } else if (type === "keypress" || type.indexOf("key ") === 0) {
        self2.screen._listenKeys(self2);
      }
    });
    this.on("resize", function() {
      self2.parseContent();
    });
    this.on("attach", function() {
      self2.parseContent();
    });
    this.on("detach", function() {
      delete self2.lpos;
    });
    if (options.hoverBg != null) {
      options.hoverEffects = options.hoverEffects || {};
      options.hoverEffects.bg = options.hoverBg;
    }
    if (this.style.hover) {
      options.hoverEffects = this.style.hover;
    }
    if (this.style.focus) {
      options.focusEffects = this.style.focus;
    }
    if (options.effects) {
      if (options.effects.hover)
        options.hoverEffects = options.effects.hover;
      if (options.effects.focus)
        options.focusEffects = options.effects.focus;
    }
    [
      ["hoverEffects", "mouseover", "mouseout", "_htemp"],
      ["focusEffects", "focus", "blur", "_ftemp"]
    ].forEach(function(props) {
      var pname = props[0], over = props[1], out = props[2], temp = props[3];
      self2.screen.setEffects(self2, self2, over, out, self2.options[pname], temp);
    });
    if (this.options.draggable) {
      this.draggable = true;
    }
    if (options.focused) {
      this.focus();
    }
  }
  Element.prototype.__proto__ = Node.prototype;
  Element.prototype.type = "element";
  Element.prototype.__defineGetter__("focused", function() {
    return this.screen.focused === this;
  });
  Element.prototype.sattr = function(style, fg, bg) {
    var { bold, underline, blink, inverse, invisible } = style;
    if (fg == null && bg == null) {
      fg = style.fg;
      bg = style.bg;
    }
    if (typeof bold === "function")
      bold = bold(this);
    if (typeof underline === "function")
      underline = underline(this);
    if (typeof blink === "function")
      blink = blink(this);
    if (typeof inverse === "function")
      inverse = inverse(this);
    if (typeof invisible === "function")
      invisible = invisible(this);
    if (typeof fg === "function")
      fg = fg(this);
    if (typeof bg === "function")
      bg = bg(this);
    return (invisible ? 16 : 0) << 18 | (inverse ? 8 : 0) << 18 | (blink ? 4 : 0) << 18 | (underline ? 2 : 0) << 18 | (bold ? 1 : 0) << 18 | colors.convert(fg) << 9 | colors.convert(bg);
  };
  Element.prototype.onScreenEvent = function(type, handler) {
    var listeners = this._slisteners = this._slisteners || [];
    listeners.push({ type, handler });
    this.screen.on(type, handler);
  };
  Element.prototype.onceScreenEvent = function(type, handler) {
    var listeners = this._slisteners = this._slisteners || [];
    var entry = { type, handler };
    listeners.push(entry);
    this.screen.once(type, function() {
      var i = listeners.indexOf(entry);
      if (~i)
        listeners.splice(i, 1);
      return handler.apply(this, arguments);
    });
  };
  Element.prototype.removeScreenEvent = function(type, handler) {
    var listeners = this._slisteners = this._slisteners || [];
    for (var i = 0;i < listeners.length; i++) {
      var listener = listeners[i];
      if (listener.type === type && listener.handler === handler) {
        listeners.splice(i, 1);
        if (this._slisteners.length === 0) {
          delete this._slisteners;
        }
        break;
      }
    }
    this.screen.removeListener(type, handler);
  };
  Element.prototype.free = function() {
    var listeners = this._slisteners = this._slisteners || [];
    for (var i = 0;i < listeners.length; i++) {
      var listener = listeners[i];
      this.screen.removeListener(listener.type, listener.handler);
    }
    delete this._slisteners;
  };
  Element.prototype.hide = function() {
    if (this.hidden)
      return;
    this.clearPos();
    this.hidden = true;
    this.emit("hide");
    if (this.screen.focused === this) {
      this.screen.rewindFocus();
    }
  };
  Element.prototype.show = function() {
    if (!this.hidden)
      return;
    this.hidden = false;
    this.emit("show");
  };
  Element.prototype.toggle = function() {
    return this.hidden ? this.show() : this.hide();
  };
  Element.prototype.focus = function() {
    return this.screen.focused = this;
  };
  Element.prototype.setContent = function(content, noClear, noTags) {
    if (!noClear)
      this.clearPos();
    this.content = content || "";
    this.parseContent(noTags);
    this.emit("set content");
  };
  Element.prototype.getContent = function() {
    if (!this._clines)
      return "";
    return this._clines.fake.join(`
`);
  };
  Element.prototype.setText = function(content, noClear) {
    content = content || "";
    content = content.replace(/\x1b\[[\d;]*m/g, "");
    return this.setContent(content, noClear, true);
  };
  Element.prototype.getText = function() {
    return this.getContent().replace(/\x1b\[[\d;]*m/g, "");
  };
  Element.prototype.parseContent = function(noTags) {
    if (this.detached)
      return false;
    var width = this.width - this.iwidth;
    if (this._clines == null || this._clines.width !== width || this._clines.content !== this.content) {
      var content = this.content;
      content = content.replace(/[\x00-\x08\x0b-\x0c\x0e-\x1a\x1c-\x1f\x7f]/g, "").replace(/\x1b(?!\[[\d;]*m)/g, "").replace(/\r\n|\r/g, `
`).replace(/\t/g, this.screen.tabc);
      if (this.screen.fullUnicode) {
        content = content.replace(unicode.chars.all, "$1\x03");
        if (this.screen.program.isiTerm2) {
          content = content.replace(unicode.chars.combining, "");
        }
      } else {
        content = content.replace(unicode.chars.all, "??");
        content = content.replace(unicode.chars.combining, "");
        content = content.replace(unicode.chars.surrogate, "?");
      }
      if (!noTags) {
        content = this._parseTags(content);
      }
      this._clines = this._wrapContent(content, width);
      this._clines.width = width;
      this._clines.content = this.content;
      this._clines.attr = this._parseAttr(this._clines);
      this._clines.ci = [];
      this._clines.reduce(function(total, line) {
        this._clines.ci.push(total);
        return total + line.length + 1;
      }.bind(this), 0);
      this._pcontent = this._clines.join(`
`);
      this.emit("parsed content");
      return true;
    }
    this._clines.attr = this._parseAttr(this._clines) || this._clines.attr;
    return false;
  };
  Element.prototype._parseTags = function(text) {
    if (!this.parseTags)
      return text;
    if (!/{\/?[\w\-,;!#]*}/.test(text))
      return text;
    var program = this.screen.program, out = "", state, bg = [], fg = [], flag = [], cap, slash, param, attr, esc;
    for (;; ) {
      if (!esc && (cap = /^{escape}/.exec(text))) {
        text = text.substring(cap[0].length);
        esc = true;
        continue;
      }
      if (esc && (cap = /^([\s\S]+?){\/escape}/.exec(text))) {
        text = text.substring(cap[0].length);
        out += cap[1];
        esc = false;
        continue;
      }
      if (esc) {
        out += text;
        break;
      }
      if (cap = /^{(\/?)([\w\-,;!#]*)}/.exec(text)) {
        text = text.substring(cap[0].length);
        slash = cap[1] === "/";
        param = cap[2].replace(/-/g, " ");
        if (param === "open") {
          out += "{";
          continue;
        } else if (param === "close") {
          out += "}";
          continue;
        }
        if (param.slice(-3) === " bg")
          state = bg;
        else if (param.slice(-3) === " fg")
          state = fg;
        else
          state = flag;
        if (slash) {
          if (!param) {
            out += program._attr("normal");
            bg.length = 0;
            fg.length = 0;
            flag.length = 0;
          } else {
            attr = program._attr(param, false);
            if (attr == null) {
              out += cap[0];
            } else {
              state.pop();
              if (state.length) {
                out += program._attr(state[state.length - 1]);
              } else {
                out += attr;
              }
            }
          }
        } else {
          if (!param) {
            out += cap[0];
          } else {
            attr = program._attr(param);
            if (attr == null) {
              out += cap[0];
            } else {
              state.push(param);
              out += attr;
            }
          }
        }
        continue;
      }
      if (cap = /^[\s\S]+?(?={\/?[\w\-,;!#]*})/.exec(text)) {
        text = text.substring(cap[0].length);
        out += cap[0];
        continue;
      }
      out += text;
      break;
    }
    return out;
  };
  Element.prototype._parseAttr = function(lines) {
    var dattr = this.sattr(this.style), attr = dattr, attrs = [], line, i, j, c;
    if (lines[0].attr === attr) {
      return;
    }
    for (j = 0;j < lines.length; j++) {
      line = lines[j];
      attrs[j] = attr;
      for (i = 0;i < line.length; i++) {
        if (line[i] === "\x1B") {
          if (c = /^\x1b\[[\d;]*m/.exec(line.substring(i))) {
            attr = this.screen.attrCode(c[0], attr, dattr);
            i += c[0].length - 1;
          }
        }
      }
    }
    return attrs;
  };
  Element.prototype._align = function(line, width, align) {
    if (!align)
      return line;
    var cline = line.replace(/\x1b\[[\d;]*m/g, ""), len = cline.length, s = width - len;
    if (this.shrink) {
      s = 0;
    }
    if (len === 0)
      return line;
    if (s < 0)
      return line;
    if (align === "center") {
      s = Array((s / 2 | 0) + 1).join(" ");
      return s + line + s;
    } else if (align === "right") {
      s = Array(s + 1).join(" ");
      return s + line;
    } else if (this.parseTags && ~line.indexOf("{|}")) {
      var parts = line.split("{|}");
      var cparts = cline.split("{|}");
      s = Math.max(width - cparts[0].length - cparts[1].length, 0);
      s = Array(s + 1).join(" ");
      return parts[0] + s + parts[1];
    }
    return line;
  };
  Element.prototype._wrapContent = function(content, width) {
    var tags = this.parseTags, state = this.align, wrap = this.wrap, margin = 0, rtof = [], ftor = [], out = [], no = 0, line, align, cap, total, i, part, j, lines, rest;
    lines = content.split(`
`);
    if (!content) {
      out.push(content);
      out.rtof = [0];
      out.ftor = [[0]];
      out.fake = lines;
      out.real = out;
      out.mwidth = 0;
      return out;
    }
    if (this.scrollbar)
      margin++;
    if (this.type === "textarea")
      margin++;
    if (width > margin)
      width -= margin;
    main:
      for (;no < lines.length; no++) {
        line = lines[no];
        align = state;
        ftor.push([]);
        if (tags) {
          if (cap = /^{(left|center|right)}/.exec(line)) {
            line = line.substring(cap[0].length);
            align = state = cap[1] !== "left" ? cap[1] : null;
          }
          if (cap = /{\/(left|center|right)}$/.exec(line)) {
            line = line.slice(0, -cap[0].length);
            state = this.align;
          }
        }
        while (line.length > width) {
          for (i = 0, total = 0;i < line.length; i++) {
            while (line[i] === "\x1B") {
              while (line[i] && line[i++] !== "m")
                ;
            }
            if (!line[i])
              break;
            if (++total === width) {
              i++;
              if (!wrap) {
                rest = line.substring(i).match(/\x1b\[[^m]*m/g);
                rest = rest ? rest.join("") : "";
                out.push(this._align(line.substring(0, i) + rest, width, align));
                ftor[no].push(out.length - 1);
                rtof.push(no);
                continue main;
              }
              if (!this.screen.fullUnicode) {
                if (i !== line.length) {
                  j = i;
                  while (j > i - 10 && j > 0 && line[--j] !== " ")
                    ;
                  if (line[j] === " ")
                    i = j + 1;
                }
              } else {
                if (i !== line.length) {
                  if (unicode.isSurrogate(line, i))
                    i--;
                  for (var s = 0, n = 0;n < i; n++) {
                    if (unicode.isSurrogate(line, n))
                      s++, n++;
                  }
                  i += s;
                  j = i;
                  while (j > i - 10 && j > 0) {
                    j--;
                    if (line[j] === " " || line[j] === "\x03" || unicode.isSurrogate(line, j - 1) && line[j + 1] !== "\x03" || unicode.isCombining(line, j)) {
                      break;
                    }
                  }
                  if (line[j] === " " || line[j] === "\x03" || unicode.isSurrogate(line, j - 1) && line[j + 1] !== "\x03" || unicode.isCombining(line, j)) {
                    i = j + 1;
                  }
                }
              }
              break;
            }
          }
          part = line.substring(0, i);
          line = line.substring(i);
          out.push(this._align(part, width, align));
          ftor[no].push(out.length - 1);
          rtof.push(no);
          if (line === "")
            continue main;
          if (/^(?:\x1b[\[\d;]*m)+$/.test(line)) {
            out[out.length - 1] += line;
            continue main;
          }
        }
        out.push(this._align(line, width, align));
        ftor[no].push(out.length - 1);
        rtof.push(no);
      }
    out.rtof = rtof;
    out.ftor = ftor;
    out.fake = lines;
    out.real = out;
    out.mwidth = out.reduce(function(current, line2) {
      line2 = line2.replace(/\x1b\[[\d;]*m/g, "");
      return line2.length > current ? line2.length : current;
    }, 0);
    return out;
  };
  Element.prototype.__defineGetter__("visible", function() {
    var el = this;
    do {
      if (el.detached)
        return false;
      if (el.hidden)
        return false;
    } while (el = el.parent);
    return true;
  });
  Element.prototype.__defineGetter__("_detached", function() {
    var el = this;
    do {
      if (el.type === "screen")
        return false;
      if (!el.parent)
        return true;
    } while (el = el.parent);
    return false;
  });
  Element.prototype.enableMouse = function() {
    this.screen._listenMouse(this);
  };
  Element.prototype.enableKeys = function() {
    this.screen._listenKeys(this);
  };
  Element.prototype.enableInput = function() {
    this.screen._listenMouse(this);
    this.screen._listenKeys(this);
  };
  Element.prototype.__defineGetter__("draggable", function() {
    return this._draggable === true;
  });
  Element.prototype.__defineSetter__("draggable", function(draggable) {
    return draggable ? this.enableDrag(draggable) : this.disableDrag();
  });
  Element.prototype.enableDrag = function(verify) {
    var self2 = this;
    if (this._draggable)
      return true;
    if (typeof verify !== "function") {
      verify = function() {
        return true;
      };
    }
    this.enableMouse();
    this.on("mousedown", this._dragMD = function(data) {
      if (self2.screen._dragging)
        return;
      if (!verify(data))
        return;
      self2.screen._dragging = self2;
      self2._drag = {
        x: data.x - self2.aleft,
        y: data.y - self2.atop
      };
      self2.setFront();
    });
    this.onScreenEvent("mouse", this._dragM = function(data) {
      if (self2.screen._dragging !== self2)
        return;
      if (data.action !== "mousedown" && data.action !== "mousemove") {
        delete self2.screen._dragging;
        delete self2._drag;
        return;
      }
      if (!self2.parent)
        return;
      var ox = self2._drag.x, oy = self2._drag.y, px = self2.parent.aleft, py = self2.parent.atop, x = data.x - px - ox, y = data.y - py - oy;
      if (self2.position.right != null) {
        if (self2.position.left != null) {
          self2.width = "100%-" + (self2.parent.width - self2.width);
        }
        self2.position.right = null;
      }
      if (self2.position.bottom != null) {
        if (self2.position.top != null) {
          self2.height = "100%-" + (self2.parent.height - self2.height);
        }
        self2.position.bottom = null;
      }
      self2.rleft = x;
      self2.rtop = y;
      self2.screen.render();
    });
    return this._draggable = true;
  };
  Element.prototype.disableDrag = function() {
    if (!this._draggable)
      return false;
    delete this.screen._dragging;
    delete this._drag;
    this.removeListener("mousedown", this._dragMD);
    this.removeScreenEvent("mouse", this._dragM);
    return this._draggable = false;
  };
  Element.prototype.key = function() {
    return this.screen.program.key.apply(this, arguments);
  };
  Element.prototype.onceKey = function() {
    return this.screen.program.onceKey.apply(this, arguments);
  };
  Element.prototype.unkey = Element.prototype.removeKey = function() {
    return this.screen.program.unkey.apply(this, arguments);
  };
  Element.prototype.setIndex = function(index) {
    if (!this.parent)
      return;
    if (index < 0) {
      index = this.parent.children.length + index;
    }
    index = Math.max(index, 0);
    index = Math.min(index, this.parent.children.length - 1);
    var i = this.parent.children.indexOf(this);
    if (!~i)
      return;
    var item = this.parent.children.splice(i, 1)[0];
    this.parent.children.splice(index, 0, item);
  };
  Element.prototype.setFront = function() {
    return this.setIndex(-1);
  };
  Element.prototype.setBack = function() {
    return this.setIndex(0);
  };
  Element.prototype.clearPos = function(get, override) {
    if (this.detached)
      return;
    var lpos = this._getCoords(get);
    if (!lpos)
      return;
    this.screen.clearRegion(lpos.xi, lpos.xl, lpos.yi, lpos.yl, override);
  };
  Element.prototype.setLabel = function(options) {
    var self2 = this;
    var Box = require_box();
    if (typeof options === "string") {
      options = { text: options };
    }
    if (this._label) {
      this._label.setContent(options.text);
      if (options.side !== "right") {
        this._label.rleft = 2 + (this.border ? -1 : 0);
        this._label.position.right = undefined;
        if (!this.screen.autoPadding) {
          this._label.rleft = 2;
        }
      } else {
        this._label.rright = 2 + (this.border ? -1 : 0);
        this._label.position.left = undefined;
        if (!this.screen.autoPadding) {
          this._label.rright = 2;
        }
      }
      return;
    }
    this._label = new Box({
      screen: this.screen,
      parent: this,
      content: options.text,
      top: -this.itop,
      tags: this.parseTags,
      shrink: true,
      style: this.style.label
    });
    if (options.side !== "right") {
      this._label.rleft = 2 - this.ileft;
    } else {
      this._label.rright = 2 - this.iright;
    }
    this._label._isLabel = true;
    if (!this.screen.autoPadding) {
      if (options.side !== "right") {
        this._label.rleft = 2;
      } else {
        this._label.rright = 2;
      }
      this._label.rtop = 0;
    }
    var reposition = function() {
      self2._label.rtop = (self2.childBase || 0) - self2.itop;
      if (!self2.screen.autoPadding) {
        self2._label.rtop = self2.childBase || 0;
      }
      self2.screen.render();
    };
    this.on("scroll", this._labelScroll = function() {
      reposition();
    });
    this.on("resize", this._labelResize = function() {
      nextTick(function() {
        reposition();
      });
    });
  };
  Element.prototype.removeLabel = function() {
    if (!this._label)
      return;
    this.removeListener("scroll", this._labelScroll);
    this.removeListener("resize", this._labelResize);
    this._label.detach();
    delete this._labelScroll;
    delete this._labelResize;
    delete this._label;
  };
  Element.prototype.setHover = function(options) {
    if (typeof options === "string") {
      options = { text: options };
    }
    this._hoverOptions = options;
    this.enableMouse();
    this.screen._initHover();
  };
  Element.prototype.removeHover = function() {
    delete this._hoverOptions;
    if (!this.screen._hoverText || this.screen._hoverText.detached)
      return;
    this.screen._hoverText.detach();
    this.screen.render();
  };
  Element.prototype._getPos = function() {
    var pos = this.lpos;
    assert.ok(pos);
    if (pos.aleft != null)
      return pos;
    pos.aleft = pos.xi;
    pos.atop = pos.yi;
    pos.aright = this.screen.cols - pos.xl;
    pos.abottom = this.screen.rows - pos.yl;
    pos.width = pos.xl - pos.xi;
    pos.height = pos.yl - pos.yi;
    return pos;
  };
  Element.prototype._getWidth = function(get) {
    var parent = get ? this.parent._getPos() : this.parent, width = this.position.width, left, expr;
    if (typeof width === "string") {
      if (width === "half")
        width = "50%";
      expr = width.split(/(?=\+|-)/);
      width = expr[0];
      width = +width.slice(0, -1) / 100;
      width = parent.width * width | 0;
      width += +(expr[1] || 0);
      return width;
    }
    if (width == null) {
      left = this.position.left || 0;
      if (typeof left === "string") {
        if (left === "center")
          left = "50%";
        expr = left.split(/(?=\+|-)/);
        left = expr[0];
        left = +left.slice(0, -1) / 100;
        left = parent.width * left | 0;
        left += +(expr[1] || 0);
      }
      width = parent.width - (this.position.right || 0) - left;
      if (this.screen.autoPadding) {
        if ((this.position.left != null || this.position.right == null) && this.position.left !== "center") {
          width -= this.parent.ileft;
        }
        width -= this.parent.iright;
      }
    }
    return width;
  };
  Element.prototype.__defineGetter__("width", function() {
    return this._getWidth(false);
  });
  Element.prototype._getHeight = function(get) {
    var parent = get ? this.parent._getPos() : this.parent, height = this.position.height, top, expr;
    if (typeof height === "string") {
      if (height === "half")
        height = "50%";
      expr = height.split(/(?=\+|-)/);
      height = expr[0];
      height = +height.slice(0, -1) / 100;
      height = parent.height * height | 0;
      height += +(expr[1] || 0);
      return height;
    }
    if (height == null) {
      top = this.position.top || 0;
      if (typeof top === "string") {
        if (top === "center")
          top = "50%";
        expr = top.split(/(?=\+|-)/);
        top = expr[0];
        top = +top.slice(0, -1) / 100;
        top = parent.height * top | 0;
        top += +(expr[1] || 0);
      }
      height = parent.height - (this.position.bottom || 0) - top;
      if (this.screen.autoPadding) {
        if ((this.position.top != null || this.position.bottom == null) && this.position.top !== "center") {
          height -= this.parent.itop;
        }
        height -= this.parent.ibottom;
      }
    }
    return height;
  };
  Element.prototype.__defineGetter__("height", function() {
    return this._getHeight(false);
  });
  Element.prototype._getLeft = function(get) {
    var parent = get ? this.parent._getPos() : this.parent, left = this.position.left || 0, expr;
    if (typeof left === "string") {
      if (left === "center")
        left = "50%";
      expr = left.split(/(?=\+|-)/);
      left = expr[0];
      left = +left.slice(0, -1) / 100;
      left = parent.width * left | 0;
      left += +(expr[1] || 0);
      if (this.position.left === "center") {
        left -= this._getWidth(get) / 2 | 0;
      }
    }
    if (this.position.left == null && this.position.right != null) {
      return this.screen.cols - this._getWidth(get) - this._getRight(get);
    }
    if (this.screen.autoPadding) {
      if ((this.position.left != null || this.position.right == null) && this.position.left !== "center") {
        left += this.parent.ileft;
      }
    }
    return (parent.aleft || 0) + left;
  };
  Element.prototype.__defineGetter__("aleft", function() {
    return this._getLeft(false);
  });
  Element.prototype._getRight = function(get) {
    var parent = get ? this.parent._getPos() : this.parent, right;
    if (this.position.right == null && this.position.left != null) {
      right = this.screen.cols - (this._getLeft(get) + this._getWidth(get));
      if (this.screen.autoPadding) {
        right += this.parent.iright;
      }
      return right;
    }
    right = (parent.aright || 0) + (this.position.right || 0);
    if (this.screen.autoPadding) {
      right += this.parent.iright;
    }
    return right;
  };
  Element.prototype.__defineGetter__("aright", function() {
    return this._getRight(false);
  });
  Element.prototype._getTop = function(get) {
    var parent = get ? this.parent._getPos() : this.parent, top = this.position.top || 0, expr;
    if (typeof top === "string") {
      if (top === "center")
        top = "50%";
      expr = top.split(/(?=\+|-)/);
      top = expr[0];
      top = +top.slice(0, -1) / 100;
      top = parent.height * top | 0;
      top += +(expr[1] || 0);
      if (this.position.top === "center") {
        top -= this._getHeight(get) / 2 | 0;
      }
    }
    if (this.position.top == null && this.position.bottom != null) {
      return this.screen.rows - this._getHeight(get) - this._getBottom(get);
    }
    if (this.screen.autoPadding) {
      if ((this.position.top != null || this.position.bottom == null) && this.position.top !== "center") {
        top += this.parent.itop;
      }
    }
    return (parent.atop || 0) + top;
  };
  Element.prototype.__defineGetter__("atop", function() {
    return this._getTop(false);
  });
  Element.prototype._getBottom = function(get) {
    var parent = get ? this.parent._getPos() : this.parent, bottom;
    if (this.position.bottom == null && this.position.top != null) {
      bottom = this.screen.rows - (this._getTop(get) + this._getHeight(get));
      if (this.screen.autoPadding) {
        bottom += this.parent.ibottom;
      }
      return bottom;
    }
    bottom = (parent.abottom || 0) + (this.position.bottom || 0);
    if (this.screen.autoPadding) {
      bottom += this.parent.ibottom;
    }
    return bottom;
  };
  Element.prototype.__defineGetter__("abottom", function() {
    return this._getBottom(false);
  });
  Element.prototype.__defineGetter__("rleft", function() {
    return this.aleft - this.parent.aleft;
  });
  Element.prototype.__defineGetter__("rright", function() {
    return this.aright - this.parent.aright;
  });
  Element.prototype.__defineGetter__("rtop", function() {
    return this.atop - this.parent.atop;
  });
  Element.prototype.__defineGetter__("rbottom", function() {
    return this.abottom - this.parent.abottom;
  });
  Element.prototype.__defineSetter__("width", function(val) {
    if (this.position.width === val)
      return;
    if (/^\d+$/.test(val))
      val = +val;
    this.emit("resize");
    this.clearPos();
    return this.position.width = val;
  });
  Element.prototype.__defineSetter__("height", function(val) {
    if (this.position.height === val)
      return;
    if (/^\d+$/.test(val))
      val = +val;
    this.emit("resize");
    this.clearPos();
    return this.position.height = val;
  });
  Element.prototype.__defineSetter__("aleft", function(val) {
    var expr;
    if (typeof val === "string") {
      if (val === "center") {
        val = this.screen.width / 2 | 0;
        val -= this.width / 2 | 0;
      } else {
        expr = val.split(/(?=\+|-)/);
        val = expr[0];
        val = +val.slice(0, -1) / 100;
        val = this.screen.width * val | 0;
        val += +(expr[1] || 0);
      }
    }
    val -= this.parent.aleft;
    if (this.position.left === val)
      return;
    this.emit("move");
    this.clearPos();
    return this.position.left = val;
  });
  Element.prototype.__defineSetter__("aright", function(val) {
    val -= this.parent.aright;
    if (this.position.right === val)
      return;
    this.emit("move");
    this.clearPos();
    return this.position.right = val;
  });
  Element.prototype.__defineSetter__("atop", function(val) {
    var expr;
    if (typeof val === "string") {
      if (val === "center") {
        val = this.screen.height / 2 | 0;
        val -= this.height / 2 | 0;
      } else {
        expr = val.split(/(?=\+|-)/);
        val = expr[0];
        val = +val.slice(0, -1) / 100;
        val = this.screen.height * val | 0;
        val += +(expr[1] || 0);
      }
    }
    val -= this.parent.atop;
    if (this.position.top === val)
      return;
    this.emit("move");
    this.clearPos();
    return this.position.top = val;
  });
  Element.prototype.__defineSetter__("abottom", function(val) {
    val -= this.parent.abottom;
    if (this.position.bottom === val)
      return;
    this.emit("move");
    this.clearPos();
    return this.position.bottom = val;
  });
  Element.prototype.__defineSetter__("rleft", function(val) {
    if (this.position.left === val)
      return;
    if (/^\d+$/.test(val))
      val = +val;
    this.emit("move");
    this.clearPos();
    return this.position.left = val;
  });
  Element.prototype.__defineSetter__("rright", function(val) {
    if (this.position.right === val)
      return;
    this.emit("move");
    this.clearPos();
    return this.position.right = val;
  });
  Element.prototype.__defineSetter__("rtop", function(val) {
    if (this.position.top === val)
      return;
    if (/^\d+$/.test(val))
      val = +val;
    this.emit("move");
    this.clearPos();
    return this.position.top = val;
  });
  Element.prototype.__defineSetter__("rbottom", function(val) {
    if (this.position.bottom === val)
      return;
    this.emit("move");
    this.clearPos();
    return this.position.bottom = val;
  });
  Element.prototype.__defineGetter__("ileft", function() {
    return (this.border ? 1 : 0) + this.padding.left;
  });
  Element.prototype.__defineGetter__("itop", function() {
    return (this.border ? 1 : 0) + this.padding.top;
  });
  Element.prototype.__defineGetter__("iright", function() {
    return (this.border ? 1 : 0) + this.padding.right;
  });
  Element.prototype.__defineGetter__("ibottom", function() {
    return (this.border ? 1 : 0) + this.padding.bottom;
  });
  Element.prototype.__defineGetter__("iwidth", function() {
    return (this.border ? 2 : 0) + this.padding.left + this.padding.right;
  });
  Element.prototype.__defineGetter__("iheight", function() {
    return (this.border ? 2 : 0) + this.padding.top + this.padding.bottom;
  });
  Element.prototype.__defineGetter__("tpadding", function() {
    return this.padding.left + this.padding.top + this.padding.right + this.padding.bottom;
  });
  Element.prototype.__defineGetter__("left", function() {
    return this.rleft;
  });
  Element.prototype.__defineGetter__("right", function() {
    return this.rright;
  });
  Element.prototype.__defineGetter__("top", function() {
    return this.rtop;
  });
  Element.prototype.__defineGetter__("bottom", function() {
    return this.rbottom;
  });
  Element.prototype.__defineSetter__("left", function(val) {
    return this.rleft = val;
  });
  Element.prototype.__defineSetter__("right", function(val) {
    return this.rright = val;
  });
  Element.prototype.__defineSetter__("top", function(val) {
    return this.rtop = val;
  });
  Element.prototype.__defineSetter__("bottom", function(val) {
    return this.rbottom = val;
  });
  Element.prototype._getShrinkBox = function(xi, xl, yi, yl, get) {
    if (!this.children.length) {
      return { xi, xl: xi + 1, yi, yl: yi + 1 };
    }
    var i, el, ret, mxi = xi, mxl = xi + 1, myi = yi, myl = yi + 1;
    var _lpos;
    if (get) {
      _lpos = this.lpos;
      this.lpos = { xi, xl, yi, yl };
    }
    for (i = 0;i < this.children.length; i++) {
      el = this.children[i];
      ret = el._getCoords(get);
      if (!ret)
        continue;
      if (el.position.left == null && el.position.right != null) {
        ret.xl = xi + (ret.xl - ret.xi);
        ret.xi = xi;
        if (this.screen.autoPadding) {
          ret.xl += this.ileft;
          ret.xi += this.ileft;
        }
      }
      if (el.position.top == null && el.position.bottom != null) {
        ret.yl = yi + (ret.yl - ret.yi);
        ret.yi = yi;
        if (this.screen.autoPadding) {
          ret.yl += this.itop;
          ret.yi += this.itop;
        }
      }
      if (ret.xi < mxi)
        mxi = ret.xi;
      if (ret.xl > mxl)
        mxl = ret.xl;
      if (ret.yi < myi)
        myi = ret.yi;
      if (ret.yl > myl)
        myl = ret.yl;
    }
    if (get) {
      this.lpos = _lpos;
    }
    if (this.position.width == null && (this.position.left == null || this.position.right == null)) {
      if (this.position.left == null && this.position.right != null) {
        xi = xl - (mxl - mxi);
        if (!this.screen.autoPadding) {
          xi -= this.padding.left + this.padding.right;
        } else {
          xi -= this.ileft;
        }
      } else {
        xl = mxl;
        if (!this.screen.autoPadding) {
          xl += this.padding.left + this.padding.right;
          if (this.type === "list-table") {
            xl -= this.padding.left + this.padding.right;
            xl += this.iright;
          }
        } else {
          xl += this.iright;
        }
      }
    }
    if (this.position.height == null && (this.position.top == null || this.position.bottom == null) && (!this.scrollable || this._isList)) {
      if (this._isList) {
        myi = 0 - this.itop;
        myl = this.items.length + this.ibottom;
      }
      if (this.position.top == null && this.position.bottom != null) {
        yi = yl - (myl - myi);
        if (!this.screen.autoPadding) {
          yi -= this.padding.top + this.padding.bottom;
        } else {
          yi -= this.itop;
        }
      } else {
        yl = myl;
        if (!this.screen.autoPadding) {
          yl += this.padding.top + this.padding.bottom;
        } else {
          yl += this.ibottom;
        }
      }
    }
    return { xi, xl, yi, yl };
  };
  Element.prototype._getShrinkContent = function(xi, xl, yi, yl) {
    var h = this._clines.length, w = this._clines.mwidth || 1;
    if (this.position.width == null && (this.position.left == null || this.position.right == null)) {
      if (this.position.left == null && this.position.right != null) {
        xi = xl - w - this.iwidth;
      } else {
        xl = xi + w + this.iwidth;
      }
    }
    if (this.position.height == null && (this.position.top == null || this.position.bottom == null) && (!this.scrollable || this._isList)) {
      if (this.position.top == null && this.position.bottom != null) {
        yi = yl - h - this.iheight;
      } else {
        yl = yi + h + this.iheight;
      }
    }
    return { xi, xl, yi, yl };
  };
  Element.prototype._getShrink = function(xi, xl, yi, yl, get) {
    var shrinkBox = this._getShrinkBox(xi, xl, yi, yl, get), shrinkContent = this._getShrinkContent(xi, xl, yi, yl, get), xll = xl, yll = yl;
    if (shrinkBox.xl - shrinkBox.xi > shrinkContent.xl - shrinkContent.xi) {
      xi = shrinkBox.xi;
      xl = shrinkBox.xl;
    } else {
      xi = shrinkContent.xi;
      xl = shrinkContent.xl;
    }
    if (shrinkBox.yl - shrinkBox.yi > shrinkContent.yl - shrinkContent.yi) {
      yi = shrinkBox.yi;
      yl = shrinkBox.yl;
    } else {
      yi = shrinkContent.yi;
      yl = shrinkContent.yl;
    }
    if (xl < xll && this.position.left === "center") {
      xll = (xll - xl) / 2 | 0;
      xi += xll;
      xl += xll;
    }
    if (yl < yll && this.position.top === "center") {
      yll = (yll - yl) / 2 | 0;
      yi += yll;
      yl += yll;
    }
    return { xi, xl, yi, yl };
  };
  Element.prototype._getCoords = function(get, noscroll) {
    if (this.hidden)
      return;
    var xi = this._getLeft(get), xl = xi + this._getWidth(get), yi = this._getTop(get), yl = yi + this._getHeight(get), base = this.childBase || 0, el = this, fixed = this.fixed, coords, v, noleft, noright, notop, nobot, ppos, b;
    if (this.shrink) {
      coords = this._getShrink(xi, xl, yi, yl, get);
      xi = coords.xi, xl = coords.xl;
      yi = coords.yi, yl = coords.yl;
    }
    while (el = el.parent) {
      if (el.scrollable) {
        if (fixed) {
          fixed = false;
          continue;
        }
        break;
      }
    }
    var thisparent = el;
    if (el && !noscroll) {
      ppos = thisparent.lpos;
      if (!ppos)
        return;
      yi -= ppos.base;
      yl -= ppos.base;
      b = thisparent.border ? 1 : 0;
      if (this._isLabel) {
        b = 0;
      }
      if (yi < ppos.yi + b) {
        if (yl - 1 < ppos.yi + b) {
          return;
        } else {
          notop = true;
          v = ppos.yi - yi;
          if (this.border)
            v--;
          if (thisparent.border)
            v++;
          base += v;
          yi += v;
        }
      } else if (yl > ppos.yl - b) {
        if (yi > ppos.yl - 1 - b) {
          return;
        } else {
          nobot = true;
          v = yl - ppos.yl;
          if (this.border)
            v--;
          if (thisparent.border)
            v++;
          yl -= v;
        }
      }
      if (yi >= yl)
        return;
      if (xi < el.lpos.xi) {
        xi = el.lpos.xi;
        noleft = true;
        if (this.border)
          xi--;
        if (thisparent.border)
          xi++;
      }
      if (xl > el.lpos.xl) {
        xl = el.lpos.xl;
        noright = true;
        if (this.border)
          xl++;
        if (thisparent.border)
          xl--;
      }
      if (xi >= xl)
        return;
    }
    if (this.noOverflow && this.parent.lpos) {
      if (xi < this.parent.lpos.xi + this.parent.ileft) {
        xi = this.parent.lpos.xi + this.parent.ileft;
      }
      if (xl > this.parent.lpos.xl - this.parent.iright) {
        xl = this.parent.lpos.xl - this.parent.iright;
      }
      if (yi < this.parent.lpos.yi + this.parent.itop) {
        yi = this.parent.lpos.yi + this.parent.itop;
      }
      if (yl > this.parent.lpos.yl - this.parent.ibottom) {
        yl = this.parent.lpos.yl - this.parent.ibottom;
      }
    }
    return {
      xi,
      xl,
      yi,
      yl,
      base,
      noleft,
      noright,
      notop,
      nobot,
      renders: this.screen.renders
    };
  };
  Element.prototype.render = function() {
    this._emit("prerender");
    this.parseContent();
    var coords = this._getCoords(true);
    if (!coords) {
      delete this.lpos;
      return;
    }
    if (coords.xl - coords.xi <= 0) {
      coords.xl = Math.max(coords.xl, coords.xi);
      return;
    }
    if (coords.yl - coords.yi <= 0) {
      coords.yl = Math.max(coords.yl, coords.yi);
      return;
    }
    var lines = this.screen.lines, xi = coords.xi, xl = coords.xl, yi = coords.yi, yl = coords.yl, x, y, cell, attr, ch, content = this._pcontent, ci = this._clines.ci[coords.base], battr, dattr, c, visible, i, bch = this.ch;
    if (coords.base >= this._clines.ci.length) {
      ci = this._pcontent.length;
    }
    this.lpos = coords;
    if (this.border && this.border.type === "line") {
      this.screen._borderStops[coords.yi] = true;
      this.screen._borderStops[coords.yl - 1] = true;
    }
    dattr = this.sattr(this.style);
    attr = dattr;
    if (ci > 0) {
      attr = this._clines.attr[Math.min(coords.base, this._clines.length - 1)];
    }
    if (this.border)
      xi++, xl--, yi++, yl--;
    if (this.tpadding || this.valign && this.valign !== "top") {
      if (this.style.transparent) {
        for (y = Math.max(yi, 0);y < yl; y++) {
          if (!lines[y])
            break;
          for (x = Math.max(xi, 0);x < xl; x++) {
            if (!lines[y][x])
              break;
            lines[y][x][0] = colors.blend(attr, lines[y][x][0]);
            lines[y].dirty = true;
          }
        }
      } else {
        this.screen.fillRegion(dattr, bch, xi, xl, yi, yl);
      }
    }
    if (this.tpadding) {
      xi += this.padding.left, xl -= this.padding.right;
      yi += this.padding.top, yl -= this.padding.bottom;
    }
    if (this.valign === "middle" || this.valign === "bottom") {
      visible = yl - yi;
      if (this._clines.length < visible) {
        if (this.valign === "middle") {
          visible = visible / 2 | 0;
          visible -= this._clines.length / 2 | 0;
        } else if (this.valign === "bottom") {
          visible -= this._clines.length;
        }
        ci -= visible * (xl - xi);
      }
    }
    for (y = yi;y < yl; y++) {
      if (!lines[y]) {
        if (y >= this.screen.height || yl < this.ibottom) {
          break;
        } else {
          continue;
        }
      }
      for (x = xi;x < xl; x++) {
        cell = lines[y][x];
        if (!cell) {
          if (x >= this.screen.width || xl < this.iright) {
            break;
          } else {
            continue;
          }
        }
        ch = content[ci++] || bch;
        while (ch === "\x1B") {
          if (c = /^\x1b\[[\d;]*m/.exec(content.substring(ci - 1))) {
            ci += c[0].length - 1;
            attr = this.screen.attrCode(c[0], attr, dattr);
            if (this.parent._isList && this.parent.interactive && this.parent.items[this.parent.selected] === this && this.parent.options.invertSelected !== false) {
              attr = attr & ~(511 << 9) | dattr & 511 << 9;
            }
            ch = content[ci] || bch;
            ci++;
          } else {
            break;
          }
        }
        if (ch === "\t")
          ch = bch;
        if (ch === `
`) {
          if (x === xi && y !== yi && content[ci - 2] !== `
`) {
            x--;
            continue;
          }
          ch = bch;
          for (;x < xl; x++) {
            cell = lines[y][x];
            if (!cell)
              break;
            if (this.style.transparent) {
              lines[y][x][0] = colors.blend(attr, lines[y][x][0]);
              if (content[ci])
                lines[y][x][1] = ch;
              lines[y].dirty = true;
            } else {
              if (attr !== cell[0] || ch !== cell[1]) {
                lines[y][x][0] = attr;
                lines[y][x][1] = ch;
                lines[y].dirty = true;
              }
            }
          }
          continue;
        }
        if (this.screen.fullUnicode && content[ci - 1]) {
          var point = unicode.codePointAt(content, ci - 1);
          if (unicode.combining[point]) {
            if (point > 65535) {
              ch = content[ci - 1] + content[ci];
              ci++;
            }
            if (x - 1 >= xi) {
              lines[y][x - 1][1] += ch;
            } else if (y - 1 >= yi) {
              lines[y - 1][xl - 1][1] += ch;
            }
            x--;
            continue;
          }
          if (point > 65535) {
            ch = content[ci - 1] + content[ci];
            ci++;
          }
        }
        if (this._noFill)
          continue;
        if (this.style.transparent) {
          lines[y][x][0] = colors.blend(attr, lines[y][x][0]);
          if (content[ci])
            lines[y][x][1] = ch;
          lines[y].dirty = true;
        } else {
          if (attr !== cell[0] || ch !== cell[1]) {
            lines[y][x][0] = attr;
            lines[y][x][1] = ch;
            lines[y].dirty = true;
          }
        }
      }
    }
    if (this.scrollbar) {
      i = Math.max(this._clines.length, this._scrollBottom());
    }
    if (coords.notop || coords.nobot)
      i = -Infinity;
    if (this.scrollbar && yl - yi < i) {
      x = xl - 1;
      if (this.scrollbar.ignoreBorder && this.border)
        x++;
      if (this.alwaysScroll) {
        y = this.childBase / (i - (yl - yi));
      } else {
        y = (this.childBase + this.childOffset) / (i - 1);
      }
      y = yi + ((yl - yi) * y | 0);
      if (y >= yl)
        y = yl - 1;
      cell = lines[y] && lines[y][x];
      if (cell) {
        if (this.track) {
          ch = this.track.ch || " ";
          attr = this.sattr(this.style.track, this.style.track.fg || this.style.fg, this.style.track.bg || this.style.bg);
          this.screen.fillRegion(attr, ch, x, x + 1, yi, yl);
        }
        ch = this.scrollbar.ch || " ";
        attr = this.sattr(this.style.scrollbar, this.style.scrollbar.fg || this.style.fg, this.style.scrollbar.bg || this.style.bg);
        if (attr !== cell[0] || ch !== cell[1]) {
          lines[y][x][0] = attr;
          lines[y][x][1] = ch;
          lines[y].dirty = true;
        }
      }
    }
    if (this.border)
      xi--, xl++, yi--, yl++;
    if (this.tpadding) {
      xi -= this.padding.left, xl += this.padding.right;
      yi -= this.padding.top, yl += this.padding.bottom;
    }
    if (this.border) {
      battr = this.sattr(this.style.border);
      y = yi;
      if (coords.notop)
        y = -1;
      for (x = xi;x < xl; x++) {
        if (!lines[y])
          break;
        if (coords.noleft && x === xi)
          continue;
        if (coords.noright && x === xl - 1)
          continue;
        cell = lines[y][x];
        if (!cell)
          continue;
        if (this.border.type === "line") {
          if (x === xi) {
            ch = "";
            if (!this.border.left) {
              if (this.border.top) {
                ch = "";
              } else {
                continue;
              }
            } else {
              if (!this.border.top) {
                ch = "";
              }
            }
          } else if (x === xl - 1) {
            ch = "";
            if (!this.border.right) {
              if (this.border.top) {
                ch = "";
              } else {
                continue;
              }
            } else {
              if (!this.border.top) {
                ch = "";
              }
            }
          } else {
            ch = "";
          }
        } else if (this.border.type === "bg") {
          ch = this.border.ch;
        }
        if (!this.border.top && x !== xi && x !== xl - 1) {
          ch = " ";
          if (dattr !== cell[0] || ch !== cell[1]) {
            lines[y][x][0] = dattr;
            lines[y][x][1] = ch;
            lines[y].dirty = true;
            continue;
          }
        }
        if (battr !== cell[0] || ch !== cell[1]) {
          lines[y][x][0] = battr;
          lines[y][x][1] = ch;
          lines[y].dirty = true;
        }
      }
      y = yi + 1;
      for (;y < yl - 1; y++) {
        if (!lines[y])
          continue;
        cell = lines[y][xi];
        if (cell) {
          if (this.border.left) {
            if (this.border.type === "line") {
              ch = "";
            } else if (this.border.type === "bg") {
              ch = this.border.ch;
            }
            if (!coords.noleft) {
              if (battr !== cell[0] || ch !== cell[1]) {
                lines[y][xi][0] = battr;
                lines[y][xi][1] = ch;
                lines[y].dirty = true;
              }
            }
          } else {
            ch = " ";
            if (dattr !== cell[0] || ch !== cell[1]) {
              lines[y][xi][0] = dattr;
              lines[y][xi][1] = ch;
              lines[y].dirty = true;
            }
          }
        }
        cell = lines[y][xl - 1];
        if (cell) {
          if (this.border.right) {
            if (this.border.type === "line") {
              ch = "";
            } else if (this.border.type === "bg") {
              ch = this.border.ch;
            }
            if (!coords.noright) {
              if (battr !== cell[0] || ch !== cell[1]) {
                lines[y][xl - 1][0] = battr;
                lines[y][xl - 1][1] = ch;
                lines[y].dirty = true;
              }
            }
          } else {
            ch = " ";
            if (dattr !== cell[0] || ch !== cell[1]) {
              lines[y][xl - 1][0] = dattr;
              lines[y][xl - 1][1] = ch;
              lines[y].dirty = true;
            }
          }
        }
      }
      y = yl - 1;
      if (coords.nobot)
        y = -1;
      for (x = xi;x < xl; x++) {
        if (!lines[y])
          break;
        if (coords.noleft && x === xi)
          continue;
        if (coords.noright && x === xl - 1)
          continue;
        cell = lines[y][x];
        if (!cell)
          continue;
        if (this.border.type === "line") {
          if (x === xi) {
            ch = "";
            if (!this.border.left) {
              if (this.border.bottom) {
                ch = "";
              } else {
                continue;
              }
            } else {
              if (!this.border.bottom) {
                ch = "";
              }
            }
          } else if (x === xl - 1) {
            ch = "";
            if (!this.border.right) {
              if (this.border.bottom) {
                ch = "";
              } else {
                continue;
              }
            } else {
              if (!this.border.bottom) {
                ch = "";
              }
            }
          } else {
            ch = "";
          }
        } else if (this.border.type === "bg") {
          ch = this.border.ch;
        }
        if (!this.border.bottom && x !== xi && x !== xl - 1) {
          ch = " ";
          if (dattr !== cell[0] || ch !== cell[1]) {
            lines[y][x][0] = dattr;
            lines[y][x][1] = ch;
            lines[y].dirty = true;
          }
          continue;
        }
        if (battr !== cell[0] || ch !== cell[1]) {
          lines[y][x][0] = battr;
          lines[y][x][1] = ch;
          lines[y].dirty = true;
        }
      }
    }
    if (this.shadow) {
      y = Math.max(yi + 1, 0);
      for (;y < yl + 1; y++) {
        if (!lines[y])
          break;
        x = xl;
        for (;x < xl + 2; x++) {
          if (!lines[y][x])
            break;
          lines[y][x][0] = colors.blend(lines[y][x][0]);
          lines[y].dirty = true;
        }
      }
      y = yl;
      for (;y < yl + 1; y++) {
        if (!lines[y])
          break;
        for (x = Math.max(xi + 1, 0);x < xl; x++) {
          if (!lines[y][x])
            break;
          lines[y][x][0] = colors.blend(lines[y][x][0]);
          lines[y].dirty = true;
        }
      }
    }
    this.children.forEach(function(el) {
      if (el.screen._ci !== -1) {
        el.index = el.screen._ci++;
      }
      el.render();
    });
    this._emit("render", [coords]);
    return coords;
  };
  Element.prototype._render = Element.prototype.render;
  Element.prototype.insertLine = function(i, line) {
    if (typeof line === "string")
      line = line.split(`
`);
    if (i !== i || i == null) {
      i = this._clines.ftor.length;
    }
    i = Math.max(i, 0);
    while (this._clines.fake.length < i) {
      this._clines.fake.push("");
      this._clines.ftor.push([this._clines.push("") - 1]);
      this._clines.rtof(this._clines.fake.length - 1);
    }
    var start = this._clines.length, diff, real;
    if (i >= this._clines.ftor.length) {
      real = this._clines.ftor[this._clines.ftor.length - 1];
      real = real[real.length - 1] + 1;
    } else {
      real = this._clines.ftor[i][0];
    }
    for (var j = 0;j < line.length; j++) {
      this._clines.fake.splice(i + j, 0, line[j]);
    }
    this.setContent(this._clines.fake.join(`
`), true);
    diff = this._clines.length - start;
    if (diff > 0) {
      var pos = this._getCoords();
      if (!pos)
        return;
      var height = pos.yl - pos.yi - this.iheight, base = this.childBase || 0, visible = real >= base && real - base < height;
      if (pos && visible && this.screen.cleanSides(this)) {
        this.screen.insertLine(diff, pos.yi + this.itop + real - base, pos.yi, pos.yl - this.ibottom - 1);
      }
    }
  };
  Element.prototype.deleteLine = function(i, n) {
    n = n || 1;
    if (i !== i || i == null) {
      i = this._clines.ftor.length - 1;
    }
    i = Math.max(i, 0);
    i = Math.min(i, this._clines.ftor.length - 1);
    var start = this._clines.length, diff, real = this._clines.ftor[i][0];
    while (n--) {
      this._clines.fake.splice(i, 1);
    }
    this.setContent(this._clines.fake.join(`
`), true);
    diff = start - this._clines.length;
    var height = 0;
    if (diff > 0) {
      var pos = this._getCoords();
      if (!pos)
        return;
      height = pos.yl - pos.yi - this.iheight;
      var base = this.childBase || 0, visible = real >= base && real - base < height;
      if (pos && visible && this.screen.cleanSides(this)) {
        this.screen.deleteLine(diff, pos.yi + this.itop + real - base, pos.yi, pos.yl - this.ibottom - 1);
      }
    }
    if (this._clines.length < height) {
      this.clearPos();
    }
  };
  Element.prototype.insertTop = function(line) {
    var fake = this._clines.rtof[this.childBase || 0];
    return this.insertLine(fake, line);
  };
  Element.prototype.insertBottom = function(line) {
    var h = (this.childBase || 0) + this.height - this.iheight, i = Math.min(h, this._clines.length), fake = this._clines.rtof[i - 1] + 1;
    return this.insertLine(fake, line);
  };
  Element.prototype.deleteTop = function(n) {
    var fake = this._clines.rtof[this.childBase || 0];
    return this.deleteLine(fake, n);
  };
  Element.prototype.deleteBottom = function(n) {
    var h = (this.childBase || 0) + this.height - 1 - this.iheight, i = Math.min(h, this._clines.length - 1), fake = this._clines.rtof[i];
    n = n || 1;
    return this.deleteLine(fake - (n - 1), n);
  };
  Element.prototype.setLine = function(i, line) {
    i = Math.max(i, 0);
    while (this._clines.fake.length < i) {
      this._clines.fake.push("");
    }
    this._clines.fake[i] = line;
    return this.setContent(this._clines.fake.join(`
`), true);
  };
  Element.prototype.setBaseLine = function(i, line) {
    var fake = this._clines.rtof[this.childBase || 0];
    return this.setLine(fake + i, line);
  };
  Element.prototype.getLine = function(i) {
    i = Math.max(i, 0);
    i = Math.min(i, this._clines.fake.length - 1);
    return this._clines.fake[i];
  };
  Element.prototype.getBaseLine = function(i) {
    var fake = this._clines.rtof[this.childBase || 0];
    return this.getLine(fake + i);
  };
  Element.prototype.clearLine = function(i) {
    i = Math.min(i, this._clines.fake.length - 1);
    return this.setLine(i, "");
  };
  Element.prototype.clearBaseLine = function(i) {
    var fake = this._clines.rtof[this.childBase || 0];
    return this.clearLine(fake + i);
  };
  Element.prototype.unshiftLine = function(line) {
    return this.insertLine(0, line);
  };
  Element.prototype.shiftLine = function(n) {
    return this.deleteLine(0, n);
  };
  Element.prototype.pushLine = function(line) {
    if (!this.content)
      return this.setLine(0, line);
    return this.insertLine(this._clines.fake.length, line);
  };
  Element.prototype.popLine = function(n) {
    return this.deleteLine(this._clines.fake.length - 1, n);
  };
  Element.prototype.getLines = function() {
    return this._clines.fake.slice();
  };
  Element.prototype.getScreenLines = function() {
    return this._clines.slice();
  };
  Element.prototype.strWidth = function(text) {
    text = this.parseTags ? helpers.stripTags(text) : text;
    return this.screen.fullUnicode ? unicode.strWidth(text) : helpers.dropUnicode(text).length;
  };
  Element.prototype.screenshot = function(xi, xl, yi, yl) {
    xi = this.lpos.xi + this.ileft + (xi || 0);
    if (xl != null) {
      xl = this.lpos.xi + this.ileft + (xl || 0);
    } else {
      xl = this.lpos.xl - this.iright;
    }
    yi = this.lpos.yi + this.itop + (yi || 0);
    if (yl != null) {
      yl = this.lpos.yi + this.itop + (yl || 0);
    } else {
      yl = this.lpos.yl - this.ibottom;
    }
    return this.screen.screenshot(xi, xl, yi, yl);
  };
  module.exports = Element;
});

// node_modules/blessed/lib/widgets/box.js
var require_box = __commonJS((exports, module) => {
  var Node = require_node5();
  var Element = require_element();
  function Box(options) {
    if (!(this instanceof Node)) {
      return new Box(options);
    }
    options = options || {};
    Element.call(this, options);
  }
  Box.prototype.__proto__ = Element.prototype;
  Box.prototype.type = "box";
  module.exports = Box;
});

// node_modules/blessed/lib/widgets/scrollablebox.js
var require_scrollablebox = __commonJS((exports, module) => {
  var Node = require_node5();
  var Box = require_box();
  function ScrollableBox(options) {
    var self2 = this;
    if (!(this instanceof Node)) {
      return new ScrollableBox(options);
    }
    options = options || {};
    Box.call(this, options);
    if (options.scrollable === false) {
      return this;
    }
    this.scrollable = true;
    this.childOffset = 0;
    this.childBase = 0;
    this.baseLimit = options.baseLimit || Infinity;
    this.alwaysScroll = options.alwaysScroll;
    this.scrollbar = options.scrollbar;
    if (this.scrollbar) {
      this.scrollbar.ch = this.scrollbar.ch || " ";
      this.style.scrollbar = this.style.scrollbar || this.scrollbar.style;
      if (!this.style.scrollbar) {
        this.style.scrollbar = {};
        this.style.scrollbar.fg = this.scrollbar.fg;
        this.style.scrollbar.bg = this.scrollbar.bg;
        this.style.scrollbar.bold = this.scrollbar.bold;
        this.style.scrollbar.underline = this.scrollbar.underline;
        this.style.scrollbar.inverse = this.scrollbar.inverse;
        this.style.scrollbar.invisible = this.scrollbar.invisible;
      }
      if (this.track || this.scrollbar.track) {
        this.track = this.scrollbar.track || this.track;
        this.style.track = this.style.scrollbar.track || this.style.track;
        this.track.ch = this.track.ch || " ";
        this.style.track = this.style.track || this.track.style;
        if (!this.style.track) {
          this.style.track = {};
          this.style.track.fg = this.track.fg;
          this.style.track.bg = this.track.bg;
          this.style.track.bold = this.track.bold;
          this.style.track.underline = this.track.underline;
          this.style.track.inverse = this.track.inverse;
          this.style.track.invisible = this.track.invisible;
        }
        this.track.style = this.style.track;
      }
      if (options.mouse) {
        this.on("mousedown", function(data) {
          if (self2._scrollingBar) {
            delete self2.screen._dragging;
            delete self2._drag;
            return;
          }
          var x = data.x - self2.aleft;
          var y = data.y - self2.atop;
          if (x === self2.width - self2.iright - 1) {
            delete self2.screen._dragging;
            delete self2._drag;
            var perc = (y - self2.itop) / (self2.height - self2.iheight);
            self2.setScrollPerc(perc * 100 | 0);
            self2.screen.render();
            var smd, smu;
            self2._scrollingBar = true;
            self2.onScreenEvent("mousedown", smd = function(data2) {
              var y2 = data2.y - self2.atop;
              var perc2 = y2 / self2.height;
              self2.setScrollPerc(perc2 * 100 | 0);
              self2.screen.render();
            });
            self2.onScreenEvent("mouseup", smu = function() {
              self2._scrollingBar = false;
              self2.removeScreenEvent("mousedown", smd);
              self2.removeScreenEvent("mouseup", smu);
            });
          }
        });
      }
    }
    if (options.mouse) {
      this.on("wheeldown", function() {
        self2.scroll(self2.height / 2 | 0 || 1);
        self2.screen.render();
      });
      this.on("wheelup", function() {
        self2.scroll(-(self2.height / 2 | 0) || -1);
        self2.screen.render();
      });
    }
    if (options.keys && !options.ignoreKeys) {
      this.on("keypress", function(ch, key) {
        if (key.name === "up" || options.vi && key.name === "k") {
          self2.scroll(-1);
          self2.screen.render();
          return;
        }
        if (key.name === "down" || options.vi && key.name === "j") {
          self2.scroll(1);
          self2.screen.render();
          return;
        }
        if (options.vi && key.name === "u" && key.ctrl) {
          self2.scroll(-(self2.height / 2 | 0) || -1);
          self2.screen.render();
          return;
        }
        if (options.vi && key.name === "d" && key.ctrl) {
          self2.scroll(self2.height / 2 | 0 || 1);
          self2.screen.render();
          return;
        }
        if (options.vi && key.name === "b" && key.ctrl) {
          self2.scroll(-self2.height || -1);
          self2.screen.render();
          return;
        }
        if (options.vi && key.name === "f" && key.ctrl) {
          self2.scroll(self2.height || 1);
          self2.screen.render();
          return;
        }
        if (options.vi && key.name === "g" && !key.shift) {
          self2.scrollTo(0);
          self2.screen.render();
          return;
        }
        if (options.vi && key.name === "g" && key.shift) {
          self2.scrollTo(self2.getScrollHeight());
          self2.screen.render();
          return;
        }
      });
    }
    this.on("parsed content", function() {
      self2._recalculateIndex();
    });
    self2._recalculateIndex();
  }
  ScrollableBox.prototype.__proto__ = Box.prototype;
  ScrollableBox.prototype.type = "scrollable-box";
  ScrollableBox.prototype.__defineGetter__("reallyScrollable", function() {
    if (this.shrink)
      return this.scrollable;
    return this.getScrollHeight() > this.height;
  });
  ScrollableBox.prototype._scrollBottom = function() {
    if (!this.scrollable)
      return 0;
    if (this._isList) {
      return this.items ? this.items.length : 0;
    }
    if (this.lpos && this.lpos._scrollBottom) {
      return this.lpos._scrollBottom;
    }
    var bottom = this.children.reduce(function(current, el) {
      if (!el.detached) {
        var lpos = el._getCoords(false, true);
        if (lpos) {
          return Math.max(current, el.rtop + (lpos.yl - lpos.yi));
        }
      }
      return Math.max(current, el.rtop + el.height);
    }, 0);
    if (this.lpos)
      this.lpos._scrollBottom = bottom;
    return bottom;
  };
  ScrollableBox.prototype.setScroll = ScrollableBox.prototype.scrollTo = function(offset, always) {
    this.scroll(0);
    return this.scroll(offset - (this.childBase + this.childOffset), always);
  };
  ScrollableBox.prototype.getScroll = function() {
    return this.childBase + this.childOffset;
  };
  ScrollableBox.prototype.scroll = function(offset, always) {
    if (!this.scrollable)
      return;
    if (this.detached)
      return;
    var visible = this.height - this.iheight, base = this.childBase, d, p, t, b, max, emax;
    if (this.alwaysScroll || always) {
      this.childOffset = offset > 0 ? visible - 1 + offset : offset;
    } else {
      this.childOffset += offset;
    }
    if (this.childOffset > visible - 1) {
      d = this.childOffset - (visible - 1);
      this.childOffset -= d;
      this.childBase += d;
    } else if (this.childOffset < 0) {
      d = this.childOffset;
      this.childOffset += -d;
      this.childBase += d;
    }
    if (this.childBase < 0) {
      this.childBase = 0;
    } else if (this.childBase > this.baseLimit) {
      this.childBase = this.baseLimit;
    }
    if (this.childBase === base) {
      return this.emit("scroll");
    }
    this.parseContent();
    max = this._clines.length - (this.height - this.iheight);
    if (max < 0)
      max = 0;
    emax = this._scrollBottom() - (this.height - this.iheight);
    if (emax < 0)
      emax = 0;
    this.childBase = Math.min(this.childBase, Math.max(emax, max));
    if (this.childBase < 0) {
      this.childBase = 0;
    } else if (this.childBase > this.baseLimit) {
      this.childBase = this.baseLimit;
    }
    p = this.lpos;
    if (p && this.childBase !== base && this.screen.cleanSides(this)) {
      t = p.yi + this.itop;
      b = p.yl - this.ibottom - 1;
      d = this.childBase - base;
      if (d > 0 && d < visible) {
        this.screen.deleteLine(d, t, t, b);
      } else if (d < 0 && -d < visible) {
        d = -d;
        this.screen.insertLine(d, t, t, b);
      }
    }
    return this.emit("scroll");
  };
  ScrollableBox.prototype._recalculateIndex = function() {
    var max, emax;
    if (this.detached || !this.scrollable) {
      return 0;
    }
    max = this._clines.length - (this.height - this.iheight);
    if (max < 0)
      max = 0;
    emax = this._scrollBottom() - (this.height - this.iheight);
    if (emax < 0)
      emax = 0;
    this.childBase = Math.min(this.childBase, Math.max(emax, max));
    if (this.childBase < 0) {
      this.childBase = 0;
    } else if (this.childBase > this.baseLimit) {
      this.childBase = this.baseLimit;
    }
  };
  ScrollableBox.prototype.resetScroll = function() {
    if (!this.scrollable)
      return;
    this.childOffset = 0;
    this.childBase = 0;
    return this.emit("scroll");
  };
  ScrollableBox.prototype.getScrollHeight = function() {
    return Math.max(this._clines.length, this._scrollBottom());
  };
  ScrollableBox.prototype.getScrollPerc = function(s) {
    var pos = this.lpos || this._getCoords();
    if (!pos)
      return s ? -1 : 0;
    var height = pos.yl - pos.yi - this.iheight, i = this.getScrollHeight(), p;
    if (height < i) {
      if (this.alwaysScroll) {
        p = this.childBase / (i - height);
      } else {
        p = (this.childBase + this.childOffset) / (i - 1);
      }
      return p * 100;
    }
    return s ? -1 : 0;
  };
  ScrollableBox.prototype.setScrollPerc = function(i) {
    var m = Math.max(this._clines.length, this._scrollBottom());
    return this.scrollTo(i / 100 * m | 0);
  };
  module.exports = ScrollableBox;
});

// node_modules/blessed/lib/widgets/scrollabletext.js
var require_scrollabletext = __commonJS((exports, module) => {
  var Node = require_node5();
  var ScrollableBox = require_scrollablebox();
  function ScrollableText(options) {
    if (!(this instanceof Node)) {
      return new ScrollableText(options);
    }
    options = options || {};
    options.alwaysScroll = true;
    ScrollableBox.call(this, options);
  }
  ScrollableText.prototype.__proto__ = ScrollableBox.prototype;
  ScrollableText.prototype.type = "scrollable-text";
  module.exports = ScrollableText;
});

// node_modules/blessed/lib/widgets/log.js
var require_log = __commonJS((exports, module) => {
  var util = __require("util");
  var nextTick = global.setImmediate || process.nextTick.bind(process);
  var Node = require_node5();
  var ScrollableText = require_scrollabletext();
  function Log(options) {
    var self2 = this;
    if (!(this instanceof Node)) {
      return new Log(options);
    }
    options = options || {};
    ScrollableText.call(this, options);
    this.scrollback = options.scrollback != null ? options.scrollback : Infinity;
    this.scrollOnInput = options.scrollOnInput;
    this.on("set content", function() {
      if (!self2._userScrolled || self2.scrollOnInput) {
        nextTick(function() {
          self2.setScrollPerc(100);
          self2._userScrolled = false;
          self2.screen.render();
        });
      }
    });
  }
  Log.prototype.__proto__ = ScrollableText.prototype;
  Log.prototype.type = "log";
  Log.prototype.log = Log.prototype.add = function() {
    var args2 = Array.prototype.slice.call(arguments);
    if (typeof args2[0] === "object") {
      args2[0] = util.inspect(args2[0], true, 20, true);
    }
    var text = util.format.apply(util, args2);
    this.emit("log", text);
    var ret = this.pushLine(text);
    if (this._clines.fake.length > this.scrollback) {
      this.shiftLine(0, this.scrollback / 3 | 0);
    }
    return ret;
  };
  Log.prototype._scroll = Log.prototype.scroll;
  Log.prototype.scroll = function(offset, always) {
    if (offset === 0)
      return this._scroll(offset, always);
    this._userScrolled = true;
    var ret = this._scroll(offset, always);
    if (this.getScrollPerc() === 100) {
      this._userScrolled = false;
    }
    return ret;
  };
  module.exports = Log;
});

// node_modules/blessed/lib/widgets/screen.js
var require_screen = __commonJS((exports, module) => {
  var path = __require("path");
  var fs = __require("fs");
  var cp = __require("child_process");
  var colors = require_colors();
  var program = require_program();
  var unicode = require_unicode();
  var nextTick = global.setImmediate || process.nextTick.bind(process);
  var helpers = require_helpers();
  var Node = require_node5();
  var Log = require_log();
  var Element = require_element();
  var Box = require_box();
  function Screen(options) {
    var self2 = this;
    if (!(this instanceof Node)) {
      return new Screen(options);
    }
    Screen.bind(this);
    options = options || {};
    if (options.rsety && options.listen) {
      options = { program: options };
    }
    this.program = options.program;
    if (!this.program) {
      this.program = program({
        input: options.input,
        output: options.output,
        log: options.log,
        debug: options.debug,
        dump: options.dump,
        terminal: options.terminal || options.term,
        resizeTimeout: options.resizeTimeout,
        forceUnicode: options.forceUnicode,
        tput: true,
        buffer: true,
        zero: true
      });
    } else {
      this.program.setupTput();
      this.program.useBuffer = true;
      this.program.zero = true;
      this.program.options.resizeTimeout = options.resizeTimeout;
      if (options.forceUnicode != null) {
        this.program.tput.features.unicode = options.forceUnicode;
        this.program.tput.unicode = options.forceUnicode;
      }
    }
    this.tput = this.program.tput;
    Node.call(this, options);
    this.autoPadding = options.autoPadding !== false;
    this.tabc = Array((options.tabSize || 4) + 1).join(" ");
    this.dockBorders = options.dockBorders;
    this.ignoreLocked = options.ignoreLocked || [];
    this._unicode = this.tput.unicode || this.tput.numbers.U8 === 1;
    this.fullUnicode = this.options.fullUnicode && this._unicode;
    this.dattr = 0 << 18 | 511 << 9 | 511;
    this.renders = 0;
    this.position = {
      left: this.left = this.aleft = this.rleft = 0,
      right: this.right = this.aright = this.rright = 0,
      top: this.top = this.atop = this.rtop = 0,
      bottom: this.bottom = this.abottom = this.rbottom = 0,
      get height() {
        return self2.height;
      },
      get width() {
        return self2.width;
      }
    };
    this.ileft = 0;
    this.itop = 0;
    this.iright = 0;
    this.ibottom = 0;
    this.iheight = 0;
    this.iwidth = 0;
    this.padding = {
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
    this.hover = null;
    this.history = [];
    this.clickable = [];
    this.keyable = [];
    this.grabKeys = false;
    this.lockKeys = false;
    this.focused;
    this._buf = "";
    this._ci = -1;
    if (options.title) {
      this.title = options.title;
    }
    options.cursor = options.cursor || {
      artificial: options.artificialCursor,
      shape: options.cursorShape,
      blink: options.cursorBlink,
      color: options.cursorColor
    };
    this.cursor = {
      artificial: options.cursor.artificial || false,
      shape: options.cursor.shape || "block",
      blink: options.cursor.blink || false,
      color: options.cursor.color || null,
      _set: false,
      _state: 1,
      _hidden: true
    };
    this.program.on("resize", function() {
      self2.alloc();
      self2.render();
      (function emit(el) {
        el.emit("resize");
        el.children.forEach(emit);
      })(self2);
    });
    this.program.on("focus", function() {
      self2.emit("focus");
    });
    this.program.on("blur", function() {
      self2.emit("blur");
    });
    this.program.on("warning", function(text) {
      self2.emit("warning", text);
    });
    this.on("newListener", function fn(type) {
      if (type === "keypress" || type.indexOf("key ") === 0 || type === "mouse") {
        if (type === "keypress" || type.indexOf("key ") === 0)
          self2._listenKeys();
        if (type === "mouse")
          self2._listenMouse();
      }
      if (type === "mouse" || type === "click" || type === "mouseover" || type === "mouseout" || type === "mousedown" || type === "mouseup" || type === "mousewheel" || type === "wheeldown" || type === "wheelup" || type === "mousemove") {
        self2._listenMouse();
      }
    });
    this.setMaxListeners(Infinity);
    this.enter();
    this.postEnter();
  }
  Screen.global = null;
  Screen.total = 0;
  Screen.instances = [];
  Screen.bind = function(screen) {
    if (!Screen.global) {
      Screen.global = screen;
    }
    if (!~Screen.instances.indexOf(screen)) {
      Screen.instances.push(screen);
      screen.index = Screen.total;
      Screen.total++;
    }
    if (Screen._bound)
      return;
    Screen._bound = true;
    process.on("uncaughtException", Screen._exceptionHandler = function(err) {
      if (process.listeners("uncaughtException").length > 1) {
        return;
      }
      Screen.instances.slice().forEach(function(screen2) {
        screen2.destroy();
      });
      err = err || new Error("Uncaught Exception.");
      console.error(err.stack ? err.stack + "" : err + "");
      nextTick(function() {
        process.exit(1);
      });
    });
    ["SIGTERM", "SIGINT", "SIGQUIT"].forEach(function(signal) {
      var name = "_" + signal.toLowerCase() + "Handler";
      process.on(signal, Screen[name] = function() {
        if (process.listeners(signal).length > 1) {
          return;
        }
        nextTick(function() {
          process.exit(0);
        });
      });
    });
    process.on("exit", Screen._exitHandler = function() {
      Screen.instances.slice().forEach(function(screen2) {
        screen2.destroy();
      });
    });
  };
  Screen.prototype.__proto__ = Node.prototype;
  Screen.prototype.type = "screen";
  Screen.prototype.__defineGetter__("title", function() {
    return this.program.title;
  });
  Screen.prototype.__defineSetter__("title", function(title) {
    return this.program.title = title;
  });
  Screen.prototype.__defineGetter__("terminal", function() {
    return this.program.terminal;
  });
  Screen.prototype.__defineSetter__("terminal", function(terminal) {
    this.setTerminal(terminal);
    return this.program.terminal;
  });
  Screen.prototype.setTerminal = function(terminal) {
    var entered = !!this.program.isAlt;
    if (entered) {
      this._buf = "";
      this.program._buf = "";
      this.leave();
    }
    this.program.setTerminal(terminal);
    this.tput = this.program.tput;
    if (entered) {
      this.enter();
    }
  };
  Screen.prototype.enter = function() {
    if (this.program.isAlt)
      return;
    if (!this.cursor._set) {
      if (this.options.cursor.shape) {
        this.cursorShape(this.cursor.shape, this.cursor.blink);
      }
      if (this.options.cursor.color) {
        this.cursorColor(this.cursor.color);
      }
    }
    if (process.platform === "win32") {
      try {
        cp.execSync("cls", { stdio: "ignore", timeout: 1000 });
      } catch (e) {}
    }
    this.program.alternateBuffer();
    this.program.put.keypad_xmit();
    this.program.csr(0, this.height - 1);
    this.program.hideCursor();
    this.program.cup(0, 0);
    if (this.tput.strings.ena_acs) {
      this.program._write(this.tput.enacs());
    }
    this.alloc();
  };
  Screen.prototype.leave = function() {
    if (!this.program.isAlt)
      return;
    this.program.put.keypad_local();
    if (this.program.scrollTop !== 0 || this.program.scrollBottom !== this.rows - 1) {
      this.program.csr(0, this.height - 1);
    }
    this.program.showCursor();
    this.alloc();
    if (this._listenedMouse) {
      this.program.disableMouse();
    }
    this.program.normalBuffer();
    if (this.cursor._set)
      this.cursorReset();
    this.program.flush();
    if (process.platform === "win32") {
      try {
        cp.execSync("cls", { stdio: "ignore", timeout: 1000 });
      } catch (e) {}
    }
  };
  Screen.prototype.postEnter = function() {
    var self2 = this;
    if (this.options.debug) {
      this.debugLog = new Log({
        screen: this,
        parent: this,
        hidden: true,
        draggable: true,
        left: "center",
        top: "center",
        width: "30%",
        height: "30%",
        border: "line",
        label: " {bold}Debug Log{/bold} ",
        tags: true,
        keys: true,
        vi: true,
        mouse: true,
        scrollbar: {
          ch: " ",
          track: {
            bg: "yellow"
          },
          style: {
            inverse: true
          }
        }
      });
      this.debugLog.toggle = function() {
        if (self2.debugLog.hidden) {
          self2.saveFocus();
          self2.debugLog.show();
          self2.debugLog.setFront();
          self2.debugLog.focus();
        } else {
          self2.debugLog.hide();
          self2.restoreFocus();
        }
        self2.render();
      };
      this.debugLog.key(["q", "escape"], self2.debugLog.toggle);
      this.key("f12", self2.debugLog.toggle);
    }
    if (this.options.warnings) {
      this.on("warning", function(text) {
        var warning = new Box({
          screen: self2,
          parent: self2,
          left: "center",
          top: "center",
          width: "shrink",
          padding: 1,
          height: "shrink",
          align: "center",
          valign: "middle",
          border: "line",
          label: " {red-fg}{bold}WARNING{/} ",
          content: "{bold}" + text + "{/bold}",
          tags: true
        });
        self2.render();
        var timeout = setTimeout(function() {
          warning.destroy();
          self2.render();
        }, 1500);
        if (timeout.unref) {
          timeout.unref();
        }
      });
    }
  };
  Screen.prototype._destroy = Screen.prototype.destroy;
  Screen.prototype.destroy = function() {
    this.leave();
    var index = Screen.instances.indexOf(this);
    if (~index) {
      Screen.instances.splice(index, 1);
      Screen.total--;
      Screen.global = Screen.instances[0];
      if (Screen.total === 0) {
        Screen.global = null;
        process.removeListener("uncaughtException", Screen._exceptionHandler);
        process.removeListener("SIGTERM", Screen._sigtermHandler);
        process.removeListener("SIGINT", Screen._sigintHandler);
        process.removeListener("SIGQUIT", Screen._sigquitHandler);
        process.removeListener("exit", Screen._exitHandler);
        delete Screen._exceptionHandler;
        delete Screen._sigtermHandler;
        delete Screen._sigintHandler;
        delete Screen._sigquitHandler;
        delete Screen._exitHandler;
        delete Screen._bound;
      }
      this.destroyed = true;
      this.emit("destroy");
      this._destroy();
    }
    this.program.destroy();
  };
  Screen.prototype.log = function() {
    return this.program.log.apply(this.program, arguments);
  };
  Screen.prototype.debug = function() {
    if (this.debugLog) {
      this.debugLog.log.apply(this.debugLog, arguments);
    }
    return this.program.debug.apply(this.program, arguments);
  };
  Screen.prototype._listenMouse = function(el) {
    var self2 = this;
    if (el && !~this.clickable.indexOf(el)) {
      el.clickable = true;
      this.clickable.push(el);
    }
    if (this._listenedMouse)
      return;
    this._listenedMouse = true;
    this.program.enableMouse();
    if (this.options.sendFocus) {
      this.program.setMouse({ sendFocus: true }, true);
    }
    this.on("render", function() {
      self2._needsClickableSort = true;
    });
    this.program.on("mouse", function(data) {
      if (self2.lockKeys)
        return;
      if (self2._needsClickableSort) {
        self2.clickable = helpers.hsort(self2.clickable);
        self2._needsClickableSort = false;
      }
      var i = 0, el2, set, pos;
      for (;i < self2.clickable.length; i++) {
        el2 = self2.clickable[i];
        if (el2.detached || !el2.visible) {
          continue;
        }
        pos = el2.lpos;
        if (!pos)
          continue;
        if (data.x >= pos.xi && data.x < pos.xl && data.y >= pos.yi && data.y < pos.yl) {
          el2.emit("mouse", data);
          if (data.action === "mousedown") {
            self2.mouseDown = el2;
          } else if (data.action === "mouseup") {
            (self2.mouseDown || el2).emit("click", data);
            self2.mouseDown = null;
          } else if (data.action === "mousemove") {
            if (self2.hover && el2.index > self2.hover.index) {
              set = false;
            }
            if (self2.hover !== el2 && !set) {
              if (self2.hover) {
                self2.hover.emit("mouseout", data);
              }
              el2.emit("mouseover", data);
              self2.hover = el2;
            }
            set = true;
          }
          el2.emit(data.action, data);
          break;
        }
      }
      if ((data.action === "mousemove" || data.action === "mousedown" || data.action === "mouseup") && self2.hover && !set) {
        self2.hover.emit("mouseout", data);
        self2.hover = null;
      }
      self2.emit("mouse", data);
      self2.emit(data.action, data);
    });
    this.on("element click", function(el2) {
      if (el2.clickable === true && el2.options.autoFocus !== false) {
        el2.focus();
      }
    });
  };
  Screen.prototype.enableMouse = function(el) {
    this._listenMouse(el);
  };
  Screen.prototype._listenKeys = function(el) {
    var self2 = this;
    if (el && !~this.keyable.indexOf(el)) {
      el.keyable = true;
      this.keyable.push(el);
    }
    if (this._listenedKeys)
      return;
    this._listenedKeys = true;
    this.program.on("keypress", function(ch, key) {
      if (self2.lockKeys && !~self2.ignoreLocked.indexOf(key.full)) {
        return;
      }
      var { focused, grabKeys } = self2;
      if (!grabKeys || ~self2.ignoreLocked.indexOf(key.full)) {
        self2.emit("keypress", ch, key);
        self2.emit("key " + key.full, ch, key);
      }
      if (self2.grabKeys !== grabKeys || self2.lockKeys) {
        return;
      }
      if (focused && focused.keyable) {
        focused.emit("keypress", ch, key);
        focused.emit("key " + key.full, ch, key);
      }
    });
  };
  Screen.prototype.enableKeys = function(el) {
    this._listenKeys(el);
  };
  Screen.prototype.enableInput = function(el) {
    this._listenMouse(el);
    this._listenKeys(el);
  };
  Screen.prototype._initHover = function() {
    var self2 = this;
    if (this._hoverText) {
      return;
    }
    this._hoverText = new Box({
      screen: this,
      left: 0,
      top: 0,
      tags: false,
      height: "shrink",
      width: "shrink",
      border: "line",
      style: {
        border: {
          fg: "default"
        },
        bg: "default",
        fg: "default"
      }
    });
    this.on("mousemove", function(data) {
      if (self2._hoverText.detached)
        return;
      self2._hoverText.rleft = data.x + 1;
      self2._hoverText.rtop = data.y;
      self2.render();
    });
    this.on("element mouseover", function(el, data) {
      if (!el._hoverOptions)
        return;
      self2._hoverText.parseTags = el.parseTags;
      self2._hoverText.setContent(el._hoverOptions.text);
      self2.append(self2._hoverText);
      self2._hoverText.rleft = data.x + 1;
      self2._hoverText.rtop = data.y;
      self2.render();
    });
    this.on("element mouseout", function() {
      if (self2._hoverText.detached)
        return;
      self2._hoverText.detach();
      self2.render();
    });
    this.on("element mouseup", function(el) {
      if (!self2._hoverText.getContent())
        return;
      if (!el._hoverOptions)
        return;
      self2.append(self2._hoverText);
      self2.render();
    });
  };
  Screen.prototype.__defineGetter__("cols", function() {
    return this.program.cols;
  });
  Screen.prototype.__defineGetter__("rows", function() {
    return this.program.rows;
  });
  Screen.prototype.__defineGetter__("width", function() {
    return this.program.cols;
  });
  Screen.prototype.__defineGetter__("height", function() {
    return this.program.rows;
  });
  Screen.prototype.alloc = function(dirty) {
    var x, y;
    this.lines = [];
    for (y = 0;y < this.rows; y++) {
      this.lines[y] = [];
      for (x = 0;x < this.cols; x++) {
        this.lines[y][x] = [this.dattr, " "];
      }
      this.lines[y].dirty = !!dirty;
    }
    this.olines = [];
    for (y = 0;y < this.rows; y++) {
      this.olines[y] = [];
      for (x = 0;x < this.cols; x++) {
        this.olines[y][x] = [this.dattr, " "];
      }
    }
    this.program.clear();
  };
  Screen.prototype.realloc = function() {
    return this.alloc(true);
  };
  Screen.prototype.render = function() {
    var self2 = this;
    if (this.destroyed)
      return;
    this.emit("prerender");
    this._borderStops = {};
    this._ci = 0;
    this.children.forEach(function(el) {
      el.index = self2._ci++;
      el.render();
    });
    this._ci = -1;
    if (this.screen.dockBorders) {
      this._dockBorders();
    }
    this.draw(0, this.lines.length - 1);
    if (this.focused && this.focused._updateCursor) {
      this.focused._updateCursor(true);
    }
    this.renders++;
    this.emit("render");
  };
  Screen.prototype.blankLine = function(ch, dirty) {
    var out = [];
    for (var x = 0;x < this.cols; x++) {
      out[x] = [this.dattr, ch || " "];
    }
    out.dirty = dirty;
    return out;
  };
  Screen.prototype.insertLine = function(n, y, top, bottom) {
    if (!this.tput.strings.change_scroll_region || !this.tput.strings.delete_line || !this.tput.strings.insert_line)
      return;
    this._buf += this.tput.csr(top, bottom);
    this._buf += this.tput.cup(y, 0);
    this._buf += this.tput.il(n);
    this._buf += this.tput.csr(0, this.height - 1);
    var j = bottom + 1;
    while (n--) {
      this.lines.splice(y, 0, this.blankLine());
      this.lines.splice(j, 1);
      this.olines.splice(y, 0, this.blankLine());
      this.olines.splice(j, 1);
    }
  };
  Screen.prototype.deleteLine = function(n, y, top, bottom) {
    if (!this.tput.strings.change_scroll_region || !this.tput.strings.delete_line || !this.tput.strings.insert_line)
      return;
    this._buf += this.tput.csr(top, bottom);
    this._buf += this.tput.cup(y, 0);
    this._buf += this.tput.dl(n);
    this._buf += this.tput.csr(0, this.height - 1);
    var j = bottom + 1;
    while (n--) {
      this.lines.splice(j, 0, this.blankLine());
      this.lines.splice(y, 1);
      this.olines.splice(j, 0, this.blankLine());
      this.olines.splice(y, 1);
    }
  };
  Screen.prototype.insertLineNC = function(n, y, top, bottom) {
    if (!this.tput.strings.change_scroll_region || !this.tput.strings.delete_line)
      return;
    this._buf += this.tput.csr(top, bottom);
    this._buf += this.tput.cup(top, 0);
    this._buf += this.tput.dl(n);
    this._buf += this.tput.csr(0, this.height - 1);
    var j = bottom + 1;
    while (n--) {
      this.lines.splice(j, 0, this.blankLine());
      this.lines.splice(y, 1);
      this.olines.splice(j, 0, this.blankLine());
      this.olines.splice(y, 1);
    }
  };
  Screen.prototype.deleteLineNC = function(n, y, top, bottom) {
    if (!this.tput.strings.change_scroll_region || !this.tput.strings.delete_line)
      return;
    this._buf += this.tput.csr(top, bottom);
    this._buf += this.tput.cup(bottom, 0);
    this._buf += Array(n + 1).join(`
`);
    this._buf += this.tput.csr(0, this.height - 1);
    var j = bottom + 1;
    while (n--) {
      this.lines.splice(j, 0, this.blankLine());
      this.lines.splice(y, 1);
      this.olines.splice(j, 0, this.blankLine());
      this.olines.splice(y, 1);
    }
  };
  Screen.prototype.insertBottom = function(top, bottom) {
    return this.deleteLine(1, top, top, bottom);
  };
  Screen.prototype.insertTop = function(top, bottom) {
    return this.insertLine(1, top, top, bottom);
  };
  Screen.prototype.deleteBottom = function(top, bottom) {
    return this.clearRegion(0, this.width, bottom, bottom);
  };
  Screen.prototype.deleteTop = function(top, bottom) {
    return this.deleteLine(1, top, top, bottom);
  };
  Screen.prototype.cleanSides = function(el) {
    var pos = el.lpos;
    if (!pos) {
      return false;
    }
    if (pos._cleanSides != null) {
      return pos._cleanSides;
    }
    if (pos.xi <= 0 && pos.xl >= this.width) {
      return pos._cleanSides = true;
    }
    if (this.options.fastCSR) {
      if (pos.yi < 0)
        return pos._cleanSides = false;
      if (pos.yl > this.height)
        return pos._cleanSides = false;
      if (this.width - (pos.xl - pos.xi) < 40) {
        return pos._cleanSides = true;
      }
      return pos._cleanSides = false;
    }
    if (!this.options.smartCSR) {
      return false;
    }
    var yi = pos.yi + el.itop, yl = pos.yl - el.ibottom, first, ch, x, y;
    if (pos.yi < 0)
      return pos._cleanSides = false;
    if (pos.yl > this.height)
      return pos._cleanSides = false;
    if (pos.xi - 1 < 0)
      return pos._cleanSides = true;
    if (pos.xl > this.width)
      return pos._cleanSides = true;
    for (x = pos.xi - 1;x >= 0; x--) {
      if (!this.olines[yi])
        break;
      first = this.olines[yi][x];
      for (y = yi;y < yl; y++) {
        if (!this.olines[y] || !this.olines[y][x])
          break;
        ch = this.olines[y][x];
        if (ch[0] !== first[0] || ch[1] !== first[1]) {
          return pos._cleanSides = false;
        }
      }
    }
    for (x = pos.xl;x < this.width; x++) {
      if (!this.olines[yi])
        break;
      first = this.olines[yi][x];
      for (y = yi;y < yl; y++) {
        if (!this.olines[y] || !this.olines[y][x])
          break;
        ch = this.olines[y][x];
        if (ch[0] !== first[0] || ch[1] !== first[1]) {
          return pos._cleanSides = false;
        }
      }
    }
    return pos._cleanSides = true;
  };
  Screen.prototype._dockBorders = function() {
    var lines = this.lines, stops = this._borderStops, i, y, x, ch;
    stops = Object.keys(stops).map(function(k) {
      return +k;
    }).sort(function(a, b) {
      return a - b;
    });
    for (i = 0;i < stops.length; i++) {
      y = stops[i];
      if (!lines[y])
        continue;
      for (x = 0;x < this.width; x++) {
        ch = lines[y][x][1];
        if (angles[ch]) {
          lines[y][x][1] = this._getAngle(lines, x, y);
          lines[y].dirty = true;
        }
      }
    }
  };
  Screen.prototype._getAngle = function(lines, x, y) {
    var angle = 0, attr = lines[y][x][0], ch = lines[y][x][1];
    if (lines[y][x - 1] && langles[lines[y][x - 1][1]]) {
      if (!this.options.ignoreDockContrast) {
        if (lines[y][x - 1][0] !== attr)
          return ch;
      }
      angle |= 1 << 3;
    }
    if (lines[y - 1] && uangles[lines[y - 1][x][1]]) {
      if (!this.options.ignoreDockContrast) {
        if (lines[y - 1][x][0] !== attr)
          return ch;
      }
      angle |= 1 << 2;
    }
    if (lines[y][x + 1] && rangles[lines[y][x + 1][1]]) {
      if (!this.options.ignoreDockContrast) {
        if (lines[y][x + 1][0] !== attr)
          return ch;
      }
      angle |= 1 << 1;
    }
    if (lines[y + 1] && dangles[lines[y + 1][x][1]]) {
      if (!this.options.ignoreDockContrast) {
        if (lines[y + 1][x][0] !== attr)
          return ch;
      }
      angle |= 1 << 0;
    }
    return angleTable[angle] || ch;
  };
  Screen.prototype.draw = function(start, end) {
    var x, y, line, out, ch, data, attr, fg, bg, flags;
    var main = "", pre, post;
    var clr, neq, xx;
    var lx = -1, ly = -1, o;
    var acs;
    if (this._buf) {
      main += this._buf;
      this._buf = "";
    }
    for (y = start;y <= end; y++) {
      line = this.lines[y];
      o = this.olines[y];
      if (!line.dirty && !(this.cursor.artificial && y === this.program.y)) {
        continue;
      }
      line.dirty = false;
      out = "";
      attr = this.dattr;
      for (x = 0;x < line.length; x++) {
        data = line[x][0];
        ch = line[x][1];
        if (this.cursor.artificial && !this.cursor._hidden && this.cursor._state && x === this.program.x && y === this.program.y) {
          var cattr = this._cursorAttr(this.cursor, data);
          if (cattr.ch)
            ch = cattr.ch;
          data = cattr.attr;
        }
        if (this.options.useBCE && ch === " " && (this.tput.bools.back_color_erase || (data & 511) === (this.dattr & 511)) && (data >> 18 & 8) === (this.dattr >> 18 & 8)) {
          clr = true;
          neq = false;
          for (xx = x;xx < line.length; xx++) {
            if (line[xx][0] !== data || line[xx][1] !== " ") {
              clr = false;
              break;
            }
            if (line[xx][0] !== o[xx][0] || line[xx][1] !== o[xx][1]) {
              neq = true;
            }
          }
          if (clr && neq) {
            lx = -1, ly = -1;
            if (data !== attr) {
              out += this.codeAttr(data);
              attr = data;
            }
            out += this.tput.cup(y, x);
            out += this.tput.el();
            for (xx = x;xx < line.length; xx++) {
              o[xx][0] = data;
              o[xx][1] = " ";
            }
            break;
          }
        }
        if (data === o[x][0] && ch === o[x][1]) {
          if (lx === -1) {
            lx = x;
            ly = y;
          }
          continue;
        } else if (lx !== -1) {
          if (this.tput.strings.parm_right_cursor) {
            out += y === ly ? this.tput.cuf(x - lx) : this.tput.cup(y, x);
          } else {
            out += this.tput.cup(y, x);
          }
          lx = -1, ly = -1;
        }
        o[x][0] = data;
        o[x][1] = ch;
        if (data !== attr) {
          if (attr !== this.dattr) {
            out += "\x1B[m";
          }
          if (data !== this.dattr) {
            out += "\x1B[";
            bg = data & 511;
            fg = data >> 9 & 511;
            flags = data >> 18;
            if (flags & 1) {
              out += "1;";
            }
            if (flags & 2) {
              out += "4;";
            }
            if (flags & 4) {
              out += "5;";
            }
            if (flags & 8) {
              out += "7;";
            }
            if (flags & 16) {
              out += "8;";
            }
            if (bg !== 511) {
              bg = this._reduceColor(bg);
              if (bg < 16) {
                if (bg < 8) {
                  bg += 40;
                } else if (bg < 16) {
                  bg -= 8;
                  bg += 100;
                }
                out += bg + ";";
              } else {
                out += "48;5;" + bg + ";";
              }
            }
            if (fg !== 511) {
              fg = this._reduceColor(fg);
              if (fg < 16) {
                if (fg < 8) {
                  fg += 30;
                } else if (fg < 16) {
                  fg -= 8;
                  fg += 90;
                }
                out += fg + ";";
              } else {
                out += "38;5;" + fg + ";";
              }
            }
            if (out[out.length - 1] === ";")
              out = out.slice(0, -1);
            out += "m";
          }
        }
        if (this.fullUnicode) {
          if (unicode.charWidth(line[x][1]) === 2) {
            if (x === line.length - 1 || angles[line[x + 1][1]]) {
              ch = " ";
              o[x][1] = "\x00";
            } else {
              o[x][1] = "\x00";
              o[++x][1] = "\x00";
            }
          }
        }
        if (this.tput.strings.enter_alt_charset_mode && !this.tput.brokenACS && (this.tput.acscr[ch] || acs)) {
          if (this.tput.acscr[ch]) {
            if (acs) {
              ch = this.tput.acscr[ch];
            } else {
              ch = this.tput.smacs() + this.tput.acscr[ch];
              acs = true;
            }
          } else if (acs) {
            ch = this.tput.rmacs() + ch;
            acs = false;
          }
        } else {
          if (!this.tput.unicode && this.tput.numbers.U8 !== 1 && ch > "~") {
            ch = this.tput.utoa[ch] || "?";
          }
        }
        out += ch;
        attr = data;
      }
      if (attr !== this.dattr) {
        out += "\x1B[m";
      }
      if (out) {
        main += this.tput.cup(y, 0) + out;
      }
    }
    if (acs) {
      main += this.tput.rmacs();
      acs = false;
    }
    if (main) {
      pre = "";
      post = "";
      pre += this.tput.sc();
      post += this.tput.rc();
      if (!this.program.cursorHidden) {
        pre += this.tput.civis();
        post += this.tput.cnorm();
      }
      this.program._write(pre + main + post);
    }
  };
  Screen.prototype._reduceColor = function(color) {
    return colors.reduce(color, this.tput.colors);
  };
  Screen.prototype.attrCode = function(code, cur, def) {
    var flags = cur >> 18 & 511, fg = cur >> 9 & 511, bg = cur & 511, c, i;
    code = code.slice(2, -1).split(";");
    if (!code[0])
      code[0] = "0";
    for (i = 0;i < code.length; i++) {
      c = +code[i] || 0;
      switch (c) {
        case 0:
          bg = def & 511;
          fg = def >> 9 & 511;
          flags = def >> 18 & 511;
          break;
        case 1:
          flags |= 1;
          break;
        case 22:
          flags = def >> 18 & 511;
          break;
        case 4:
          flags |= 2;
          break;
        case 24:
          flags = def >> 18 & 511;
          break;
        case 5:
          flags |= 4;
          break;
        case 25:
          flags = def >> 18 & 511;
          break;
        case 7:
          flags |= 8;
          break;
        case 27:
          flags = def >> 18 & 511;
          break;
        case 8:
          flags |= 16;
          break;
        case 28:
          flags = def >> 18 & 511;
          break;
        case 39:
          fg = def >> 9 & 511;
          break;
        case 49:
          bg = def & 511;
          break;
        case 100:
          fg = def >> 9 & 511;
          bg = def & 511;
          break;
        default:
          if (c === 48 && +code[i + 1] === 5) {
            i += 2;
            bg = +code[i];
            break;
          } else if (c === 48 && +code[i + 1] === 2) {
            i += 2;
            bg = colors.match(+code[i], +code[i + 1], +code[i + 2]);
            if (bg === -1)
              bg = def & 511;
            i += 2;
            break;
          } else if (c === 38 && +code[i + 1] === 5) {
            i += 2;
            fg = +code[i];
            break;
          } else if (c === 38 && +code[i + 1] === 2) {
            i += 2;
            fg = colors.match(+code[i], +code[i + 1], +code[i + 2]);
            if (fg === -1)
              fg = def >> 9 & 511;
            i += 2;
            break;
          }
          if (c >= 40 && c <= 47) {
            bg = c - 40;
          } else if (c >= 100 && c <= 107) {
            bg = c - 100;
            bg += 8;
          } else if (c === 49) {
            bg = def & 511;
          } else if (c >= 30 && c <= 37) {
            fg = c - 30;
          } else if (c >= 90 && c <= 97) {
            fg = c - 90;
            fg += 8;
          } else if (c === 39) {
            fg = def >> 9 & 511;
          } else if (c === 100) {
            fg = def >> 9 & 511;
            bg = def & 511;
          }
          break;
      }
    }
    return flags << 18 | fg << 9 | bg;
  };
  Screen.prototype.codeAttr = function(code) {
    var flags = code >> 18 & 511, fg = code >> 9 & 511, bg = code & 511, out = "";
    if (flags & 1) {
      out += "1;";
    }
    if (flags & 2) {
      out += "4;";
    }
    if (flags & 4) {
      out += "5;";
    }
    if (flags & 8) {
      out += "7;";
    }
    if (flags & 16) {
      out += "8;";
    }
    if (bg !== 511) {
      bg = this._reduceColor(bg);
      if (bg < 16) {
        if (bg < 8) {
          bg += 40;
        } else if (bg < 16) {
          bg -= 8;
          bg += 100;
        }
        out += bg + ";";
      } else {
        out += "48;5;" + bg + ";";
      }
    }
    if (fg !== 511) {
      fg = this._reduceColor(fg);
      if (fg < 16) {
        if (fg < 8) {
          fg += 30;
        } else if (fg < 16) {
          fg -= 8;
          fg += 90;
        }
        out += fg + ";";
      } else {
        out += "38;5;" + fg + ";";
      }
    }
    if (out[out.length - 1] === ";")
      out = out.slice(0, -1);
    return "\x1B[" + out + "m";
  };
  Screen.prototype.focusOffset = function(offset) {
    var shown = this.keyable.filter(function(el) {
      return !el.detached && el.visible;
    }).length;
    if (!shown || !offset) {
      return;
    }
    var i = this.keyable.indexOf(this.focused);
    if (!~i)
      return;
    if (offset > 0) {
      while (offset--) {
        if (++i > this.keyable.length - 1)
          i = 0;
        if (this.keyable[i].detached || !this.keyable[i].visible)
          offset++;
      }
    } else {
      offset = -offset;
      while (offset--) {
        if (--i < 0)
          i = this.keyable.length - 1;
        if (this.keyable[i].detached || !this.keyable[i].visible)
          offset++;
      }
    }
    return this.keyable[i].focus();
  };
  Screen.prototype.focusPrev = Screen.prototype.focusPrevious = function() {
    return this.focusOffset(-1);
  };
  Screen.prototype.focusNext = function() {
    return this.focusOffset(1);
  };
  Screen.prototype.focusPush = function(el) {
    if (!el)
      return;
    var old = this.history[this.history.length - 1];
    if (this.history.length === 10) {
      this.history.shift();
    }
    this.history.push(el);
    this._focus(el, old);
  };
  Screen.prototype.focusPop = function() {
    var old = this.history.pop();
    if (this.history.length) {
      this._focus(this.history[this.history.length - 1], old);
    }
    return old;
  };
  Screen.prototype.saveFocus = function() {
    return this._savedFocus = this.focused;
  };
  Screen.prototype.restoreFocus = function() {
    if (!this._savedFocus)
      return;
    this._savedFocus.focus();
    delete this._savedFocus;
    return this.focused;
  };
  Screen.prototype.rewindFocus = function() {
    var old = this.history.pop(), el;
    while (this.history.length) {
      el = this.history.pop();
      if (!el.detached && el.visible) {
        this.history.push(el);
        this._focus(el, old);
        return el;
      }
    }
    if (old) {
      old.emit("blur");
    }
  };
  Screen.prototype._focus = function(self2, old) {
    var el = self2;
    while (el = el.parent) {
      if (el.scrollable)
        break;
    }
    if (el && !el.detached) {
      var visible = self2.screen.height - el.atop - el.itop - el.abottom - el.ibottom;
      if (self2.rtop < el.childBase) {
        el.scrollTo(self2.rtop);
        self2.screen.render();
      } else if (self2.rtop + self2.height - self2.ibottom > el.childBase + visible) {
        el.scrollTo(self2.rtop - (el.height - self2.height) + el.itop, true);
        self2.screen.render();
      }
    }
    if (old) {
      old.emit("blur", self2);
    }
    self2.emit("focus", old);
  };
  Screen.prototype.__defineGetter__("focused", function() {
    return this.history[this.history.length - 1];
  });
  Screen.prototype.__defineSetter__("focused", function(el) {
    return this.focusPush(el);
  });
  Screen.prototype.clearRegion = function(xi, xl, yi, yl, override) {
    return this.fillRegion(this.dattr, " ", xi, xl, yi, yl, override);
  };
  Screen.prototype.fillRegion = function(attr, ch, xi, xl, yi, yl, override) {
    var lines = this.lines, cell, xx;
    if (xi < 0)
      xi = 0;
    if (yi < 0)
      yi = 0;
    for (;yi < yl; yi++) {
      if (!lines[yi])
        break;
      for (xx = xi;xx < xl; xx++) {
        cell = lines[yi][xx];
        if (!cell)
          break;
        if (override || attr !== cell[0] || ch !== cell[1]) {
          lines[yi][xx][0] = attr;
          lines[yi][xx][1] = ch;
          lines[yi].dirty = true;
        }
      }
    }
  };
  Screen.prototype.key = function() {
    return this.program.key.apply(this, arguments);
  };
  Screen.prototype.onceKey = function() {
    return this.program.onceKey.apply(this, arguments);
  };
  Screen.prototype.unkey = Screen.prototype.removeKey = function() {
    return this.program.unkey.apply(this, arguments);
  };
  Screen.prototype.spawn = function(file, args2, options) {
    if (!Array.isArray(args2)) {
      options = args2;
      args2 = [];
    }
    var screen = this, program2 = screen.program, spawn = __require("child_process").spawn, mouse = program2.mouseEnabled, ps;
    options = options || {};
    options.stdio = options.stdio || "inherit";
    program2.lsaveCursor("spawn");
    program2.normalBuffer();
    program2.showCursor();
    if (mouse)
      program2.disableMouse();
    var write = program2.output.write;
    program2.output.write = function() {};
    program2.input.pause();
    if (program2.input.setRawMode) {
      program2.input.setRawMode(false);
    }
    var resume = function() {
      if (resume.done)
        return;
      resume.done = true;
      if (program2.input.setRawMode) {
        program2.input.setRawMode(true);
      }
      program2.input.resume();
      program2.output.write = write;
      program2.alternateBuffer();
      if (mouse) {
        program2.enableMouse();
        if (screen.options.sendFocus) {
          screen.program.setMouse({ sendFocus: true }, true);
        }
      }
      screen.alloc();
      screen.render();
      screen.program.lrestoreCursor("spawn", true);
    };
    ps = spawn(file, args2, options);
    ps.on("error", resume);
    ps.on("exit", resume);
    return ps;
  };
  Screen.prototype.exec = function(file, args2, options, callback) {
    var ps = this.spawn(file, args2, options);
    ps.on("error", function(err) {
      if (!callback)
        return;
      return callback(err, false);
    });
    ps.on("exit", function(code) {
      if (!callback)
        return;
      return callback(null, code === 0);
    });
    return ps;
  };
  Screen.prototype.readEditor = function(options, callback) {
    if (typeof options === "string") {
      options = { editor: options };
    }
    if (!callback) {
      callback = options;
      options = null;
    }
    if (!callback) {
      callback = function() {};
    }
    options = options || {};
    var self2 = this, editor = options.editor || process.env.EDITOR || "vi", name = options.name || process.title || "blessed", rnd = Math.random().toString(36).split(".").pop(), file = "/tmp/" + name + "." + rnd, args2 = [file], opt;
    opt = {
      stdio: "inherit",
      env: process.env,
      cwd: process.env.HOME
    };
    function writeFile(callback2) {
      if (!options.value)
        return callback2();
      return fs.writeFile(file, options.value, callback2);
    }
    return writeFile(function(err) {
      if (err)
        return callback(err);
      return self2.exec(editor, args2, opt, function(err2, success) {
        if (err2)
          return callback(err2);
        return fs.readFile(file, "utf8", function(err3, data) {
          return fs.unlink(file, function() {
            if (!success)
              return callback(new Error("Unsuccessful."));
            if (err3)
              return callback(err3);
            return callback(null, data);
          });
        });
      });
    });
  };
  Screen.prototype.displayImage = function(file, callback) {
    if (!file) {
      if (!callback)
        return;
      return callback(new Error("No image."));
    }
    file = path.resolve(process.cwd(), file);
    if (!~file.indexOf("://")) {
      file = "file://" + file;
    }
    var args2 = ["w3m", "-T", "text/html"];
    var input = "<title>press q to exit</title>" + '<img align="center" src="' + file + '">';
    var opt = {
      stdio: ["pipe", 1, 2],
      env: process.env,
      cwd: process.env.HOME
    };
    var ps = this.spawn(args2[0], args2.slice(1), opt);
    ps.on("error", function(err) {
      if (!callback)
        return;
      return callback(err);
    });
    ps.on("exit", function(code) {
      if (!callback)
        return;
      if (code !== 0)
        return callback(new Error("Exit Code: " + code));
      return callback(null, code === 0);
    });
    ps.stdin.write(input + `
`);
    ps.stdin.end();
  };
  Screen.prototype.setEffects = function(el, fel, over, out, effects, temp) {
    if (!effects)
      return;
    var tmp = {};
    if (temp)
      el[temp] = tmp;
    if (typeof el !== "function") {
      var _el = el;
      el = function() {
        return _el;
      };
    }
    fel.on(over, function() {
      var element = el();
      Object.keys(effects).forEach(function(key) {
        var val = effects[key];
        if (val !== null && typeof val === "object") {
          tmp[key] = tmp[key] || {};
          Object.keys(val).forEach(function(k) {
            var v = val[k];
            tmp[key][k] = element.style[key][k];
            element.style[key][k] = v;
          });
          return;
        }
        tmp[key] = element.style[key];
        element.style[key] = val;
      });
      element.screen.render();
    });
    fel.on(out, function() {
      var element = el();
      Object.keys(effects).forEach(function(key) {
        var val = effects[key];
        if (val !== null && typeof val === "object") {
          tmp[key] = tmp[key] || {};
          Object.keys(val).forEach(function(k) {
            if (tmp[key].hasOwnProperty(k)) {
              element.style[key][k] = tmp[key][k];
            }
          });
          return;
        }
        if (tmp.hasOwnProperty(key)) {
          element.style[key] = tmp[key];
        }
      });
      element.screen.render();
    });
  };
  Screen.prototype.sigtstp = function(callback) {
    var self2 = this;
    this.program.sigtstp(function() {
      self2.alloc();
      self2.render();
      self2.program.lrestoreCursor("pause", true);
      if (callback)
        callback();
    });
  };
  Screen.prototype.copyToClipboard = function(text) {
    return this.program.copyToClipboard(text);
  };
  Screen.prototype.cursorShape = function(shape, blink) {
    var self2 = this;
    this.cursor.shape = shape || "block";
    this.cursor.blink = blink || false;
    this.cursor._set = true;
    if (this.cursor.artificial) {
      if (!this.program.hideCursor_old) {
        var hideCursor = this.program.hideCursor;
        this.program.hideCursor_old = this.program.hideCursor;
        this.program.hideCursor = function() {
          hideCursor.call(self2.program);
          self2.cursor._hidden = true;
          if (self2.renders)
            self2.render();
        };
      }
      if (!this.program.showCursor_old) {
        var showCursor = this.program.showCursor;
        this.program.showCursor_old = this.program.showCursor;
        this.program.showCursor = function() {
          self2.cursor._hidden = false;
          if (self2.program._exiting)
            showCursor.call(self2.program);
          if (self2.renders)
            self2.render();
        };
      }
      if (!this._cursorBlink) {
        this._cursorBlink = setInterval(function() {
          if (!self2.cursor.blink)
            return;
          self2.cursor._state ^= 1;
          if (self2.renders)
            self2.render();
        }, 500);
        if (this._cursorBlink.unref) {
          this._cursorBlink.unref();
        }
      }
      return true;
    }
    return this.program.cursorShape(this.cursor.shape, this.cursor.blink);
  };
  Screen.prototype.cursorColor = function(color) {
    this.cursor.color = color != null ? colors.convert(color) : null;
    this.cursor._set = true;
    if (this.cursor.artificial) {
      return true;
    }
    return this.program.cursorColor(colors.ncolors[this.cursor.color]);
  };
  Screen.prototype.cursorReset = Screen.prototype.resetCursor = function() {
    this.cursor.shape = "block";
    this.cursor.blink = false;
    this.cursor.color = null;
    this.cursor._set = false;
    if (this.cursor.artificial) {
      this.cursor.artificial = false;
      if (this.program.hideCursor_old) {
        this.program.hideCursor = this.program.hideCursor_old;
        delete this.program.hideCursor_old;
      }
      if (this.program.showCursor_old) {
        this.program.showCursor = this.program.showCursor_old;
        delete this.program.showCursor_old;
      }
      if (this._cursorBlink) {
        clearInterval(this._cursorBlink);
        delete this._cursorBlink;
      }
      return true;
    }
    return this.program.cursorReset();
  };
  Screen.prototype._cursorAttr = function(cursor, dattr) {
    var attr = dattr || this.dattr, cattr, ch;
    if (cursor.shape === "line") {
      attr &= ~(511 << 9);
      attr |= 7 << 9;
      ch = "";
    } else if (cursor.shape === "underline") {
      attr &= ~(511 << 9);
      attr |= 7 << 9;
      attr |= 2 << 18;
    } else if (cursor.shape === "block") {
      attr &= ~(511 << 9);
      attr |= 7 << 9;
      attr |= 8 << 18;
    } else if (typeof cursor.shape === "object" && cursor.shape) {
      cattr = Element.prototype.sattr.call(cursor, cursor.shape);
      if (cursor.shape.bold || cursor.shape.underline || cursor.shape.blink || cursor.shape.inverse || cursor.shape.invisible) {
        attr &= ~(511 << 18);
        attr |= (cattr >> 18 & 511) << 18;
      }
      if (cursor.shape.fg) {
        attr &= ~(511 << 9);
        attr |= (cattr >> 9 & 511) << 9;
      }
      if (cursor.shape.bg) {
        attr &= ~(511 << 0);
        attr |= cattr & 511;
      }
      if (cursor.shape.ch) {
        ch = cursor.shape.ch;
      }
    }
    if (cursor.color != null) {
      attr &= ~(511 << 9);
      attr |= cursor.color << 9;
    }
    return {
      ch,
      attr
    };
  };
  Screen.prototype.screenshot = function(xi, xl, yi, yl, term) {
    if (xi == null)
      xi = 0;
    if (xl == null)
      xl = this.cols;
    if (yi == null)
      yi = 0;
    if (yl == null)
      yl = this.rows;
    if (xi < 0)
      xi = 0;
    if (yi < 0)
      yi = 0;
    var x, y, line, out, ch, data, attr;
    var sdattr = this.dattr;
    if (term) {
      this.dattr = term.defAttr;
    }
    var main = "";
    for (y = yi;y < yl; y++) {
      line = term ? term.lines[y] : this.lines[y];
      if (!line)
        break;
      out = "";
      attr = this.dattr;
      for (x = xi;x < xl; x++) {
        if (!line[x])
          break;
        data = line[x][0];
        ch = line[x][1];
        if (data !== attr) {
          if (attr !== this.dattr) {
            out += "\x1B[m";
          }
          if (data !== this.dattr) {
            var _data = data;
            if (term) {
              if ((_data >> 9 & 511) === 257)
                _data |= 511 << 9;
              if ((_data & 511) === 256)
                _data |= 511;
            }
            out += this.codeAttr(_data);
          }
        }
        if (this.fullUnicode) {
          if (unicode.charWidth(line[x][1]) === 2) {
            if (x === xl - 1) {
              ch = " ";
            } else {
              x++;
            }
          }
        }
        out += ch;
        attr = data;
      }
      if (attr !== this.dattr) {
        out += "\x1B[m";
      }
      if (out) {
        main += (y > 0 ? `
` : "") + out;
      }
    }
    main = main.replace(/(?:\s*\x1b\[40m\s*\x1b\[m\s*)*$/, "") + `
`;
    if (term) {
      this.dattr = sdattr;
    }
    return main;
  };
  Screen.prototype._getPos = function() {
    return this;
  };
  var angles = {
    "": true,
    "": true,
    "": true,
    "": true,
    "": true,
    "": true,
    "": true,
    "": true,
    "": true,
    "": true,
    "": true
  };
  var langles = {
    "": true,
    "": true,
    "": true,
    "": true,
    "": true,
    "": true,
    "": true
  };
  var uangles = {
    "": true,
    "": true,
    "": true,
    "": true,
    "": true,
    "": true,
    "": true
  };
  var rangles = {
    "": true,
    "": true,
    "": true,
    "": true,
    "": true,
    "": true,
    "": true
  };
  var dangles = {
    "": true,
    "": true,
    "": true,
    "": true,
    "": true,
    "": true,
    "": true
  };
  var angleTable = {
    "0000": "",
    "0001": "",
    "0010": "",
    "0011": "",
    "0100": "",
    "0101": "",
    "0110": "",
    "0111": "",
    "1000": "",
    "1001": "",
    "1010": "",
    "1011": "",
    "1100": "",
    "1101": "",
    "1110": "",
    "1111": ""
  };
  Object.keys(angleTable).forEach(function(key) {
    angleTable[parseInt(key, 2)] = angleTable[key];
    delete angleTable[key];
  });
  module.exports = Screen;
});

// node_modules/blessed/lib/helpers.js
var require_helpers = __commonJS((exports) => {
  var fs = __require("fs");
  var unicode = require_unicode();
  var helpers = exports;
  helpers.merge = function(a, b) {
    Object.keys(b).forEach(function(key) {
      a[key] = b[key];
    });
    return a;
  };
  helpers.asort = function(obj) {
    return obj.sort(function(a, b) {
      a = a.name.toLowerCase();
      b = b.name.toLowerCase();
      if (a[0] === "." && b[0] === ".") {
        a = a[1];
        b = b[1];
      } else {
        a = a[0];
        b = b[0];
      }
      return a > b ? 1 : a < b ? -1 : 0;
    });
  };
  helpers.hsort = function(obj) {
    return obj.sort(function(a, b) {
      return b.index - a.index;
    });
  };
  helpers.findFile = function(start, target) {
    return function read(dir) {
      var files, file, stat, out;
      if (dir === "/dev" || dir === "/sys" || dir === "/proc" || dir === "/net") {
        return null;
      }
      try {
        files = fs.readdirSync(dir);
      } catch (e) {
        files = [];
      }
      for (var i = 0;i < files.length; i++) {
        file = files[i];
        if (file === target) {
          return (dir === "/" ? "" : dir) + "/" + file;
        }
        try {
          stat = fs.lstatSync((dir === "/" ? "" : dir) + "/" + file);
        } catch (e) {
          stat = null;
        }
        if (stat && stat.isDirectory() && !stat.isSymbolicLink()) {
          out = read((dir === "/" ? "" : dir) + "/" + file);
          if (out)
            return out;
        }
      }
      return null;
    }(start);
  };
  helpers.escape = function(text) {
    return text.replace(/[{}]/g, function(ch) {
      return ch === "{" ? "{open}" : "{close}";
    });
  };
  helpers.parseTags = function(text, screen) {
    return helpers.Element.prototype._parseTags.call({ parseTags: true, screen: screen || helpers.Screen.global }, text);
  };
  helpers.generateTags = function(style, text) {
    var open = "", close = "";
    Object.keys(style || {}).forEach(function(key) {
      var val = style[key];
      if (typeof val === "string") {
        val = val.replace(/^light(?!-)/, "light-");
        val = val.replace(/^bright(?!-)/, "bright-");
        open = "{" + val + "-" + key + "}" + open;
        close += "{/" + val + "-" + key + "}";
      } else {
        if (val === true) {
          open = "{" + key + "}" + open;
          close += "{/" + key + "}";
        }
      }
    });
    if (text != null) {
      return open + text + close;
    }
    return {
      open,
      close
    };
  };
  helpers.attrToBinary = function(style, element) {
    return helpers.Element.prototype.sattr.call(element || {}, style);
  };
  helpers.stripTags = function(text) {
    if (!text)
      return "";
    return text.replace(/{(\/?)([\w\-,;!#]*)}/g, "").replace(/\x1b\[[\d;]*m/g, "");
  };
  helpers.cleanTags = function(text) {
    return helpers.stripTags(text).trim();
  };
  helpers.dropUnicode = function(text) {
    if (!text)
      return "";
    return text.replace(unicode.chars.all, "??").replace(unicode.chars.combining, "").replace(unicode.chars.surrogate, "?");
  };
  helpers.__defineGetter__("Screen", function() {
    if (!helpers._screen) {
      helpers._screen = require_screen();
    }
    return helpers._screen;
  });
  helpers.__defineGetter__("Element", function() {
    if (!helpers._element) {
      helpers._element = require_element();
    }
    return helpers._element;
  });
});

// node_modules/blessed/lib/blessed.js
var require_blessed = __commonJS((exports, module) => {
  function blessed() {
    return blessed.program.apply(null, arguments);
  }
  blessed.program = blessed.Program = require_program();
  blessed.tput = blessed.Tput = require_tput();
  blessed.widget = require_widget();
  blessed.colors = require_colors();
  blessed.unicode = require_unicode();
  blessed.helpers = require_helpers();
  blessed.helpers.sprintf = blessed.tput.sprintf;
  blessed.helpers.tryRead = blessed.tput.tryRead;
  blessed.helpers.merge(blessed, blessed.helpers);
  blessed.helpers.merge(blessed, blessed.widget);
  module.exports = blessed;
});

// node_modules/default-gateway/index.js
var require_default_gateway = __commonJS((exports, module) => {
  var { platform, type } = __require("os");
  var supportedPlatforms = new Set([
    "aix",
    "android",
    "darwin",
    "freebsd",
    "linux",
    "openbsd",
    "sunos",
    "win32"
  ]);
  var plat = platform();
  if (supportedPlatforms.has(plat)) {
    let file = plat;
    if (plat === "aix") {
      file = type() === "OS400" ? "ibmi" : "sunos";
    }
    const m = __require(`./${file}.js`);
    exports.v4 = () => m.v4();
    exports.v6 = () => m.v6();
    exports.v4.sync = () => m.v4.sync();
    exports.v6.sync = () => m.v6.sync();
  } else {
    const err = new Error(`Unsupported Platform: ${plat}`);
    exports.v4 = () => Promise.reject(err);
    exports.v6 = () => Promise.reject(err);
    exports.v4.sync = () => {
      throw err;
    };
    exports.v6.sync = () => {
      throw err;
    };
  }
});

// node_modules/running-at/src/index.js
var require_src5 = __commonJS((exports, module) => {
  var os = __require("os");
  var defaultGateway = require_default_gateway();
  var url = __require("url");
  var print = function(options) {
    const result = runningAt(options);
    const indentation = options && options.indentation ? "   " : "";
    console.log(indentation + "Running at:");
    console.log(indentation + "- Local:   \x1B[34m%s\x1B[0m", result.local);
    if (result.network)
      console.log(indentation + "- Network: \x1B[34m%s\x1B[0m", result.network);
  };
  var getNetworkIp = function(name, family) {
    const interfaces = os.networkInterfaces();
    for (let i = -1;i < 8; i++) {
      const interfaceName = name + (i >= 0 ? i : "");
      const items = interfaces[interfaceName];
      if (items) {
        for (let j = 0;j < items.length; j++) {
          const item = items[j];
          if (item.family === family) {
            return item.address;
          }
        }
      }
    }
    return;
  };
  var getInterfaceName = function() {
    const result = defaultGateway.v4.sync();
    return result && result.interface;
  };
  var runningAt = function(options) {
    const defaultOptions = {
      port: 3000,
      protocol: "http",
      host: "localhost",
      pathname: "/",
      family: "IPv4",
      interface: getInterfaceName(),
      getNetwork: true,
      indentation: false
    };
    if (typeof options === "number" || typeof options === "string") {
      options = Object.assign({}, defaultOptions, { port: options });
    } else {
      options = Object.assign({}, defaultOptions, options);
    }
    const formatUrl = (hostname) => url.format({
      protocol: options.protocol,
      hostname,
      port: options.port,
      pathname: options.pathname
    });
    const networkIp = options.getNetwork ? getNetworkIp(options.interface, options.family) : undefined;
    return {
      ip: networkIp,
      local: formatUrl(options.host),
      network: networkIp !== undefined ? formatUrl(networkIp) : undefined
    };
  };
  module.exports = runningAt;
  module.exports.print = print;
});

// src/index.ts
var import_apollo_server2 = __toESM(require_dist15(), 1);

// src/graphql/typeDefs.ts
var import_apollo_server = __toESM(require_dist15(), 1);
var typeDefs = import_apollo_server.gql`
  """
  Represents a message in a chat
  """
  type ChatMessage {
    """
    The sender's identifier (email, phone number, etc.)
    """
    chatter: String!
    
    """
    The message content
    """
    text: String!
    
    """
    Timestamp of the message
    """
    date: Float
    
    """
    Whether the message was sent by the current user (1) or received (0)
    """
    is_from_me: Int
    
    """
    Handle ID reference in the iMessage database
    """
    handle_id: Int
    
    """
    Row ID in the message table
    """
    ROWID: Int
  }

  """
  Represents a chat or conversation
  """
  type Chat {
    """
    Unique identifier for the chat
    """
    name: String!
    
    """
    Human-readable name of the chat
    """
    friendlyName: String
  }

  """
  Represents a count of messages in a chat
  """
  type ChatCount {
    """
    Human-readable name of the chat
    """
    friendlyName: String!
    
    """
    Number of messages in the chat
    """
    count: Int!
  }

  """
  Root query type
  """
  type Query {
    """
    Get list of all chats/conversations
    """
    getChats: [Chat]
    
    """
    Get count of messages in each chat
    """
    getChatCounts: [ChatCount]
    
    """
    Get messages in a chat, with optional pagination
    """
    getMessages(chatId: String, page: String): [ChatMessage]
    
    """
    Send a message to a chat and return the updated messages
    """
    sendMessage(chatId: String, message: String): [ChatMessage]
  }
`;

// src/imessage.ts
import { exec } from "child_process";
import { promisify } from "util";
var execAsync = promisify(exec);
async function getLoggedInUseriMessageHandle(database) {
  try {
    const sql = "SELECT DISTINCT account_login FROM chat WHERE service_name = ?";
    const rows = await database.query(sql, ["iMessage"]);
    if (!rows || rows.length === 0) {
      return "no chat handle! [1]";
    }
    if (!rows[0].account_login) {
      return "no chat handle! [2]";
    }
    return rows[0].account_login.split("E:")[1];
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    throw new Error(`Failed to get iMessage handle: ${errorMessage}`);
  }
}
async function getChats(database) {
  try {
    const sql = `
      SELECT DISTINCT 
        handle.id,
        chat.chat_identifier,
        chat.display_name
      FROM
        message
      LEFT OUTER JOIN chat ON chat.room_name = message.cache_roomnames 
      LEFT OUTER JOIN handle ON handle.ROWID = message.handle_id
      WHERE
        message.is_from_me = 0 AND 
        message.service = 'iMessage'
      ORDER BY message.date DESC
    `;
    const rows = await database.query(sql);
    const result = [];
    const seenNames = new Set;
    for (const row of rows) {
      let chatId;
      if (row.chat_identifier === null) {
        chatId = row.id;
      } else if (row.chat_identifier?.includes("chat") && row.display_name) {
        chatId = row.display_name + "-" + row.chat_identifier;
      } else {
        chatId = row.chat_identifier;
      }
      if (!chatId || seenNames.has(chatId)) {
        continue;
      }
      seenNames.add(chatId);
      result.push({
        name: chatId,
        friendlyName: row.display_name || null
      });
    }
    return result;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    throw new Error(`Failed to get chats: ${errorMessage}`);
  }
}
async function getChatMessagesByArgs(args2, database) {
  try {
    if (!args2.chatId) {
      return [];
    }
    const chatId = args2.chatId;
    let limit = 20;
    let offset = 0;
    if (args2.page) {
      offset = (parseInt(args2.page) - 1) * limit;
    }
    let sql;
    let params;
    if (chatId.includes("-chat")) {
      const [displayName, roomName] = chatId.split("-");
      sql = `
        SELECT
          message.ROWID,
          message.date,
          message.text,
          message.is_from_me,
          message.handle_id,
          handle.id AS chatter
        FROM
          message
        LEFT OUTER JOIN handle ON handle.ROWID = message.handle_id
        LEFT OUTER JOIN chat ON chat.room_name = message.cache_roomnames
        WHERE
          chat.room_name = ? AND
          message.service = 'iMessage'
        ORDER BY message.date DESC
        LIMIT ? OFFSET ?
      `;
      params = [roomName, limit, offset];
    } else {
      sql = `
        SELECT
          message.ROWID,
          message.date,
          message.text,
          message.is_from_me,
          message.handle_id,
          handle.id AS chatter
        FROM
          message
        LEFT OUTER JOIN handle ON handle.ROWID = message.handle_id
        WHERE
          handle.id = ? AND
          message.service = 'iMessage'
        ORDER BY message.date DESC
        LIMIT ? OFFSET ?
      `;
      params = [chatId, limit, offset];
    }
    const messages = await database.query(sql, params);
    return messages.map((msg) => ({
      ROWID: msg.ROWID,
      chatter: msg.chatter || (msg.is_from_me ? "me" : chatId),
      text: msg.text || "",
      date: msg.date,
      is_from_me: msg.is_from_me,
      handle_id: msg.handle_id
    }));
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    throw new Error(`Failed to get messages: ${errorMessage}`);
  }
}
async function sendNewMessage(chatId, message2) {
  try {
    const script = `
      tell application "Messages"
        set targetService to 1st service whose service type = iMessage
        set targetBuddy to buddy "${chatId}" of targetService
        send "${message2}" to targetBuddy
      end tell
    `;
    await execAsync(`osascript -e '${script}'`);
    return true;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    throw new Error(`Failed to send message: ${errorMessage}`);
  }
}

// src/graphql/resolvers.ts
var resolvers = {
  Query: {
    getChats: async (_, __, { db }) => {
      return await getChats(db);
    },
    getMessages: async (_, args2, { db }) => {
      return await getChatMessagesByArgs(args2, db);
    },
    sendMessage: async (_, args2, { db }) => {
      const chatId = args2.chatId;
      const message2 = args2.message;
      if (!chatId || !message2) {
        throw new Error("Chat ID and message are required");
      }
      await sendNewMessage(chatId, message2);
      return await getChatMessagesByArgs({ chatId }, db);
    }
  }
};

// src/utils/database.ts
var import_sqlite3 = __toESM(require_sqlite3(), 1);

class Database {
  db;
  constructor(filePath) {
    const sqlite = import_sqlite3.default.verbose();
    this.db = new sqlite.Database(filePath);
  }
  async query(sql, params = []) {
    return new Promise((resolve, reject) => {
      this.db.all(sql, params, (err, rows) => {
        if (err)
          return reject(err);
        resolve(rows);
      });
    });
  }
  async exec(sql, params = []) {
    return new Promise((resolve, reject) => {
      this.db.run(sql, params, (err) => {
        if (err)
          return reject(err);
        resolve();
      });
    });
  }
  async close() {
    return new Promise((resolve, reject) => {
      this.db.close((err) => {
        if (err)
          return reject(err);
        resolve();
      });
    });
  }
}

// src/ui/terminal.ts
var import_blessed = __toESM(require_blessed(), 1);
function createUI() {
  const screen = import_blessed.default.screen({
    smartCSR: true
  });
  screen.title = "iMessage GraphQL Server";
  const ipBox = import_blessed.default.box({
    top: "0%",
    left: "0%",
    width: "50%",
    height: "25%",
    tags: true,
    label: "IP Address",
    border: {
      type: "line"
    }
  });
  const chatHandleBox = import_blessed.default.box({
    top: "25%",
    left: "0%",
    width: "50%",
    height: "25%",
    tags: true,
    label: "Chat Handle",
    border: {
      type: "line"
    }
  });
  const infoBox = import_blessed.default.box({
    top: "50%",
    left: "0%",
    width: "50%",
    height: "25%",
    tags: true,
    label: "Help",
    border: {
      type: "line"
    },
    content: "Press {bold}escape{/bold}, {bold}q{/bold}, or {bold}Ctrl+c{/bold} to quit"
  });
  const statusBox = import_blessed.default.box({
    top: "75%",
    left: "0%",
    width: "100%",
    height: "25%",
    tags: true,
    label: "Logs",
    border: {
      type: "line"
    },
    alwaysScroll: true,
    scrollable: true,
    scrollbar: {
      ch: " ",
      track: {
        bg: "blue"
      },
      style: {
        bg: "white"
      }
    },
    content: "Starting, waiting for server to begin..."
  });
  const statsBox = import_blessed.default.box({
    top: "0%",
    left: "50%",
    width: "50%",
    height: "75%",
    tags: true,
    label: "Stats",
    border: {
      type: "line"
    }
  });
  screen.append(ipBox);
  screen.append(chatHandleBox);
  screen.append(infoBox);
  screen.append(statusBox);
  screen.append(statsBox);
  screen.render();
  return {
    screen,
    ipBox,
    chatHandleBox,
    infoBox,
    statusBox
  };
}

// src/index.ts
var import_running_at = __toESM(require_src5(), 1);
import path from "path";
import os from "os";
async function main() {
  const dbPath = path.join(os.homedir(), "Library/Messages/chat.db");
  const db = new Database(dbPath);
  const { screen, statusBox, ipBox, chatHandleBox } = createUI();
  const server = new import_apollo_server2.ApolloServer({
    typeDefs,
    resolvers,
    context: { db }
  });
  try {
    const result = await import_running_at.default();
    const ipv4 = result?.address || "localhost";
    const port = 4000;
    const { url } = await server.listen(port);
    const chatHandle = await getLoggedInUseriMessageHandle(db);
    ipBox.setContent(`Server running at: ${url}
IP: ${ipv4}:${port}`);
    chatHandleBox.setContent(`Current chat handle: ${chatHandle}`);
    statusBox.setContent(`Server started successfully. GraphQL API available at ${url}`);
    screen.render();
    screen.key(["escape", "q", "C-c"], () => {
      statusBox.setContent("Shutting down server...");
      screen.render();
      db.close().then(() => {
        process.exit(0);
      });
    });
    console.log(`\uD83D\uDE80 Server running at ${url}`);
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    statusBox.setContent(`Error starting server: ${errorMessage}`);
    screen.render();
    setTimeout(() => {
      db.close().then(() => {
        process.exit(1);
      });
    }, 5000);
  }
}
main().catch((error) => {
  console.error("Unhandled error:", error);
  process.exit(1);
});
